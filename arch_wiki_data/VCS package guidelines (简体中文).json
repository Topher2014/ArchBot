{
  "title": "VCS package guidelines (简体中文)",
  "url": "https://wiki.archlinux.org/title/VCS_package_guidelines_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Font – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel modules – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust - Security – Shell – VCS – Web – Wine\n\nRelated articles\n\n- Arch User Repository\n- AUR submission guidelines\n- PKGBUILD\n\nVersion control systems can be used for retrieval of source code for usual statically versioned packages, and the latest (trunk) version of a development branch.\n\n"
    },
    {
      "title": "Package naming",
      "level": 2,
      "content": "Suffix pkgname with -bzr, -cvs, -darcs, -git, -hg, -svn, etc., unless the package fetches a specific release.\n\n"
    },
    {
      "title": "Versioning",
      "level": 2,
      "content": "If the resulting package is different after changing e.g. the dependencies, URL or sources — update pkgver to the latest version. If pkgver has not changed since the last update to the PKGBUILD, increase pkgrel instead.\n\nIt is recommended to have following version format: RELEASE.rREVISION, where REVISION is a monotonically increasing number that uniquely identifies the source tree (VCS revisions do this). If there are no public releases and no repository tags then zero could be used as a release number or you can drop RELEASE completely and use version number that looks like rREVISION. If there are public releases but repository has no tags then the developer should get the release version somehow e.g. by parsing the project files.\n\nThe revision number delimiter — r right before REVISION — is important. This delimiter allows to avoid problems in case if upstream decides to make its first release or uses versions with different number of components. E.g. if at revision 455 upstream decides to release version 0.1, then the revision delimiter preserves version monotonicity: 0.1.r456 > r454. Without the delimiter monotonicity fails: 0.1.456 < 454.\n\n"
    },
    {
      "title": "Conflicts and dependencies",
      "level": 2,
      "content": "- Include what the package conflicts with and provides, e.g. for fluxbox-gitAUR:\n\n```\nconflicts=('fluxbox')\nprovides=(\"fluxbox=${pkgver}\")\n```\n\n- replaces=() generally causes unnecessary problems and should be avoided.\n\n- Include the appropriate VCS tool in makedepends=() — cvs, subversion, git, etc.\n\n"
    },
    {
      "title": "Authentication and security",
      "level": 2,
      "content": "- When using the cvsroot, use anonymous:@ rather than anonymous@ to avoid having to enter a blank password or anonymous:password@, if one is required.\n- Because the sources are not static, skip the checksum in sha256sums=() by adding 'SKIP'.\n\n"
    },
    {
      "title": "VCS sources",
      "level": 2,
      "content": "The VCS sources should be specified in the source array and will be treated like any other source. makepkg will clone/checkout/branch the repository into $SRCDEST — same as $startdir if not set in makepkg.conf(5), and copy it to $srcdir (in a specific way to each VCS). The local repository is left untouched, thus invalidating the need for a -build directory.\n\nThe general format of a source array is:\n\n```\nsource=('[folder::][vcs+]url[#fragment]')\n```\n\n- folder (optional) — is used to change the default repository name to something more relevant, e.g. than trunk, or to preserve the previous sources.\n- vcs+ is needed for URLs that do not reflect the VCS type, e.g. git+https://some_repo.\n- url is the URL to the distant or local repository.\n- #fragment (optional) — is needed to pull a specific branch or commit. See PKGBUILD(5) § USING VCS SOURCES for a list of supported VCS and the respective fragments available.\n\nAn example Git source array:\n\n```\nsource=('project_name::git+https://project_url#branch=project_branch')\n```\n\n"
    },
    {
      "title": "The pkgver() function",
      "level": 2,
      "content": "The pkgver autobump is now achieved via a dedicated pkgver() function. This allows for better control over the pkgver, and maintainers should favor a pkgver that makes sense. To use pkgver(), you still need to declare the pkgver variable with the most recent value. makepkg will invoke function pkgver(), and update variable pkgver accordingly.\n\n"
    },
    {
      "title": "Bazaar",
      "level": 3,
      "content": "```\npkgver() {\n  cd \"$pkgname\"\n  printf \"r%s\" \"$(bzr revno)\"\n}\n```\n\n```\nr830\n```\n\n"
    },
    {
      "title": "Git",
      "level": 3,
      "content": "Using the most recent annotated tag reachable from the last commit:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  git describe --long --abbrev=7 | sed 's/\\([^-]*-g\\)/r\\1/;s/-/./g'\n}\n```\n\n```\n2.0.r6.ga17a017\n```\n\nUsing the most recent un-annotated tag reachable from the last commit:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  git describe --long --tags --abbrev=7 | sed 's/\\([^-]*-g\\)/r\\1/;s/-/./g'\n}\n```\n\n```\n0.71.r115.gd95ee07\n```\n\nIn case if the git-tag(1) does not contain dashes then one can use simpler sed(1) expression sed 's/-/.r/;s/-/./'.\n\nIf tag contains a prefix, like v or project name then it should be cut off:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  # cutting off 'foo-' prefix that presents in the git tag\n  git describe --long --abbrev=7 | sed 's/^foo-//;s/\\([^-]*-g\\)/r\\1/;s/-/./g'\n}\n```\n\n```\n6.1.r3.gd77e105\n```\n\nIf there are no tags then use number of revisions since beginning of the history:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  printf \"r%s.%s\" \"$(git rev-list --count HEAD)\" \"$(git rev-parse --short=7 HEAD)\"\n}\n```\n\n```\nr1142.a17a017\n```\n\nVersion and only commit/revision number (SHA-1 omitted; however, without a SHA-1 quick referencing of an exact revision is lost if not mindful of versioning):\n\n```\ngit describe --long --abbrev=7 --tags | sed 's/\\([^-]*\\)-g.*/r\\1/;s/-/./g'\n```\n\nBoth methods can also be combined, to support repositories that start without a tag but get tagged later on (uses a bashism):\n\n```\npkgver() {\n  cd \"$pkgname\"\n  ( set -o pipefail\n    git describe --long --abbrev=7 2>/dev/null | sed 's/\\([^-]*-g\\)/r\\1/;s/-/./g' ||\n    printf \"r%s.%s\" \"$(git rev-list --count HEAD)\" \"$(git rev-parse --short=7 HEAD)\"\n  )\n}\n```\n\n```\n0.9.9.r27.g2b039da  # if tags exist\nr1581.2b039da       # else fallback\n```\n\n"
    },
    {
      "title": "Mercurial",
      "level": 3,
      "content": "```\npkgver() {\n  cd \"$pkgname\"\n  printf \"r%s.%s\" \"$(hg identify -n)\" \"$(hg identify -i)\"\n}\n```\n\n```\nr2813.75881cc5391e\n```\n\n"
    },
    {
      "title": "Subversion",
      "level": 3,
      "content": "```\npkgver() {\n  cd \"$pkgname\"\n  local ver=\"$(svnversion)\"\n  printf \"r%s\" \"${ver//[[:alpha:]]}\"\n}\n```\n\n```\nr8546\n```\n\n"
    },
    {
      "title": "Fallback",
      "level": 3,
      "content": "In case no satisfactory pkgver can be extracted from the repository, the current date(1) can be used:\n\n```\npkgver() {\n  date +%Y%m%d\n}\n```\n\n```\n20130408\n```\n\n"
    },
    {
      "title": "Git submodules",
      "level": 3,
      "content": "Git submodules are a little tricky to do. The idea is to add the URLs of the submodules themselves directly to the sources array and then reference them during prepare().\n\nDownstream project developers may not name their submodule as the same name as the upstream module's repository. To view the name of the Git submodules, go to the .gitmodules file in the project's repository and preview it. For example, a repository named lib-dependency by the upstream developers may be registered as a submodule named libs/libdep in .gitmodules downstream.\n\n```\n[submodule \"libs/libdep\"]\n  path = libs/libdep\n  url = https://example.org/lib-dependency/lib-dependency.git\n```\n\n```\nsource=(\"git+https://example.org/main-project/main-project.git\"\n        \"git+https://example.org/lib-dependency/lib-dependency.git\")\n\nprepare() {\n  cd main-project\n  git submodule init\n  git config submodule.libs/libdep.url \"$srcdir/lib-dependency\"\n  git -c protocol.file.allow=always submodule update\n}\n```\n\n"
    },
    {
      "title": "Git LFS",
      "level": 3,
      "content": "Git LFS needs a bit of extra setup:\n\n```\nmakedepends=(... 'git-lfs')\n```\n\n```\nprepare() {\n  git lfs install --local\n  git remote add network-origin https://example.org/upstream/lfs/repo\n  git lfs fetch network-origin\n  git lfs checkout\n}\n```\n\nThis also works when the LFS is used in submodules:\n\n```\nprepare() {\n  git submodule init\n  git config submodule.libs/libdep.url \"$srcdir/lib-dependency\"\n  git -c protocol.file.allow=always submodule update\n\n  git -C libs/libdep lfs install --local\n  git -C libs/libdep remote add network-origin https://example.org/upstream/lfs/repo\n  git -C libs/libdep lfs fetch network-origin\n  git -C libs/libdep lfs checkout\n}\n```\n\n"
    },
    {
      "title": "Git checksums",
      "level": 3,
      "content": "When referencing stable git tags or specific commits as a source via git+https://domain.invalid/repository.git#tag=v1.0.0, it is possible to specify their checksum in the PKGBUILD. To do so, simply use makepkg -g or updatepkgsums to generate them as you would for any other non-git source.\n\n"
    }
  ]
}