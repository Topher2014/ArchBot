{
  "title": "Bash/Functions (简体中文)",
  "url": "https://wiki.archlinux.org/title/Bash/Functions_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Bash also supports functions. Add the functions to ~/.bashrc, or a separate file which is sourced from ~/.bashrc. More Bash function examples can be found in BBS#30155.\n\n"
    },
    {
      "title": "Display error codes",
      "level": 2,
      "content": "To set trap to intercept a non-zero return code of the last program run:\n\n```\nEC() {\n\techo -e '\\e[1;33m'code $?'\\e[m\\n'\n}\ntrap EC ERR\n```\n\n"
    },
    {
      "title": "Compile and execute a C source on the fly",
      "level": 2,
      "content": "The following function will compile (within the /tmp/ directory) and execute the C source argument on the fly (and the execution will be without arguments). And finally, after program terminates, will remove the compiled file.\n\n```\n# Compile and execute a C source on the fly\ncsource() {\n\t[[ $1 ]]    || { echo \"Missing operand\" >&2; return 1; }\n\t[[ -r $1 ]] || { printf \"File %s does not exist or is not readable\\n\" \"$1\" >&2; return 1; }\n\tlocal output_path=${TMPDIR:-/tmp}/${1##*/};\n\tgcc \"$1\" -o \"$output_path\" && \"$output_path\";\n\trm \"$output_path\";\n\treturn 0;\n}\n```\n\n"
    },
    {
      "title": "Extract",
      "level": 2,
      "content": "The following function will extract a wide range of compressed file types. Use it with the syntax extract <file1> <file2> ...\n\n```\nextract() {\n    local c e i\n\n    (($#)) || return\n\n    for i; do\n        c=''\n        e=1\n\n        if [[ ! -r $i ]]; then\n            echo \"$0: file is unreadable: \\`$i'\" >&2\n            continue\n        fi\n\n        case $i in\n            *.t@(gz|lz|xz|b@(2|z?(2))|a@(z|r?(.@(Z|bz?(2)|gz|lzma|xz|zst)))))\n                   c=(bsdtar xvf);;\n            *.7z)  c=(7z x);;\n            *.Z)   c=(uncompress);;\n            *.bz2) c=(bunzip2);;\n            *.exe) c=(cabextract);;\n            *.gz)  c=(gunzip);;\n            *.rar) c=(unrar x);;\n            *.xz)  c=(unxz);;\n            *.zip) c=(unzip);;\n            *.zst) c=(unzstd);;\n            *)     echo \"$0: unrecognized file extension: \\`$i'\" >&2\n                   continue;;\n        esac\n\n        command \"${c[@]}\" \"$i\"\n        ((e = e || $?))\n    done\n    return \"$e\"\n}\n```\n\nAnother way to do this is to install a specialized package, see Archiving and compression tools#Convenience tools.\n\n"
    },
    {
      "title": "cd and ls in one",
      "level": 2,
      "content": "Very often changing to a directory is followed by the ls command to list its contents. Therefore it is helpful to have a second function doing both at once. In this example we will name it cl (change list) and show an error message if the specified directory does not exist.\n\n```\ncl() {\n\tlocal dir=\"$1\"\n\tlocal dir=\"${dir:=$HOME}\"\n\tif [[ -d \"$dir\" ]]; then\n\t\tcd \"$dir\" >/dev/null; ls\n\telse\n\t\techo \"bash: cl: $dir: Directory not found\"\n\tfi\n}\n```\n\nOf course the ls command can be altered to fit your needs, for example ls -hall --color=auto.\n\n"
    },
    {
      "title": "Simple note taker",
      "level": 2,
      "content": "```\nnote () {\n    # if file doesn't exist, create it\n    if [[ ! -f $HOME/.notes ]]; then\n        touch \"$HOME/.notes\"\n    fi\n\n    if ! (($#)); then\n        # no arguments, print file\n        cat \"$HOME/.notes\"\n    elif [[ \"$1\" == \"-c\" ]]; then\n        # clear file\n        printf \"%s\" > \"$HOME/.notes\"\n    else\n        # add all arguments to file\n        printf \"%s\\n\" \"$*\" >> \"$HOME/.notes\"\n    fi\n}\n```\n\n"
    },
    {
      "title": "Simple task utility",
      "level": 2,
      "content": "Inspired by #Simple note taker\n\n```\ntodo() {\n    if [[ ! -f $HOME/.todo ]]; then\n        touch \"$HOME/.todo\"\n    fi\n\n    if ! (($#)); then\n        cat \"$HOME/.todo\"\n    elif [[ \"$1\" == \"-l\" ]]; then\n        nl -b a \"$HOME/.todo\"\n    elif [[ \"$1\" == \"-c\" ]]; then\n        > $HOME/.todo\n    elif [[ \"$1\" == \"-r\" ]]; then\n        nl -b a \"$HOME/.todo\"\n        eval printf %.0s- '{1..'\"${COLUMNS:-$(tput cols)}\"\\}; echo\n        read -p \"Type a number to remove: \" number\n        sed -i ${number}d $HOME/.todo \"$HOME/.todo\"\n    else\n        printf \"%s\\n\" \"$*\" >> \"$HOME/.todo\"\n    fi\n}\n```\n\n"
    },
    {
      "title": "Calculator",
      "level": 2,
      "content": "```\ncalc() {\n    echo \"scale=3;$@\" | bc -l\n}\n```\n\n"
    },
    {
      "title": "IP info",
      "level": 2,
      "content": "Detailed information on an IP address or hostname in bash via https://ipinfo.io:\n\n```\nipif() { \n    if grep -P \"(([1-9]\\d{0,2})\\.){3}(?2)\" <<< \"$1\"; then\n\t curl ipinfo.io/\"$1\"\n    else\n\tipawk=($(host \"$1\" | awk '/address/ { print $NF }'))\n\tcurl ipinfo.io/${ipawk[1]}\n    fi\n    echo\n}\n```\n\n"
    },
    {
      "title": "Whatsize",
      "level": 2,
      "content": "List folders sorted by size, showing the largest first. A helper where to start cleaning when the disk is full. Use it with the syntax whatsize directory or just whatsize to list the / directory sizes.\n\n```\nwhatsize(){\n    du -h --max-depth=1 --exclude=/{proc,sys,dev,run} -t 1 ${1:-/} 2>/dev/null | sort -hr\n}\n```\n\n"
    }
  ]
}