{
  "title": "DNSCrypt (简体中文)",
  "url": "https://wiki.archlinux.org/title/DNSCrypt_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Domain name resolution\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\ndnscrypt-proxy is a DNS proxy client with support for the encrypted DNS protocols DNS over HTTPS and DNSCrypt, which can be used to prevent man-in-the-middle attacks and eavesdropping. dnscrypt-proxy is also compatible with DNSSEC.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the dnscrypt-proxy package.\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "The default configuration file referred to is at /etc/dnscrypt-proxy/dnscrypt-proxy.toml.\n\n"
    },
    {
      "title": "Startup",
      "level": 3,
      "content": "The service can be started in two mutually exclusive ways (i.e. only one of the two may be enabled):\n\n1. With the systemd service dnscrypt-proxy.service. The listen_addresses option must be configured (e.g. listen_addresses = ['127.0.0.1:53', '[::1]:53']) in the configuration file when using the service.\n1. Through socket activation using dnscrypt-proxy.socket. The listen_addresses option must be set to empty (i.e. listen_addresses = [ ]) in the configuration file, since systemd is taking care of the socket configuration.\n\n- The listen_addresses option must be configured (e.g. listen_addresses = ['127.0.0.1:53', '[::1]:53']) in the configuration file when using the service.\n\n- The listen_addresses option must be set to empty (i.e. listen_addresses = [ ]) in the configuration file, since systemd is taking care of the socket configuration.\n\n"
    },
    {
      "title": "Select resolver",
      "level": 3,
      "content": "By leaving server_names commented out in the configuration file, dnscrypt-proxy will choose the fastest server from the sources already configured under [sources] [3]. The lists will be downloaded, verified, and automatically updated [4]. Thus, configuring a specific set of servers is optional.\n\nTo manually set which server is used, uncomment the server_names variable in the configuration file and select one or more of the servers. For example, to use Cloudflare's servers:\n\n```\nserver_names = ['cloudflare', 'cloudflare-ipv6']\n```\n\nA full list of resolvers is located at the upstream page or Github. If dnscrypt-proxy has run successfully on the system before, /var/cache/dnscrypt-proxy/public-resolvers.md will also contain a list. Look at the description for servers note which validate DNSSEC, do not log, and are uncensored. These requirements can be configured globally with the require_dnssec, require_nolog, require_nofilter options.\n\n"
    },
    {
      "title": "Modify resolv.conf and coordinate with other local domain name resolvers",
      "level": 3,
      "content": "Modify the resolv.conf file and replace the current set of resolver addresses with the address for localhost and options[5]:\n\n```\n/etc/resolv.conf\n```\n\n```\nnameserver ::1\nnameserver 127.0.0.1\noptions edns0\n```\n\nNext, existing services doing domain name resolution must be configured not to overwrite the settings. See resolv.conf#Overwriting of /etc/resolv.conf for details. They can be used, if they are configured to bind to different addresses than localhost and forward DNS requests to localhost port 53. For example, systemd-resolved uses address 127.0.0.53 by default.\n\n"
    },
    {
      "title": "Disable any services bound to port 53",
      "level": 4,
      "content": "To see if any programs are using port 53, run:\n\n```\n$ ss -lp 'sport = :domain'\n```\n\nIf the output contains more than the first line of column names, you need to disable whatever service is using port 53. For example, NetworkManager may try to activate a resolver automatically, but other network managers may have analogous components. You are ready to proceed once the above command outputs nothing more than the following line:\n\n```\nNetid               State                 Recv-Q                Send-Q                                 Local Address:Port                                   Peer Address:Port\n```\n\n"
    },
    {
      "title": "Start systemd service",
      "level": 3,
      "content": "Finally, start/enable the dnscrypt-proxy.service unit or dnscrypt-proxy.socket, depending on which method you chose above.\n\n"
    },
    {
      "title": "Check if dnscrypt-proxy is working",
      "level": 3,
      "content": "Open the browser and head to DnsLeakTest and do an extended test, if the results show servers that you have set in the configuration files it means that dnscrypt-proxy is working, otherwise something is wrong.\n\n"
    },
    {
      "title": "Enabling, downloading and auto-updating filter lists / block lists",
      "level": 3,
      "content": "Note: **This article or section is being considered for removal.** This article or section is being considered for removal.\n\nThis article or section is being considered for removal.\n\nConfigure filter list sources in /usr/share/dnscrypt-proxy/utils/generate-domains-blocklist/domains-blocklist.conf. For example:\n\n```\n# NextDNS CNAME cloaking list\nhttps://raw.githubusercontent.com/nextdns/cname-cloaking-blocklist/master/domains\n# AdGuard Simplified Domain Names filter\nhttps://adguardteam.github.io/AdGuardSDNSFilter/Filters/filter.txt\n# OISD.NL Big:\nhttps://big.oisd.nl/domainswild\n# HaGeZi Multi Pro\nhttps://raw.githubusercontent.com/hagezi/dns-blocklists/main/wildcard/pro-onlydomains.txt\n# HaGeZi Thread Intelligence Feeds\nhttps://raw.githubusercontent.com/hagezi/dns-blocklists/main/wildcard/tif-onlydomains.txt\n```\n\nCreate a service to download & combine filter lists. /etc/systemd/system/dnscrypt-filterlist-update.service:\n\n```\n[Unit]\nDescription=DNSCrypt Filterlist Update\n\n[Service]\nType=oneshot\nUser=root\nWorkingDirectory=/usr/share/dnscrypt-proxy/utils/generate-domains-blocklist/\nExecStart=generate-domains-blocklist -a domains-allowlist.txt -o blocklist.txt ; sleep 2 ; systemctl restart dnscrypt-proxy.service\n\n[Install]\nWantedBy=multi-user.target\n```\n\nCreate a time to run on boot but also every 5 hours. /etc/systemd/system/dnscrypt-filterlist-update.timer:\n\n```\n[Unit]\nDescription=Run 15min after boot and every 5 hours (DNSCrypt Filterlist Update)\n\n[Timer]\nOnBootSec=15min\nOnUnitActiveSec=5h\n\n[Install]\nWantedBy=timers.target\n```\n\nEnable the timer:\n\n```\nsystemctl daemon-reload\nsystemctl enable dnscrypt-filterlist-update.timer\n```\n\nConfigure DNSCrypt to apply the created filter rules. /etc/dnscrypt-proxy/dnscrypt-proxy.toml:\n\n```\nblocked_names_file = '/usr/share/dnscrypt-proxy/utils/generate-domains-blocklist/blocklist.txt'\nlog_file = '/var/log/dnscrypt-proxy/blocked-names.log'\n```\n\n"
    },
    {
      "title": "Local DNS cache configuration",
      "level": 3,
      "content": "It is recommended to run dnscrypt-proxy as a forwarder for a local DNS cache if not using dnscrypt-proxy's cache feature; otherwise, every single query will make a round-trip to the upstream resolver. Any local DNS caching program should work. In addition to setting up dnscrypt-proxy, you must setup your local DNS cache program.\n\n"
    },
    {
      "title": "Change port",
      "level": 4,
      "content": "In order to forward queries from a local DNS cache, dnscrypt-proxy should listen on a port different from the default 53, since the DNS cache itself needs to listen on 53 and query dnscrypt-proxy on a different port. Port number 54 is used as an example in this section.\n\nThere are two methods for changing the default port:\n\nSocket method\n\nEdit dnscrypt-proxy.socket with the following contents:\n\n```\n[Socket]\nListenStream=\nListenDatagram=\nListenStream=127.0.0.1:54\nListenStream=[::1]:54\nListenDatagram=127.0.0.1:54\nListenDatagram=[::1]:54\n```\n\nWhen queries are forwarded from the local DNS cache to 54, dnscrypt-proxy.socket will start dnscrypt-proxy.service.\n\nService method\n\nEdit the listen_addresses option in /etc/dnscrypt-proxy/dnscrypt-proxy.toml with the following:\n\n```\nlisten_addresses = ['127.0.0.1:54', '[::1]:54']\n```\n\n"
    },
    {
      "title": "Example local DNS cache configurations",
      "level": 4,
      "content": "The following configurations should work with dnscrypt-proxy and assume that it is listening on port 54.\n\nConfigure Unbound to your liking (in particular, see Unbound#Local DNS server) and add the following lines to the end of the server section in /etc/unbound/unbound.conf:\n\n```\ndo-not-query-localhost: no\nforward-zone:\n  name: \".\"\n  forward-addr: ::1@54\n  forward-addr: 127.0.0.1@54\n```\n\nRestart unbound.service to apply the changes.\n\nConfigure dnsmasq as a local DNS cache. The basic configuration to work with dnscrypt-proxy:\n\n```\n/etc/dnsmasq.conf\n```\n\n```\nno-resolv\nserver=::1#54\nserver=127.0.0.1#54\nlisten-address=::1,127.0.0.1\n```\n\nIf you configured dnscrypt-proxy to use a resolver with enabled DNSSEC validation, make sure to enable it also in dnsmasq:\n\n```\n/etc/dnsmasq.conf\n```\n\n```\nconf-file=/usr/share/dnsmasq/trust-anchors.conf\ndnssec\n```\n\nRestart dnsmasq.service to apply the changes.\n\nInstall pdnsd. A basic configuration to work with dnscrypt-proxy is:\n\n```\n/etc/pdnsd.conf\n```\n\n```\nglobal {\n    perm_cache = 1024;\n    cache_dir = \"/var/cache/pdnsd\";\n    run_as = \"pdnsd\";\n    server_ip = 127.0.0.1;\n    status_ctl = on;\n    query_method = udp_tcp;\n    min_ttl = 15m;       # Retain cached entries at least 15 minutes.\n    max_ttl = 1w;        # One week.\n    timeout = 10;        # Global timeout option (10 seconds).\n    neg_domain_pol = on;\n    udpbufsize = 1024;   # Upper limit on the size of UDP messages.\n}\n\nserver {\n    label = \"dnscrypt-proxy\";\n    ip = 127.0.0.1;\n    port = 54;\n    timeout = 4;\n    proxy_only = on;\n}\n\nsource {\n    owner = localhost;\n    file = \"/etc/hosts\";\n}\n```\n\nRestart pdnsd.service to apply the changes.\n\n"
    },
    {
      "title": "Enable EDNS0",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nExtension Mechanisms for DNS that, among other things, allows a client to specify how large a reply over UDP can be.\n\nAdd the following line to your /etc/resolv.conf:\n\n```\noptions edns0\n```\n\n"
    },
    {
      "title": "Test EDNS0",
      "level": 4,
      "content": "Make use of the DNS Reply Size Test Server, use the drill command line tool to issue a TXT query for the name rs.dns-oarc.net:\n\n```\n$ drill rs.dns-oarc.net TXT\n```\n\nWith EDNS0 supported, the \"answer section\" of the output should look similar to this:\n\n```\nrst.x3827.rs.dns-oarc.net.\nrst.x4049.x3827.rs.dns-oarc.net.\nrst.x4055.x4049.x3827.rs.dns-oarc.net.\n\"2a00:d880:3:1::a6c1:2e89 DNS reply size limit is at least 4055 bytes\"\n\"2a00:d880:3:1::a6c1:2e89 sent EDNS buffer size 4096\"\n```\n\n"
    }
  ]
}