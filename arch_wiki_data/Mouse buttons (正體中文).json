{
  "title": "Mouse buttons (正體中文)",
  "url": "https://wiki.archlinux.org/title/Mouse_buttons_(%E6%AD%A3%E9%AB%94%E4%B8%AD%E6%96%87)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nRelated articles\n\n- Mouse acceleration\n- Mouse polling rate\n\nThis article describes how to configure a mouse with more than 3 buttons.\n\n"
    },
    {
      "title": "Prerequisite testing mouse input in X",
      "level": 2,
      "content": "This page assumes you are using Xorg (X Window System) and not Wayland.\n\nYou will first want to check what X sees from your mouse. X events can be displayed by the xev utility. A window will pop up by running\n\n```\n$ xev -event button | grep button\n```\n\nAny xevents (like moving, resizing, or clicking in) that window will then be reported to the console you launched xev from. Since you are filtering for lines which contain \"button\" it will show mouse click and release events with their relevant button numbers. For most mice, this will be '1' for left button, '2' for middle, '3' for right. Other buttons will vary (e.g. for an Logitech MX Master 3 the scroll wheel is 4 & 5, thumb wheel is 6 & 7, the thumb-tip button is 9, and the inner-thumb button is 8).\n\nExample output:\n\n```\nstate 0x0, button 1, same_screen YES\nstate 0x100, button 1, same_screen YES\nstate 0x0, button 9, same_screen YES\nstate 0x0, button 9, same_screen YES\n```\n\nThis corresponds to a left mouse click and release followed by a thumb-tip click and release.\n\nYou can use xev to confirm your mouse button numbers and to confirm that X is being notified of mouse clicks.\n\n"
    },
    {
      "title": "Rebinding mouse and keyboard functions",
      "level": 2,
      "content": "This section covers details of using various tools to rearrange mouse and keyboard functions.\n\n"
    },
    {
      "title": "xte",
      "level": 4,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nxte from xautomation comes handy when we want to bind keyboard buttons to mouse.\n\nHere is example ~/.xbindkeysrc which binds Shift_R to mouse button 3 (\"right click\"):\n\n```\n~/.xbindkeysrc\n```\n\n```\n\"xte 'mouseclick 3'\"\n  Shift_R\n```\n\n"
    },
    {
      "title": "xvkbd and xbindkeys",
      "level": 4,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nLet us say we want to bind some mouse buttons to keyboard ones. The problem we will encounter is that we do not know how to emulate a key press. Here comes in handy xvkbdAUR. We can use it along with xbindkeys.\n\n```\n$ xbindkeys --defaults >> ~/.xbindkeysrc\n$ xbindkeys\n```\n\nTo restart xbindkeys type:\n\n```\n$ pkill -f xbindkeys\n$ xbindkeys\n```\n\nHere is example ~/.xbindkeysrc config:\n\n```\n\"xvkbd  -text \"\\[F8]\"\"\n       m:0x0 + b:8\n\"xvkbd  -text \"\\[Shift]\\[Left]\"\"\n       m:0x0 + b:9\n\"xvkbd  -text \"\\[Shift]\\[Right]\"\"\n       m:0x0 + b:10\n\"xvkbd  -text 2\"\n       m:0x0 + b:11\n\"xvkbd  -text 3\"\n       m:0x0 + b:12\n```\n\nIf you want to check your mouse buttons number use xev. Do not forget to type capital letters in xvkbd -text usage and to escape opening bracket with \\ or you get simply [Shift] written.\n\nHere is an example for xbindkeys to enable x selection paste(third click pasting), you need both xsel and xvkbd installed, What it does it executes that command whenever button 13 of the mouse is pressed (in ~/.xbindkeysrc) :\n\n```\n\"xvkbd -no-jump-pointer -text \"\\D1$(xsel)\" 2>/dev/null\"\nb:13\n```\n\nThis is an example for a keybinding for Meta+M:\n\n```\n\"xvkbd  -text \"\\{+Super_L}m\\{-Super_L}\"\"\nb:10\n```\n\n"
    },
    {
      "title": "evrouter",
      "level": 4,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nSome programs, especially games, use different methods of reading input, so another program is needed: evrouterAUR.\n\nFor the evrouter command to be able to read the input devices, it will have to be run in the input group (or as root). This can be achieved by adding yourself to that group:\n\n```\n# gpasswd -a user input\n```\n\nNow we can use the --dump option to display what the button to be changed is called:\n\n```\n$ evrouter --dump /dev/input/event*\n```\n\n```\ndevice  0: /dev/input/event0: AT Translated Set 2 keyboard\ndevice  1: /dev/input/event1: Microsoft Microsoft Trackball Explorer®\ndevice  2: /dev/input/event2: Sleep Button\ndevice  3: /dev/input/event3: Power Button\ndevice  4: /dev/input/event4: Power Button\ndevice  5: /dev/input/event5: PC Speaker\nDisplay name: :0.0\n```\n\nNow press the buttons that you wish to change:\n\n```\nWindow \"(null)\": # Window title\n# Window \"(null)\": # Resource name\n# Window \"(null)\": # Class name\n\"Microsoft Trackball Explorer®\" \"/dev/input/event1\" none key/275 \"fill this in!\"\n\nWindow \"(null)\": # Window title\n# Window \"(null)\": # Resource name\n# Window \"(null)\": # Class name\n\"Microsoft Trackball Explorer®\" \"/dev/input/event1\" none key/276 \"fill this in!\"\n```\n\nThe line that ends with \"fill this in!\" can be copied into the configuration file which by default is ~/.evrouterrc. For example, using the X11 key event emulator built into evrouter:\n\n```\n~/.evrouterrc\n```\n\n```\n\"Microsoft Trackball Explorer®\" \"/dev/input/event*\" any key/275 \"XKey/1\"\n\"Microsoft Trackball Explorer®\" \"/dev/input/event*\" any key/276 \"XKey/2\"\n```\n\nThe 'event1' was changed to 'event*' in case udev gives it a different device number at boot. The 'none' was changed to 'any' so that the rule works even if any modifier keys are pressed when the button is pressed. To determine the key codes (in brackets) you can use\n\n```\n# xmodmap -pk\n```\n\nSee evrouter(1) for a full explanation of the fields.\n\nAfter setting up the configuration file, run it as a daemon:\n\n```\n$ evrouter /dev/input/event*\n```\n\nTo stop the daemon:\n\n```\n$ evrouter -q\n$ rm -f /tmp/.evrouter*\n```\n\n"
    },
    {
      "title": "User tools",
      "level": 2,
      "content": "This section outlines hardware-specific tools which are useful for configuring mouse settings, and in particular their buttons. For the generic remap tools, see Input remap utilities.\n\n- Piper (piper) is a graphical user interface to configure gaming mice, works with Wayland. In order to work with your mouse, it must be in the list of supported devices.\n- lomocoAUR for Logitech MX mice will help you set the proper resolution, enable or disable smart scroll (with boot time support too!), etc. Be sure to look at /etc/udev/lomoco_mouse.conf and set up the options you want to be automatically applied when the mouse gets loaded by udev. Note: The lomoco package may be out of date. There is a hack for newer Logitech mice: [1]\n- logiopsAUR is a tool for configuring Logitech mice (Logitech Options for Linux). It may remap buttons to actions, support gestures, smart shift and so on.\n\n"
    },
    {
      "title": "evdev Xorg.conf setup",
      "level": 2,
      "content": "This section explains setting up mice with more than 3 buttons using evdev. There are other ways to achieve this, but some of the notes and tools described here may be useful for people with other needs. Some parts may help getting extra mouse buttons working using other drivers as well.\n\nWe will be using the evdev driver for Xorg. EVentDEVice is an advanced driver for USB input devices which offers much greater power over the standard Xorg mouse driver. It is also more \"direct\" than the mouse driver, allowing lower latency and less translation issues.\n\n- Note that evdev is both a kernel module and an Xorg input driver. All the Arch kernels come with the evdev module.\n\nWith the Xorg 11R7.0 or newer, only the following changes to /etc/X11/xorg.conf need to be made.\n\n"
    },
    {
      "title": "Finding the mouse name",
      "level": 3,
      "content": "The first step is to find the name of the mouse / mice. To do this, execute the following command:\n\n```\n$ grep -E \"Name|Handlers\" /proc/bus/input/devices | grep -E -B1 'Handlers.*mouse'\n```\n\nThis should output something like this:\n\n```\nN: Name=\"Logitech USB Gaming Mouse\"\nH: Handlers=mouse0 event0 ts0\n```\n\nOr this if you have more than one mouse:\n\n```\nN: Name=\"Kensington Kensington Expert Mouse Wireless\"\nH: Handlers=event0 mouse0 \n--\nN: Name=\"Logitech USB Receiver\"\nH: Handlers=kbd event2 mouse1\n```\n\nThe mouse is the one that has the Handlers=mouse0, so the name of the device is Logitech USB Gaming Mouse.\n\nCopy the name of the device, and open up /etc/X11/xorg.conf.\n\n"
    },
    {
      "title": "Configuring Xorg",
      "level": 3,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nNow, we need an entry in xorg.conf that tells X how to use this mouse. It should look something like this:\n\n```\nSection \"InputDevice\"\n  Identifier      \"Evdev Mouse\"\n  Driver          \"evdev\"\n  Option          \"Name\" \"Logitech USB Gaming Mouse\"\n  Option          \"evBits\"  \"+1-2\"\n  Option          \"keyBits\" \"~272-287\"\n  Option          \"relBits\" \"~0-2 ~6 ~8\"\n  Option          \"Pass\"    \"3\"\n  Option          \"CorePointer\"\nEndSection\n```\n\nReplace the Name option with the name you copied from above. You may also omit the CorePointer option if you use multiple mice or experience errors when attempting to load Xorg. The other options are all basic mouse configurations for evdev and should work with most mice.\n\nNext, we need to tell X to use the mouse, so look in xorg.conf for ServerLayout.\n\nModify the ServerLayout section to use \"Evdev Mouse\" as the device. When you are done, it should look something like this:\n\n```\nSection \"ServerLayout\"\n  Identifier     \"Default Layout\"\n  Screen 0       \"Monitor0\" 0 0\n  InputDevice    \"Keyboard0\" \"CoreKeyboard\"\n  InputDevice    \"Evdev Mouse\" \"CorePointer\"\nEndSection\n```\n\nThe only thing you should change in the layout is the InputDevice line that refers to your mouse.\n\nThat should be all that is required.\n\n- Edit by: xxsashixx\n\nThis is for Logitech G5 Mouse users. I have not tested this for other mice, but if you do not add this, your mouse MAY not work. If you do not need to add this, then do not.\n\nPut\n\n```\nOption \"Device\" \"/dev/input/event[#]\"\n```\n\nin the InputDevice section or else the mouse will not be picked up.\n\n[#] = The number you got from:\n\n```\ngrep -E \"Name|Handlers\" /proc/bus/input/devices\n```\n\n- Edit by: bapman\n\nWith the above method, your mouse might not to work after reboot (event number changes). To fix this, you can use symlinks in /dev/input/by-id. For example:\n\n```\nOption      \"Device\" \"/dev/input/by-id/usb-Logitech_USB_Receiver-event-mouse\"\n```\n\nTo find the appropriate id, do:\n\n```\nls /dev/input/by-id/\n```\n\n- Edit by: Diamir\n\nNote: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nWith a Desktop type keyboard-mouse, this does not work because there is only one USB attachment and /dev/input/by-id contains only the keyboard. In this case, we can create a udev rule to get a consistent link. The following rules create the link /dev/input/usbmouse which points on the correct event entry:\n\n```\nKERNEL==\"event[0-9]*\", BUS==\"usb\", SYSFS{modalias}==\"usb:v045Ep008Ad7373dc00dsc00dp00ic03isc00ip00\", SYMLINK+=\"input/usbmouse\"\n```\n\nYou can call it z10_usb_mouse.rules and put it in /etc/udev/rules.d\n\nThe cryptic value to use for SYSFS(modalias) can be gotten in the following way:\n\nenter the command cat /proc/bus/input/devices\n\nYou will find the keyboard and the mouse and see event4 is the mouse in this case:\n\n```\nI: Bus=0003 Vendor=045e Product=008a Version=0111\nN: Name=\"Microsoft Microsoft Wireless Optical Desktop� 1.00\"\nP: Phys=usb-0000:00:10.0-2/input0\nS: Sysfs=/devices/pci0000:00/0000:00:10.0/usb1/1-2/1-2:1.0/input/input3\nU: Uniq=\nH: Handlers=kbd event0 \nB: EV=120013\nB: KEY=1000000000007 ff800000000007ff febeffdff3cfffff fffffffffffffffe\nB: MSC=10\nB: LED=107\n```\n\n```\nI: Bus=0003 Vendor=045e Product=008a Version=0111\nN: Name=\"Microsoft Microsoft Wireless Optical Desktop� 1.00\"\nP: Phys=usb-0000:00:10.0-2/input1\nS: Sysfs=/devices/pci0000:00/0000:00:10.0/usb1/1-2/1-2:1.1/input/input4\nU: Uniq=\nH: Handlers=kbd mouse0 event1 \nB: EV=17\nB: KEY=3000000000000 0 1f0000 f8400244000 601878d800d448 1e000000000000 0\nB: REL=7c3\nB: MSC=10\n```\n\nSo I enter the following command (adapt event # to your particular case):\n\n```\nudevinfo -a -p $(udevinfo -q path -n /dev/input/event4) | grep modalias\nATTRS{modalias}==\"input:b0003v045Ep008Ae0111-0,1,2,4,k71,72,73,74,83,86,8A,8C,8E,8F,9B,9C,9E,9F,A3,A4,A5,A6,AB,AC,B5,B6,CE,D2,D5,E2,E7,E8,E9,EA,EB,110,111,112,113,114,1B0,1B1,r0,1,6,7,8,9,A,am4,lsfw\"\nATTRS{modalias}==\"usb:v045Ep008Ad7373dc00dsc00dp00ic03isc00ip00\"\nATTRS{modalias}==\"pci:v00001106d00003038sv00001043sd000080EDbc0Csc03i00\"\n```\n\ngrab the ATTRS which becomes with usb: to complete \"SYSFS{modalias}== \" entry\n\nAnd finally, use usbmouse as the Device Option in xorg.conf:\n\n```\nOption \"Device\" \"/dev/input/usbmouse\"\n```\n\n"
    },
    {
      "title": "Google Chrome",
      "level": 4,
      "content": "It works. Horizontal scroll works out of the box - push the scroll wheel left or right. Thumb buttons also work as next/previous page.\n\n"
    },
    {
      "title": "Opera",
      "level": 4,
      "content": "It works. Note: buttons can be mapped to functions easily in Preferences > Advanced > Shortcuts > Mouse set-up. For example, to bind button 8 to back:\n\n1. Navigate to mouse set-up and expand the Application drop-down\n1. In the input column, type: Button 8\n1. In the actions column, type: Back\n\n"
    },
    {
      "title": "Firefox",
      "level": 4,
      "content": "To get back and forward enabled, instead of scroll left/right, change the following settings in about:config:\n\n```\nmousewheel.default.action.override_x         2\nmousewheel.default.delta_multiplier_x       -100\n```\n\n"
    },
    {
      "title": "Thumb buttons - forward and back",
      "level": 4,
      "content": "To do this we need to map keystrokes to the desired mouse buttons and install xvkbdAUR and xbindkeys.\n\nIn most modern applications which use back/forward features, XF86Back is mapped to back and XF86Forward is mapped to forward by default. On most MX mice the thumb buttons resolve to 8 & 9. If your mouse is different, check button numbers using xev and replace the numbers used in the example (b:8 & b:9).\n\nSo if you have an MX mouse you would create the file ~/.xbindkeysrc, containing:\n\n```\n# Mouse Buttons\n\"xvkbd -xsendevent -text \"\\[XF86Back]\"\"\nm:0x0 + b:8 \n\"xvkbd -xsendevent -text \"\\[XF86Forward]\"\"\nm:0x0 + b:9\n```\n\nNow to test... Run the following command and if it works as expected remember to add xbindkeys to .xinitrc or somewhere where it will be executed each time X starts. Also, this should work with Epiphany and Konqueror without any additional configuration or use of IMWheel.\n\n```\nxbindkeys\n```\n\nSince xvkbd is not available from the official repositories here is another example using xte from the xautomation package\n\n```\n# Mouse Buttons\n\"xte \"key XF86Back\"\"\nm:0x0 + b:8\n\"xte \"key XF86Forward\"\"\nm:0x0 + b:9\n```\n\n"
    },
    {
      "title": "xmodmap tweaking",
      "level": 4,
      "content": "It may prove to be more comfortable for some to change the ordering of button codes, as the case may be for left-handed people. Depending on the environment you use, the button codes can be configured in two different ways. If you use .xinitrc to load X, then add this to .xinitrc (change for the number of buttons you have):\n\n```\nxmodmap -e \"pointer = 1 2 3 6 7 8 9 10 11 12 4 5\" &\n```\n\nNote that buttons 4 and 5 must go on the end or else your scroll wheel will not work.\n\nIf you use GDM/SDDM/XDM instead of .xinitrc, then create the file ~/.Xmodmap and add this to it (change for the number of buttons you have):\n\n```\npointer = 1 2 3 6 7 8 9 10 11 12 4 5\n```\n\n- GDM/SDDM/XDM read the ~/.Xmodmap file if it is present, whereas startx does not. Another solution would be to add this to your ~/.xinitrc: xmodmap ~/.Xmodmap. This would allow you to use *DM and startx while only having to edit ~/.Xmodmap when you need to make changes.\n\nYou may have to play with these numbers a bit to get your desired behavior. Some mice use buttons 6 and 7 for the scroll wheel, in which case those buttons would have to be the last numbers. Keep playing with it until it works!\n\n"
    },
    {
      "title": "xinput tweaking",
      "level": 4,
      "content": "For debugging purposes xinput can be used as it is able to change the button map on the fly in userspace. The following line corrects the button mapping (there have been reported cases with Logitech M505/B605 mice and possibly others) so the received events are mapped correctly:\n\n```\n$ xinput set-button-map \"$(xinput | awk -F'[=]' '/Logitech M505\\/B605/ {print $2}' | awk '{print $1}')\" 1 2 3 4 5 8 9\n```\n\n"
    },
    {
      "title": "Logitech G600",
      "level": 3,
      "content": "It is known that in xorg-server 1.18.0-3 side buttons of G600 are not recognized as a separate keyboard device, but another mouse which causes strange (moving mouse cursor to an edge of screen when one of main mouse buttons are clicked) behavior. To force xorg to recognize them as a keyboard buttons, add following section to your /etc/X11/xorg.conf:\n\n```\nSection \"InputClass\"\n    Identifier \"G600 misconfiguration fix\"\n    MatchProduct \"G600\"\n    # Match just the keyboard section of the G600\n    MatchIsKeyboard \"true\"\n    # evdev assumes it is a mouse when it sees the absolute axis. Stop that from happening. \n    Option \"IgnoreAbsoluteAxes\" \"on\"  \nEndSection\n```\n\n"
    },
    {
      "title": "Mad Catz Mouse",
      "level": 3,
      "content": "Mad Catz Mouse\n\n"
    },
    {
      "title": "Logitech M560/M545/M546",
      "level": 3,
      "content": "These mice are designed for Windows 8 and have non-conventional behavior: the mouse appears as a mouse and keyboard and some buttons do not emit the standard mouse button event but a combination of keyboard and mouse button presses instead. This prevents \"comfortable\" use of this mouse under Linux.\n\nThe appropriate driver allows the mouse to be used like an ordinary mouse:\n\nNote: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\n- kernel module for M560 (already merged into kernel v4.2)\n- kernel module for M545/M546\n\nSee also Xbindkeys for mouse button mapping.\n\n"
    },
    {
      "title": "Logitech G5 mouse: Binding + and -",
      "level": 3,
      "content": "If you want to bind the buttons + and - in G5/7 mouse, which normally changes DPI, you have to use g5hack [3] released by a lomoco author.\n\n```\nwget http://piie.net/temp/g5_hiddev.c\ngcc -o g5hack g5_hiddev.c\n./g5hack /dev/usb/hiddev0 3\n```\n\nThis will change your DPI to 2000, light the 1st LED and disables DPI on-the-fly changing, so you can use it with evrouter. If you would use it frequently I suggest you to copy it to the /usr/bin directory:\n\n```\n# cp g5hack /usr/bin/\n```\n\nIf you want to bind your + and - buttons you must copy the line at the bottom (one with the comment '\"-\" button does not function anymore' above) to the mode you will be using, like, for example, under the \"case 3:\" you can put it on the line with the comment 'turn on third led' above (deleting the old one before of course).\n\nFor the newest G5 mouse which is reported as \"product 0xc049\" original hack does not work. You have to simply change the #define MOUSE_G5 0xc041 to #define MOUSE_G5 0xc049 and recompile.\n\nYou can execute the g5hack tool at system start up using systemd unit. See Systemd#Writing unit files for detail.\n\n"
    },
    {
      "title": "If Arch is a guest virtual machine",
      "level": 2,
      "content": "If you want to support more than two or three mouse buttons, the capability will depend on your hypervisor software.\n\n"
    },
    {
      "title": "VMware workstation",
      "level": 3,
      "content": "For your Arch-based guest VM, add the below lines to its .vmx configuration file:\n\n```\nmouse.vusb.enable = \"TRUE\"\nmouse.vusb.useBasicMouse = \"FALSE\"\n```\n\n"
    }
  ]
}