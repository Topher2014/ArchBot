{
  "title": "Stress testing (Polski)",
  "url": "https://wiki.archlinux.org/title/Stress_testing_(Polski)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Powiązane artykuły\n\n- Benchmarking\n- Sysstat\n\nTesty obciążeniowe to proces uruchamiania różnych obciążeń roboczych na komputerze w celu oceny jego stabilności. Jest to często wykorzystywane do niezawodnego sprawdzania stabilności podkręconego sprzętu i monitorowania zachowania termicznego systemu (np. maksymalnych temperatur, ograniczania wydajności, poziomów hałasu). Dostępnych jest kilka programów do testowania różnych części systemu, takich jak CPU, GPU, pamięć RAM i pamięć masowa, przy użyciu różnych rodzajów obciążeń.\n\n"
    },
    {
      "title": "Czynności obciążeniowe",
      "level": 2,
      "content": "Poniższa tabela zawiera poszczególne oprogramowania mogące służyć do testów obciążeniowych. Ważne jest to, żeby wykonywać testy używając obciążeń różnego rodzaju. Ma to służyć zweryfikowaniu stabilności systemu pod różnymi kątami.\n\nNote: **wysoce** \n\nTable content:\nIntensywność | Testowany sprzęt1 | Zadanie | Opis\nLekka2\nCPU, pamięć masowa | Aktualizowanie łatek | Niestandardowy skrypt aktualizujący setki łatek kernela w projekcie OpenWRT. Zobacz #Aktualizowanie łatek w OpenWRT.\nCPU, pamięć masowa | Zapisywanie obrazu dysku | Zobacz #Zapisywanie obrazu dysku.\nRAM | Testy obciążeniowe pamięci | Zobacz #MemTest86+.\nRealistyczna3\nCPU, RAM, pamięć masowa | Kompilacja | Równoległa kompilacja to dobry sposób na testowanie obciążeniowe procesora. Zobacz #GCC.\nCPU, RAM | Enkodowanie wideo | ffmpeg, x264, handbrake-cli, itd. mogą zostać użyte do enkodowania wideo. Zobacz #Enkodowanie wideo.\nCPU, RAM | Kopanie kryptowalut | xmrig - polecenie xmrig --stress będzie używało poszczególnych algorytmów kopania (bazując na modelu procesora), aby wygenerować największe, możliwe obciążenie. Dobry sposób na testowanie stabilności i temperatur.\nGPU | Renderowanie 3D | unigine-heavenAUR to benchmark karty graficznej, który się zapętla. Jest to przyzwoity test obciążeniowy dla kart graficznych. Zobacz Benchmarking#Graphics.\nSyntetyczna4 | CPU, RAM, pamięć masowa | Testy syntetyczne | stress to prosty generator obciążenia procesora, pamięci, I/O oraz dysku zaimplementowany w C. Zobacz #stress.\nCPU, RAM | Obliczanie liczb pierwszych | mprime-binAUR jest doskonałym sposobem na obciążenie procesora i pamięci. Zobacz #MPrime.\nCPU | Obliczenia algebraiczne | linpackAUR - Linpack wykorzystuje biblioteki BLAS (Basic Linear Algebra Subprograms) do wykonywania podstawowych operacji na wektorach i macierzach i jest doskonałym sposobem na sprawdzenie stabilności procesorów. Zobacz #Linpack.\nCPU | Obliczanie miejsc dziesiętnych Pi | systesterAUR to wielowątkowe oprogramowanie zdolne do wyznaczania wartości liczby pi z dokładnością do 128 000 000 miejsc po przecinku. Posiada wbudowaną kontrolę stabilności systemu. Zobacz #Systester.\nRAM | Testy obciążeniowe pamięci | stressapptestAUR to test interfejsu pamięci.\n\n- 1 Główny cel testu, praktycznie wszystkie testy będą w jakiś sposób wykorzystywały procesor i RAM.\n- 2 Testy o niskiej instensywności nie męczą komponentów zbyt mocno (jeżeli chodzi o limity prądu/termiczne). Testy te są przydatne, aby sprawdzić jak sprzęt zachowuje się w niższych poziomach mocy (tzw P states), zwłaszcza dla systemów, w których napięcie zostało obniżone (a nie podkręcone).\n- 3 Testy realistyczne bazowane są na realistycznych scenariuszach działania/obciążeniach.\n- 4 Testy syntetyczne są jawnie projektowane, aby torturować sprzęt jak najbardziej się da i mogą nie być reprezentatywne dla rzeczywistych obciążeń.\n\n"
    },
    {
      "title": "Aktualizowanie łatek w OpenWRT",
      "level": 3,
      "content": "Dobrym testem stabilności przy niskim obciążeniu jest aktualizacja zestawów poprawek w projekcie OpenWRT. Wykonaj następujące kroki.\n\n```\ngit clone --depth 1 git@github.com:openwrt/openwrt.git\ncd openwrt\nmkdir -p staging_dir/host/bin\ncp /usr/bin/sed ./staging_dir/host/bin\ncurl -Os https://raw.githubusercontent.com/KanjiMonster/maintainer-tools/master/update_kernel.sh\nchmod +x update_kernel.sh\n./update_kernel.sh -v -u 5.15\n```\n\n"
    },
    {
      "title": "stress",
      "level": 3,
      "content": "stress wykonuje pętlę, która oblicza pierwiastek kwadratowy z losowej liczby w celu obciążenia procesora. Może uruchomić jednocześnie kilka instancji, na przykład w celu obciążenia wszystkich rdzeni procesora. Może również generować obciążenie pamięci, I/O lub dysku w zależności od przekazanych parametrów. Strona często zadawanych pytań dostarcza przykłady i wyjaśnienia.\n\nAby uruchomić 4 instancje liczące pierwiastek kwadratowy, użyj polecenia:\n\n```\n$ stress --cpu 4\n```\n\n"
    },
    {
      "title": "MPrime",
      "level": 3,
      "content": "MPrime (znany również jako Prime95 w implementacji Windows i MacOS) jest powszechnie uznawany za defacto miarę stabilności systemu. MPrime w trybie testu tortur wykona serię bardzo intensywnych obliczeń procesora i porówna uzyskane wartości ze znanymi dobrymi wartościami.\n\nImplementacja na Linux nazywa się mprimeAUR.\n\nAby uruchomić mprime, wystarczy uruchomić powłokę i wpisać \"mprime\":\n\n```\n$ mprime\n```\n\nKiedy program załaduje się, wystarczy odpowiedzieć 'N' na pierwsze pytanie, aby rozpocząć testowanie:\n\n```\nMain Menu\n\n1.  Test/Primenet\n2.  Test/Worker threads\n3.  Test/Status\n4.  Test/Continue\n5.  Test/Exit\n6.  Advanced/Test\n7.  Advanced/Time\n8.  Advanced/P-1\n9.  Advanced/ECM\n10.  Advanced/Manual Communication\n11.  Advanced/Unreserve Exponent\n12.  Advanced/Quit Gimps\n13.  Options/CPU\n14.  Options/Preferences\n15.  Options/Torture Test\n16.  Options/Benchmark\n17.  Help/About\n18.  Help/About PrimeNet Server\n```\n\nIstnieje kilka opcji dotyczących testów torturowych (15. opcja menu).\n\n- FFT małych rozmiarów (opcja 1), aby obciążyć procesor\n- FFT in-place, dużych rozmiarów (opcja 2), aby obciążyć zarówno procesor jak i kontroler pamięci\n- Mieszanka (opcja 3) to opcja domyślna i oznacza tryb hybrydowy, który obciąża procesor i RAM.\n\nBłędy będą zgłaszane, jeśli wystąpią, zarówno na wyjście standardowe (stdout), jak i do ~/results.txt w celu późniejszego sprawdzenia. Wiele osób nie uważa systemu za \"stabilny\", jeśli nie może on wykonywać dużych FFT przez okres 24 godzin.\n\nPrzykład pliku ~/results.txt; zauważ, że dwie sesje z 26. czerwca wskazują na usterkę sprzętu. W tym przypadku jest to spowodowane zbyt małym napięciem procesora (vcore).\n\n```\n[Sun Jun 26 20:10:35 2011]\nFATAL ERROR: Rounding was 0.5, expected less than 0.4\nHardware failure detected, consult stress.txt file.\nFATAL ERROR: Rounding was 0.5, expected less than 0.4\nHardware failure detected, consult stress.txt file.\n[Sat Aug 20 10:50:45 2011]\nSelf-test 480K passed!\nSelf-test 480K passed!\n[Sat Aug 20 11:06:02 2011]\nSelf-test 128K passed!\nSelf-test 128K passed!\n[Sat Aug 20 11:22:10 2011]\nSelf-test 560K passed!\nSelf-test 560K passed!\n...\n```\n\n"
    },
    {
      "title": "Linpack",
      "level": 3,
      "content": "linpackAUR wykorzystuje biblioteki BLAS (Basic Linear Algebra Subprograms) do wykonywania podstawowych operacji na wektorach i macierzach. Jest to doskonały sposób na przetestowanie procesorów pod kątem stabilności (obsługiwane są tylko procesory Intel). Po instalacji użytkownicy powinni skopiować /usr/share/linpack/linpack.conf do ~/.config/linpack.conf i dostosować go do ilości pamięci w systemie.\n\n"
    },
    {
      "title": "Systester",
      "level": 3,
      "content": "SystesterAUR (aka SuperPi dla Windows) jest dostępny zarówno w wersji CLI, jak i GUI. Testuje stabilność systemu, obliczając do 128 milionów cyfr po przecinku liczby Pi i obejmuje sprawdzanie błędów. Można wybrać jeden z dwóch różnych algorytmów obliczeniowych: Quadratic Convergence of Borwein i Gauss-Legendre. Ten ostatni jest tą samą metodą, której używa popularny SuperPi dla Windows.\n\nPoniżej przykład CLI wykorzystujący 8 wątków:\n\n```\n$ systester-cli -gausslg 64M -threads 8\n```\n\n"
    },
    {
      "title": "MemTest86+",
      "level": 3,
      "content": "Możesz użyć MemTest86 (zamknięto-źródłowy) lub Memtest86+ (na licencji GPL), aby przetestować RAM.\n\n- Wersja GPL jest dostępna w obrazie instlacyjnym Arch Linuxa. Jest dostępna (do zainstalowania) dla: systemów EFI - w pakiecie memtest86+-efi, systemów BIOS - w pakiecie memtest86+\n- Wersje zamknięto-źródłowe nie wspierają systemów BIOS. Dostępne są pod pakietem memtest86-efiAUR.\n- Po instalacji, użytkownicy mogą zaktualizować GRUBa: automatycznie wykryje on pakiet i pozwoli użytkownikom na bezpośrednie uruchomienie memtest86(+).\n\n- systemów EFI - w pakiecie memtest86+-efi,\n- systemów BIOS - w pakiecie memtest86+\n\n- Wiarygodnym źródłem historii wersji jest sekcja History of MemTest86 na stronie memtest86.com, w szczególności sekcja \"2002 - 2004\" i kolejne. Należy zauważyć, że własnościowy MemTest86 od wersji 5 do 7 twierdzi, że obsługuje zarówno BIOS, jak i UEFI, ale po prostu łączy stare i nowe wersje.\n- Zwykle wystarczające jest umożliwienie testom wykonania co najmniej 10 cykli bez błędów.\n\n"
    },
    {
      "title": "Zapisywanie obrazu dysku",
      "level": 3,
      "content": "Dobrym testem stabilności przy niskim obciążeniu jest użycie dd do sformatowania obrazu. Może to być dysk fizyczny lub obraz zamontowany w pętli (loop). Poniższy skrypt wykorzystuje zamontowany obraz i cyklicznie przechodzi przez każdy rdzeń jeden po drugim. Zauważ, że powinieneś dostosować zmienne w górnej części skryptu, aby pasowały do twojego systemu. Domyślnie skrypt uruchamia polecenie tylko raz na rdzeń. Można go łatwo dostosować, aby działał na znanych słabych rdzeniach, zamiast skanować wszystkie rdzenie od 0 do n, zmieniając pętlę for. Uruchom skrypt jako root.\n\n```\nformat-test.sh\n```\n\n```\n#!/bin/bash\n\n# zdefiuniuj scieżkę zapisu obrazu, zalecane jest, aby była to lokalizacja zamontowana jako tmpfs, aby uniknąć odczytów/zapisów\nimg=/scratch/image.img\n\n# zdefiniuj punkt montowania\nmnt=/mnt/loop\n\n# wielkość argumentu time do przekazania do truncate, upewnij się, aby wybrać liczbę mniejszą od ilości wolnej pamięci systemu\n# zobacz truncate --help po więcej opcji\nsize=40G\n\n# domyślnie 1, powinno być mniejsze niż liczba wątków, opcjonalnie można zdefiniować ręcznie\nmax=$(($(nproc) - 1))\n\nif [[ ! -f $img ]]; then\n  truncate -s $size $img\n  mkfs.ext4 $img\n  [[ -d $mnt ]] || mkdir -p $mnt\n  if ! mountpoint -q $mnt; then\n    mount -o loop $img $mnt || exit 1\n  fi\nfi\n\nfor i in $(eval echo \"{0..$max}\"); do\n  echo \"używam rdzenia $i z $max\"\n  taskset -c \"$i\" time dd if=/dev/zero of=$mnt/zerofill status=progress\ndone\n\numount $mnt\nrm $img\n```\n\n"
    },
    {
      "title": "GCC",
      "level": 3,
      "content": "Równoległa kompilacja przy użyciu GCC (lub innych kompilatorów) spowoduje duże obciążenie procesora i pamięci. Aby uniknąć zadławienia I/O, kompiluj na dysku SSD lub w tmpfs.\n\nDobrym przykładem może być kompilacja jądra: zobacz Kernel/Arch build system po szczegółowe instrukcje, uruchom makepkg -sf MAKEFLAGS=\"-j$(nproc)\" w Kernel/Arch build system#Compiling.\n\n"
    },
    {
      "title": "Enkodowanie wideo",
      "level": 3,
      "content": "Większość koderów wideo jest wysoce równoległa i zaprojektowana tak, aby wykorzystywać większość możliwości procesora. Poniższy przykład koduje szum przy użyciu x265 i odrzuca wynik. Spowoduje to znaczne obciążenie procesora.\n\n```\nffmpeg -y -f rawvideo -video_size 1920x1080 -pixel_format yuv420p -framerate 60 -i /dev/urandom -c:v libx265 -preset placebo -f matroska /dev/null\n```\n\n"
    },
    {
      "title": "Wykrywanie błędów",
      "level": 2,
      "content": "Niektóre aplikacje stresujące, takie jak #MPrime lub #Linpack, mają wbudowane kontrole spójności, aby wykryć błędy spowodowane niepasującymi wynikami. Bardziej ogólną i prostą metodę pomiaru niestabilności sprzętu można znaleźć w samym jądrze. Aby z niej skorzystać, wystarczy przefiltrować dziennik awarii w następujący sposób:\n\n```\n# journalctl -k --grep=mce\n```\n\nChipy wielordzeniowe mogą również podawać informacje o tym, który rdzeń fizyczny/logiczny spowodował błąd. Może to być ważne, jeśli użytkownicy optymalizują ustawienia dla poszczególnych rdzeni.\n\nJądro może wyrzucać te błędy podczas działania obciążającej aplikacji, zanim zakończy obliczenia i zgłosi błąd, zapewniając w ten sposób bardzo czułą metodę oceny stabilności. Rozważmy poniższy przykład z procesora Ryzen 5900X:\n\n```\nmce: [Hardware Error]: Machine check events logged\nmce: [Hardware Error]: CPU 21: Machine Check: 0 Bank 5: baa0000000030150\nmce: [Hardware Error]: TSC 0 MISC d012000100000000 SYND 4d000002 IPID 500b000000000\nmce: [Hardware Error]: PROCESSOR 2:a20f10 TIME 1625265814 SOCKET 0 APIC 4 microcode a201016\n```\n\nTen układ ma 12 fizycznych rdzeni. W tym przypadku CPU 21 można przypisać do fizycznego rdzenia 10. Użyj lstopo z hwloc aby wyświetlić topologię sprzętu.\n\n```\nCore 0 = CPU 0 + CPU 1\nCore 1 = CPU 2 + CPU 3\nCore 2 = CPU 4 + CPU 5\nCore 3 = CPU 6 + CPU 7\nCore 4 = CPU 8 + CPU 9\nCore 5 = CPU 10 + CPU 11\nCore 6 = CPU 12 + CPU 13\nCore 7 = CPU 14 + CPU 15\nCore 8 = CPU 16 + CPU 17\nCore 9 = CPU 18 + CPU 19\nCore 10 = CPU 20 + CPU 21\nCore 11 = CPU 22 + CPU 23\n```\n\n"
    }
  ]
}