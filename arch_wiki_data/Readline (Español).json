{
  "title": "Readline (Español)",
  "url": "https://wiki.archlinux.org/title/Readline_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2022-11-04** \n\nReadline es una biblioteca del Proyecto GNU, utilizada por Bash y otros programas con interfaz CLI para editar e interactuar con la línea de órdenes. Véase readline(3) para más información.\n\n"
    },
    {
      "title": "Instalación",
      "level": 2,
      "content": "Es probable que el paquete readline ya esté instalado como una dependencia de Bash.\n\n"
    },
    {
      "title": "Modo de edición",
      "level": 2,
      "content": "De manera predeterminada, Readline utiliza los atajos de estilo Emacs para interactuar con la línea de órdenes. Sin embargo, la interfaz de edición de estilo vi también están soportados añadiendo lo siguiente a ~/.inputrc:\n\n```\n~/.inputrc\n```\n\n```\nset editing-mode vi\n```\n\nAlternativamente, para configurarlo solo para Bash, añada la siguiente línea a ~/.bashrc:\n\n```\n~/.bashrc\n```\n\n```\nset -o vi\n```\n\n"
    },
    {
      "title": "Indicador de modo en el prompt",
      "level": 3,
      "content": "La edición de estilo vi tiene dos modos: comando e insertar. Puede visualizar cuál está activo actualmente añadiendo la siguiente opción:\n\n```\n~/.inputrc\n```\n\n```\nset show-mode-in-prompt on\n```\n\nEsto imprimirá una cadena en su prompt ((cmd)/(ins) por defecto) que se puede personalizar con las variables vi-ins-mode-string y vi-cmd-mode-string.\n\n"
    },
    {
      "title": "Diferentes formas de cursor para cada modo",
      "level": 3,
      "content": "Puede configurar una forma de cursor diferente para cada modo utilizando \"\\1 .. \\2\" escapes:\n\n```\n~/.inputrc\n```\n\n```\nset vi-ins-mode-string \\1\\e[6 q\\2\nset vi-cmd-mode-string \\1\\e[2 q\\2\n```\n\nEsto establecerá un cursor en forma de bloque cuando esté en el modo de comando y un cursor de tubería cuando esté en el modo de inserción. Tenga en cuenta que debe tener activado el indicador de modo para que esto funcione (véase #Indicador de modo en el prompt.\n\nLa consola virtual utiliza diferentes códigos de escape, por lo que antes debe verificar qué terminal se está utilizando:\n\n```\n~/.inputrc\n```\n\n```\n$if term=linux\n\tset vi-ins-mode-string \\1\\e[?0c\\2\n\tset vi-cmd-mode-string \\1\\e[?8c\\2\n$else\n\tset vi-ins-mode-string \\1\\e[6 q\\2\n\tset vi-cmd-mode-string \\1\\e[2 q\\2\n$endif\n```\n\nVéase Cursor software para VGA para mas detalles.\n\n"
    },
    {
      "title": "Movimiento rápido entre palabras",
      "level": 2,
      "content": "Xterm permite moverse entre palabras con Control+Izquierda y Control+Derecha de forma predeterminada. Para lograr este efecto con otros emuladores de terminal, encuentre los códigos de terminal correctos [1], y conéctelos a backward-word y forward-word en ~/.inputrc.\n\nPor ejemplo, para urxvt:\n\n```\n~/.inputrc\n```\n\n```\n\"\\e[1;5D\": backward-word\n\"\\e[1;5C\": forward-word\n```\n\n"
    },
    {
      "title": "Historial",
      "level": 2,
      "content": "Por lo general, presionar la tecla de flecha hacia arriba hará que se muestre la última orden, independientemente de la orden que se haya escrito hasta el momento. Sin embargo, a los usuarios les puede resultar más práctico listar solo las órdenes anteriores ​​que coincidan con la entrada actual.\n\nPor ejemplo, si el usuario ha escrito las siguientes órdenes:\n\n- ls /usr/src/linux-2.6.15-ARCH/kernel/power/Kconfig\n- who\n- mount\n- man mount\n\nEn esta situación, al escribir ls y presionar la tecla de flecha hacia arriba, la entrada actual se reemplazará con man mount, la última orden ejecutada. Si se ha habilitado la búsqueda de historial, solo se mostrarán las órdenes anteriores que comiencen con ls (la entrada actual), en este caso ls /usr/src/linux-2.6.15-ARCH/kernel/power/Kconfig.\n\nPuede habilitar el modo de búsqueda de historial añadiendo las siguientes líneas a /etc/inputrc o ~/.inputrc:\n\n```\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n```\n\nSi está utilizando el modo vi, puede añadir las siguientes líneas a ~/.inputrc (de esta publicación):\n\n```\nset editing-mode vi\n$if mode=vi\nset keymap vi-command\n# estos son para el modo de órdenes vi\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\nj: history-search-forward\nk: history-search-backward\nset keymap vi-insert\n# estos son para el modo de inserción vi\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n$endif\n```\n\nSi eligió añadir estas líneas a ~/.inputrc, se recomienda que también añada la siguiente línea al principio de este archivo para evitar cosas extrañas como esta:\n\n```\n$include /etc/inputrc\n```\n\nAlternativamente, se puede utilizar el historial de búsqueda inversa (búsqueda incremental) presionando Control+R, que no busca en base a la entrada anterior, sino que salta hacia atrás en el búfer del historial a medida que se escriben las órdenes en la búsqueda de términos. Al presionar nuevamente Control+R durante este modo, se mostrará la línea anterior en el búfer que coincide con el término de búsqueda actual, mientras que al presionar Control+G (abortar) se cancelará la búsqueda y se restaurará la línea de entrada actual. Entonces, para buscar en todos las órdenes mount anteriores, presione Control+R, escriba 'mount' y siga presionando Control+R hasta que se encuentre la línea deseada.\n\nEl equivalente directo de este modo se denomina historial de búsqueda avanzada y está vinculado a Control+S de forma predeterminada. Tenga en cuenta que la mayoría de los terminales anulan Control+S para suspender la ejecución hasta que se presione Control+Q. (A esto se le llama control de flujo XON/XOFF). Para activar el historial de búsqueda avanzada, deshabilite el control de flujo de esta forma:\n\n```\n$ stty -ixon\n```\n\no utilice una tecla diferente en inputrc. Por ejemplo, para utilizar Alt+S que no está enlazado por defecto:\n\n```\n\"\\es\": forward-search-history\n```\n\n"
    },
    {
      "title": "Completado más rápido",
      "level": 2,
      "content": "Al realizar el completado mediante tabulador, una sola pulsación intenta completar parcialmente la palabra actual. Si no son posibles los completados parciales, una doble pulsación muestra todas los completados posibles.\n\nLa doble pulsación de tabulador se puede cambiar a una sola pulsación con la configuración siguiente:\n\n```\n~/.inputrc\n```\n\n```\nset show-all-if-unmodified on\n```\n\nO puede configurarlo de modo que una sola pulsación de tabulador realice ambos pasos: que complete parcialmente la palabra y que muestre todas los completados posibles si aún es ambigua:\n\n```\n~/.inputrc\n```\n\n```\nset show-all-if-ambiguous on\n```\n\n"
    },
    {
      "title": "Colores en el completado",
      "level": 2,
      "content": "Puede habilitar el coloreado del completado de los nombres de archivo con la opción colored-stats. También puede colorear el prefijo idéntico de las listas de completado con colored-completed-prefix. Por ejemplo:\n\n```\n~/.inputrc\n```\n\n```\n# Archivos de color por tipos\n# Tenga en cuenta que esto puede hacer que el texto de finalización parpadee en algunos terminales (p.e. xterm)\nset colored-stats On\n# Añadir un carácter para indicar el tipo\nset visible-stats On\n# Marcar directorios enlazados\nset mark-symlinked-directories On\n# Colorea el prefijo común\nset colored-completion-prefix On\n# Colorea el prefijo común en completado por menú\nset menu-complete-display-prefix On\n```\n\n"
    },
    {
      "title": "Macros",
      "level": 2,
      "content": "Readline también admite teclas enlazadas para macros de teclado. Para un ejemplo simple, ejecute esta orden en Bash:\n\n```\nbind '\"\\ew\": \"\\C-e # macro\"'\n```\n\no añada la parte entre comillas simples a inputrc:\n\n```\n\"\\ew\": \"\\C-e # macro\"\n```\n\nAhora escriba una línea y presione Alt+W. Readline actuará como si se hubiera presionado Control+E (final de línea), añadido con ' # macro'.\n\nUtilice cualquiera de las combinaciones de teclas existentes dentro de una macro de readline, lo que puede ser bastante útil para automatizar los términos de uso frecuente. Por ejemplo, este hace que Control+Alt+L añada \"| less\" a la línea y la ejecute (Control+M es equivalente a Intro):\n\n```\n\"\\e\\C-l\": \"\\C-e | less\\C-m\"\n```\n\nEl siguiente prefija la línea con 'yes |' al presionar Control+Alt+Y, confirmando cualquier pregunta de sí/no que la orden pudiera preguntar:\n\n```\n\"\\e\\C-y\": \"\\C-ayes | \\C-m\"\n```\n\nEste ejemplo ajusta la línea en su -c '', si se presiona Alt+S:\n\n```\n\"\\es\": \"\\C-a su -c '\\C-e'\\C-m\"\n```\n\nEste ejemplo prefija la línea con sudo, si se presiona Alt+S. Es más seguro porque no introduce la tecla Intro.\n\n```\n\"\\es\": \"\\C-asudo \\C-e\"\n```\n\nComo último ejemplo, envíe rápidamente una orden en segundo plano con Control+Alt+B, descartando toda su salida:\n\n```\n\"\\e\\C-b\": \"\\C-e > /dev/null 2>&1 &\\C-m\"\n```\n\n"
    },
    {
      "title": "Desactivando el control de eco",
      "level": 2,
      "content": "Readline hace que el terminal se haga eco de ^C después de presionar Control+C. Para los usuarios que deseen deshabilitar esto, simplemente añada lo siguiente a ~/.inputrc:\n\n```\nset echo-control-characters off\n```\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- Hoja de trucos de edición de vi readline\n- Hoja de trucos de edición de emacs readline\n\n"
    }
  ]
}