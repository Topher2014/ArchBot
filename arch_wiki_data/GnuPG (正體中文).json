{
  "title": "GnuPG (正體中文)",
  "url": "https://wiki.archlinux.org/title/GnuPG_(%E6%AD%A3%E9%AB%94%E4%B8%AD%E6%96%87)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- pacman/Package signing\n- Data-at-rest encryption\n- List of applications/Security#Encryption, signing, steganography\n- OpenPGP\n\nAccording to the official website:\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the gnupg package.\n\nThis will also install pinentry, a collection of simple PIN or passphrase entry dialogs which GnuPG uses for passphrase entry. The shell script /usr/bin/pinentry determines which pinentry dialog is used, in the order described at #pinentry.\n\nIf you want to use a graphical frontend or program that integrates with GnuPG, see List of applications/Security#Encryption, signing, steganography.\n\n"
    },
    {
      "title": "Home directory",
      "level": 3,
      "content": "The GnuPG home directory is where the GnuPG suite stores its keyrings and private keys, and reads configurations from. By default, the path used is ~/.gnupg. There are two ways to override this:\n\n- Set the $GNUPGHOME environment variable.\n- Use the --homedir argument, e.g. $ gpg --homedir path/to/dir [1].\n\nBy default, the home directory has its permissions set to 700 and the files it contains have their permissions set to 600. Only the owner of the directory has permission to read, write, and access the files. This is for security purposes and should not be changed. In case this directory or any file inside it does not follow this security measure, you will get warnings about unsafe file and home directory permissions.\n\n"
    },
    {
      "title": "Configuration files",
      "level": 3,
      "content": "All of GnuPG's behavior is configurable via command line arguments. For arguments you would like to be the default, you can add them to the respective configuration file:\n\n- gpg checks gnupg_home/gpg.conf (user) and /etc/gnupg/gpg.conf (global) [2]. Since gpg is the main entrypoint for GnuPG, most configuration of interest will be here. See GPG Options for possible options.\n- dirmngr checks gnupg_home/dirmngr.conf and /etc/gnupg/dirmngr.conf. dirmngr is a program internally invoked by gpg to access PGP keyservers [3]. See Dirmngr Options for possible options.\n\nThese two configuration files cover the common usecases, but there are more auxiliary programs in the GnuPG suite with their own options. See the GnuPG manual for a comprehensive list.\n\nCreate the desired file(s), and set their permissions to 600 as discussed in #Home directory.\n\nAdd to these files any long options you want. Do not write the two dashes, but simply the name of the option and required arguments. For example, to make GnuPG always use a keyring at a specific path, as if it was invoked as gpg --no-default-keyring --keyring keyring-path ...:\n\n```\ngnupg_home/gpg.conf (or /etc/gnupg/gpg.conf)\n```\n\n```\nno-default-keyring\nkeyring keyring-path\n```\n\nOther examples are found in #See also.\n\nAdditionally, pacman uses a different set of configuration files for package signature verification. See Pacman/Package signing for details.\n\n"
    },
    {
      "title": "Default options for new users",
      "level": 3,
      "content": "If you want to setup some default options for new users, put configuration files in /etc/skel/.gnupg/. When the new user is added in system, files from here will be copied to its GnuPG home directory. There is also a simple script called addgnupghome which you can use to create new GnuPG home directories for existing users:\n\n```\n# addgnupghome user1 user2\n```\n\nThis will add the respective /home/user1/.gnupg/ and /home/user2/.gnupg/ and copy the files from the skeleton directory to it. Users with existing GnuPG home directory are simply skipped.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "- Whenever a user-id is required in a command, it can be specified with your key ID, fingerprint, a part of your name or email address, etc. GnuPG is flexible on this.\n- Whenever a key-id is needed, it can be found adding the --keyid-format=long flag to the command. To show the master secret key for example, run gpg --list-secret-keys --keyid-format=long user-id, the key-id is the hexadecimal hash provided on the same line as sec.\n\n"
    },
    {
      "title": "Create a key pair",
      "level": 3,
      "content": "Generate a key pair by typing in a terminal:\n\n```\n$ gpg --full-gen-key\n```\n\nAlso add the --expert option to the command line to access more ciphers and in particular some newer elliptic curves like Curve448.\n\nThe command will prompt for answers to several questions. For general use most people will want:\n\n- The default ECC (sign and encrypt) for signing and encryption keys.\n- The default Curve 25519 to use Curve25519 and Ed25519.\n- An expiration date: a period of one year is good enough for the average user. This way even if access is lost to the keyring, it will allow others to know that it is no longer valid. At a later stage, if necessary, the expiration date can be extended without having to re-issue a new key.\n- Your name and email address. You can add multiple identities to the same key later (e.g., if you have multiple email addresses you want to associate with this key).\n- no optional comment. Since the semantics of the comment field are not well-defined, it has limited value for identification.\n- A secure passphrase, find some guidelines in Security#Choosing secure passwords.\n\n"
    },
    {
      "title": "List keys",
      "level": 3,
      "content": "To list keys in your public key ring:\n\n```\n$ gpg --list-keys\n```\n\nTo list keys in your secret key ring:\n\n```\n$ gpg --list-secret-keys\n```\n\n"
    },
    {
      "title": "Export your public key",
      "level": 3,
      "content": "GnuPG's main usage is to ensure confidentiality of exchanged messages via public-key cryptography. With it each user distributes the public key of their keyring, which can be used by others to encrypt messages to the user. The private key must always be kept private, otherwise confidentiality is broken. See Wikipedia:Public-key cryptography for examples about the message exchange.\n\nSo, in order for others to send encrypted messages to you, they need your public key.\n\nTo generate an ASCII version of a user's public key to file public-key.asc (e.g. to distribute it by e-mail):\n\n```\n$ gpg --export --armor --output public-key.asc user-id\n```\n\nAlternatively, or in addition, you can use a keyserver to share your key.\n\n- Add --no-emit-version to avoid printing the version number, or add the corresponding setting to your gpg.conf.\n- You can omit the user-id to export all public keys within your keyring. This is useful if you want to share multiple identities at once, or for importing in another application, e.g. Thunderbird.\n\n"
    },
    {
      "title": "Import a public key",
      "level": 3,
      "content": "In order to encrypt messages to others, as well as verify their signatures, you need their public key. To import a public key with file name public-key.asc to your public key ring:\n\n```\n$ gpg --import public-key.asc\n```\n\nAlternatively, use a keyserver to find a public key.\n\nIf you wish to import a key ID to install a specific Arch Linux package, see pacman/Package signing#Managing the keyring and Makepkg#Signature checking.\n\n"
    },
    {
      "title": "Sending keys",
      "level": 4,
      "content": "You can register your key with a public PGP key server, so that others can retrieve it without having to contact you directly:\n\n```\n$ gpg --send-keys key-id\n```\n\n"
    },
    {
      "title": "Searching and receiving keys",
      "level": 4,
      "content": "To find out details of a key on the keyserver, without importing it, do:\n\n```\n$ gpg --search-keys user-id\n```\n\nTo import a key from a key server:\n\n```\n$ gpg --receive-keys key-id\n```\n\nTo refresh/update the keychain with the latest version from a key server:\n\n```\n$ gpg --refresh-keys\n```\n\n- You should verify the authenticity of the retrieved public key by comparing its fingerprint with one that the owner published on an independent source(s) (e.g., contacting the person directly). See Wikipedia:Public key fingerprint for more information.\n- It is recommended to use the long key ID or the full fingerprint when receiving a key. Using a short ID may encounter collisions. All keys will be imported that have the short ID, see fake keys found in the wild for such example.\n\nNote: **privacy violation** \n\n"
    },
    {
      "title": "Key servers",
      "level": 4,
      "content": "See OpenPGP#Keyserver for a general overview of OpenPGP keyservers and their features.\n\nAn alternative key server can be specified with the keyserver option in one of the configuration files, for instance:\n\n```\n~/.gnupg/dirmngr.conf\n```\n\n```\nkeyserver hkp://keyserver.ubuntu.com\n```\n\nA temporary use of another server is handy when the regular one does not work as it should. It can be achieved by, for example,\n\n```\n$ gpg --keyserver hkps://keys.openpgp.org/ --search-keys user-id\n```\n\n- If you are experiencing keyserver failures, you may want to check your DNS and your resolver configurations or its logs beforehand (e.g systemd-resolved).\n- If receiving fails with the message gpg: keyserver receive failed: Connection refused, try using a different DNS server.\n- If connecting to a keyserver fails with gpg: keyserver receive failed: Server indicated a failure, you may need to configure gpg to use an alternate port. For example, to use port 80 on Ubuntu's keyserver, use keyserver hkp://keyserver.ubuntu.com:80.\n- You can connect to the keyserver over Tor with Tor#Torsocks. Or using the --use-tor command line option. See [4] for more information.\n- You can connect to a keyserver using a proxy by setting the http_proxy environment variable and setting honor-http-proxy in dirmngr.conf. Alternatively, set http-proxy host[:port] in the configuration file to override the environment variable of the same name. Restart the dirmngr.service user service for the changes to take effect.\n\n"
    },
    {
      "title": "Web Key Directory",
      "level": 3,
      "content": "See OpenPGP#Web Key Directory for a general overview.\n\n"
    },
    {
      "title": "Lookup certificates using WKD",
      "level": 4,
      "content": "When encrypting to an email address (e.g. user@example.org), GnuPG (>=2.1.16) will query the domain (example.com) via HTTPS for the public OpenPGP key if it is not already in the local keyring. The option --auto-key-locate will default to locate a key using the WKD protocol, if there is no key on the local keyring for this email address:\n\n```\n$ gpg --recipient user@example.org --auto-key-locate --encrypt doc\n```\n\n"
    },
    {
      "title": "Create a WKD",
      "level": 4,
      "content": "If you control the domain of your email address yourself, you can follow this guide to enable WKD for your domain.\n\n"
    },
    {
      "title": "Asymmetric",
      "level": 4,
      "content": "You need to import a public key of a user before encrypting (option -e/--encrypt) a file or message to that recipient (option -r/--recipient). Additionally you need to create a key pair if you have not already done so.\n\nTo encrypt a file with the name doc, use:\n\n```\n$ gpg --recipient user-id --encrypt doc\n```\n\nTo decrypt (option -d/--decrypt) a file with the name doc.gpg encrypted with your public key, use:\n\n```\n$ gpg --output doc --decrypt doc.gpg\n```\n\ngpg will prompt you for your passphrase and then decrypt and write the data from doc.gpg to doc. If you omit the -o/--output option, gpg will write the decrypted data to stdout.\n\n- Add --armor to encrypt a file using ASCII armor, suitable for copying and pasting a message in text format.\n- Use -R user-id or --hidden-recipient user-id instead of -r to not put the recipient key IDs in the encrypted message. This helps to hide the receivers of the message and is a limited countermeasure against traffic analysis.\n- Add --no-emit-version to avoid printing the version number, or add the corresponding setting to your configuration file.\n- You can use GnuPG to encrypt your sensitive documents by using your own user-id as recipient or by using the --default-recipient-self flag; however, you can only do this one file at a time, although you can always tarball various files and then encrypt the tarball. See also Data-at-rest encryption#Available methods if you want to encrypt directories or a whole file-system.\n\n"
    },
    {
      "title": "Symmetric",
      "level": 4,
      "content": "Symmetric encryption does not require the generation of a key pair and can be used to simply encrypt data with a passphrase. Simply use -c/--symmetric to perform symmetric encryption:\n\n```\n$ gpg -c doc\n```\n\nThe following example:\n\n- Encrypts doc with a symmetric cipher using a passphrase\n- Uses the AES-256 cipher algorithm to encrypt the data\n- Uses the SHA-512 digest algorithm to mangle the passphrase and generate the encryption key\n- Mangles the passphrase for 65536 iterations\n\n```\n$ gpg -c --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-count 65536 doc\n```\n\nTo decrypt a symmetrically encrypted doc.gpg using a passphrase and output decrypted contents into the same directory as doc do:\n\n```\n$ gpg --output doc --decrypt doc.gpg\n```\n\n"
    },
    {
      "title": "Directory",
      "level": 4,
      "content": "Encrypting/decrypting a directory can be done with gpgtar(1).\n\nEncrypt:\n\n```\n$ gpgtar -c -o dir.gpg dir\n```\n\nDecrypt:\n\n```\n$ gpgtar -d dir.gpg\n```\n\n"
    },
    {
      "title": "Backup your private key",
      "level": 3,
      "content": "To backup your private key do the following:\n\n```\n$ gpg --export-secret-keys --armor --output private-key.asc user-id\n```\n\nIf the private key is protected by a passphrase, the exported key file will be protected by the same one.\n\nGnuPG may ask you to enter the passphrase for the key. This is required, because the internal protection method of the secret key is different from the one specified by the OpenPGP protocol.[5]\n\n- The passphrase is usually the weakest link in protecting your secret key. Place the private key in a safe place on a different system/device, such as a locked container or encrypted drive. It is the only safety you have to regain control to your keyring in case of, for example, a drive failure, theft or worse.\n- This method of backing up key has some security limitations. See the Moving GPG Keys Privately post on VHSblog for a potentially more secure way to back up and import keys using gpg.\n\nTo import the backup of your private key:\n\n```\n$ gpg --import private-key.asc\n```\n\n"
    },
    {
      "title": "Backup your revocation certificate",
      "level": 3,
      "content": "Revocation certificates are automatically generated for newly generated keys. These are by default located in ~/.gnupg/openpgp-revocs.d/. The filename of the certificate is the fingerprint of the key it will revoke. The revocation certificates can also be generated manually by the user later using:\n\n```\n$ gpg --gen-revoke --armor --output revcert.asc user-id\n```\n\nThis certificate can be used to revoke a key if it is ever lost or compromised. The backup will be useful if you have no longer access to the secret key and are therefore not able to generate a new revocation certificate with the above command. It is short enough to be printed out and typed in by hand if necessary.\n\n"
    },
    {
      "title": "Edit your key",
      "level": 3,
      "content": "Running the gpg --edit-key user-id command will present a menu which enables you to do most of your key management related tasks.\n\nType help in the edit key sub menu to show the complete list of commands. Some useful ones:\n\n```\n> passwd       # change the passphrase\n> clean        # compact any user ID that is no longer usable (e.g revoked or expired)\n> revkey       # revoke a key\n> addkey       # add a subkey to this key\n> expire       # change the key expiration time\n> adduid       # add additional names, comments, and email addresses\n> addphoto     # add photo to key (must be JPG, 240x288 recommended, enter full path to image when prompted)\n```\n\n"
    },
    {
      "title": "Exporting subkey",
      "level": 3,
      "content": "If you plan to use the same key across multiple devices, you may want to strip out your master key and only keep the bare minimum encryption subkey on less secure systems.\n\nFirst, find out which subkey you want to export.\n\n```\n$ gpg --list-secret-keys --with-subkey-fingerprint\n```\n\nSelect only that subkey to export.\n\n```\n$ gpg --armor --export-secret-subkeys subkey-id! > /tmp/subkey.asc\n```\n\nAt this point you could stop, but it is most likely a good idea to change the passphrase as well. Import the key into a temporary folder.\n\n```\n$ gpg --homedir /tmp/gpg --import /tmp/subkey.asc\n$ gpg --homedir /tmp/gpg --edit-key user-id\n> passwd\n> save\n$ gpg --homedir /tmp/gpg --armor --export-secret-subkeys subkey-id! > /tmp/subkey.altpass.asc\n```\n\nAt this point, you can now use /tmp/subkey.altpass.asc on your other devices.\n\n"
    },
    {
      "title": "Extending expiration date",
      "level": 3,
      "content": "Note: **Never** \n\nIt is good practice to set an expiration date on your subkeys, so that if you lose access to the key (e.g. you forget the passphrase) the key will not continue to be used indefinitely by others. When the key expires, it is relatively straight-forward to extend the expiration date:\n\n```\n$ gpg --edit-key user-id\n> expire\n```\n\nYou will be prompted for a new expiration date, as well as the passphrase for your secret key, which is used to sign the new expiration date.\n\nRepeat this for any further subkeys that have expired:\n\n```\n> key 1\n> expire\n```\n\nFinally, save the changes and quit:\n\n```\n> save\n```\n\nUpdate it to a keyserver.\n\n```\n$ gpg --keyserver keyserver.ubuntu.com --send-keys key-id\n```\n\nAlternatively, if you use this key on multiple computers, you can export the public key (with new signed expiration dates) and import it on those machines:\n\n```\n$ gpg --export --output pubkey.gpg user-id\n$ gpg --import pubkey.gpg\n```\n\nThere is no need to re-export your secret key or update your backups: the master secret key itself never expires, and the signature of the expiration date left on the public key and subkeys is all that is needed.\n\n"
    },
    {
      "title": "Rotating subkeys",
      "level": 3,
      "content": "Note: **Never** \n\nAlternatively, if you prefer to stop using subkeys entirely once they have expired, you can create new ones. Do this a few weeks in advance to allow others to update their keyring.\n\nCreate new subkey (repeat for both signing and encrypting key)\n\n```\n$ gpg --edit-key user-id\n> addkey\n```\n\nAnd answer the following questions it asks (see #Create a key pair for suggested settings).\n\nSave changes\n\n```\n> save\n```\n\nUpdate it to a keyserver.\n\n```\n$ gpg --keyserver pgp.mit.edu --send-keys user-id\n```\n\nYou will also need to export a fresh copy of your secret keys for backup purposes. See #Backup your private key for details on how to do this.\n\n"
    },
    {
      "title": "Revoke a key",
      "level": 3,
      "content": "Key revocation should be performed if the key is compromised, superseded, no longer used, or you forget your passphrase. This is done by merging the key with the revocation certificate of the key.\n\nIf you have no longer access to your keypair, first import a public key to import your own key.\n\nThen, to revoke the key, import the file saved in #Backup your revocation certificate:\n\n```\n$ gpg --import revcert.asc\n```\n\nNow the revocation needs to be made public. Use a keyserver to send the revoked key to a public PGP server if you used one in the past, otherwise, export the revoked key to a file and distribute it to your communication partners.\n\n"
    },
    {
      "title": "Signatures",
      "level": 2,
      "content": "Signatures certify and timestamp documents. If the document is modified, verification of the signature will fail. Unlike encryption which uses the recipient public key to encrypt a document, signatures are created with the sender's private key. The recipient of a signed document then verifies the signature using the sender's public key.\n\n"
    },
    {
      "title": "Sign a file",
      "level": 4,
      "content": "To sign a file use the -s/--sign flag:\n\n```\n$ gpg --output doc.sig --sign doc\n```\n\ndoc.sig contains both the compressed content of the original file doc and the signature in a binary format, but the file is not encrypted. However, you can combine signing with encrypting.\n\n"
    },
    {
      "title": "Clearsign a file or message",
      "level": 4,
      "content": "To sign a file without compressing it into binary format use:\n\n```\n$ gpg --output doc.sig --clearsign doc\n```\n\nHere both the content of the original file doc and the signature are stored in human-readable form in doc.sig.\n\n"
    },
    {
      "title": "Make a detached signature",
      "level": 4,
      "content": "To create a separate signature file to be distributed separately from the document or file itself, use the --detach-sig flag:\n\n```\n$ gpg --output doc.sig --detach-sig doc\n```\n\nHere the signature is stored in doc.sig, but the contents of doc are not stored in it. This method is often used in distributing software projects to allow users to verify that the program has not been modified by a third party.\n\n"
    },
    {
      "title": "Verify a signature",
      "level": 3,
      "content": "To verify a signature use the --verify flag:\n\n```\n$ gpg --verify doc.sig\n```\n\nwhere doc.sig is the signed file containing the signature you wish to verify.\n\nIf you are verifying a detached signature, both the signed data file and the signature file must be present when verifying. For example, to verify Arch Linux's latest iso you would do:\n\n```\n$ gpg --verify archlinux-version.iso.sig\n```\n\nwhere archlinux-version.iso must be located in the same directory.\n\nYou can also specify the signed data file with a second argument:\n\n```\n$ gpg --verify archlinux-version.iso.sig /path/to/archlinux-version.iso\n```\n\nIf a file has been encrypted in addition to being signed, simply decrypt the file and its signature will also be verified.\n\n"
    },
    {
      "title": "gpg-agent",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\ngpg-agent is mostly used as daemon to request and cache the password for the keychain. This is useful if GnuPG is used from an external program like a mail client. gnupg comes with systemd user sockets which are enabled by default. These sockets are gpg-agent.socket, gpg-agent-extra.socket, gpg-agent-browser.socket, gpg-agent-ssh.socket, and dirmngr.socket.\n\n- The main gpg-agent.socket is used by gpg to connect to the gpg-agent daemon.\n- The intended use for the gpg-agent-extra.socket on a local system is to set up a Unix domain socket forwarding from a remote system. This enables to use gpg on the remote system without exposing the private keys to the remote system. See gpg-agent(1) for details.\n- The gpg-agent-browser.socket allows web browsers to access the gpg-agent daemon.\n- The gpg-agent-ssh.socket can be used by SSH to cache SSH keys added by the ssh-add program. See #SSH agent for the necessary configuration.\n- The dirmngr.socket starts a GnuPG daemon handling connections to keyservers.\n\n"
    },
    {
      "title": "Configuration",
      "level": 3,
      "content": "gpg-agent can be configured via ~/.gnupg/gpg-agent.conf file. The configuration options are listed in gpg-agent(1). For example you can change cache ttl for unused keys:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\ndefault-cache-ttl 3600\n```\n\nNote: where XXXXX is the keygrip. You can get its value when running gpg --with-keygrip --list-secret-keys. The passphrase will be stored until gpg-agent is restarted. If you set up default-cache-ttl value, it will take precedence.\n\n```\n$ /usr/lib/gnupg/gpg-preset-passphrase --preset XXXXX\n```\n\nwhere XXXXX is the keygrip. You can get its value when running gpg --with-keygrip --list-secret-keys. The passphrase will be stored until gpg-agent is restarted. If you set up default-cache-ttl value, it will take precedence.\n\n"
    },
    {
      "title": "Reload the agent",
      "level": 3,
      "content": "After changing the configuration, reload the agent using gpg-connect-agent:\n\n```\n$ gpg-connect-agent reloadagent /bye\n```\n\nThe command should print OK.\n\nHowever in some cases only the restart may not be sufficient, like when keep-screen has been added to the agent configuration. In this case you firstly need to kill the ongoing gpg-agent process and then you can restart it as was explained above.\n\n"
    },
    {
      "title": "pinentry",
      "level": 3,
      "content": "gpg-agent can be configured via the pinentry-program stanza to use a particular pinentry user interface when prompting the user for a passphrase. For example:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\npinentry-program /usr/bin/pinentry-curses\n```\n\nThere are other pinentry programs that you can choose from - see pacman -Ql pinentry | grep /usr/bin/. You may need to install the relevant optional dependencies for your chosen pinentry program.\n\n- The pinentry programs /usr/bin/pinentry-gnome3 (GNOME), /usr/bin/pinentry-qt, /usr/bin/pinentry-qt5 and /usr/bin/pinentry-gtk (generic) [8] support the DBus Secret Service API, which allows for remembering passwords via a compliant manager such as GNOME Keyring, KeePassXC or KDE Wallet.\n- An alternative for KDE Wallet is /usr/bin/pinentry-kwallet which requires installing the kwalletcliAUR package.\n\nRemember to reload the agent after making changes to the configuration.\n\n"
    },
    {
      "title": "Cache passwords",
      "level": 3,
      "content": "max-cache-ttl and default-cache-ttl defines how many seconds gpg-agent should cache the passwords. To enter a password once a session, set them to something very high, for instance:\n\n```\ngpg-agent.conf\n```\n\n```\nmax-cache-ttl 60480000\ndefault-cache-ttl 60480000\n```\n\nFor password caching in SSH emulation mode, set default-cache-ttl-ssh and max-cache-ttl-ssh instead, for example:\n\n```\ngpg-agent.conf\n```\n\n```\ndefault-cache-ttl-ssh 60480000\nmax-cache-ttl-ssh 60480000\n```\n\n"
    },
    {
      "title": "Unattended passphrase",
      "level": 3,
      "content": "Starting with GnuPG 2.1.0 the use of gpg-agent and pinentry is required, which may break backwards compatibility for passphrases piped in from STDIN using the --passphrase-fd 0 commandline option. In order to have the same type of functionality as the older releases two things must be done:\n\nFirst, edit the gpg-agent configuration to allow loopback pinentry mode:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\nallow-loopback-pinentry\n```\n\nReload the agent if it is running to let the change take effect.\n\nSecond, either the application needs to be updated to include a commandline parameter to use loopback mode like so:\n\n```\n$ gpg --pinentry-mode loopback ...\n```\n\n...or if this is not possible, add the option to the configuration:\n\n```\n~/.gnupg/gpg.conf\n```\n\n```\npinentry-mode loopback\n```\n\n"
    },
    {
      "title": "SSH agent",
      "level": 3,
      "content": "gpg-agent has OpenSSH agent emulation. If you already use the GnuPG suite, you might consider using its agent to also cache your SSH keys. Additionally, some users may prefer the PIN entry dialog GnuPG agent provides as part of its passphrase management.\n\n"
    },
    {
      "title": "Set SSH_AUTH_SOCK",
      "level": 4,
      "content": "Set the following variables to communicate with gpg-agent instead of the default ssh-agent.\n\n```\nSSH_AGENT_PID=\"\"\nSSH_AUTH_SOCK=\"${XDG_RUNTIME_DIR}/gnupg/S.gpg-agent.ssh\"\n```\n\n- If you are using a script to manage your variables, you may also unset SSH_AGENT_PID rather than setting it to \"\", via unset SSH_AGENT_PID.\n- If you set your SSH_AUTH_SOCK manually, keep in mind that your socket location may be different if you are using a custom GNUPGHOME. You can use the following bash example, or change SSH_AUTH_SOCK to the value of gpgconf --list-dirs agent-ssh-socket.\n- If GNOME Keyring is installed, it is necessary to deactivate its ssh component. Otherwise, it will overwrite SSH_AUTH_SOCK.\n\nAlternatively, depend on Bash. This works for non-standard socket locations as well:\n\n```\n~/.bashrc\n```\n\n```\nunset SSH_AGENT_PID\nif [ \"${gnupg_SSH_AUTH_SOCK_by:-0}\" -ne $$ ]; then\n  export SSH_AUTH_SOCK=\"$(gpgconf --list-dirs agent-ssh-socket)\"\nfi\n```\n\n"
    },
    {
      "title": "Configure pinentry to use the correct TTY",
      "level": 4,
      "content": "Also set the GPG_TTY and refresh the TTY in case user has switched into an X session as stated in gpg-agent(1). For example:\n\n```\n~/.bashrc\n```\n\n```\nexport GPG_TTY=$(tty)\ngpg-connect-agent updatestartuptty /bye >/dev/null\n```\n\nIf you use multiple terminals simultaneously and want gpg-agent to ask for passphrase via pinentry-curses from the same terminal where the ssh command was run, add the following to the SSH configuration file. This will make the TTY to be refreshed every time an ssh command is run [11]:\n\n```\n~/.ssh/config\n```\n\n```\nMatch host * exec \"gpg-connect-agent UPDATESTARTUPTTY /bye\"\n```\n\nNote that GPG_TTY environment variable has to be set for this to work.\n\n"
    },
    {
      "title": "Add SSH keys",
      "level": 4,
      "content": "Once gpg-agent is running you can use ssh-add to approve keys, following the same steps as for ssh-agent. The list of approved keys is stored in the ~/.gnupg/sshcontrol file.\n\nOnce your key is approved, you will get a pinentry dialog every time your passphrase is needed. For password caching see #Cache passwords.\n\n"
    },
    {
      "title": "Using a PGP key for SSH authentication",
      "level": 4,
      "content": "You can also use your PGP key as an SSH key. This requires a key with the Authentication capability (see #Custom capabilities). There are various benefits gained by using a PGP key for SSH authentication, including:\n\n- Reduced key maintenance, as you will no longer need to maintain an SSH key.\n- The ability to store the authentication key on a smartcard. GnuPG will automatically detect the key when the card is available, and add it to the agent (check with ssh-add -l or ssh-add -L). The comment for the key should be something like: openpgp:key-id or cardno:card-id.\n\nTo retrieve the public key part of your GPG/SSH key, run gpg --export-ssh-key gpg-key. If your key is authentication-capable but this command still fails with \"Unusable public key\", add a ! suffix ([12]).\n\nUnless you have your GPG key on a keycard, you need to add your key to $GNUPGHOME/sshcontrol to be recognized as a SSH key. If your key is on a keycard, its keygrip is added to sshcontrol implicitly. If not, get the keygrip of your key this way:\n\n```\n$ gpg --list-keys --with-keygrip\n```\n\n```\nsub   rsa4096 2018-07-25 [A]\n      Keygrip = 1531C8084D16DC4C36911F1585AF0ACE7AAFD7E7\n```\n\nThen edit sshcontrol like this. Adding the keygrip is a one-time action; you will not need to edit the file again, unless you are adding additional keys.\n\n```\n$GNUPGHOME/sshcontrol\n```\n\n```\n1531C8084D16DC4C36911F1585AF0ACE7AAFD7E7\n```\n\n"
    },
    {
      "title": "Forwarding gpg-agent and ssh-agent to remote",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nIt is possible to forward one's gpg-agent to a remote machine by forwarding gpg sockets to the remote machine, as explained by the GnuPG wiki.\n\nFirst, add the following line to /etc/ssh/sshd_config on the remote machine to enable automatic removal of stale sockets on connect. Without this, the socket(s) on the remote machine will need to removed manually before connecting with forwarding enabled for agent forwarding to work:\n\n```\n/etc/ssh/sshd_config\n```\n\n```\n...\nStreamLocalBindUnlink yes\n...\n```\n\nOn the client, use the RemoteForward SSH directive to forward traffic destined for a remote port, to a port on your local host. As described in ssh_config(5) § RemoteForward, this directive's parameters are the listening socket path on the remote, and then the destination socket path on the local host. Your configuration should look something like this:\n\n```\n~/.ssh/config\n```\n\n```\nHost remote_name\n    ...\n    RemoteForward remote_agent_socket local_agent_extra_socket\n    RemoteForward remote_agent_ssh_socket local_agent_ssh_socket\n```\n\nThe first line configures gpg-agent forwarding:\n\n- remote_agent_socket is the output of gpgconf --list-dir agent-socket on the remote host.\n- local_agent_extra_socket is gpgconf --list-dir agent-extra-socket on the local host.\n\nThe second line is optional. It configures ssh-agent forwarding:\n\n- remote_agent_ssh_socket is gpgconf --list-dir agent-ssh-socket on the remote host.\n- local_agent_ssh_socket is gpgconf --list-dir agent-ssh-socket on the local host.\n\nSo, with the default paths, it would be:\n\n```\nRemoteForward /run/user/1000/gnupg/S.gpg-agent /run/user/1000/gnupg/S.gpg-agent.extra\n    RemoteForward /run/user/1000/gnupg/S.gpg-agent.ssh /run/user/1000/gnupg/S.gpg-agent.ssh\n```\n\nWith this configuration in place, invoking ssh remote_name should automatically forward the gpg-agent to the remote, and allow the use of your gpg key(s) for both decryption/signing (and allows the use of ssh-agent with gpg if the second RemoteForward line is included).\n\n"
    },
    {
      "title": "Smartcards",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nGnuPG uses scdaemon as an interface to your smartcard reader, please refer to the man page scdaemon(1) for details.\n\nGnuPG's gpg-card tool can be used to configure scdaemon and serves as front-end for smartcard configuration, see gpg-card(1) for details.\n\n"
    },
    {
      "title": "GnuPG only setups",
      "level": 3,
      "content": "If you do not plan to use other cards but those based on GnuPG, you should check the reader-port parameter in ~/.gnupg/scdaemon.conf. The value '0' refers to the first available serial port reader and a value of '32768' (default) refers to the first USB reader.\n\n"
    },
    {
      "title": "GnuPG with pcscd (PCSC Lite)",
      "level": 3,
      "content": "pcscd(8) is a daemon which handles access to smartcard (SCard API). In earlier versions, if GnuPG's scdaemon failed to connect to the smartcard directly (e.g. by using its integrated CCID support), it fell back and tried to find a smartcard using the PCSC Lite driver. Since version 2.4 however, you will have to add the disable-ccid option in ~/.gnupg/scdaemon.conf, to be able to use pcscd.\n\nTo use pscsd install pcsclite and ccid. Then start and/or enable pcscd.service. Alternatively start and/or enable pcscd.socket to activate the daemon when needed.\n\n"
    },
    {
      "title": "Always use pcscd",
      "level": 4,
      "content": "If you are using any smartcard with an opensc driver (e.g.: ID cards from some countries) you should pay some attention to GnuPG configuration. Out of the box you might receive a message like this when using gpg --card-status\n\n```\ngpg: selecting openpgp failed: ec=6.108\n```\n\nBy default, scdaemon will try to connect directly to the device. This connection will fail if the reader is being used by another process. For example: the pcscd daemon used by OpenSC. To cope with this situation we should use the same underlying driver as opensc so they can work well together. In order to point scdaemon to use pcscd you should remove reader-port from ~/.gnupg/scdaemon.conf, specify the location to libpcsclite.so library and disable ccid so we make sure that we use pcscd:\n\n```\n~/.gnupg/scdaemon.conf\n```\n\n```\npcsc-driver /usr/lib/libpcsclite.so\ncard-timeout 5\ndisable-ccid\n```\n\nPlease check scdaemon(1) if you do not use OpenSC.\n\n"
    },
    {
      "title": "Shared access with pcscd",
      "level": 4,
      "content": "GnuPG scdaemon is the only popular pcscd client that uses PCSC_SHARE_EXCLUSIVE flag when connecting to pcscd. Other clients like OpenSC PKCS#11 that are used by browsers and programs listed in Electronic identification are using PCSC_SHARE_SHARED that allows simultaneous access to single smartcard. pcscd will not give exclusive access to smartcard while there are other clients connected. This means that to use GnuPG smartcard features you must before have to close all your open browser windows or do some other inconvenient operations.\n\nStarting from version 2.2.28 LTS and 2.3.0 you can enable shared access by modifying your scdaemon.conf file and adding the line pcsc-shared to the end of it. Keep in mind that scdaemon(1) § --pcsc-shared describes this flag as a \"somewhat dangerous option\" due to \"certain information being cached from the card\".\n\nWhen using YubiKeys or other multi applet USB dongles with OpenSC PKCS#11 may run into problems where OpenSC switches your Yubikey from OpenPGP to PIV applet, breaking the scdaemon.\n\nYou can hack around the problem by forcing OpenSC to also use the OpenPGP applet. Open /etc/opensc.conf file, search for Yubikey and change the driver = \"PIV-II\"; line to driver = \"openpgp\";. If there is no such entry, use opensc-tool --atr provided by opensc. Search for the Answer to Reset ATR: 12 34 56 78 90 AB CD .... Then create a new card_atr block referencing your device ATR within the app block.\n\n```\n/etc/opensc.conf\n```\n\n```\napp default {\n    ...\n    card_atr 12:23:34:45:67:89:ab:cd:... {\n        name = \"YubiKey Neo\";\n        driver = \"openpgp\"\n    }\n}\n...\n```\n\nAfter that you can test with pkcs11-tool -O --login that the OpenPGP applet is selected by default. Other PKCS#11 clients like browsers may need to be restarted for that change to be applied.\n\n"
    },
    {
      "title": "Using a smart card on a remote client",
      "level": 4,
      "content": "If for example you log into a machine via SSH or share a smart card to WSL via usbipd-win and try to use an attached device via pcscd, you will notice errors such as:\n\n```\ngpg: selecting card failed: No such device\ngpg: OpenPGP card not available: No such device\n```\n\nThis is due to Polkit restricting access to local clients. To fix this, you can add a rule to allow certain users in all cases. The below rule allows all users in the wheel group to access devices via pcscd:\n\n```\n/etc/polkit-1/rules.d/99-pcscd.rules\n```\n\n```\npolkit.addRule(function(action, subject) {\n    if (action.id == \"org.debian.pcsc-lite.access_card\" &&\n        subject.isInGroup(\"wheel\")) {\n        return polkit.Result.YES;\n    }\n});\npolkit.addRule(function(action, subject) {\n    if (action.id == \"org.debian.pcsc-lite.access_pcsc\" &&\n        subject.isInGroup(\"wheel\")) {\n        return polkit.Result.YES;\n    }\n});\n```\n\nAfter creating the file, make sure to restart polkit.service.\n\n"
    },
    {
      "title": "OpenPGP compatibility",
      "level": 2,
      "content": "GnuPG started out as an implementation of the OpenPGP format. Currently, the project is based on RFC 4880 and does not support RFC 9580 (which supersedes RFC 4880).\n\nHowever, beginning with version 2.4.0 (from December 2022) GnuPG has opted to roll out changes and extensions to the format outside of the IETF process (see draft-koch-librepgp).\n\nMost of the GnuPG-proprietary formats (which diverge from the OpenPGP standard) carry \"version 5\" (this version is not used in the IETF OpenPGP standard) and introduce incompatibilities:\n\n- GnuPG \"version 5\" keys use different fingerprints (longer, due to the use of SHA-256).\n- A new symmetrically encrypted data packet format (OCB Encrypted Data Packet) is added. Support for this format is signalled with a \"feature flag\" which is aggressively enabled by default. See #Disable unsupported AEAD mechanism.\n- A new Post-Quantum Cryptography format, again diverging from the IETF process (see draft-ietf-openpgp-pqc).\n\nExternal reviews have raised concerns about the soundness of the format extensions by GnuPG (see A Summary of Known Security Issues in LibrePGP).\n\nSee A Critique on \"A Critique on the OpenPGP Updates\" for a more in-depth discussion of concerns with regard to the GnuPG-specific format changes.\n\nArch Linux's position is to prefer compatibility with the OpenPGP standard. To this end patches such as the one for reverting RFC4880bis by default are applied to the gnupg package. This ensures the longterm compatibility with other OpenPGP implementations and avoids vendor lock-in by default.\n\n"
    },
    {
      "title": "Disable unsupported AEAD mechanism",
      "level": 3,
      "content": "With gnupg 2.4, gpg generates keys, which advertise support for a GnuPG specific AEAD encryption mechanism (based on OCB). However, this flavor of AEAD is not supported by other OpenPGP implementations!\n\nAlthough many downstreams attempt to remove this new default by patching the GnuPG sources, when using --full-gen-key the OCB based custom AEAD encryption mechanism is nonetheless set for the new key.\n\nWhether GnuPG's custom AEAD is set for a key can be inspected with the help of gpg itself:\n\n```\n$ gpg --expert --edit-key <FINGERPRINT>\ngpg> showpref\n[ultimate] (1). Foobar McFooface (test) <foobar@mcfooface.com>\n    Cipher: AES256, AES192, AES, 3DES\n    AEAD: OCB\n    Digest: SHA512, SHA384, SHA256, SHA224, SHA1\n    Compression: ZLIB, BZIP2, ZIP, Uncompressed\n    Features: MDC, AEAD, Keyserver no-modify\n```\n\nThis mechanism can be disabled:\n\n```\ngpg> setpref AES256 AES192 AES SHA512 SHA384 SHA256 SHA224 ZLIB BZIP2 ZIP\nSet preference list to:\n    Cipher: AES256, AES192, AES, 3DES\n    AEAD:\n    Digest: SHA512, SHA384, SHA256, SHA224, SHA1\n    Compression: ZLIB, BZIP2, ZIP, Uncompressed\n    Features: MDC, Keyserver no-modify\nReally update the preferences? (y/N) y\n```\n\n"
    },
    {
      "title": "Different algorithm",
      "level": 3,
      "content": "You may want to use stronger algorithms:\n\n```\n~/.gnupg/gpg.conf\n```\n\n```\n...\n\npersonal-digest-preferences SHA512\ncert-digest-algo SHA512\ndefault-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed\npersonal-cipher-preferences TWOFISH CAMELLIA256 AES 3DES\n```\n\nIn the latest version of GnuPG, the default algorithms used are SHA256 and AES, both of which are secure enough for most people. However, if you are using a version of GnuPG older than 2.1, or if you want an even higher level of security, then you should follow the above step.\n\n"
    },
    {
      "title": "Encrypt a password",
      "level": 3,
      "content": "It can be useful to encrypt some password, so it will not be written in clear on a configuration file. A good example is your email password.\n\nFirst create a file with your password. You need to leave one empty line after the password, otherwise gpg will return an error message when evaluating the file.\n\nThen run:\n\n```\n$ gpg -e -a -r user-id your_password_file\n```\n\n-e is for encrypt, -a for armor (ASCII output), -r for recipient user ID.\n\nYou will be left with a new your_password_file.asc file.\n\n"
    },
    {
      "title": "Change trust model",
      "level": 3,
      "content": "By default GnuPG uses the Web of Trust as the trust model. You can change this to Trust on first use by adding --trust-model=tofu when adding a key or adding this option to your GnuPG configuration file. More details are in this email to the GnuPG list.\n\n"
    },
    {
      "title": "Hide all recipient id's",
      "level": 3,
      "content": "By default the recipient's key ID is in the encrypted message. This can be removed at encryption time for a recipient by using hidden-recipient user-id. To remove it for all recipients add throw-keyids to your configuration file. This helps to hide the receivers of the message and is a limited countermeasure against traffic analysis (i.e. using a little social engineering, anyone who is able to decrypt the message can check whether one of the other recipients is the one they suspect). On the receiving side, it may slow down the decryption process because all available secret keys must be tried (e.g. with --try-secret-key user-id).\n\n"
    },
    {
      "title": "Using caff for keysigning parties",
      "level": 3,
      "content": "To allow users to validate keys on the keyservers and in their keyrings (i.e. make sure they are from whom they claim to be), PGP/GPG uses the Web of Trust. Keysigning parties allow users to get together at a physical location to validate keys. The Zimmermann-Sassaman key-signing protocol is a way of making these very effective. Here you will find a how-to article.\n\nFor an easier process of signing keys and sending signatures to the owners after a keysigning party, you can use the tool caff. It can be installed from the AUR with the package caff-gitAUR.\n\nTo send the signatures to their owners you need a working MTA. If you do not have already one, install msmtp.\n\n"
    },
    {
      "title": "Always show long ID's and fingerprints",
      "level": 3,
      "content": "To always show long key ID's add keyid-format 0xlong to your configuration file. To always show full fingerprints of keys, add with-fingerprint to your configuration file.\n\n"
    },
    {
      "title": "Custom capabilities",
      "level": 3,
      "content": "For further customization also possible to set custom capabilities to your keys. The following capabilities are available:\n\n- Certify (only for primary keys) - allows the key to create certifications that the User IDs on other keys are correct.\n- Sign - allows the key to create cryptographic signatures over data, that others can verify with the public key.\n- Encrypt - allows anyone to encrypt data with the public key, that only the private key can decrypt.\n- Authenticate - allows the key to authenticate with various non-GnuPG programs. The key can be used as e.g. an SSH key.\n\nIt is possible to specify the capabilities of the primary key, by running:\n\n```\n$ gpg --full-generate-key --expert\n```\n\nAnd select an option that allows you to set your own capabilities.\n\nComparably, to specify custom capabilities for subkeys, add the --expert flag to gpg --edit-key, see #Edit your key for more information.\n\n"
    },
    {
      "title": "su",
      "level": 3,
      "content": "When using pinentry, you must have the proper permissions of the terminal device (e.g. /dev/tty1) in use. However, with su (or sudo), the ownership stays with the original user, not the new one. This means that pinentry will fail with a Permission denied error, even as root. If this happens when attempting to use ssh, an error like sign_and_send_pubkey: signing failed: agent refused operation will be returned. The fix is to change the permissions of the device at some point before the use of pinentry (i.e. using gpg with an agent). If doing gpg as root, simply change the ownership to root right before using gpg:\n\n```\n# chown root $(tty)\n```\n\nand then change it back after su (or sudo) terminated.\n\nNote: **is not** \n\n```\n# script -q -c \"gpg --gen-key\" /dev/null\n```\n\n"
    },
    {
      "title": "Agent complains end of file",
      "level": 3,
      "content": "If the pinentry program is /usr/bin/pinentry-gnome3, it needs a DBus session bus to run properly. See General troubleshooting#Session permissions for details.\n\nAlternatively, you can use a variety of different options described in #pinentry.\n\n"
    },
    {
      "title": "KGpg configuration permissions",
      "level": 3,
      "content": "There have been issues with kgpg being able to access the ~/.gnupg/ options. One issue might be a result of a deprecated options file, see the bug report.\n\n"
    },
    {
      "title": "GNOME on Wayland overrides SSH agent socket",
      "level": 3,
      "content": "For Wayland sessions, gnome-session sets SSH_AUTH_SOCK to the standard gnome-keyring socket, $XDG_RUNTIME_DIR/keyring/ssh. This overrides any value set elsewhere.\n\nSee GNOME/Keyring#Disabling on how to disable this behavior.\n\n"
    },
    {
      "title": "mutt",
      "level": 3,
      "content": "Mutt might not use gpg-agent correctly, you need to set an environment variable GPG_AGENT_INFO (the content does not matter) when running mutt. Be also sure to enable password caching correctly, see #Cache passwords.\n\nSee this forum thread.\n\n"
    },
    {
      "title": "\"Lost\" keys, upgrading to gnupg version 2.1",
      "level": 3,
      "content": "When gpg --list-keys fails to show keys that used to be there, and applications complain about missing or invalid keys, some keys may not have been migrated to the new format.\n\nPlease read GnuPG invalid packet workaround. Basically, it says that there is a bug with keys in the old pubring.gpg and secring.gpg files, which have now been superseded by the new pubring.kbx file and the private-keys-v1.d/ subdirectory and files. Your missing keys can be recovered with the following commands:\n\n```\n$ cd\n$ cp -r .gnupg gnupgOLD\n$ gpg --export-ownertrust > otrust.txt\n$ gpg --import .gnupg/pubring.gpg\n$ gpg --import-ownertrust otrust.txt\n$ gpg --list-keys\n```\n\n"
    },
    {
      "title": "gpg hanged for all keyservers (when trying to receive keys)",
      "level": 3,
      "content": "If gpg hanged with a certain keyserver when trying to receive keys, you might need to kill dirmngr in order to get access to other keyservers which are actually working, otherwise it might keeping hanging for all of them.\n\n"
    },
    {
      "title": "Smartcard not detected",
      "level": 3,
      "content": "Your user might not have the permission to access the smartcard which results in a card error to be thrown, even though the card is correctly set up and inserted.\n\nOne possible solution is to add a new group scard including the users who need access to the smartcard.\n\nThen use udev rules, similar to the following:\n\n```\n/etc/udev/rules.d/71-gnupg-ccid.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"usb\", ENV{ID_VENDOR_ID}==\"1050\", ENV{ID_MODEL_ID}==\"0116|0111\", MODE=\"660\", GROUP=\"scard\"\n```\n\nOne needs to adapt VENDOR and MODEL according to the lsusb output, the above example is for a YubikeyNEO.\n\n"
    },
    {
      "title": "server 'gpg-agent' is older than us (x < y)",
      "level": 3,
      "content": "This warning appears if gnupg is upgraded and the old gpg-agent is still running. Restart the user's gpg-agent.socket (i.e., use the --user flag when restarting).\n\n"
    },
    {
      "title": "IPC connect call failed",
      "level": 3,
      "content": "Make sure gpg-agent and dirmngr are not running with killall gpg-agent dirmngr and the $GNUPGHOME/crls.d/ folder has permission set to 700.\n\nBy default, the gnupg package uses the directory /run/user/$UID/gnupg/ for sockets. GnuPG documentation states this is the preferred directory (not all file systems are supported for sockets). Validate that your agent-socket configuration specifies a path that has an appropriate file system. You can find your path settings for agent-socket by running gpgconf --list-dirs agent-socket.\n\nTest that gpg-agent starts successfully with gpg-agent --daemon.\n\n"
    },
    {
      "title": "Mitigating Poisoned PGP Certificates",
      "level": 3,
      "content": "In June 2019, an unknown attacker spammed several high-profile PGP certificates with tens of thousands (or hundreds of thousands) of signatures (CVE-2019-13050) and uploaded these signatures to keyservers. The existence of these poisoned certificates in a keyring causes gpg to hang with the following message:\n\n```\ngpg: removing stale lockfile (created by 7055)\n```\n\nPossible mitigation involves removing the poisoned certificate as per this blog post.\n\n"
    },
    {
      "title": "Invalid IPC response and Inappropriate ioctl for device",
      "level": 3,
      "content": "The default pinentry program is /usr/bin/pinentry-gtk-2. If gtk2 is unavailable, pinentry falls back to /usr/bin/pinentry-curses and causes signing to fail:\n\n```\ngpg: signing failed: Inappropriate ioctl for device\ngpg: [stdin]: clear-sign failed: Inappropriate ioctl for device\n```\n\nYou need to set the GPG_TTY environment variable for the pinentry programs /usr/bin/pinentry-tty and /usr/bin/pinentry-curses.\n\n```\n$ export GPG_TTY=$(tty)\n```\n\n"
    },
    {
      "title": "Keyblock resource does not exist",
      "level": 3,
      "content": "If you get an error like this when trying to import keys\n\n```\ngpg: keyblock resource 'gnupg_home/pubring.kbx': No such file or directory\n```\n\nit is because GnuPG will not create its home directory if it does not yet exist. Simply create it manually\n\n```\n$ mkdir -m 700 gnupg_home\n```\n\n"
    },
    {
      "title": "Subkey is created with Restricted capability",
      "level": 3,
      "content": "In some cases creating a subkey with a custom set of capabilities results in the subkey marked as \"Restricted\". This happens in the addkey command with option 7 or 8 (\"set your own capabilities\") when the capabilities are toggled in the interactive prompt. A workaround is to enter the desired capability set directly as a string instead of toggling individual capabilities, when prompted with the capability selection. For example, enter \"=A\" to create a subkey with only the Authentication capability.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- GNU Privacy Guard Homepage\n- Alan Eliasen's GPG Tutorial\n- RFC 4880 — \"OpenPGP Message Format\"\n- gpg.conf recommendations and best practices\n- Fedora:Creating GPG Keys\n- Debian:Subkeys\n- Protecting code integrity with PGP\n- A more comprehensive gpg Tutorial\n- /r/GPGpractice - a subreddit to practice using GnuPG.\n- A Summary of Known Security Issues in LibrePGP on blog.pgpkeys.eu\n\n"
    }
  ]
}