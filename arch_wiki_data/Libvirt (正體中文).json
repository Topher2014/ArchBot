{
  "title": "Libvirt (正體中文)",
  "url": "https://wiki.archlinux.org/title/Libvirt_(%E6%AD%A3%E9%AB%94%E4%B8%AD%E6%96%87)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Category:Hypervisors\n- PCI passthrough via OVMF\n\nLibvirt is a collection of software that provides a convenient way to manage virtual machines and other virtualization functionality, such as storage and network interface management. These software pieces include a long term stable C API, a daemon (libvirtd), and a command line utility (virsh). A primary goal of libvirt is to provide a single way to manage multiple different virtualization providers/hypervisors, such as the KVM/QEMU, Xen, LXC, OpenVZ or VirtualBox hypervisors (among others).\n\nSome of the major libvirt features are:\n\n- VM management: Various domain lifecycle operations such as start, stop, pause, save, restore, and migrate. Hotplug operations for many device types including disk and network interfaces, memory, and CPUs.\n- Remote machine support: All libvirt functionality is accessible on any machine running the libvirt daemon, including remote machines. A variety of network transports are supported for connecting remotely, with the simplest being SSH, which requires no extra explicit configuration.\n- Storage management: Any host running the libvirt daemon can be used to manage various types of storage: create file images of various formats (qcow2, vmdk, raw, ...), mount NFS shares, enumerate existing LVM volume groups, create new LVM volume groups and logical volumes, partition raw disk devices, mount iSCSI shares, and much more.\n- Network interface management: Any host running the libvirt daemon can be used to manage physical and logical network interfaces. Enumerate existing interfaces, as well as configure (and create) interfaces, bridges, vlans, and bond devices.\n- Virtual NAT and Route based networking: Any host running the libvirt daemon can manage and create virtual networks. Libvirt virtual networks use firewall rules to act as a router, providing VMs transparent access to the host machines network.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Because of its daemon/client architecture, libvirt needs only be installed on the machine which will host the virtualized system. Note that the server and client can be the same physical machine.\n\n"
    },
    {
      "title": "Server",
      "level": 3,
      "content": "Install the libvirt package, as well as at least one hypervisor:\n\n- The libvirt KVM/QEMU driver is the primary libvirt driver and if KVM is enabled, fully virtualized, hardware accelerated guests will be available. See the QEMU article for more information.\n- Other supported hypervisors include LXC, VirtualBox and Xen. See the respective articles for installation instructions. With respect to libvirtd installation note: The libvirt LXC driver has no dependency on the LXC userspace tools provided by lxc, therefore there is no need to install the package if planning on using the driver. libvirtd needs to be running to use libvirt-lxc connection. Xen support is available, but not by default (FS#27356). You need to use the ABS to modify libvirt's PKGBUILD and build it without the -Ddriver_libxl=disabled option.\n\n- The libvirt LXC driver has no dependency on the LXC userspace tools provided by lxc, therefore there is no need to install the package if planning on using the driver. libvirtd needs to be running to use libvirt-lxc connection.\n- Xen support is available, but not by default (FS#27356). You need to use the ABS to modify libvirt's PKGBUILD and build it without the -Ddriver_libxl=disabled option.\n\nFor network connectivity, install:\n\n- dnsmasq for the default NAT/DHCP networking.\n- openbsd-netcat for remote management over SSH.\n\nOther optional dependencies may provide desired or extended features, such as dmidecode for DMI system info support. Install the ones you may need as dependencies after reading pacman's output for libvirt.\n\n"
    },
    {
      "title": "Client",
      "level": 3,
      "content": "The client is the user interface that will be used to manage and access the virtual machines.\n\n- virsh — Command line program for managing and configuring domains.\n\n- Boxes — Simple GNOME application to access virtual systems. Part of gnome-extra.\n\n- Libvirt Sandbox — Application sandbox toolkit.\n\n- Virt Viewer — Simple remote display client.\n\n- Virt-manager — Graphically manage KVM, Xen, or LXC via libvirt.\n\n- Cockpit — Web-based system administration tool with plugin to manage virtual machines.\n\nA list of libvirt-compatible software can be found here.\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "Libvirt can manage QEMU virtual machines in two modes, system and session[1][2]:\n\n- system URIs connect to the libvirtd daemon running as root which is launched at system startup. Virtual machines created and run using 'system' are usually launched as root, unless configured otherwise (for example in /etc/libvirt/qemu.conf)\n- session URIs launch a libvirtd instance as your local user, and all VMs are run with local user permissions.\n\nRegarding their pros and cons:\n\n- VM autostart on host boot only works for 'system', and the root libvirtd instance has necessary permissions to use proper networkings via bridges or virtual networks. qemu:///system is generally what tools like virt-manager default to.\n- qemu:///session has a serious drawback: since the libvirtd instance does not have sufficient privileges, the only out of the box network option is qemu's usermode networking, which has non-obvious limitations, so its usage is discouraged (more info on qemu networking options)\n\nFor system-level administration (i.e. global settings and image-volume location), libvirt minimally requires setting up authorization, and starting the daemon.\n\nFor user-session administration, daemon setup and configuration is not required; however, authorization is limited to local abilities; the front-end will launch a local instance of the libvirtd daemon.\n\n"
    },
    {
      "title": "Set up authentication",
      "level": 3,
      "content": "From libvirt: Connection authentication:\n\n"
    },
    {
      "title": "Using libvirt group",
      "level": 4,
      "content": "The easiest way to ensure your user has access to libvirt daemon is to add member to libvirt user group.\n\nMembers of the libvirt group have passwordless access to the RW daemon socket by default.\n\n"
    },
    {
      "title": "Using polkit",
      "level": 4,
      "content": "Because libvirt pulls polkit as a dependency during installation, polkit is used as the default value for the unix_sock_auth parameter (source). File-based permissions remain nevertheless available.\n\nThe libvirt daemon provides two polkit actions in /usr/share/polkit-1/actions/org.libvirt.unix.policy:\n\n- org.libvirt.unix.manage for full management access (RW daemon socket), and\n- org.libvirt.unix.monitor for monitoring only access (read-only socket).\n\nThe default policy for the RW daemon socket will require to authenticate as an admin. This is akin to sudo auth, but does not require that the client application ultimately run as root. Default policy will still allow any application to connect to the RO socket.\n\nArch defaults to consider anybody in the wheel group as an administrator: this is defined in /usr/share/polkit-1/rules.d/50-default.rules (see Polkit#Administrator identities). Therefore there is no need to create a new group and rule file if your user is a member of the wheel group: upon connection to the RW socket (e.g. via virt-manager) you will be prompted for your user's password.\n\nYou may change the group authorized to access the RW daemon socket. As an example, to authorize the mykvm group, create the following file:\n\n```\n/etc/polkit-1/rules.d/50-libvirt.rules\n```\n\n```\n/* Allow users in mykvm group to manage the libvirt\ndaemon without authentication */\npolkit.addRule(function(action, subject) {\n    if (action.id == \"org.libvirt.unix.manage\" &&\n        subject.isInGroup(\"mykvm\")) {\n            return polkit.Result.YES;\n    }\n});\n```\n\nThen add yourself to the mykvm group and relogin. Replace mykvm with any group of your preference just make sure it exists and that your user is a member of it (see Users and groups for more information).\n\nDo not forget to relogin for group changes to take effect.\n\n"
    },
    {
      "title": "Authenticate with file-based permissions",
      "level": 4,
      "content": "To define file-based permissions for users in the libvirt group to manage virtual machines, uncomment and define:\n\n```\n/etc/libvirt/libvirtd.conf\n```\n\n```\n#unix_sock_group = \"libvirt\"\n#unix_sock_ro_perms = \"0777\"  # set to 0770 to deny non-group libvirt users\n#unix_sock_rw_perms = \"0770\"\n#auth_unix_ro = \"none\"\n#auth_unix_rw = \"none\"\n```\n\nWhile some guides mention changed permissions of certain libvirt directories to ease management, keep in mind permissions are lost on package update. To edit these system directories, root user is expected.\n\n"
    },
    {
      "title": "Daemon",
      "level": 3,
      "content": "Start both libvirtd.service and virtlogd.service. Optionally enable libvirtd.service (which will also enable virtlogd.socket and virtlockd.socket units, so there is NO need to also enable virtlogd.service).\n\nAnother possibility is to only start/enable libvirtd.socket and virtlogd.socket for on-demand socket activation.\n\n"
    },
    {
      "title": "Unencrypt TCP/IP sockets",
      "level": 3,
      "content": "Edit /etc/libvirt/libvirtd.conf:\n\n```\n/etc/libvirt/libvirtd.conf\n```\n\n```\nlisten_tls = 0\nlisten_tcp = 1\nauth_tcp=\"none\"\n```\n\nIt is also necessary to start the server in listening mode by editing /etc/conf.d/libvirtd:\n\n```\n/etc/conf.d/libvirtd\n```\n\n```\nLIBVIRTD_ARGS=\"--listen\"\n```\n\n"
    },
    {
      "title": "Access virtual machines using their hostnames",
      "level": 3,
      "content": "For host access to guests on non-isolated, bridged networks, enable the libvirt and/or libvirt_guest NSS modules provided by libvirt. For the comparison of the two modules and technical details, see libvirt documentation.\n\nAdd desired modules in nsswitch.conf(5):\n\n```\n/etc/nsswitch.conf\n```\n\n```\nhosts: files libvirt libvirt_guest dns myhostname\n```\n\n"
    },
    {
      "title": "Test",
      "level": 2,
      "content": "To test if libvirt is working properly on a system level:\n\n```\n$ virsh -c qemu:///system\n```\n\nTo test if libvirt is working properly for a user-session:\n\n```\n$ virsh -c qemu:///session\n```\n\n"
    },
    {
      "title": "Management",
      "level": 2,
      "content": "Libvirt management is done mostly with three tools: virt-manager (GUI), virsh, and guestfish (which is part of libguestfs).\n\n"
    },
    {
      "title": "virsh",
      "level": 3,
      "content": "The virsh program is for managing guest domains (virtual machines) and works well for scripting, virtualization administration. Though most virsh commands require root privileges to run due to the communication channels used to talk to the hypervisor, typical management, creation, and running of domains (like that done with VirtualBox) can be done as a regular user.\n\nThe virsh program includes an interactive terminal that can be entered if no commands are passed (options are allowed though): virsh. The interactive terminal has support for tab completion.\n\nFrom the command line:\n\n```\n$ virsh [option] <command> [argument]...\n```\n\nFrom the interactive terminal:\n\n```\nvirsh # <command> [argument]...\n```\n\nHelp is available:\n\n```\n$ virsh help [option*] or [group-keyword*]\n```\n\n"
    },
    {
      "title": "Storage pools",
      "level": 3,
      "content": "A pool is a location where storage volumes can be kept. What libvirt defines as volumes others may define as \"virtual disks\" or \"virtual machine images\". Pool locations may be a directory, a network filesystem, or partition (this includes a LVM). Pools can be toggled active or inactive and allocated for space.\n\nOn the system-level, /var/lib/libvirt/images/ will be activated by default; on a user-session, virt-manager creates $XDG_DATA_HOME/images.\n\nPrint active and inactive storage pools:\n\n```\n$ virsh pool-list --all\n```\n\n"
    },
    {
      "title": "Create a new pool using virsh",
      "level": 4,
      "content": "If one wanted to add a storage pool, here are examples of the command form, adding a directory, and adding a LVM volume:\n\n```\n$ virsh pool-define-as name type [source-host] [source-path] [source-dev] [source-name] [<target>] [--source-format format]\n$ virsh pool-define-as poolname dir - - - - /home/username/.local/libvirt/images\n$ virsh pool-define-as poolname fs - -  /dev/vg0/images - mntpoint\n```\n\nThe above command defines the information for the pool, to build it:\n\n```\n$ virsh pool-build     poolname\n$ virsh pool-start     poolname\n$ virsh pool-autostart poolname\n```\n\nTo remove it:\n\n```\n$ virsh pool-undefine  poolname\n```\n\n- It is a good practice to dedicate a volume group to the storage pool only.\n- Choose a LVM volume group that differs from the pool name, otherwise when the storage pool is deleted the LVM group will be too.\n\n"
    },
    {
      "title": "Create a new pool using virt-manager",
      "level": 4,
      "content": "First, connect to a hypervisor (e.g. QEMU/KVM system, or user-session). Then, right-click on a connection and select Details; select the Storage tab, push the + button on the lower-left, and follow the wizard.\n\n"
    },
    {
      "title": "Storage volumes",
      "level": 3,
      "content": "Once the pool has been created, volumes can be created inside the pool. If building a new domain (virtual machine), this step can be skipped as a volume can be created in the domain creation process.\n\n"
    },
    {
      "title": "Create a new volume with virsh",
      "level": 4,
      "content": "Create volume, list volumes, resize, and delete:\n\n```\n$ virsh vol-create-as      poolname volumename 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk\n$ virsh vol-upload  --pool poolname volumename volumepath\n$ virsh vol-list           poolname\n$ virsh vol-resize  --pool poolname volumename 12GiB\n$ virsh vol-delete  --pool poolname volumename\n$ virsh vol-dumpxml --pool poolname volumename  # for details.\n```\n\n"
    },
    {
      "title": "Domains",
      "level": 3,
      "content": "Virtual machines are called domains. If working from the command line, use virsh to list, create, pause, shutdown domains, etc. virt-viewer can be used to view domains started with virsh. Creation of domains is typically done either graphically with virt-manager or with virt-install (a command line program installed as part of the virt-install package).\n\nCreating a new domain typically involves using some installation media, such as an .iso from the storage pool or an optical drive.\n\nPrint active and inactive domains:\n\n```\n# virsh list --all\n```\n\n"
    },
    {
      "title": "Create a new domain using virt-install",
      "level": 4,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nFor an extremely detailed domain (virtual machine) setup, it is easier to #Create a new domain using virt-manager. However, basics can easily be done with virt-install and still run quite well. Minimum specifications are --name, --memory, guest storage (--disk, --filesystem, or --nodisks), and an install method (generally an .iso or CD). See virt-install(1) for more details and information about unlisted options.\n\nArch Linux install (two GiB, qcow2 format volume create; user-networking):\n\n```\n$ virt-install  \\\n  --name arch-linux_testing \\\n  --memory 1024             \\\n  --vcpus=2,maxvcpus=4      \\\n  --cpu host                \\\n  --cdrom $HOME/Downloads/arch-linux_install.iso \\\n  --disk size=2,format=qcow2  \\\n  --network user            \\\n  --virt-type kvm\n```\n\nFedora testing (Xen hypervisor, non-default pool, do not originally view):\n\n```\n$ virt-install  \\\n  --connect xen:///     \\\n  --name fedora-testing \\\n  --memory 2048         \\\n  --vcpus=2             \\\n  --cpu=host            \\\n  --cdrom /tmp/fedora20_x84-64.iso      \\\n  --os-type=linux --os-variant=fedora20 \\\n  --disk pool=testing,size=4            \\\n  --network bridge=br0                  \\\n  --graphics=vnc                        \\\n  --noautoconsole\n$ virt-viewer --connect xen:/// fedora-testing\n```\n\nWindows:\n\n```\n$ virt-install \\\n  --name=windows7           \\\n  --memory 2048             \\\n  --cdrom /dev/sr0          \\\n  --os-variant=win7         \\\n  --disk /mnt/storage/domains/windows7.qcow2,size=20GiB \\\n  --network network=vm-net  \\\n  --graphics spice\n```\n\nImport existing volume:\n\n```\n$ virt-install  \\\n  --name demo  \\\n  --memory 512 \\\n  --disk /home/user/VMs/mydisk.img \\\n  --import\n```\n\n"
    },
    {
      "title": "Create a new domain using virt-manager",
      "level": 4,
      "content": "First, connect to the hypervisor (e.g. QEMU/KVM system or user session), right click on a connection and select New, and follow the wizard.\n\n- On the fourth step, de-selecting Allocate entire disk now will make setup quicker and can save disk space in the interum; however, it may cause volume fragmentation over time.\n- On the fifth step, open Advanced options and make sure that Virt Type is set to kvm (this is usually the preferred method). If additional hardware setup is required, select the Customize configuration before install option.\n\n"
    },
    {
      "title": "Manage a domain",
      "level": 4,
      "content": "Start a domain:\n\n```\n$ virsh start domain\n$ virt-viewer --connect qemu:///session domain\n```\n\nGracefully attempt to shutdown a domain; force off a domain:\n\n```\n$ virsh shutdown domain\n$ virsh destroy  domain\n```\n\nAutostart domain on libvirtd start:\n\n```\n$ virsh autostart domain\n$ virsh autostart domain --disable\n```\n\nShutdown domain on host shutdown:\n\nEdit a domain's XML configuration:\n\n```\n$ virsh edit domain\n```\n\nTo know more about XML configurations read the XML format section of the libvirt wiki.\n\n"
    },
    {
      "title": "Networking",
      "level": 3,
      "content": "There are four types of network that a domain can be connected to:\n\n- bridge — a virtual device; shares data directly with a physical interface. Use this if the host has static networking, it does not need to connect other domains, the domain requires full inbound and outbound traffic, and the domain is running on a system-level. The bridge must be configured outside of libvirt. See Network bridge on how to add a bridge. After creation, it needs to be specified in the domain configuration.\n- network — a virtual network; has ability to share with other domains. Libvirt offers many virtual network modes, such as Network Address Translation (NAT) mode, routed mode and isolated mode. Using a virtual network is desirable if the host has dynamic networking (e.g. NetworkManager), or if using wireless.\n- macvtap — connect directly to a host physical interface. This is much simpler to set up than bridge networking, with the one disadvantage that is the host cannot communicate with the domains through this interface. Libvirt can set up this type of networking easily.\n- user — local ability networking. Use this only for a user session.\n\n"
    },
    {
      "title": "Using iptables",
      "level": 4,
      "content": "If iptables is to be used and not nftables, it is necessary to specify this accordingly in the configuration file: /etc/libvirt/network.conf.\n\nFor example':\n\n```\n# default: #firewall_backend = \"nftables\"\nfirewall_backend = \"iptables\"\n```\n\n"
    },
    {
      "title": "Retrieving a domain IP address",
      "level": 4,
      "content": "If using the default network and addresses are assigned using DHCP:\n\n```\n$ virsh net-dhcp-leases default\n```\n\nIf the domain is using the qemu-guest-agent:\n\n```\n$ virsh domifaddr --source agent domain\n```\n\n"
    },
    {
      "title": "Using nftables",
      "level": 4,
      "content": "When using network type NAT in combination with a simple restrictive nftables firewall (e.g. the default configuration) you might need to allow forwarding to/from the virtual network interface (default configuration drops packets here) and DNS/DHCP requests for DHCP clients from the virtual network interface to the host. Reduced Example assuming virbr0 as libvirt bridge interface:\n\n```\n/etc/nftables.conf\n```\n\n```\n# ...\ntable inet filter {\n  chain input {\n    type filter hook input priority filter\n    policy drop\n    # ...\n    iifname virbr0 udp dport {53, 67} accept comment \"allow VM dhcp/dns requests to host\"\n    # ...\n  }\n\n  chain forward {\n    type filter hook forward priority filter\n    policy drop\n    \n    iifname virbr0 accept\n    oifname virbr0 accept\n  }\n}\n```\n\n"
    },
    {
      "title": "Adding an IPv6 address",
      "level": 4,
      "content": "When adding an IPv6 address through any of the configuration tools, you will likely receive the following error:\n\n```\nCheck the host setup: enabling IPv6 forwarding with RA routes without accept_ra set to 2 is likely to cause routes loss. Interfaces to look at: eth0\n```\n\nFix this by running the following command (replace eth0 with the name of your physical interface):\n\n```\n# sysctl net.ipv6.conf.eth0.accept_ra=2\n```\n\n"
    },
    {
      "title": "Port forwarding to domains",
      "level": 4,
      "content": "Details on how to do this can be found in the libvirt NAT forwarding documentation.\n\n"
    },
    {
      "title": "Macvtap",
      "level": 4,
      "content": "To set up macvtap networking, first create this file:\n\n```\nmacvtap.xml\n```\n\n```\n<network>\n  <name>macvtap-net</name>\n  <forward mode='bridge'>\n    <interface dev='eth0'/>\n  </forward>\n</network>\n```\n\nThen, define and enable the network:\n\n```\n$ virsh net-define macvtap.xml\n$ virsh net-autostart macvtap-net\n$ virsh net-start macvtap-net\n```\n\nNow the network macvtap-net is available, and persistent across reboots. It is bridged to the external network via eth0.\n\n"
    },
    {
      "title": "Snapshots",
      "level": 3,
      "content": "Snapshots take the disk, memory, and device state of a domain at a point-of-time, and save it for future use. They have many uses, from saving a \"clean\" copy of an OS image to saving a domain's state before a potentially destructive operation. Snapshots are identified with a unique name.\n\nSnapshots are saved within the volume itself and the volume must be the format: qcow2 or raw. Snapshots use deltas in order not to take as much space as a full copy would.\n\n"
    },
    {
      "title": "Create a snapshot",
      "level": 4,
      "content": "Note: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nOnce a snapshot is taken it is saved as a new block device and the original snapshot is taken offline. Snapshots can be chosen from and also merged into another (even without shutting down the domain).\n\nPrint a running domain's volumes (running domains can be printed with virsh list):\n\n```\n# virsh domblklist domain\n```\n\n```\nTarget     Source\n ------------------------------------------------\n vda        /vms/domain.img\n```\n\nTo see a volume's physical properties:\n\n```\n# qemu-img info /vms/domain.img\n```\n\n```\nimage: /vms/domain.img\n file format: qcow2\n virtual size: 50G (53687091200 bytes)\n disk size: 2.1G\n cluster_size: 65536\n```\n\nCreate a disk-only snapshot (the option --atomic will prevent the volume from being modified if snapshot creation fails):\n\n```\n# virsh snapshot-create-as domain snapshot1 --disk-only --atomic\n```\n\nList snapshots:\n\n```\n# virsh snapshot-list domain\n```\n\n```\nName                 Creation Time             State\n ------------------------------------------------------------\n snapshot1           2012-10-21 17:12:57 -0700 disk-snapshot\n```\n\nOne can then copy the original image with cp --sparse=true or rsync -S and then merge the original back into snapshot:\n\n```\n# virsh blockpull --domain domain --path /vms/domain.snapshot1\n```\n\ndomain.snapshot1 becomes a new volume. After this is done the original volume (domain.img and snapshot metadata can be deleted. The virsh blockcommit would work opposite to blockpull but it seems to be currently under development (including snapshot-revert feature, scheduled to be released sometime next year.\n\n"
    },
    {
      "title": "Other management",
      "level": 3,
      "content": "Connect to non-default hypervisor:\n\n```\n$ virsh --connect xen:///\nvirsh # uri\nxen:///\n```\n\nConnect to the QEMU hypervisor over SSH; and the same with logging:\n\n```\n$ virsh --connect qemu+ssh://username@host/system\n$ LIBVIRT_DEBUG=1 virsh --connect qemu+ssh://username@host/system\n```\n\nConnect a graphic console over SSH:\n\n```\n$ virt-viewer  --connect qemu+ssh://username@host/system domain\n$ virt-manager --connect qemu+ssh://username@host/system domain\n```\n\nConnect to the VirtualBox hypervisor (VirtualBox support in libvirt is not stable yet and may cause libvirtd to crash):\n\n```\n$ virsh --connect vbox:///system\n```\n\nNetwork configurations:\n\n```\n$ virsh -c qemu:///system net-list --all\n$ virsh -c qemu:///system net-dumpxml default\n```\n\n"
    },
    {
      "title": "Hooks",
      "level": 2,
      "content": "Hooks are scripts that are triggered by different events happening while starting and running the libvirt daemon. They can be used to execute commands needed in preparation to launch a guest like setup networks or reserve memory.\n\nThe following hooks exists:\n\n- daemon - occasions to trigger: start, shutdown, reload\n- qemu - occasions to trigger: prepare, prepare, start, started, stopped, release, migrate, restore, reconnect, attach\n- lxc - occasions to trigger: prepare, start, started, stopped, release, reconnect\n- libxl - occasions to trigger: prepare, start, started, stopped, release migrate, reconnect\n- network - occasions to trigger: start, started, stopped, port-created, updated, port-deleted\n\nSee the libvirt Documentation for details about each hook and trigger.\n\n"
    },
    {
      "title": "Create a hook",
      "level": 3,
      "content": "Hooks are represented by scripts located at /etc/libvirt/hooks. If the folder does not exist, you have to create it. Each hook is represented by a script in this folder with the same name (e.g. /etc/libvirt/hooks/qemu) or a sub-folder (e.g. /etc/libvirt/hooks/qemu.d/). The later can contain different scripts, which are all run at the trigger points. The scripts are run like any other scripts, so they need to start with the declaration of the command interpreter to use (e.g. #!/bin/bash) and be executable by the libvirt user.\n\nEvery time a trigger point is met, the script is run. For example, the daemon script would run at least two times in a start/stop cycle of the system, at start and at shutdown. To run an command only at a given point, you have to implement conditions in the script. To do this, libvirt passes parameters which can be used to identify the current trigger condition.\n\nAccording to the libvirt documentation these parameters are defined as follows:\n\n- Parameter 1: The name of the object involved in the operation\n- Parameter 2: The name of the operation being performed\n- Parameter 3: Used if a sub-operation is to be named\n- Parameter 4: An extra argument if needed\n\nIf one of the arguments is not applicable, a dash is passed.\n\n"
    },
    {
      "title": "Example",
      "level": 4,
      "content": "To run an command every time you start an qemu guest, before any resources are allocated, you can use the qemu hook. At this point, libvirt runs the hooks like this: /etc/libvirt/hooks/qemu <guest_name> prepare begin - The script for this could like this:\n\n```\n/etc/libvirt/hooks/qemu\n```\n\n```\n#!/bin/bash\nguest_name=\"$1\"\nlibvirt_task=\"$2\"\nif [ \"$libvirt_task\" = \"prepare\" ]; then\n\t<run some important code here>\nfi\n```\n\nIf the guest is stopped, the same script would be run, but this time the daemon would start the command like this: /etc/libvirt/hooks/qemu <guest_name> stopped end -\n\n"
    },
    {
      "title": "Virtio-FS",
      "level": 3,
      "content": "Sharing files with Virtio-FS lists an overview of the supported options to enable filesharing with the guest.\n\n"
    },
    {
      "title": "Set up the memory backend",
      "level": 4,
      "content": "Memory backends must be allocated before using virtiofs. memfd and file-backed memory backends can be used in system sessions and unprivileged QEMU/KVM user sessions. Hugepages only supports system sessions.\n\nTo use memfd memory backend, you need to add the following domain XML elements:\n\n```\n# virsh edit name_of_virtual_machine\n```\n\n```\n<domain>\n  ...\n  <memoryBacking>\n    <source type='memfd'/>\n    <access mode='shared'/>\n  </memoryBacking>\n  ...\n</domain>\n```\n\nAdd the following domain XML elements:\n\n```\n# virsh edit name_of_virtual_machine\n```\n\n```\n<domain>\n  ...\n  <memoryBacking>\n    <access mode='shared'/>\n  </memoryBacking>\n  ...\n</domain>\n```\n\nYou can configure where the backing file is stored with the memory_backing_dir option in /etc/libvirt/qemu.conf or, if you are running a user session, in $XDG_CONFIG_HOME/libvirt/qemu.conf:\n\n```\nmemory_backing_dir = \"/dev/shm/\"\n```\n\nFirst you need to enable hugepages which are used by the virtual machine:\n\n```\n/etc/sysctl.d/40-hugepage.conf\n```\n\n```\nvm.nr_hugepages = nr_hugepages\n```\n\nTo determine the number of hugepages needed check the size of the hugepages:\n\n```\n$ grep Hugepagesize /proc/meminfo\n```\n\nThe number of hugepages is memory size of virtual machine / Hugepagesize. Add to this value some additional pages. You have to reboot after this step, so that the hugepages are allocated.\n\nNow you have to prepare the configuration of the virtual machine:\n\n```\n# virsh edit name_of_virtual_machine\n```\n\n```\n<domain>\n  ...\n  <memoryBacking>\n    <hugepages/>\n  </memoryBacking>\n  ...\n  <cpu ...>\n    <numa>\n      <cell memory='memory size of virtual machine' unit='KiB' memAccess='shared'/>\n    </numa>\n  </cpu>\n  ...\n</domain>\n```\n\nIt is necessary to add the NUMA definition so that the memory access can be declared as shared. id and cpus values for NUMA will be inserted by virsh.\n\n"
    },
    {
      "title": "Configure filesystem passthrough",
      "level": 4,
      "content": "Add the following domain XML elements:\n\n```\n# virsh edit name_of_virtual_machine\n```\n\n```\n<domain>\n...\n  <devices>\n    ...\n    <filesystem type='mount' accessmode='passthrough'>\n      <driver type='virtiofs'/>\n      <source dir='path/to/folder/on/host'/>\n      <target dir='mount_tag'/>\n    </filesystem>\n    ...\n  </devices>\n</domain>\n```\n\nReplace path/to/folder/on/host with the directory you want to share, and mount_tag with an arbitrary string that will be used to identify the shared file system in the guest.\n\nIt should now be possible to mount the folder in the shared machine:\n\n```\n# mount -t virtiofs mount_tag /mnt/mount/path\n```\n\nAdd the following fstab entry to mount the folder automatically at boot:\n\n```\n/etc/fstab\n```\n\n```\n...\nmount_tag /mnt/mount/path virtiofs rw,noatime 0 0\n```\n\n"
    },
    {
      "title": "Mapping user/group IDs in unprivileged mode",
      "level": 4,
      "content": "By default, the root user (id 0) in the guest is mapped to the current user on the host. Other IDs are mapped to the subordinate user IDs specified in subuid(5) and subgid(5).\n\nYou can also configure this mapping manually using idmap tag:\n\n```\n# virsh edit name_of_virtual_machine\n```\n\n```\n<domain>\n...\n  <devices>\n    ...\n    <filesystem type='mount' accessmode='passthrough'>\n      <idmap>\n        <uid start=\"2000\" target=\"1000\" count=\"1\"/>\n        <gid start=\"2000\" target=\"1000\" count=\"1\"/>\n      </idmap>\n    </filesystem>\n    ...\n  </devices>\n</domain>\n```\n\n"
    },
    {
      "title": "9p",
      "level": 3,
      "content": "File system directories can be shared using the 9P protocol. Details are available in QEMU's documentation of 9psetup.\n\nConfigure the virtual machine as follows:\n\n```\n<domain>\n...\n  <devices>\n    ...\n    <filesystem type=\"mount\" accessmode=\"mapped\">\n      <source dir=\"/path/on/host\"/>\n      <target dir=\"mount_tag\"/>\n    </filesystem>\n  </devices>\n</domain>\n```\n\nBoot the guest and mount the shared directory from it using:\n\n```\n# mount -t 9p -o trans=virtio,version=9p2000.L mount_tag /path/to/mount_point/on/guest\n```\n\nSee https://docs.kernel.org/filesystems/9p.html for more mount options.\n\nTo mount it at boot, add it to the guest's fstab:\n\n```\n/etc/fstab\n```\n\n```\n...\nmount_tag\t/path/to/mount_point/on/guest\t9p\ttrans=virtio,version=9p2000.L\t0 0\n```\n\nThe module for the 9p transport (i.e. 9pnet_virtio for trans=virtio) will not be automatically loaded, so mounting the file system from /etc/fstab will fail and you will encounter an error like 9pnet: Could not find request transport: virtio. The solution is to preload the module during boot:\n\n```\n/etc/modules-load.d/9pnet_virtio.conf\n```\n\n```\n9pnet_virtio\n```\n\n"
    },
    {
      "title": "Samba / SMB",
      "level": 3,
      "content": "An other easy way to share data between guest and host is to use the smb protocol. While performance and latency may not be as good as in the other described ways, its sufficient for simple tasks like transfering simple files like images or documents from and to the guest.\n\nThe smb server can be set up directly on either the host, or the guest, for example using Samba, eliminating the need for a dedicated file server. Windows guests have the ability to create smb shares included right after installation (Microsoft Supportpage).\n\nOne possible way to access the share under linux (either from the host, or from the guest, depending, where you have installed your server) is to create an entry in your fstab. The samba package is required.\n\n```\n/etc/fstab\n```\n\n```\n#Accessing a samba share on my vm from the host\n//my_vm/my_share /home/archuser/my_vm cifs _netdev,noauto,nofail,user,credentials=/home/archuser/.config/my_vm.key,gid=1000,uid=984 0 0\n```\n\n_netdev,noauto,nofail ensures that the share is only mounted when needed without causing issues if the vm is not booted. user,credentials=/home/user/.config/my_vm.key,gid=1000,uid=984 gives you the ability to mount the share on the fly while first accessing it, without needing a password.\n\n"
    },
    {
      "title": "UEFI support",
      "level": 2,
      "content": "Libvirt can support UEFI virtual machines through QEMU and OVMF.\n\nInstall the edk2-ovmf package.\n\nRestart libvirtd.\n\nNow you are ready to create a UEFI virtual machine. Create a new virtual machine through virt-manager. When you get to the final page of the New VM wizard, do the following:\n\n1. Click Customize configuration before install, then select Finish.\n1. In the Overview screen, change the Firmware field to: UEFI x86_64: /usr/share/edk2/x64/OVMF_CODE.4m.fd for x64 UEFI without Secure Boot support, UEFI x86_64: /usr/share/edk2/x64/OVMF_CODE.secboot.4m.fd for x64 UEFI with Secure Boot support (without any pre-enrolled certificates).\n1. Click Apply.\n1. Click Begin Installation.\n\n- UEFI x86_64: /usr/share/edk2/x64/OVMF_CODE.4m.fd for x64 UEFI without Secure Boot support,\n- UEFI x86_64: /usr/share/edk2/x64/OVMF_CODE.secboot.4m.fd for x64 UEFI with Secure Boot support (without any pre-enrolled certificates).\n\nSee Fedora:Using UEFI with QEMU for more information.\n\n"
    },
    {
      "title": "Using an entire physical disk device inside the virtual machine",
      "level": 3,
      "content": "You may have a second disk with a different OS (like Windows) on it and may want to gain the ability to also boot it inside a virtual machine. Since the disk access is raw, the disk will perform quite well inside the virtual machine.\n\n"
    },
    {
      "title": "Windows virtual machine boot prerequisites",
      "level": 4,
      "content": "Be sure to install the virtio drivers inside the OS on that disk before trying to boot it in the virtual machine. For Win 7 use version 0.1.173-4. Some singular drivers from newer virtio builds may be used on Win 7 but you will have to install them manually via device manager. For Win 10 you can use the latest virtio build.\n\nYou may get a 0x0000007B bluescreen when trying to boot the virtual machine. This means Windows can not access the drive during the early boot stage because the disk interface driver it would need for that is not loaded / is set to start manually.\n\nThe solution is to enable these drivers to start at boot.\n\nIn HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services, find the folders aliide, amdide, atapi, cmdide, iastor (may not exist), iastorV, intelide, LSI_SAS, msahci, pciide and viaide. Inside each of those, set all their \"start\" values to 0 in order to enable them at boot. If your drive is a PCIe NVMe drive, also enable that driver (should it exist).\n\n"
    },
    {
      "title": "Find the unique path of your disk",
      "level": 4,
      "content": "Run ls /dev/disk/by-id/: tere you pick out the ID of the drive you want to insert into the virtual machine, for example ata-TS512GMTS930L_C199211383. Now add that ID to /dev/disk/by-id/ so you get /dev/disk/by-id/ata-TS512GMTS930L_C199211383. That is the unique path to that disk.\n\n"
    },
    {
      "title": "Add the disk in QEMU CLI",
      "level": 4,
      "content": "In QEMU CLI that would probably be -drive file=/dev/disk/by-id/ata-TS512GMTS930L_C199211383,format=raw,media=disk.\n\nJust modify file= to be the unique path of your drive.\n\n"
    },
    {
      "title": "Add the disk in libvirt",
      "level": 4,
      "content": "In libvirt XML that translates to\n\n```\n$ virsh edit vmname\n```\n\n```\n...\n    <disk type=\"block\" device=\"disk\">\n      <driver name=\"qemu\" type=\"raw\" cache=\"none\" io=\"native\"/>\n      <source dev=\"/dev/disk/by-id/ata-TS512GMTS930L_C199211383\"/>\n      <target dev=\"sda\" bus=\"sata\"/>\n      <address type=\"drive\" controller=\"0\" bus=\"0\" target=\"0\" unit=\"0\"/>\n    </disk>\n...\n```\n\nJust modify \"source dev\" to be the unique path of your drive.\n\n"
    },
    {
      "title": "Add the disk in virt-manager",
      "level": 4,
      "content": "When creating a virtual machine, select \"import existing drive\" and just paste that unique path. If you already have the virtual machine, add a device, storage, then select or create custom storage. Now paste the unique path.\n\n"
    },
    {
      "title": "Python connectivity code",
      "level": 3,
      "content": "The libvirt-python package provides a Python API in /usr/lib/python3.x/site-packages/libvirt.py.\n\nGeneral examples are given in /usr/share/doc/libvirt-python-your_libvirt_version/examples/\n\nUnofficial example using qemu-desktop and openssh:\n\n```\n#! /usr/bin/env python3\nimport socket\nimport sys\nimport libvirt\n\nconn = libvirt.open(\"qemu+ssh://xxx/system\")\nprint(\"Trying to find node on xxx\")\ndomains = conn.listDomainsID()\nfor domainID in domains:\n    domConnect = conn.lookupByID(domainID)\n    if domConnect.name() == 'xxx-node':\n        print(\"Found shared node on xxx with ID {}\".format(domainID))\n        domServ = domConnect\n        break\n```\n\n"
    },
    {
      "title": "Advanced Format 4K native disk",
      "level": 3,
      "content": "To turn a disk into an Advanced Format 4Kn disk, both its physical and logical sector size needs to be set to 4 KiB. For virtio-blk and virtio-scsi this can be done by setting the logical_block_size and physical_block_size options with the <blockio> element. For example:\n\n```\n# virsh edit name_of_virtual_machine\n```\n\n```\n<domain>\n  ...\n  <devices>\n    ...\n    <disk type='file' device='disk'>\n      ..\n      <blockio logical_block_size='4096' physical_block_size='4096'/>\n    </disk>\n    ...\n  </devices>\n</domain>\n```\n\n"
    },
    {
      "title": "commanding QEMU",
      "level": 3,
      "content": "Libvirt is capable of passing on QEMU command line arguments to the underlying QEMU instance running the VM. This functionality is highly useful when libvirt does not provide QEMU features (yet). For examples, see the entire Intel GVT-g article.\n\n"
    },
    {
      "title": "modify VM XML schema for QEMU",
      "level": 4,
      "content": "This serves to enable QEMU-specific elements. Change\n\n```\n$ virsh edit vmname\n```\n\n```\n<domain type='kvm'>\n```\n\nto\n\n```\n$ virsh edit vmname\n```\n\n```\n<domain xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0' type='kvm'>\n```\n\n"
    },
    {
      "title": "QEMU command line arguments",
      "level": 4,
      "content": "In libvirt, QEMU command line arguments separated by whitespaces need to be provided separately.\n\nThe correct location to insert them is at the end of the <domain> element, i. e. right above the closing </domain> tag.\n\n```\n-display gtk,gl=es,zoom-to-fit=off\n```\n\nBecomes\n\n```\n$ virsh edit vmname\n```\n\n```\n...\n  </devices>\n  <qemu:commandline>\n    <qemu:arg value=\"-display\"/>\n    <qemu:arg value=\"gtk,gl=es,zoom-to-fit=off\"/>\n  </qemu:commandline>\n</domain>\n```\n\n"
    },
    {
      "title": "PulseAudio on system instance",
      "level": 3,
      "content": "The PulseAudio daemon normally runs under your regular user account, and will only accept connections from the same user. This can be a problem if QEMU is being run as root through libvirt. To run QEMU as a regular user, edit /etc/libvirt/qemu.conf and set the user option to your username.\n\n```\nuser = \"dave\"\n```\n\nYou will also need to tell QEMU to use the PulseAudio backend and identify the server to connect to. Add the following section to your domain configuration using virsh edit.\n\n```\n<audio id=\"1\" type=\"pulseaudio\" serverName=\"/run/user/1000/pulse/native\">\n    <input latency=\"20000\"/>\n    <output latency=\"20000\"/>\n  </audio>\n```\n\n1000 is your user id. Change it if necessary.\n\nYou can omit the latency settings (in microseconds) but using the defaults might result in crackling.\n\n"
    },
    {
      "title": "Hypervisor CPU use",
      "level": 3,
      "content": "Default VM configuration generated by virt-manager may cause rather high (10-20%) CPU use caused by the QEMU process. If you plan to run the VM in headless mode, consider removing some of the unnecessary devices.\n\n"
    },
    {
      "title": "Virtual machine cannot be un-paused on virt-manager",
      "level": 3,
      "content": "If you are using a disk image format such as qcow2 which has a specified virtual capacity, but only stores what is needed, then you need to have space on the host partition for the image to grow. If you see I/O related errors when attempting to start the VM, it is possible that the host partition holding the virtual disk image is full. You can run df -h on the host to verify how much free space is available.\n\nIf this is the case, see System maintenance#Clean the filesystem for ways to free up space.\n\n"
    },
    {
      "title": "Redirect USB Device is greyed out in virt-manager",
      "level": 3,
      "content": "If the Redirect USB Device menu item is greyed out, check that the following hardware is configured for the VM:\n\n- A USB Controller.\n- One or more USB Redirectors.\n\n"
    },
    {
      "title": "Error starting domain: Requested operation is not valid",
      "level": 3,
      "content": "When you try to open a virtual machine this error may pop up. This is because when you try to open a existing virtual machine libvirt tries to search for the default network which is not available. To make it available you have to autostart your network interface so that whenever your restart your computer your network interface is always active. See libvirt networking page.\n\nLook at the name of your network interface with the following command:\n\n```\n# virsh net-list --all\n```\n\nTo autostart your network interface:\n\n```\n# virsh net-autostart name_of_the_network\n```\n\nTo start your network interface:\n\n```\n# virsh net-start name_of_the_network\n```\n\n"
    },
    {
      "title": "Virt Manager Error 'Virt Manager doesn't have search permissions'",
      "level": 3,
      "content": "Ensure the folder containing your virtual machine files and installation ISO are owned by the libvirt-qemu group\n\n```\n$ sudo chown -R $USER:libvirt-qemu /path/to/virtual/machine\n```\n\n"
    },
    {
      "title": "Error starting domain: Requested operation is not valid: network 'default' is not active",
      "level": 3,
      "content": "If for any reason the default network is deactivated, you will not be able to start any guest virtual machines which are configured to use the network. Your first attempt can be simply trying to start the network with virsh.\n\n```\n# virsh net-start default\n```\n\nFor additional troubleshooting steps, see [3].\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Official libvirt web site\n- Red Hat Virtualization Deployment and Administration Guide\n- Red Hat Virtualization Tuning and Optimization Guide\n- Slackware KVM and libvirt\n- IBM KVM\n- libvirt Networking Handbook\n\n"
    }
  ]
}