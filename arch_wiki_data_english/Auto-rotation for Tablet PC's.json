{
  "title": "Auto-rotation for Tablet PC's",
  "url": "https://wiki.archlinux.org/title/Auto-rotation_for_Tablet_PC%27s",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nRelated articles\n\n- Graphics tablet\n\nThis article aggregates information to get Arch Linux working on a tablet PC. The instructions contain information for getting the touch keyboard, stylus, stylus rotation, and screen rotation to work properly on such devices.\n\n"
    },
    {
      "title": "Stylus",
      "level": 2,
      "content": "Install xf86-input-wacom.\n\n- To configure stylus devices manually (although not recommended), see the Linux Wacom Project Wiki.\n- If your keyboard stops working properly in X after installing xf86-input-wacom, comment all unnecessary entries in /usr/share/X11/xorg.conf.d/70-wacom.conf and put the resulting file in /etc/xorg.conf.d/70-wacom.conf.\n\n"
    },
    {
      "title": "On-screen keyboards",
      "level": 2,
      "content": "See List of applications/Utilities#On-screen keyboards.\n\n"
    },
    {
      "title": "With GNOME",
      "level": 3,
      "content": "Depending on your device, the default GNOME screen keyboard will work automatically when you tap on text input fields. If \"Tablet Mode\" detection is not working on your device (mutter issue), you might want to customize Gnome Settings > Accessibility.\n\nEnabling Screen keyboard will allow it to always display when a text input field becomes focused.\n\nAlways Show Accessibility Menu will allow you to manually enable or disable this depending on your needs.\n\n"
    },
    {
      "title": "Enable Xserver option",
      "level": 4,
      "content": "Unless you are running a very old Xserver, rotation capabilities (included in xrandr) should already be on by default. If not, you can enable xrandr by adding the following option to the Screen section of the xorg.conf file.\n\n```\nOption         \"RandRRotation\" \"on\"\n```\n\nSave the file and restart the xserver for changes to take effect.\n\n"
    },
    {
      "title": "Use xrandr",
      "level": 4,
      "content": "The simplest way is to use:\n\n```\nxrandr -o 1 #portrait mode\n xrandr -o 0 #back to normal\n```\n\nor similarly:\n\n```\nxrandr -o left #portrait mode\n xrandr -o normal #back to normal\n```\n\nOn some drivers, rotating the screen with xrandr -o 1 or xrandr -o left messes-up the dpi: the fonts become unreadable. The xrandr -o option is quite old. Using the --rotate solves the issue, but we need to specify the --output option first. Identify the wanted device with xrandr, and type something like:\n\n```\nxrandr --output eDP --rotate left\n```\n\n"
    },
    {
      "title": "With xsetwacom",
      "level": 4,
      "content": "If not done yet and in analogy to graphics tablet, an approach to get also the inputs of the touch panel rotated is to install the xf86-input-wacom Xorg driver just as suggested above. After doing so there are various commands available how to manipulate and manage the inputs of the touch panel.\n\nTo set the stylus input to portrait mode:\n\n```\n$ xsetwacom set stylus Rotate cw\n```\n\nTo return to landscape mode:\n\n```\n$ xsetwacom set stylus Rotate none\n```\n\nIn case the device 'stylus' cannot be found, use:\n\n```\n$ xsetwacom list devices\n```\n\nto get a list of devices.\n\nFor example:\n\n```\nxsetwacom set \"Wacom Co.,Ltd. Pen and multitouch sensor Pen stylus\" Rotate cw\n```\n\nSource: https://xournal.sourceforge.net/manual.html\n\nIf you still cannot change the rotation, you can try to use xinput.\n\n"
    },
    {
      "title": "With xinput",
      "level": 4,
      "content": "You can also use xinput to turn the stylus, like you would rotate a touchscreen.\n\nTo set the stylus input to portrait mode:\n\n```\nxinput set-prop <Name of Stylus|Touch Screen> --type=float \"Coordinate Transformation Matrix\"  0 -1 1 1 0 0 0 0 1\n```\n\nTo return to landscape mode:\n\n```\nxinput set-prop <Name of Stylus|Touch Screen> --type=float \"Coordinate Transformation Matrix\"  0  0 0 0 0 0 0 0 0\n```\n\nIf your stylus is only listed as keyboard while using \"xinput list\", these are my results:\n\n```\n$ xinput list\n```\n\n```\n⎡ Virtual core pointer                    \tid=2\t[master pointer  (3)]\n⎜   ↳ SynPS/2 Synaptics TouchPad              \tid=14\t[slave  pointer  (2)]\n⎣ Virtual core keyboard                   \tid=3\t[master keyboard (2)]\n    ↳ Virtual core XTEST keyboard             \tid=5\t[slave  keyboard (3)]\n    ↳ ELAN0732:00 04F3:272A Pen               \tid=11\t[slave  keyboard (3)] #My Pen\n```\n\nYou can try touching the screen with the pen:\n\n```\n$ xinput list\n```\n\n```\n⎡ Virtual core pointer                    \tid=2\t[master pointer  (3)]\n⎜   ↳ SynPS/2 Synaptics TouchPad              \tid=14\t[slave  pointer  (2)]\n⎜   ↳ ELAN0732:00 04F3:272A Pen Pen (0)       \tid=17\t[slave  pointer  (2)] #My Pen Pointer\n⎣ Virtual core keyboard                   \tid=3\t[master keyboard (2)]\n    ↳ Virtual core XTEST keyboard             \tid=5\t[slave  keyboard (3)]\n    ↳ ELAN0732:00 04F3:272A Pen               \tid=11\t[slave  keyboard (3)] #My Pen Keyboard\n```\n\nUsing the now listed pointer, the commands should work as expected, turning the stylus.\n\nThis worked on my HP Envy x360.\n\n"
    },
    {
      "title": "Xfce: Stylus and screen rotation",
      "level": 3,
      "content": "The following script will rotate the display 90 degrees clockwise every time it is executed. It will also rotate the Wacom pointer so that the stylus will still work.\n\n```\nrotate.sh\n```\n\n```\n#!/bin/bash\n\ncase $(xfconf-query -c pointers -p /Wacom_ISDv4_90_Pen_stylus/Properties/Wacom_Rotation) in\n    2)  # Currently top is rotated left, we should set it normal (0°)\n          xrandr -o 0\n          xfconf-query -c pointers -p /Wacom_ISDv4_90_Pen_stylus/Properties/Wacom_Rotation -s 0\n          xfconf-query -c xsettings -p /Xft/RGBA -s rgb\n          ;;\n    0)  # Screen is not rotated, we should rotate it right (90°)\n           xrandr -o 3\n           xfconf-query -c pointers -p /Wacom_ISDv4_90_Pen_stylus/Properties/Wacom_Rotation -s 1\n           xfconf-query -c xsettings -p /Xft/RGBA -s vbgr\n           ;;\n    1)    # Top of screen is rotated right, we should invert it (180°)\n           xrandr -o 2\n           xfconf-query -c pointers -p /Wacom_ISDv4_90_Pen_stylus/Properties/Wacom_Rotation -s 3\n           xfconf-query -c xsettings -p /Xft/RGBA -s bgr\n           ;;\n    3)  # Screen is inverted, we should rotate it left (270°)\n           xrandr -o 1\n           xfconf-query -c pointers -p /Wacom_ISDv4_90_Pen_stylus/Properties/Wacom_Rotation -s 2\n           xfconf-query -c xsettings -p /Xft/RGBA -s vrgb\n           ;;\n    *)\n           echo \"Unknown result from 'xfconf-query -c pointers -p /Wacom_ISDv4_90_Pen_stylus/Properties/Wacom_Rotation'\" >&2\n           exit 1\n           ;;\nesac\n```\n\nSave the file and make it executable.\n\nYou can create a link to it on your desktop or panel, or link it to a keyboard shortcut or special button on your tablet.\n\n"
    },
    {
      "title": "With xrandr + xinput",
      "level": 3,
      "content": "The following python script was developed to automatic rotate the screen and the touchscreen. Furthermore, it disable the touchpad for inverted, right, and left orientation, and supports automatic detection of accelerometers, touchscreens, and touchpad devices.\n\nIt works for devices with an accelerometer communicating through the industrial I/O subsystem /sys/bus/iio/devices/iio:deviceX, where X is the number of the device. Usually, it is necessary to change the following parameters dpath, devicename, and touchpad.\n\nSee rotate.py or a C version of the script that aims to reduce some system overhead: 2in1screen.c.\n\nYou will need to replace your actual touch device name and recompile. Instruction to recompile is located at the 1st line. You can put this in .xinitrc before the exec line:\n\n```\n.xinitrc\n```\n\n```\n#!/bin/sh\n# xrandr --dpi 180\nxrdb -merge ~/.Xresources\n~/bin/2in1screen &\nexec i3\n```\n\nNote that there are many other rotate scripts on github, including:\n\n- https://github.com/freundTech/surface-tools/tree/master/autorotate\n- https://github.com/andrewrembrandt/surface-autorotate2\n\n"
    },
    {
      "title": "With GNOME",
      "level": 3,
      "content": "See iio-sensor-proxy. Install the iio-sensor-proxy package, a git version iio-sensor-proxy-gitAUR is available.\n\nIf you want the rotation, but have the problem that GNOME is adjusting your brightness automatically in a bad way, then you can use these commands to disable it.\n\nFor current user, which can also be done via power management GUI:\n\n```\n$ dbus-launch gsettings set org.gnome.settings-daemon.plugins.power ambient-enabled false\n```\n\nFor GDM, which cannot be done via GUI, run as the gdm user:\n\n```\n[gdm]$ dbus-launch gsettings set org.gnome.settings-daemon.plugins.power ambient-enabled false\n```\n\nIn the default Wayland mode GNOME screen rotation is broken on some laptops that don't report the screen flip kernel event (SW_TABLET_MODE) and so GNOME does not turn on some tablet features: there is a discussion on GitLab. Install the gnome-shell-extension-screen-autorotateAUR extension to always assume tablet mode when there is a touch screen.\n\nAlternatively use the X11 mode, which you can select from the login screen.\n\n"
    },
    {
      "title": "With a KDE module",
      "level": 3,
      "content": "- From Plasma 5.25+, kded-rotation-gitAUR is not needed for Plasma Wayland Session.\n- kded_rotation is in early development stages and is a bit hacky. Use caution.\n\nInstall iio-sensor-proxy or iio-sensor-proxy-gitAUR and kded-rotation-gitAUR, then restart your Plasma session. Screen rotation should now just work.\n\nFor automatic touch screen rotation edit /usr/bin/orientation-helper script, changing the hardcoded input device name to match the one you have (choose from the output of xinput list).\n\n"
    },
    {
      "title": "With rot8",
      "level": 3,
      "content": "Install rot8-gitAUR and execute rot8 for Wayland or rot8 --touchscreen TOUCHSCREEN for X11. This integrates well with i3 or sway by using exec rot8.\n\nTo only start rot8 when the tabletmode is enabled, you can use acpid and modify the handler at /etc/acpi/handler.sh to execute rot8 when the tabletmode event is triggered (you can get the correct event by calling acpi_listen and trigger the event by flipping your display).\n\n```\n/etc/acpi/handler.sh\n```\n\n```\n...\n    video/tabletmode)\n        case \"$3\" in\n            0000008A)\n                #echo 'tablet mode'\n                case \"$4\" in\n                    00000001)\n                        DISPLAY=:0 rot8 --touchscreen TOUCHSCREEN &\n                        logger 'tablet mode enabled'\n                        ;;\n                    00000000)\n                        killall rot8\n                        DISPLAY=:0 xrandr --output eDP-1 --rotate normal\n                        rmmod wacom\n                        modprobe wacom\n                        logger 'tablet mode disabled'\n                        ;;\n                    *)\n                        logger \"ACPI action undefined: $4\"\n                        ;;\n                esac\n                ;;\n            *)\n                logger \"ACPI action undefined: $3\"\n        esac\n        ;;\n ...\n```\n\nrot8 will automatically detect orientation and rotate modern Linux desktop screen and input devices. For additional configuration see [1].\n\n"
    },
    {
      "title": "Tablet mode",
      "level": 2,
      "content": "You can use linuxflip-gitAUR or detect-tablet-mode-gitAUR to configure laptop and tablet modes (e.g. enable/disable keyboard/touchpad/trackpoint, start/kill on-screen keyboard etc.)\n\nIf no sensor is detected, it can be manually triggered using tablet-modeAUR.\n\n"
    },
    {
      "title": "i3",
      "level": 3,
      "content": "Using a tiling window manager like i3 makes a lot of sense for a tablet, where screen space is limited. While that may seem unintuitive at first – think about it: Android, iOS and Windows 10's tablet mode all use tiling window managers. Thus, i3 is an excellent window managers for tablets running Arch. The problem is that i3 is designed to be used with a keyboard, without a mouse, so there are no touch controls built in. For the most part, users will need to build their own, though touch gestures (see #Tips and tricks) or by adding touch button controls to a status bar or panel. Users of the polybar status bar can try i3touchmenu.\n\n"
    },
    {
      "title": "Xfce",
      "level": 3,
      "content": "Xfce works fine on tablets. However, when xfce-screensaver locks, there is no way to show an on-screen keyboard by default. One can be enabled by going to Settings > Screensaver > Lock Screen and enabling the On Screen Keyboard option. You will also need to add the command required to display your keyboard of choice. For example, using onboard enter this command: onboard -e\n\n"
    },
    {
      "title": "Easystroke",
      "level": 3,
      "content": "Easystroke is a gesture recognition application, recognizing gestures by a variety of input devices, to include pen stylus, mouse, and touch. Gestures can be used to launch programs, enter text, emulate buttons and keys, and scroll. Easystroke is available in the AUR: easystroke-gitAUR.\n\nNote: Easystroke is now unmaintained, the author recommand mouse-actions instead mouse-actions-cli-binAUR and mouse-actions-gui-binAUR.\n\nEasystroke is now unmaintained, the author recommand mouse-actions instead mouse-actions-cli-binAUR and mouse-actions-gui-binAUR.\n\n"
    },
    {
      "title": "Check pen battery",
      "level": 3,
      "content": "See: Laptop#Battery state\n\n"
    },
    {
      "title": "Launch CellWriter under pen",
      "level": 4,
      "content": "One useful application of Easystroke is to use it to launch CellWriter right below your mouse pointer.\n\nNote: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\n```\n#!/bin/bash\n# Original author: mr_deimos (ubuntuforums.org). February 14, 2010\n# Many bugs fixed and improvements made by Ben Wong.  October 20, 2010\n\n# This script toggles the cellwriter letter recognizer window.\n# If a cellwriter window is visible, it will be hidden.\n# If cellwriter is not already running, this will create a new process.\n# If coordinates are specified, the window pops up at those coordinates. \n# If coordinates are not specified, the window is toggled, but not moved.\n\n# Implementation Note: this script is trickier than it should be\n# because cellwriter does two stupid things. First, it has no\n# --get-state option, so we can't tell if it is hidden or not. Second,\n# both the notification area applet and the actual program window have\n# the same window name in X, which means we can't simply use xwininfo\n# to find out if it is showing or not. \n#\n# (Of course, we wouldn't have to be doing this crazy script at all,\n# if cellwriter had a --toggle-window option to toggle showing the\n# keyboard, but that's another rant...)\n#\n# To work around the problem, we'll assume that if the window we got\n# information about from xwininfo is smaller than 100 pixels wide, it\n# must be an icon in the notification area. This may be the wrong\n# assumption, but, oh well...\n\nif [[ \"$1\" == \"-v\" || \"$1\" == \"--verbose\" ]]; then\n    verbose=echo\n    shift\nelse\n    verbose=:\nfi\n\nif [[ \"$1\" && -z \"$2\"  ||  \"$1\" == \"-h\"  ||  \"$1\" == \"--help\" ]] ; then \n    cat >&2 <<EOF\n$(basename $0): Toggle showing the cellwriter window, optionally moving it.\"\n\nUsage:  $(basename $0) [x y]\"\n\tWhere x and y are the desired position of the cellwriter window.\"\n\tIf x and y are omitted, the window is not moved.\"\nEOF\n    exit 1\nfi\n\nif [[ \"$1\" && \"$2\" ]]; then\n    x=$[$1-20]\t\t\t# Offset slightly so cursor will be in window \n    y=$[$2-30]\n    [ $x -lt 0 ] && x=0\t\t# Minimum value is zero\n    [ $y -lt 0 ] && y=0\nfi\n\nif ! xwininfo -root >/dev/null; then\n    echo \"$(basename $0): Error: Could not connect to your X server.\" >&2\n    exit 1\nfi\n\n# Try to obtain CellWriter's window id.\n# We can't use \"xwininfo -name\" b/c that might find the notification icon. \nOLDIFS=\"$IFS\"\nIFS=$'\\n'\nfor line in $(xwininfo -root -tree | grep CellWriter); do\n    line=0x${line#*0x}\t\t# Just to get rid of white space before 0x.\n    $verbose -en \"Checking: $line\\t\"\n    if [[ $line =~ (0x[A-Fa-f0-9]+).*\\)\\ *([0-9]+)x([0-9]+) ]]; then\n\tid=${BASH_REMATCH[1]}\n\twidth=${BASH_REMATCH[2]}\n\theight=${BASH_REMATCH[3]}\n\tif [[ $width -gt 100 ]]; then\n\t    $verbose \"looks good.\"\n\t    CW_WIN_ID=$id\n\t    break;\n\telse\n\t    $verbose \"too small, ignoring.\"\n\tfi\n    else\n\techo \"BUG: The xwininfo regular expression in $0 is broken.\" >&2\n    fi\ndone\nIFS=\"$OLDIFS\"\n\n#Check if Cellwriter's window is visible\nif [ \"$CW_WIN_ID\" ] ; then\n    CW_MAP_STATE=`xwininfo -id \"$CW_WIN_ID\"|grep \"Map State\"|cut -f 2 -d :`\nelse\n    $verbose \"Can't find cellwriter window, checking for a running process...\"\n    if ! pgrep -x cellwriter >& /dev/null; then\n\t$verbose \"No cellwriter process running, starting a new one.\"\n\tif [[ \"$x\" && \"$y\" ]]; then\n\t    cellwriter --show-window --window-x=$x --window-y=$y &\n\telse\n\t    cellwriter --show-window &\n\tfi\n\texit 0\n    else\n\t$verbose \"Found a process, so the window has not been created yet.\"\n\t$verbose \"Pretending the window is UnMapped.\"\n\tCW_MAP_STATE=IsUnMapped\n    fi\nfi\n\n$verbose \"Map state: $CW_MAP_STATE\"\n\ncase \"$CW_MAP_STATE\" in\n\n    *IsViewable*)\t\t# Window is currently visible.\n\t$verbose \"hiding window\"\n\tcellwriter --hide-window &\n\t;;\n\n    *IsUnMapped*)\t\t# Window is currently hidden or non-existent.\n\tif [[ \"$x\" && \"$y\" && \"$CW_WIN_ID\" ]]; then\n\t    $verbose \"moving window to $x $y\"\n\t    xdotool windowmove $CW_WIN_ID $x $y\n\tfi\n\t$verbose \"showing window\"\n\tcellwriter --show-window &    # In bg in case cw is not already running\n\t;;\n\n    *) \t\t\t\t# This will never happen...\n\techo \"BUG: cellwriter is neither viewable nor unmapped\" >&2\n\techo \"BUG: ...which means this script, $0, is buggy.\" >&2\n\texit 1\n\t;;\nesac\n\nexit 0\n```\n\nSave the script as cellwriter.sh in either /usr/local/bin/ or $HOME/bin, and make it executable.\n\nThen create a gesture in Easystroke tied to the following command:\n\n```\ncellwriter.sh $EASYSTROKE_X1 $EASYSTROKE_Y1\n```\n\nWhen you launch it (using the gesture you created), it will open right under your pen.\n\n"
    },
    {
      "title": "Gestures for the Alphabet",
      "level": 4,
      "content": "You can also use Easystroke to make gestures for the entire alphabet, replacing much of the need for CellWriter. To avoid having to make separate gestures for the upper-case letters, you can use the following script to activate the shift key.\n\n```\n#!/bin/bash\nif [ -f /tmp/shift ]\nthen\n  xte \"keydown Shift_L\" \"key $1\" \"keyup Shift_L\"\n  rm -f /tmp/shift\nelse\n  xte \"key $1\"\nfi\n```\n\nSave the script as keypress.sh in either /usr/local/bin/ or $HOME/bin, and make it executable.\n\nThen create a gesture in Easystroke tied to the following command:\n\n```\ntouch /tmp/shift\n```\n\nThis will activate the shift key. To activate the letter keys, tie your gestures to the following command:\n\n```\nkeypress.sh $LETTER\n```\n\nReplace $LETTER with the letter in the alphabet in question.\n\nSo, when you want to enter an upper-case letter, use your gesture for the shift key followed by the letter. If you want a lower-case letter, simply use your gesture for the letter.\n\n"
    },
    {
      "title": "Xournal",
      "level": 4,
      "content": "Xournal is an application for notetaking, sketching, and keeping a journal using a stylus. Xournal aims to provide superior graphical quality (subpixel resolution) and overall functionality.\n\nYou can also extend the functionality of xournalAUR with patches, to enable things such as autosaving documents and inserting images. See SourceForge for links to all the available patches. To apply a patch, see Patching packages.\n\n"
    },
    {
      "title": "Xournal++",
      "level": 4,
      "content": "Xournal++ (xournalpp) is the successor to Xournal that is currently in development. If you want a newer version Xournal, then you could try this. It is currently stable with little to no bugs that causes crashes.\n\n"
    },
    {
      "title": "GDM",
      "level": 3,
      "content": "You can also use CellWriter with GDM. First open /etc/gdm/Init/Default as root with a text editor. Then near the bottom of the file, add the lines in bold as shown:\n\n```\nfi\ncellwriter --keyboard-only &\nexit 0\n```\n\nYou can add --window-x and --window-y to adjust the position of CellWriter accordingly. For example:\n\n```\ncellwriter --keyboard-only --window-x=512 --window-y=768 &\n```\n\nTo start a fully fledged CellWriter instance within the user session, you might want to terminate the instance started with the keyboard-only switch within the gdm context. Add something such as killall cellwriter to your newly created file /etc/gdm/PostLogin/Default.\n\n"
    },
    {
      "title": "LightDM",
      "level": 3,
      "content": "Configuring LightDM to use Onboard for touchscreen login and unlocking is likely the simplest option (and stable) to provide onscreen keyboard login (when using the default GTK greeter).\n\nEnsure onboard and lightdm-gtk-greeter-settings are installed and run lightdm-gtk-greeter-settings to configure onboard to start.\n\nSpecifiying onboard -t Droid -l Phone configures the Droid theme and sets the Phone layout.\n\n"
    },
    {
      "title": "Touchegg",
      "level": 3,
      "content": "Touchegg is a multitouch gesture recognizer. It can recongize up to five finger gestures (tap, drag, pinch, rotate...).\n\n"
    },
    {
      "title": "Wacom Drivers",
      "level": 3,
      "content": "These commands are useful in troubleshooting:\n\n```\nwacdump -f tpc /dev/ttyS0\nxidump -l\nxidump -u stylus\n```\n\nIf xidump shows that your tablets max resolution is the same as screen resolution, then your wacom driver has rescaled your wacom coordinates to the X server's resolution. To fix this, try recompiling your linuxwacom driver with:\n\n```\n./configure --disable-quirk-tablet-rescale\n```\n\n"
    },
    {
      "title": "Screen Rotation support",
      "level": 3,
      "content": "Some video drivers do not support rotation. To check if your driver supports rotation, check the output of xrandr for the list orientations:\n\n```\nnormal left inverted right\n```\n\n"
    }
  ]
}