{
  "title": "Configurando a rede",
  "url": "https://wiki.archlinux.org/title/Configurando_a_rede",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- Depuração de rede\n- Firewalls\n- Compartilhamento de internet\n- Roteador\n\nEsse artigo descreve como configurar conexões de rede na camada 3 do Modelo OSI e acima. Especificidades para cada meio de transporte são tratadas nas subpáginas /Ethernet e /Sem fio.\n\n"
    },
    {
      "title": "Verificar a conexão",
      "level": 2,
      "content": "Para solucionar problemas de uma conexão de rede, siga as seguintes condições e assegure-se de atendê-las:\n\n1. Suas interfaces de rede estão listadas e habilitadas. Do contrário, confira o driver de dispositivo – veja /Ethernet#Driver de dispositivo ou /Sem fio#Driver de dispositivo.\n1. Você está conectado à rede. O cabo está conectado ou você está conectado com a rede sem fio.\n1. Sua interface de rede tem um endereço IP.\n1. Sua tabela de roteamento está configurada corretamente.\n1. Você pode pingar um endereço IP local (por exemplo, seu gateway padrão).\n1. Você pode pingar um endereço IP público (por exemplo, 8.8.8.8), que é um servidor DNS do Google e é um endereço conveniente para se usar em um teste.\n1. Verifique se você consegue resolver nomes de domínio (por exemplo, archlinux.org).\n\n"
    },
    {
      "title": "Ping",
      "level": 3,
      "content": "ping é usado para testar se você consegue alcançar um host.\n\n```\n$ ping www.example.com\n```\n\n```\nPING www.example.com (93.184.216.34): 56(84) data bytes\n64 bytes from 93.184.216.34: icmp_seq=0 ttl=56 time=11.632 ms\n64 bytes from 93.184.216.34: icmp_seq=1 ttl=56 time=11.726 ms\n64 bytes from 93.184.216.34: icmp_seq=2 ttl=56 time=10.683 ms\n...\n```\n\nPara cada resposta que você recebe, o utilitário ping imprimirá uma linha como a acima. Para mais informações, consulte o manual ping(8). Observe que os computadores podem ser configurados para não responder às solicitações de eco ICMP. [1]\n\nSe você não receber nenhuma resposta, isso pode estar relacionado a seu gateway padrão ou a seu provedor de internet. Você pode executar um traceroute para diagnosticar ainda mais a rota para o host.\n\n"
    },
    {
      "title": "Gerenciamento de rede",
      "level": 2,
      "content": "Para configurar uma conexão de rede, siga as etapas abaixo:\n\n1. Certifique-se que sua interface de rede está listada e habilitada.\n1. Conecte à rede. Conecte o cabo de rede ou conecte à rede sem fio.\n1. Configure sua conexão de rede: endereço IP estático endereço IP dinâmico: use DHCP\n\n- endereço IP estático\n- endereço IP dinâmico: use DHCP\n\n"
    },
    {
      "title": "net-tools",
      "level": 3,
      "content": "Arch Linux tornou net-tools obsoleto em favor do iproute2.[2][link inativo 2023-09-16 ⓘ]\n\nTable content:\nComando obsoleto | Comandos substitutos\narp | ip neighbor\nifconfig | ip address, ip link\nnetstat | ss\nroute | ip route\n\nPara um resumo mais completo, veja essa publicação de blogue.\n\n"
    },
    {
      "title": "iproute2",
      "level": 3,
      "content": "iproute2 é uma dependência do metapacote base e fornece a interface de linha de comando ip(8), usado para gerenciar interfaces de rede, endereços IP e a tabela de roteamento. Esteja ciente de que a configuração feita usando ip será perdida após uma reinicialização. Para uma configuração persistente, você pode usar um gerenciador de rede ou automatizar comandos ip usando scripts e units de systemd. Observe também que os comandos ip geralmente podem ser abreviados, para maior clareza eles são descritos neste artigo.\n\n"
    },
    {
      "title": "Interfaces de rede",
      "level": 3,
      "content": "Por padrão, o udev atribui nomes para suas interfaces de rede usando Predictable Network Interface Names, que prefixam nomes de interfaces com en (cabeada/Ethernet), wl (sem fio/wireless/WLAN) ou ww (WWAN).\n\n"
    },
    {
      "title": "Listando interfaces de rede",
      "level": 4,
      "content": "Ambos nomes de interfaces com e sem fio podem ser descobertos por meio de ls /sys/class/net ou ip link. Note que lo é o dispositivo loop ou de laço e não é usado para fazer conexões de rede.\n\nNomes de dispositivos sem fio também podem ser obtidos usando iw dev. Veja também /Sem fio#Obter o nome da interface.\n\nSe sua interface de rede não estiver listada, certifique-se que o driver de seu dispositivo foi carregado com sucesso. Consulte /Ethernet#Driver de dispositivo e /Sem fio#Driver de dispositivo.\n\n"
    },
    {
      "title": "Habilitando e desabilitando interfaces de rede",
      "level": 4,
      "content": "Interfaces de rede podem ser habilitadas/desabilitadas usando ip link set interface up|down. Veja ip-link(8).\n\nPara verificar o status da interface eth0:\n\n```\n$ ip link show dev eth0\n```\n\n```\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master br0 state DOWN mode DEFAULT qlen 1000\n...\n```\n\nO UP em <BROADCAST,MULTICAST,UP,LOWER_UP> é o que indica a interface está ativa, e não o state DOWN posterior.\n\n"
    },
    {
      "title": "Endereço IP estático",
      "level": 3,
      "content": "Um endereço IP estático pode ser configurado com a maioria dos gerenciadores de rede padrão e também dhcpcd.\n\nPara configurar manualmente um endereço IP estático, adicione um endereço IP como descrito em #Endereços IP, configure sua tabela de roteamento e configure seus servidores DNS.\n\n"
    },
    {
      "title": "Endereços IP",
      "level": 3,
      "content": "Endereços IP são gerenciados usando ip-address(8).\n\nListe endereços IP:\n\n```\n$ ip address show\n```\n\nAdicione um endereço IP a uma interface:\n\n```\n# ip address add endereço/tam_prefixo broadcast + dev interface\n```\n\n- o endereço é dado em notação CIDR para também fornecer uma máscara de sub-rede\n- + é um símbolo especial que faz o ip derivar o endereço broadcast do endereço IP e a máscara de sub-rede\n\nExclui um endereço IP de uma interface:\n\n```\n# ip address del endereço/tam_prefixo dev interface\n```\n\nExclui todos os endereços correspondendo a um critério, por exemplo, de uma interface específica:\n\n```\n# ip address flush dev interface\n```\n\n"
    },
    {
      "title": "Tabela de roteamento",
      "level": 3,
      "content": "A tabela de roteamento é usada para determinar se você pode alcançar um endereço IP diretamente ou qual gateway (roteador) você deve usar. Se nenhuma rota corresponde ao endereço IP, o gateway padrão é usado.\n\nA tabela de roteamento é gerenciada usando ip-route(8).\n\nPREFIXO é uma notação CIDR ou default para o gateway padrão.\n\nLista rotas IPv4:\n\n```\n$ ip route show\n```\n\nLista rotas IPv6:\n\n```\n$ ip -6 route\n```\n\nAdiciona uma rota:\n\n```\n# ip route add PREFIXO via endereço dev interface\n```\n\nExclui uma rota:\n\n```\n# ip route del PREFIXO via endereço dev interface\n```\n\n"
    },
    {
      "title": "DHCP",
      "level": 3,
      "content": "Um servidor Dynamic Host Configuration Protocol (DHCP) fornece aos clientes um endereço IP dinâmico, a máscara de sub-rede, o endereço IP do gateway padrão e, opcionalmente, também servidores de nome DNS.\n\nPara usar DHCP, você precisa de um servidor DHCP em sua rede e um cliente DHCP:\n\nTable content:\nCliente | Pacote | Archiso | Nota | Units de systemd\ndhcpcd | dhcpcd | Sim | DHCP, DHCPv6, ZeroConf, IP estático | dhcpcd.service, dhcpcd@interface.service\nISC dhclient | dhclient | Sim | DHCP, DHCPv6, BOOTP, IP estático | dhclient@interface.service\n\nAlternativamente, iwd tem um cliente DHCP embutido que pode ser usado com algumas configurações: iwd (Português)#Ativar configuração de rede embutida.\n\n- Você não deve usar dois clientes DHCP simultaneamente.\n- Em vez de usar diretamente um cliente DHCP, você também pode usar um gerenciador de rede.\n\n"
    },
    {
      "title": "Servidores",
      "level": 4,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nTable content:\nServidor | Pacote | IPv4 | IPv6 | GUI | Interfaces | Backend(s) de armazenamento | Observação\ndhcpd | dhcp | Sim | Sim | Glass-ISC-DHCP | ? | Arquivo | \ndnsmasq | dnsmasq | Sim | Sim | Não | ? | Arquivo | Também DNS, PXE e TFTP\nKea | kea | Sim | Sim | Kea-Anterius (Experimental) | REST, RADIUS e NETCONF | Arquivo, MySQL, PostgreSQL e Cassandra | Também DNS\n\n"
    },
    {
      "title": "Gerenciadores de rede",
      "level": 3,
      "content": "Um gerenciador de rede permite que você gerencie configurações de conexão de rede nos chamados peris de rede para facilitar a troca de redes.\n\nTable content:\nGerenciadorde rede | GUI | Archiso [3] | Ferramentas CLI | Suporte a PPP (ex., Modem 3G) | Cliente DHCP | Units de systemd\nConnMan | 8 não oficiais | Não | connmanctl(1) | Sim ((com ofonoAUR) | interno | connman.service\nnetctl | 2 não oficiais | Sim | netctl(1), wifi-menu | Sim | dhcpcd ou dhclient | netctl-ifplugd@interface.service, netctl-auto@interface.service\nNetworkManager | Sim | Não | nmcli(1), nmtui(1) | Sim | interno ou dhclient | NetworkManager.service\nsystemd-networkd | Não | Sim (base) | networkctl(1) | Não | interno | systemd-networkd.service, systemd-resolved.service\n\n"
    },
    {
      "title": "Configurando um hostname",
      "level": 2,
      "content": "Um hostname, ou \"nome de máquina\", é um nome único criado para identificar uma máquina em uma rede, configurada em /etc/hostname — veja hostname(5) e hostname(7) para detalhes. O arquivo pode conter o nome de domínio do sistema, se houver. Para configurar o hostname, edite /etc/hostname para incluir uma única linha com meuhostname:\n\n```\n/etc/hostname\n```\n\n```\nmeuhostname\n```\n\nAlternativamente, usando hostnamectl(1):\n\n```\n# hostnamectl set-hostname meuhostname\n```\n\nPara definir temporariamente o hostname (até reiniciar), use hostname(1) do inetutils:\n\n```\n# hostname meuhostname\n```\n\nPara configurar um hostname \"bonito\" e outros metadados de máquina, veja machine-info(5).\n\n"
    },
    {
      "title": "Resolução de hostname local",
      "level": 3,
      "content": "O módulo Name Service Switch (NSS) myhostname do systemd fornece resolução de hostname local sem ter que editar /etc/hosts (hosts(5)). Ele está habilitado por padrão.\n\nAlguns clientes, porém, podem depender de /etc/hosts, veja [4] [5] por exemplos.\n\nPara configurar o arquivo hosts, adicione as seguintes linhas ao /etc/hosts:\n\n```\n127.0.0.1        localhost\n::1              localhost\n127.0.1.1        meuhostname.localdomain        meuhostname\n```\n\nComo um resultado, o sistema resolve ambas entradas:\n\n```\n$ getent hosts\n```\n\n```\n127.0.0.1       localhost\n127.0.0.1       localhost\n127.0.1.1       meuhostname.localdomain meuhostname\n```\n\nPara um sistema com um endereço IP permanente, esse endereço IP permanente deve ser usado em vez de 127.0.1.1.\n\n"
    },
    {
      "title": "Resolução de hostname de rede local",
      "level": 3,
      "content": "Para tornar sua máquina acessível em sua LAN por seu hostname, você pode:\n\n- editar o arquivo /etc/hosts para todo dispositivio em sua LAN, veja hosts(5)\n- configurar um servidor DNS para resolver seu hostname e faça com que os dispositivos LAN o usem (ex., por #DHCP)\n- ou a forma fácil: use um serviço Zero-configuration networking: Resolução de nomes de host através do serviço NetBIOS da Microsoft. Fornecido pelo Samba no Linux. Ele precisa da instalação do samba e habilitação do serviço nmb.service. Computadores usando Windows, macOS ou Linux com nmb ativo, serão capazes de localizar sua máquina. Resolução de nomes de host via mDNS. Fornecido por nss_mdns com Avahi (consulte Avahi#Hostname resolution para detalhes de configuração) ou systemd-resolved. Computadores usando macOS, ou Linux com o Avahi ou o systemd-running em execução, poderão localizar sua máquina. A API Win32 mais antiga não possui suporte a mDNS, o que pode impedir que alguns aplicativos antigos do Windows acessem seu dispositivo.\n\n- Resolução de nomes de host através do serviço NetBIOS da Microsoft. Fornecido pelo Samba no Linux. Ele precisa da instalação do samba e habilitação do serviço nmb.service. Computadores usando Windows, macOS ou Linux com nmb ativo, serão capazes de localizar sua máquina.\n- Resolução de nomes de host via mDNS. Fornecido por nss_mdns com Avahi (consulte Avahi#Hostname resolution para detalhes de configuração) ou systemd-resolved. Computadores usando macOS, ou Linux com o Avahi ou o systemd-running em execução, poderão localizar sua máquina. A API Win32 mais antiga não possui suporte a mDNS, o que pode impedir que alguns aplicativos antigos do Windows acessem seu dispositivo.\n\n"
    },
    {
      "title": "Alterando o nome da interface",
      "level": 3,
      "content": "Você pode alterar o nome de um dispositivo definindo o nome em uma regra de udev. Exemplo:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTR{address}==\"aa:bb:cc:dd:ee:ff\", NAME=\"net1\"\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTR{address}==\"ff:ee:dd:cc:bb:aa\", NAME=\"net0\"\n```\n\nEssas regras serão aplicadas automaticamente na inicialização.\n\nAlguns detalhes devem ser ressaltados:\n\n- Para obter o endereço MAC de cada placa de rede, utilize o comando: cat /sys/class/net/nome_dispositivo/address\n- Certifique-se de usar valores hexadecimais minúsculos em suas regras de udev. Ele não gosta de letras maiúsculas.\n\nSe a placa de rede possui um MAC dinâmico, você pode usar DEVPATH, por exemplo:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", DEVPATH==\"/devices/platform/wemac.*\", NAME=\"int\"\nSUBSYSTEM==\"net\", DEVPATH==\"/devices/pci*/*1c.0/*/net/*\", NAME=\"en\"\n```\n\nPara obter o DEVPATH de todos os dispositivos atualmente conecados, veja para onde os links simbólicos em /sys/class/net/ levam. Por exemplo:\n\n```\nfile /sys/class/net/*\n```\n\n```\n/sys/class/net/enp0s20f0u4u1: symbolic link to ../../devices/pci0000:00/0000:00:14.0/usb2/2-4/2-4.1/2-4.1:1.0/net/enp0s20f0u4u1\n/sys/class/net/enp0s31f6:     symbolic link to ../../devices/pci0000:00/0000:00:1f.6/net/enp0s31f6\n/sys/class/net/lo:            symbolic link to ../../devices/virtual/net/lo\n/sys/class/net/wlp4s0:        symbolic link to ../../devices/pci0000:00/0000:00:1c.6/0000:04:00.0/net/wlp4s0\n```\n\nO caminho do dispositivo deve corresponder ao nome do dispositivo novo e antigo, uma vez que a regra pode ser executada mais de uma vez na inicialização. Por exemplo, na segunda regra, \"/devices/pci*/*1c.0/*/net/enp*\" seria errado, uma vez que irá parar de corresponder depois que o nome for alterado para en. Somente a regra padrão do sistema será chamada na segunda vez, fazendo com que o nome seja alterado de volta para, por exemplo, enp1s0.\n\nSe você estiver usando um dispositivo de rede USB (por exemplo, tethering de telefone Android) que tenha um endereço MAC dinâmico e deseje usar diferentes portas USB, poderá usar uma regra que corresponda, dependendo do fornecedor e do ID do produto:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTRS{idVendor}==\"12ab\", ATTRS{idProduct}==\"3cd4\", NAME=\"net2\"\n```\n\nPara testar suas regras, elas podem ser acionadas diretamente do espaço de usuário, por exemplo, com udevadm --debug test /sys/class/net/*. Lembre-se de primeiro retirar a interface que você está tentando renomear (ex. ip link set enp1s0 down).\n\nNote: **deve-se evitar o uso de nomes no formato de \"ethX\" e \"wlanX\"** \n\n"
    },
    {
      "title": "Revertendo para nomes tradicionais de interfaces",
      "level": 3,
      "content": "Se você preferir manter os nomes de interface tradicionais, como eth0, Predictable Network Interface Names podem ser desabilitados mascarando a regra de rule:\n\n```\n# ln -s /dev/null /etc/udev/rules.d/80-net-setup-link.rules\n```\n\nAlternativamente, adicione net.ifnames=0 aos parâmetros do kernel.\n\n"
    },
    {
      "title": "Definindo o MTU do dispositivo e o tamanho da fila",
      "level": 3,
      "content": "Você pode alterar o MTU do dispositivo e o tamanho da fila ao definir manualmente com uma regra de udev. Por exemplo:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"net\", KERNEL==\"wl*\", ATTR{mtu}=\"1500\", ATTR{tx_queue_len}=\"2000\"\n```\n\n- mtu: Para PPPoE, o MTU não deve ser maior que 1492. Você também pode definir o MTU via systemd.netdev(5).\n- tx_queue_len: Valores pequenos para dispositivos menores com uma latência maior, como modens e ISDN. Valor alto é recomendado para servidor conectado por meio conexões de Internet de alta velocidade que realiza grandes transferências de dados.\n\n"
    },
    {
      "title": "Bonding e LAG (agregação de LINK)",
      "level": 3,
      "content": "Veja netctl ou systemd-networkd, ou Wireless bonding.\n\n"
    },
    {
      "title": "Aliasing de endereço IP",
      "level": 3,
      "content": "IP aliasing é o processo de adicionar mais de um endereço IP para uma interface de rede. Como isso, um nó em uma rede pode ter múltiplas conexões com uma rede, cada uma servindo um propósito diferente. Usos típicos são hospedagem virtual de servidores Web e FTP ou reorganização de servidores sem ter que atualizar qualquer outras máquinas (isso é especialmente útil para servidores de nome).\n\n"
    },
    {
      "title": "Exemplo",
      "level": 4,
      "content": "Para definir manualmente um alias, para algumas interfaces de rede, use iproute2 para executar\n\n```\n# ip addr add 192.168.2.101/24 dev eth0 label eth0:1\n```\n\nPara remover um dado alias, execute\n\n```\n# ip addr del 192.168.2.101/24 dev eth0:1\n```\n\nOs pacotes de rede destinados para uma sub-rede vão usar o alias primário por padrão. Se o IP de destino está dentro de uma sub-rede de um alias secundário, então o IP fonte está definido respectivamente. Considere o caso em que há mais de uma interface de rede, as rotas padrão podem ser listadas com ip route.\n\n"
    },
    {
      "title": "Modo promíscuo",
      "level": 3,
      "content": "Ativar modo promíscuo fará com que uma interface de rede (sem fio) encaminhe todo o tráfego que receber para o sistema operacional para processamento posterior. Isso é contrário ao \"modo normal\" onde uma interface de rede irá descartar quadros que não pretende receber. É usado com mais frequência para solução de problemas avançados de rede e análise de pacotes (sniffing).\n\n```\n/etc/systemd/system/promiscuous@.service\n```\n\n```\n[Unit]\nDescription=Set %i interface in promiscuous mode\nAfter=network.target\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/ip link set dev %i promisc on\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n\nSe você deseja habilitar o modo promíscuo na interface eth0, execute enable promiscuous@eth0.service.\n\n"
    },
    {
      "title": "Investigar soquetes",
      "level": 3,
      "content": "ss é um utilitário para investigar portas de rede e é parte do pacote iproute2. Ele tem uma funcionalidade similar ao utilitário obsoleto netstat.\n\nUso comum inclui:\n\nExibe todos os TCP Sockets com nomes de serviços:\n\n```\n$ ss -at\n```\n\nExibe todos os TCP Sockets com números de portas:\n\n```\n$ ss -atn\n```\n\nExibe todos os UDP Sockets:\n\n```\n$ ss -au\n```\n\nPara mais informações, veja ss(8).\n\n"
    },
    {
      "title": "O problema de escala de janela TCP",
      "level": 3,
      "content": "Os pacotes TCP contêm um valor \"janela\" em seus cabeçalhos indicando quantos dados o outro host pode enviar em troca. Esse valor é representado com apenas 16 bits, então o tamanho da janela é no máximo 64Kb. Os pacotes TCP são armazenados em cache por um tempo (eles precisam ser reordenados) e, como a memória é (ou costumava ser) limitada, um host poderia ficar sem isso.\n\nEm 1992, à medida que mais e mais memória ficava disponível, RFC 1323 foi escrito para melhorar a situação: escala de janela. O valor \"janela\", fornecido em todos os pacotes, será modificado por um Fator de Escala definido uma vez, no início da conexão. Esse Fator de Escala de 8 bits permite que a Janela seja até 32 vezes maior do que os 64Kb iniciais.\n\nParece que alguns roteadores quebrados e firewalls na Internet estão reescrevendo o Fator de Escala para 0, o que causa mal-entendidos entre hosts. O kernel do Linux 2.6.17 introduziu um novo esquema de cálculo gerando maiores fatores de escala, tornando visíveis as consequências dos roteadores quebrados e dos firewalls.\n\nA conexão resultante é no máximo muito lenta ou quebrada.\n\n"
    },
    {
      "title": "Como diagnosticar o problema",
      "level": 4,
      "content": "Antes de mais, vamos deixar claro: esse problema é estranho. Em alguns casos, você não poderá usar conexões TCP (HTTP, FTP, ...) e em outros, você poderá se comunicar com alguns hosts (muito poucos).\n\nQuando você tiver esse problema, a saída do dmesg está normal, os logs estão limpos e ip addr informará o estado como normal... e, na verdade, tudo parece normal.\n\nSe você não pode navegar em nenhum site, mas você pode fazer ping em alguns hosts aleatórios, você tem grande chances de estar enfrentando esse problema: o ping usa o ICMP e não é afetado pelos problemas do TCP.\n\nVocê pode tentar usar Wireshark. Você pode ver comunicações UDP e ICMP bem-sucedidas, mas comunicações TCP mal sucedidas (somente para hosts estrangeiros).\n\n"
    },
    {
      "title": "Formas de corrigi-lo",
      "level": 4,
      "content": "Para corrigi-lo de forma incorreta, você pode alterar o valor tcp_rmem, no qual o cálculo do Fator de Escala se baseia. Embora ele funcione para a maioria dos hosts, não é garantido, especialmente para os mais distantes.\n\n```\n# echo \"4096 87380 174760\" > /proc/sys/net/ipv4/tcp_rmem\n```\n\nSimplesmente desative Escala de Janela. Como a Escala de Janela é um bom recurso TCP, pode ser desconfortável desativá-lo, especialmente se você não conseguir corrigir o roteador quebrado. Há várias maneiras de desativar Escala de Janela, e parece que a maneira mais segura (que funcionará com a maioria dos kernels) é adicionar a seguinte linha a /etc/sysctl.d/99-disable_window_scaling.conf (veja também sysctl):\n\n```\nnet.ipv4.tcp_window_scaling = 0\n```\n\nEsse problema é causado por roteadores/firewalls quebrados, então vamos mudá-los. Alguns usuários relataram que o roteador quebrado era o próprio roteador DSL.\n\n"
    },
    {
      "title": "Mais sobre isso",
      "level": 4,
      "content": "Essa seção é baseada nos artigos, em inglês, do LWN Escala de janela e roteadores quebrados e do Kernel Trap Escala de Janela na Internet (arquivado).\n\nHá também vários tópicos relevantes no LKML.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- Linux Network Administrators Guide\n- Referência do Debian: Configuração de Rede\n- RHEL7: Guia de Rede\n- Linux Home Networking\n- Monitorando e ajustando o Linux a Pilha de Conectividade: Recebendo dados\n- Monitorando e ajustando o Linux a Pilha de Conectividade: Enviando dados\n- Rastreamento de uma viagem de pacotes usando tracepoints, perf e eBPF\n\n"
    }
  ]
}