{
  "title": "Package Proxy Cache",
  "url": "https://wiki.archlinux.org/title/Package_Proxy_Cache",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "If you want to install the same Arch packages over and over - e.g. for testing purposes - it could help if you would not have to get the packages every time from the internet. This article shows you how to share packages so that you can greatly decrease your download times.\n\nWhich solution is best depends on your individual use-case. The methods can be grouped into #Package cache sharing of the machines, or deploying a #Proxy server for extra caching on one machine and configuring the machines to use it accordingly. Keep in mind you should not share between different architectures (i.e. i686 and x86_64) or you will run into problems.\n\n"
    },
    {
      "title": "Package cache sharing",
      "level": 2,
      "content": "For all solutions to share the package cache, keep in mind that, by default, pacman -Sc removes package tarballs from the cache that correspond to packages that are not installed on the machine the command was issued on. Because pacman cannot predict what packages are installed on all machines that share the cache, it will end up deleting files that should not be.\n\nTo clean up the cache so that only outdated tarballs are deleted:\n\n```\n/etc/pacman.conf\n```\n\n```\n[options]\nCleanMethod = KeepCurrent\n```\n\n"
    },
    {
      "title": "Read-only cache",
      "level": 3,
      "content": "Pacman 6.1.0 supports cache servers directly. Cache servers will be tried before any non-cache servers, will not be removed from the server pool because of HTTP 404 download errors, and will not be used for database files.\n\nIf you are looking for a quick solution, you can simply run a basic temporary webserver which other computers can use as their cache server.\n\nStart serving this directory. For example, with Python http.server module:\n\n```\n$ python -m http.server -d /var/cache/pacman/pkg/\n```\n\n```\n$ python -m http.server -d /var/cache/pacman/pkg/ --bind 127.0.0.1 8080\n```\n\nThen edit /etc/pacman.d/mirrorlist on each client machine to add this server:\n\n```\n/etc/pacman.d/mirrorlist\n```\n\n```\nCacheServer = http://server-ip:port\n```\n\nNote: **not** \n\nIf looking for a more standalone solution, darkhttpd offers a very minimal webserver. Replace the previous python command with e.g.:\n\n```\n[http]$ darkhttpd /var/cache/pacman/pkg --no-server-id\n```\n\nYou could also run darkhttpd as a systemd service for convenience: see Systemd#Writing unit files.\n\nminiserve, a small web server written in Rust, can also be used:\n\n```\n$ miniserve /var/cache/pacman/pkg\n```\n\nThen edit /etc/pacman.d/mirrorlist as above with the first url miniserve is available at.\n\nIf you are already running a web server for some other purpose, you might wish to reuse that as your local repository server instead. For example, if you already serve a site with nginx, you can add an nginx server block listening on port 8080:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nserver {\n    listen 8080;\n    root /var/cache/pacman/pkg;\n    server_name myarchrepo.localdomain;\n    try_files $uri $uri/;\n}\n```\n\nRemember to restart nginx.service after making this change.\n\n"
    },
    {
      "title": "Overlay mount of read-only cache",
      "level": 3,
      "content": "It is possible to use one machine on a local network as a read-only package cache by overlay mounting its /var/cache/pacman/pkg directory. Such a configuration is advantageous if this server has installed on it a reasonably comprehensive selection of up-to-date packages which are also used by other boxes. This is useful for maintaining a number of machines at the end of a low bandwidth upstream connection.\n\nAs an example, to use this method:\n\n```\n# mkdir /tmp/remote_pkg /mnt/workdir_pkg /tmp/pacman_pkg\n# sshfs remote_username@remote_pkgcache_addr:/var/cache/pacman/pkg /tmp/remote_pkg -C\n# mount -t overlay overlay -o lowerdir=/tmp/remote_pkg,upperdir=/var/cache/pacman/pkg,workdir=/mnt/workdir_pkg /tmp/pacman_pkg\n```\n\nAfter this, run pacman using the option --cachedir /tmp/pacman_pkg, e.g.:\n\n```\n# pacman -Syu --cachedir /tmp/pacman_pkg\n```\n\n"
    },
    {
      "title": "Distributed read-only cache",
      "level": 3,
      "content": "There are Arch-specific tools for automatically discovering other computers on your network offering a package cache. Try pacredir, pacserve, pkgdistcacheAUR, or paclanAUR. pkgdistcache uses Avahi instead of plain UDP which may work better in certain home networks that route instead of bridge between Wi-Fi and Ethernet.\n\nHistorically, there was PkgD and multipkg, but they are no longer maintained.\n\n"
    },
    {
      "title": "Read-write cache",
      "level": 3,
      "content": "In order to share packages between multiple computers, simply share /var/cache/pacman/ using any network-based mount protocol. This section shows how to use SSHFS to share a package cache plus the related library-directories between multiple computers on the same local network. Keep in mind that a network shared cache can be slow depending on the file-system choice, among other factors.\n\nFirst, install any network-supporting filesystem packages: sshfs, curlftpfs, samba or nfs-utils.\n\n- To use sshfs, consider reading Using SSH Keys.\n- By default, smbfs does not serve filenames that contain colons, which results in the client downloading the offending package afresh. To prevent this, use the mapchars mount option on the client.\n\nThen, to share the actual packages, mount /var/cache/pacman/pkg from the server to /var/cache/pacman/pkg on every client machine.\n\n"
    },
    {
      "title": "Two-way with rsync or FTP",
      "level": 3,
      "content": "Another approach in a local environment is rsync. Choose a server for caching and enable the rsync daemon. On clients synchronize two-way with this share via the rsync protocol. Filenames that contain colons are no problem for the rsync protocol.\n\nDraft example for a client, using uname -m within the share name ensures an architecture-dependent sync:\n\n```\n# rsync ... rsync://server/share_$(uname -m)/ /var/cache/pacman/pkg/ \n# pacman -Syu\n# paccache --remove --keep 3\n# rsync --delete ... /var/cache/pacman/pkg/ rsync://server/share_$(uname -m)/\n```\n\nInstead of relying on unencrypted rsync daemon a more secure security option is rsync over ssh, Rsync#Automated backup with SSH gives an overview.\n\nIn case rsync is not available in your local environment, a simple ftp service is suitable for the two-way sync as well. lftp provides a --mirror and a --delete option to sync a local with a remote storage.\n\n"
    },
    {
      "title": "Synchronize pacman package cache using synchronization programs",
      "level": 3,
      "content": "Use Syncthing or Resilio Sync to synchronize the pacman cache directories (i.e. /var/cache/pacman/pkg).\n\n"
    },
    {
      "title": "Proxy server",
      "level": 2,
      "content": "For proxy server solutions, keep in mind the machines should only use HTTP mirrors, because a proxy server cannot introspect HTTPS connections by default.\n\n"
    },
    {
      "title": "Dynamic reverse proxy cache using nginx",
      "level": 3,
      "content": "nginx can be used to proxy package requests to official upstream mirrors and cache the results to the local disk. All subsequent requests for that package will be served directly from the local cache, minimizing the amount of internet traffic needed to update a large number of computers.\n\nIn this example, the cache server will run at http://cache.domain.example:8080/ and store the packages in /srv/http/pacman-cache/.\n\nInstall nginx on the computer that is going to host the cache. Create the directory for the cache and adjust the permissions so nginx can write files to it:\n\n```\n# mkdir /srv/http/pacman-cache\n# chown http:http /srv/http/pacman-cache\n```\n\nUse the nginx pacman cache config as a starting point for /etc/nginx/nginx.conf. Check that the resolver directive works for your needs. In the upstream server blocks, configure the proxy_pass directives with addresses of official mirrors, see examples in the configuration file about the expected format. Once you are satisfied with the configuration file start and enable nginx.\n\nIn order to use the cache each Arch Linux computer (including the one hosting the cache) must have the following line at the top of the mirrorlist file:\n\n```\n/etc/pacman.d/mirrorlist\n```\n\n```\nServer = http://cache.domain.example:8080/$repo/os/$arch\n...\n```\n\n"
    },
    {
      "title": "Squid",
      "level": 3,
      "content": "Squid proxy can be setup to only cache arch packages and can be used with aif/pacman/wget/etc with minimal configuration on the client system.\n\n"
    },
    {
      "title": "Install Squid",
      "level": 4,
      "content": "Install squid.\n\n"
    },
    {
      "title": "Configure Squid",
      "level": 4,
      "content": "This is the minimum configuration to get squid cache arch packages.\n\nBefore defining these rules, remove/comment (if you do not need them) all the default refresh_patterns\n\n```\n/etc/squid/squid.conf\n```\n\n```\nrefresh_pattern \\.pkg\\.tar\\.   0       20%     4320      reload-into-ims\nrefresh_pattern .              0       0%      0\n```\n\nThat should define that *.pkg.tar.* gets cached, and anything else should not.\n\nObjects larger than this size will NOT be saved on disk:\n\n```\n/etc/squid/squid.conf\n```\n\n```\nmaximum_object_size 256 MB\n```\n\nSet the cache dir and its maximum size and subdirs:\n\n```\n/etc/squid/squid.conf\n```\n\n```\ncache_dir aufs /var/cache/squid 10000 16 256\n```\n\nTime to wait until all active client sockets are closed:\n\n```\n/etc/squid/squid.conf\n```\n\n```\nshutdown_lifetime 1 seconds\n```\n\nNote: Every time you change the cache_dir path (and after fresh install), you need to (re)create this directory:\n\nEvery time you change the cache_dir path (and after fresh install), you need to (re)create this directory:\n\n```\n# squid -z\n```\n\nand it could be helpful to check the configuration file before running squid:\n\n```\n# squid -k parse\n```\n\n"
    },
    {
      "title": "Start Squid",
      "level": 4,
      "content": "Just start squid.service or if squid is already running restart it.\n\nNote: It could be helpful to check the configuration file before running:\n\nIt could be helpful to check the configuration file before running:\n\n```\n# squid -k check\n```\n\n"
    },
    {
      "title": "Follow Squid access log",
      "level": 4,
      "content": "To see the access to squid:\n\n```\n# tail -f /var/log/squid/access.log\n```\n\nYou should see this for packages that are directed to original host:\n\n```\n...TCP_MISS/200...DIRECT...\n```\n\nand for packages that are delivered from the cache:\n\n```\n...TCP_HIT/200...NONE...\n```\n\n"
    },
    {
      "title": "Manual Arch Install",
      "level": 4,
      "content": "On the individual machines, add environment variables for your proxy. To do so for testing:\n\n```\n# export http_proxy='http://your_squid_machine_ip:3128/'\n# export ftp_proxy='ftp://your_squid_machine_ip:3128/'\n```\n\nNow it should use your proxy. Watch the squid logs to verify this. Once it works, add the http_proxy and/or ftp_proxy variables in an appropriate place on the installed system, e.g. in /etc/profile.d/proxy.sh.\n\n"
    },
    {
      "title": "Intercepting local requests",
      "level": 4,
      "content": "If you want all HTTP requests on local machine automagically go through squid, we first need to add an intercepting port for squid:\n\n```\n/etc/squid/squid.conf\n```\n\n```\nhttp_port 3127 intercept\n```\n\nand iptables rules to redirect all (except the ones from squid) port 80 requests to squid:\n\n```\n# iptables -t nat -A OUTPUT -p tcp --dport 80 -m owner --uid-owner proxy -j ACCEPT\n# iptables -t nat -A OUTPUT -p tcp --dport 80 -j REDIRECT --to-ports 3127\n```\n\n"
    },
    {
      "title": "Pacoloco proxy cache server",
      "level": 3,
      "content": "Pacoloco is an easy-to-use proxy cache server for pacman repositories. It also allows automatic prefetching of the cached packages.\n\nIt can be installed as pacoloco. Open the configuration file and add pacman mirrors:\n\n```\n/etc/pacoloco.yaml\n```\n\n```\nport: 9129\nrepos:\n  mycopy:\n    urls:\n      - http://mirror.lty.me/archlinux\n      - http://mirrors.kernel.org/archlinux\n```\n\nRestart pacoloco.service and the proxy repository will be available at http://myserver:9129/repo/mycopy.\n\n"
    },
    {
      "title": "Flexo proxy cache server",
      "level": 3,
      "content": "Flexo is yet another proxy cache server for pacman repositories. Flexo is available as flexo-gitAUR. Once installed, start the flexo.service unit.\n\nFlexo runs on port 7878 by default. Enter Server = http://myserver:7878/$repo/os/$arch to the top of your /etc/pacman.d/mirrorlist so that pacman downloads packages via Flexo.\n\n"
    }
  ]
}