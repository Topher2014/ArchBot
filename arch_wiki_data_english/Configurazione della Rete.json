{
  "title": "Configurazione della Rete",
  "url": "https://wiki.archlinux.org/title/Configurazione_della_Rete",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Articoli correlati\n\n- Network Debugging\n- Category:Firewalls (Italiano)\n- Internet sharing (Italiano)\n- Router\n\nQuesto articolo descrive come configurare le connessioni di rete su strato OSI 3 e versioni successive. Le specifiche del supporto sono gestite nelle sottopagine /Ethernet e /Wireless.\n\n"
    },
    {
      "title": "Controllare la connessione",
      "level": 2,
      "content": "Per risolvere i problemi relativi a una connessione di rete, attenersi alle seguenti condizioni e assicurarsi di soddisfarle:\n\n1. La vostra interfaccia di rete è elencata e abilitata. Altrimenti, controllate il driver del dispositivo – vedasi /Ethernet#Driver del dispositivo o /Wireless#Driver del dispositivo.\n1. Siete connessi alla rete. Il cavo è collegato o siete connessi alla LAN wireless.\n1. La vostra interfaccia di rete ha un indirizzo IP.\n1. La vostra tabella di instradamento è configurata correttamente.\n1. Potete effettuare il ping di un indirizzo IP locale (es. il vostro gateway predefinito).\n1. Potete effettuare il ping di un indirizzo IP pubblico (es. 9.9.9.9, che è un server DNS appartenente alla Fondazione Quad9 ed è un indirizzo conveniente con cui eseguire prove).\n1. Controllate se potete risolvere i nomi di dominio (es. archlinux.org).\n\n"
    },
    {
      "title": "Ping",
      "level": 3,
      "content": "ping viene usata per verificare di poter raggiungere un host.\n\n```\n$ ping www.example.com\n```\n\n```\nPING www.example.com (93.184.216.34): 56(84) data bytes\n64 bytes from 93.184.216.34: icmp_seq=0 ttl=56 time=11.632 ms\n64 bytes from 93.184.216.34: icmp_seq=1 ttl=56 time=11.726 ms\n64 bytes from 93.184.216.34: icmp_seq=2 ttl=56 time=10.683 ms\n...\n```\n\nPer ogni risposta ricevuta, l'utilità ping scriverà una riga come quella sopra finchè non la interrompete (Ctrl+c) in modo interattivo. Per maggiori informazioni vedere il manuale ping(8). Si noti che i computer possono essere configurati per non rispondere alle richieste echo ICMP. [1]\n\nSe vi viene mostrato un messaggio di errore (vedasi indicazioni di errore di ping) oppure non ricevete risposta, ciò potrebbe essere correlato ad una configurazione incompleta, ma anche al vostro gateway predefinito o al vostro Provider di Servizi Internet (ISP). Potete eseguire un traceroute per diagnosticare ulteriormente il percorso verso l'host.\n\n"
    },
    {
      "title": "Gestione della rete",
      "level": 2,
      "content": "Per configurare una connessione di rete, seguire i passaggi seguenti:\n\n1. Assicuratevi che la vostra interfaccia di rete sia elencata e abilitata.\n1. Connettetevi alla rete. Collegate il cavo Ethernet o connettetevi alla LAN wireless.\n1. Configurate la vostra connessione di rete: indirizzo IP statico indirizzo IP dinamico: utilizzate DHCP\n\n- indirizzo IP statico\n- indirizzo IP dinamico: utilizzate DHCP\n\n"
    },
    {
      "title": "net-tools",
      "level": 3,
      "content": "Arch Linux ha deprecato net-tools in favore di iproute2.[2]\n\nTable content:\nComando deprecato | comandi di rimpiazzo\narp | ip neighbor\nifconfig | ip address, ip link\nnetstat | ss\nroute | ip route\n\nPer una panoramica più completa, vedere Comandi di Linux deprecati per la gestione di una rete e loro sostituzioni.\n\n"
    },
    {
      "title": "iproute2",
      "level": 3,
      "content": "iproute2 è una dipendenza del metacontenuto base e fornisce l'interfaccia a riga di comando ip(8), utilizzata per gestire interfacce di rete, indirizzi IP e la tabella di instradamento. Tenete presente che la configurazione eseguita utilizzando ip andrà perduta dopo un riavvio. Per una configurazione persistente, potete utilizzare un gestore di rete o automatizzare i comandi ip utilizzando script e unità di systemd. Si noti inoltre che i comandi ip possono essere generalmente abbreviati, per chiarezza sono comunque scritti per intero in questo articolo.\n\n"
    },
    {
      "title": "Interfacce di rete",
      "level": 3,
      "content": "Per impostazione predefinita udev assegna dei nomi ai vostri controller dell'interfaccia di rete utilizzando Nomi dell'Interfaccia di Rete Prevedibili, che antepone i nomi delle interfacce con en (cablata/Ethernet), wl (wireless/WLAN), o ww (WWAN). Vedasi systemd.net-naming-scheme(7).\n\n"
    },
    {
      "title": "Elencare le interfacce di rete",
      "level": 4,
      "content": "I nomi delle interfacce sia cablate che wireless possono essere trovati tramite ls /sys/class/net o ip link. Si noti che lo è l'interfaccia virtuale di loopback e non viene utilizzata per effettuare connessioni di rete.\n\nI nomi dei dispositivi wireless possono essere recuperati anche utilizzando iw dev. Vedere anche /Wireless#Ottenere il nome dell'interfaccia.\n\nSe la vostra interfaccia di rete non è elencata, assicuratevi che il driver del dispositivo sia stato caricato correttamente. Vedasi /Ethernet#Driver del dispositivo o /Wireless#Driver del dispositivo.\n\n"
    },
    {
      "title": "Abilitare e disabilitare le interfacce di rete",
      "level": 4,
      "content": "Le interfacce di rete possono essere abilitate o disabilitate mediante ip link set interfaccia up|down, vedere ip-link(8).\n\nPer controllare lo stato dell'interfaccia enp2s0:\n\n```\n$ ip link show dev enp2s0\n```\n\n```\n2: enp2s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master br0 state DOWN mode DEFAULT qlen 1000\n...\n```\n\nLa parola UP in <BROADCAST,MULTICAST,UP,LOWER_UP> è l'effettiva indicazione che l'interfaccia è attiva, non la successiva state DOWN.\n\n"
    },
    {
      "title": "Indirizzo IP statico o dinamico?",
      "level": 3,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nSe utilizzate un Wi-FI o un router, ad esempio, a casa, starete molto probabilmente utilizzando un indirizzo IP dinamico. L'indirizzo IP viene assegnato dal Wi-Fi o dal router ed è ciò che la configurazione del vostro computer dovrebbe utilizzare. Oppure, se siete a casa e il vostro computer è connesso al modem del vostro ISP, ad esempio un modem via cavo, anch'esso utilizzerà un indirizzo IP dinamico. Gli indirizzi IP dinamici possono cambiare ogni volta che accendete il vostro computer. In un ambiente di lavoro, potreste avere un indirizzo IP statico o un indirizzo IP dinamico. A casa, potete configurare il vostro router in modo che assegni sempre al vostro computer lo stesso indirizzo IP, dunque starete utilizzando un indirizzo IP statico. Quando state utilizzando un indirizzo IP dinamico, dovrete utilizzare DHCP, così esso potrà configurare la vostra interfaccia di rete con l'indirizzo IP corretto. Oltre a configurare il vostro ìndirizzo IP, DHCP può anche configurare il vostro instradamento (come arrivare da dove ci si trova a un qualsiasi punto della rete si stia andando) così come i vostri name servers, che convertono il nome host, ad esempio, example.com, nel suo indirizzo IP, quel numero con dei punti inseriti.\n\n"
    },
    {
      "title": "Indirizzo IP statico",
      "level": 3,
      "content": "Un indirizzo IP statico può essere configurato con la maggior parte dei gestori di rete predefiniti e anche con dhcpcd.\n\nPer configurare manualmente un indirizzo IP statico, aggiungete un indirizzo IP come descritto in #Indirizzi IP, impostate la vostra Tabella di instradamento e configurate i vostri server DNS.\n\n"
    },
    {
      "title": "Indirizzi IP",
      "level": 3,
      "content": "Gli indirizzi IP sono gestiti mediante ip-address(8).\n\nElencare gli indirizzi IP:\n\n```\n$ ip address show\n```\n\nAggiungere un indirizzo IP a una interfaccia:\n\n```\n# ip address add indirizzo/lunghezza_prefisso broadcast + dev interfaccia\n```\n\n- l'indirizzo è dato in notazione CIDR per fornire anche una maschera della sottorete\n- + è un simbolo speciale che, mediante ip, deriva l'indirizzo di trasmissione dall'indirizzo IP e dalla maschera della sottorete\n\nEliminare un indirizzo IP da un'interfaccia:\n\n```\n# ip address del indirizzo/lunghezza_prefisso dev interfaccia\n```\n\nEliminare tutti gli indirizzi che corrispondono a un criterio, ad es. di una specifica interfaccia:\n\n```\n# ip address flush dev interfaccia\n```\n\n"
    },
    {
      "title": "Tabella di instradamento",
      "level": 3,
      "content": "La tabella di instradamento è utilizzata per determinare se potete raggiungere direttamente un indirizzo IP o quale gateway (router) dovreste usare. Se nessun'altro perscorso corrisponde all'indirizzo IP, viene utilizzato il gateway predefinito.\n\nLa tabella di instradamento è gestita utilizzando ip-route(8).\n\nPREFISSO è una notazione CIDR o default per il gateway predefinito.\n\nElencare percorsi IPv4:\n\n```\n$ ip route show\n```\n\nElencare percorsi IPv6:\n\n```\n$ ip -6 route\n```\n\nAggiungere un percorso:\n\n```\n# ip route add PREFISSO via indirizzo dev interfaccia\n```\n\nCancellare un percorso:\n\n```\n# ip route del PREFISSO via indirizzo dev interfaccia\n```\n\n"
    },
    {
      "title": "DHCP",
      "level": 3,
      "content": "Un server Protocollo Dinamico di Configurazione Host (DHCP) fornisce ai client un indirizzo IP dinamico, la maschera della sottorete, l'indirizzo IP del gateway predefinito e, facoltativamente, anche i name server del DNS.\n\nPer utilizzare DHCP è necessario un server DHCP nella vostra rete e un client DHCP:\n\nTable content:\nClient | Contenuto | Archiso | Nota | Unità di systemd\ndhcpcd | dhcpcd | Yes | DHCP, DHCPv6, ZeroConf, IP statico | dhcpcd.service, dhcpcd@interfaccia.service\nISC dhclient | dhclient | Yes | DHCP, DHCPv6, BOOTP, IP statico | dhclient@interfaccia.service\n\n- ISC ha terminato lo sviluppo sul client DHCP ISC da inizio 2022. Questa implementazione del client non è più mantenuta e non dovrebbe essere utilizzata in ambito produttivo.\n- Non dovreste eseguire due client DHCP contemporaneamente.\n- Invece di utilizzare direttamente un client DHCP autonomo, potete anche utilizzare un gestore di rete, alcuni dei quali hanno un client DHCP integrato.\n- In alternativa, iwd ha un client DHCP integrato di cui si può far uso con qualche configurazione: iwd#Abilitare la configurazione di rete integrata.\n\n- Potete controllare se un server DHCP sia in esecuzione con dhcping.\n- Mentre aspettate che venga assegnato un IP, potete eseguire qualcosa come watch -n 1 ping -c 1 archlinux.org per confermare che la rete sia connessa.\n\n"
    },
    {
      "title": "Server",
      "level": 4,
      "content": "Table content:\nServer | Contenuto | IPv4 | IPv6 | GUI | Interfacce | Backend(s) di memorizzazione | Nota\ndhcpd | dhcp | Yes | Yes | Glass-ISC-DHCP | ? | File | \ndnsmasq | dnsmasq | Yes | Yes | No | ? | File | anche DNS, PXE e TFTP\nKea | kea | Yes | Yes | Stork | REST, RADIUS e NETCONF | File, MySQL, PostgreSQL e Cassandra | anche DNS\n\n"
    },
    {
      "title": "Gestori di rete",
      "level": 3,
      "content": "Un gestore di rete consente di gestire le impostazioni della connessione di rete in dei cosiddetti profili di rete per facilitare il cambio di rete.\n\nTable content:\nGestore di rete | GUI | Archiso [3] | Strumenti CLI | Supporto per PPP (es. modem 3G) | Client DHCP | Unità di systemd\nConnMan | 8 non ufficiale | No | connmanctl(1) | Yes (con ofonoAUR) | interno | connman.service\nnetctl | 2 non ufficiale | No | netctl(1), wifi-menu | Yes | dhcpcd o dhclient | netctl-ifplugd@interfaccia.service, netctl-auto@interfaccia.service\nNetworkManager | Yes | No | nmcli(1), nmtui(1) | Yes | interno o dhclient | NetworkManager.service\nsystemd-networkd | No | Yes (base) | networkctl(1) | No | interno | systemd-networkd.service, systemd-resolved.service\n\n"
    },
    {
      "title": "Set the hostname",
      "level": 2,
      "content": "Note: **This article or section needs to be translated.** This article or section needs to be translated.\n\nThis article or section needs to be translated.\n\nNote: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nA hostname is a unique name created to identify a machine on a network, configured in /etc/hostname—see hostname(5) and hostname(7) for details. The file can contain the system's domain name, if any. To set the hostname, edit /etc/hostname to include a single line with myhostname:\n\n```\n/etc/hostname\n```\n\n```\nmyhostname\n```\n\nAlternatively, using hostnamectl(1):\n\n```\n# hostnamectl set-hostname myhostname\n```\n\nTo temporarily set the hostname (until reboot), use hostname(1) from inetutils:\n\n```\n# hostname myhostname\n```\n\nTo set the \"pretty\" hostname and other machine metadata, see machine-info(5).\n\n"
    },
    {
      "title": "Local hostname resolution",
      "level": 3,
      "content": "nss-myhostname(8) (an NSS module provided by systemd) provides local hostname resolution without having to edit /etc/hosts. It is enabled by default.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nSome software may however still read /etc/hosts directly, see [4] [5] for examples. To prevent them from potentially breaking, hanging or otherwise delaying operation, make sure they can resolve the local hostname and localhost by configuring the hosts(5) file:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n127.0.1.1        myhostname\n```\n\nFor a system with a permanent IP address, replace 127.0.1.1 with that permanent IP address. For a system with a fully qualified domain name, insert the fully qualified domain name before the hostname (see the following link for the reasoning). For example:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n203.0.113.45     host1.fqdomain.example host1\n```\n\nAs a result the system resolves to both entries:\n\n```\n$ getent hosts\n```\n\n```\n127.0.0.1       localhost\n127.0.0.1       localhost\n127.0.1.1       myhostname\n```\n\n"
    },
    {
      "title": "Local network hostname resolution",
      "level": 3,
      "content": "To make your machine accessible in your LAN via its hostname you can:\n\n- edit the /etc/hosts file for every device in your LAN, see hosts(5)\n- set up a DNS server to resolve your hostname and make the LAN devices use it (e.g. via #DHCP)\n- or the easy way: use a Zero-configuration networking service: Hostname resolution via Microsoft's NetBIOS. Provided by Samba on Linux. It only requires the nmb.service. Computers running Windows, macOS, or Linux with nmb running, will be able to find your machine. Hostname resolution via mDNS. Provided by either nss_mdns with Avahi (see Avahi#Hostname resolution for setup details) or systemd-resolved. Computers running macOS, or Linux with Avahi or systemd-resolved running, will be able to find your machine. The older Win32 API does not support mDNS, which may prevent some older Windows applications from accessing your device.\n\n- Hostname resolution via Microsoft's NetBIOS. Provided by Samba on Linux. It only requires the nmb.service. Computers running Windows, macOS, or Linux with nmb running, will be able to find your machine.\n- Hostname resolution via mDNS. Provided by either nss_mdns with Avahi (see Avahi#Hostname resolution for setup details) or systemd-resolved. Computers running macOS, or Linux with Avahi or systemd-resolved running, will be able to find your machine. The older Win32 API does not support mDNS, which may prevent some older Windows applications from accessing your device.\n\n"
    },
    {
      "title": "Cambiare il nome dell'interfaccia",
      "level": 3,
      "content": "Potete modificare il nome del dispositivo definendo il nome manualmente con una regola udev. Per esempio:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTR{address}==\"aa:bb:cc:dd:ee:ff\", NAME=\"net1\"\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTR{address}==\"ff:ee:dd:cc:bb:aa\", NAME=\"net0\"\n```\n\nQueste regole verranno applicate automaticamente all'avvio.\n\nUn paio di cose da notare:\n\n- Per ottenere l'indirizzo MAC di ogni scheda, utilizzare questo comando: cat /sys/class/net/nome_del_dispositivo/address\n- Assicuratevi di utilizzare i valori esadecimali in carattere minuscolo nelle vostre regole udev. Non gli piace il maiuscolo.\n\nSe la scheda di rete ha un MAC dinamico, potete utilizzare DEVPATH, ad esempio:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", DEVPATH==\"/devices/platform/wemac.*\", NAME=\"int\"\nSUBSYSTEM==\"net\", DEVPATH==\"/devices/pci*/*1c.0/*/net/*\", NAME=\"en\"\n```\n\nPer ottenere il DEVPATH di tutti i dispositivi attualmente connessi, osservate dove conducono i collegamenti simbolici in /sys/class/net/. Per esempio:\n\n```\nfile /sys/class/net/*\n```\n\n```\n/sys/class/net/enp0s20f0u4u1: symbolic link to ../../devices/pci0000:00/0000:00:14.0/usb2/2-4/2-4.1/2-4.1:1.0/net/enp0s20f0u4u1\n/sys/class/net/enp0s31f6:     symbolic link to ../../devices/pci0000:00/0000:00:1f.6/net/enp0s31f6\n/sys/class/net/lo:            symbolic link to ../../devices/virtual/net/lo\n/sys/class/net/wlp4s0:        symbolic link to ../../devices/pci0000:00/0000:00:1c.6/0000:04:00.0/net/wlp4s0\n```\n\nIl percorso del dispositivo dovrebbe corrispondere sia al nuovo che al vecchio nome del dispositivo, poiché la regola potrebbe venir eseguita più di una volta all'avvio. Ad esempio, nella seconda regola, \"/devices/pci*/*1c.0/*/net/enp*\" sarebbe sbagliato, poiché smetterebbe di corrispondere una volta che il nome dovesse cambiare in en. Solo la regola predefinita del sistema si attiverà la seconda volta, causando il ritorno del nome a, ad es., enp1s0.\n\nSe state utilizzando un dispositivo di rete USB (ad es. il tethering di un telefono Android) che ha un indirizzo MAC dinamico e volete essere in grado di utilizzare delle porte USB diverse, potreste invece utilizzare una regola che corrisponda a seconda del fornitore e dell'ID di un prodotto:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTRS{idVendor}==\"12ab\", ATTRS{idProduct}==\"3cd4\", NAME=\"net2\"\n```\n\nPer provare le vostre regole esse possono essere verificare direttamente dallo spazio utente, ad es. con udevadm --debug test /sys/class/net/*. Ricordatevi di disabilitare prima l'interfaccia che state cercando di rinominare (es. ip link set enp1s0 down).\n\nNote: **dovrebbe essere evitato l'uso di nomi nel formato di \"ethX\" e \"wlanX\"** \n\n"
    },
    {
      "title": "Ritornare ai nomi dell'interfaccia tradizionali",
      "level": 3,
      "content": "Se preferiste mantenere i nomi dell'interfaccia tradizionali come eth0, eth0, i Nomi dell'Interfaccia di Rete Prevedibili possono essere disabilitati mascherando la regola udev:\n\n```\n# ln -s /dev/null /etc/udev/rules.d/80-net-setup-link.rules\n```\n\nIn alternativa, aggiungere net.ifnames=0 ai parametri del kernel.\n\n"
    },
    {
      "title": "Impostare l'MTU del dispositivo e la lunghezza della coda",
      "level": 3,
      "content": "Potete modificare l'MTU del dispositivo e la lunghezza della coda definendo manualmente con una regola udev. Per esempio:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"net\", KERNEL==\"wl*\", ATTR{mtu}=\"1500\", ATTR{tx_queue_len}=\"2000\"\n```\n\nmtu: l'utilizzo di un valore superiore a 1500 (i cosiddetti jumbo frames) può accelerare notevolmente i trasferimenti di rete. Si noti che tutte le interfacce di rete, inclusi gli switche nella rete locale, devono supportare la stessa MTU per poter utilizzare i jumbo frames. Per PPPoE, l'MTU non deve essere superiore a 1492. Potete anche impostare l'MTU tramite systemd.netdev(5).\n\ntx_queue_len: valore ridotto per dispositivi più lenti con una latenza elevata come collegamenti modem e ISDN. Un valore alto è consigliato per server connessi tramite le connessioni Internet ad alta velocità che eseguono grandi trasferimenti di dati.\n\n"
    },
    {
      "title": "Incollaggio o LAG",
      "level": 3,
      "content": "Vedere netctl o systemd-networkd, oppure Incollaggio wireless.\n\n"
    },
    {
      "title": "Aliasing dell'indirizzo IP",
      "level": 3,
      "content": "L'aliasing dell'IP è il processo di aggiunta di più di un indirizzo IP a un'interfaccia di rete. Con ciò, un nodo su una rete può avere più connessioni a una rete, ognuna con uno scopo diverso. È tipicamente utile per l'hosting virtuale di server Web e FTP o la riorganizzazione dei server senza dover aggiornare altre macchine (questo è particolarmente utile per i server dei nomi).\n\n"
    },
    {
      "title": "Esempio",
      "level": 4,
      "content": "Per impostare manualmente un alias, per alcune NIC, utilizzare iproute2 per eseguire\n\n```\n# ip addr add 192.168.2.101/24 dev enp2s0 label enp2s0:1\n```\n\nPer rimuovere un certo alias eseguire\n\n```\n# ip addr del 192.168.2.101/24 dev enp2s0:1\n```\n\nI pacchetti destinati a una sottorete utilizzeranno l'alias primario per impostazione predefinita. Se l'IP di destinazione si trova all'interno di una sottorete appartenente a un alias secondario, l'IP di origine verrà impostato rispettivamente. Considerate il caso in cui sia presente più di una NIC, i percorsi predefiniti possono essere elencati con ip route.\n\n"
    },
    {
      "title": "Modalità promiscua",
      "level": 3,
      "content": "L'attivazione della modalità promiscua farà sì che una NIC (wireless) inoltri tutto il traffico ricevuto al sistema operativo per un'ulteriore elaborazione. Questo è l'opposto della \"modalità normale\", in cui una NIC scarterà i frame che non è destinata a ricevere. Viene spesso utilizzata per la risoluzione dei problemi di rete avanzata e lo sniffing dei pacchetti.\n\n```\n/etc/systemd/system/promiscuous@.service\n```\n\n```\n[Unit]\nDescription=Set %i interface in promiscuous mode\nAfter=network.target\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/ip link set dev %i promisc on\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n\nSe volete abilitare la modalità promiscua sull'interfaccia enp2s0, eseguite enable promiscuous@enp2s0.service.\n\n"
    },
    {
      "title": "Interrogare i socket",
      "level": 3,
      "content": "ss è un'utilità per esaminare le porte di rete e fa parte del contenuto iproute2. Ha una funzionalità simile all'utilità netstat deprecata.\n\nL'utilizzo comune include:\n\nVisualizzare tutti i Socket TCP con i nomi dei servizi:\n\n```\n$ ss -at\n```\n\nVisualizzare tutti i Socket TCP con i numeri di porta:\n\n```\n$ ss -atn\n```\n\nVisualizzare tutti i Socket UDP:\n\n```\n$ ss -au\n```\n\nPer maggiori informazioni, vedere ss(8).\n\n"
    },
    {
      "title": "Il problema del ridimensionamento window di TCP",
      "level": 3,
      "content": "I pacchetti TCP contengono un valore \"window\" nei loro header che indica la quantità di dati che debba restituire l'altro host. Questo valore è rappresentato con solo 16 bit, infatti la dimensione della finestra è al massimo 64KiB. I pacchetti TCP vengono mantenuti in cache per un periodo di tempo (devono essere riordinati), e dato che la memoria è (o era) limitata, uno host potrebbe finirla facilmente.\n\nNel 1992, man mano che più memoria diveniva disponibile, fu scritta la RFC:1323 per migliorare la situazione: il Ridimensionamento della Finestra. Il valore \"window\", fornito in tutti i pacchetti, verrà modificato in base ad un Fattore di Ridimensionamento, definito una sola volta proprio all'inizio della connessione. Quel Fattore di Ridimensionamento di 8 bit permette alla finestra di essere fino a 32 volte superiore ai 64KiB iniziali.\n\nSembrerebbe che alcuni router e firewall difettosi su Internet stiano riscrivendo il Fattore di Ridimensionamento a 0, causando incomprensioni tra gli hosts.\n\nIl kernel di Linux 2.6.17 ha introdotto un nuovo schema di calcolo che genera Fattori di Ridimensionamento più alti, rendendo il disastro di questi router e firewall virtualmente più visibile.\n\nLa connessione in questi casi è al massimo molto lenta oppure viene interrotta.\n\n"
    },
    {
      "title": "Come diagnosticare il problema?",
      "level": 4,
      "content": "Prima di tutto chiariamo: questo problema è strano. In alcuni casi, non vi sarà affatto possibile effettuare connessioni TCP (HTTP, FTP, ...), in altri sarete in grado di comunicare con alcuni host (molto pochi).\n\nQuando siete affetti da questo problema, il risultato da dmesg va bene, i log sono puliti e ip addr riporta uno status normale... ed effettivamente sembra tutto normale.\n\nSe non vi è possibile navigare su nessun sito Web, ma riuscite a eseguire il ping degli host a caso, probabilmente siete incappati in questo problema: ping utilizza il protocollo ICMP e non è affetta da problemi di TCP.\n\nPotete provare tramite Wireshark. Potreste osservare comunicazioni UDP e ICMP avvenute con successo, ma comunicazioni TCP non riuscite (solo verso host esterni).\n\n"
    },
    {
      "title": "Modalità di risoluzione",
      "level": 4,
      "content": "Per risolverlo nel modo sbagliato, potete cambiare il valore tcp_rmem, su cui si basa il calcolo del Fattore di Ridimensionamento. Sebbene dovrebbe funzionare per la maggior parte degli hosts, non è garantito, specialmente per quelli molto distanti.\n\n```\n# echo \"4096 87380 174760\" > /proc/sys/net/ipv4/tcp_rmem\n```\n\nDisabilitate semplicemente il Ridimensionamento della Finestra. Poichè essa rappresenta una buona caratteristica di TCP, disabilitarla può rivelarsi scomodo, specialmente se non potete sistemare il router malfunzionante. Ci sono diversi metodi per disabiltare il Ridimensionamento della Finestra, e sembra che il più sicuro (che funzionerà con la maggior parte dei kernel) sia di aggiungere la seguente riga a /etc/sysctl.d/99-disable_window_scaling.conf (vedasi anche sysctl):\n\n```\nnet.ipv4.tcp_window_scaling = 0\n```\n\nQuesto problema è causato da router/firewall malfunzionanti, dunque cambiamoli. Alcuni utenti hanno riportato che il router difettoso era proprio il loro router DSL.\n\n"
    },
    {
      "title": "Ulteriori informazioni",
      "level": 4,
      "content": "Questa sezione si basa sull'articolo LWN Ridimensionamento della finestra di TCP e router difettosi e su un articolo archiviato di Kernel Trap: Ridimensionamento della Finestra su Internet.\n\nCi sono anche diverse discussioni pertinenti sul LKML.\n\n"
    },
    {
      "title": "Il secondo PC connesso non è in grado di utilizzare la LAN in parallelo",
      "level": 3,
      "content": "Il primo PC ha due LAN. Il secondo PC ha una LAN ed è connesso al primo PC. Andare al secondo PC per fornire tutto l'accesso alla LAN dopo l'interfaccia in parallelo:\n\n```\n# sysctl net.bridge.bridge-nf-filter-pppoe-tagged=0\n# sysctl net.bridge.bridge-nf-filter-vlan-tagged=0\n# sysctl net.bridge.bridge-nf-call-ip6tables=0\n# sysctl net.bridge.bridge-nf-call-iptables=0\n# sysctl net.bridge.bridge-nf-call-arptables=0\n```\n\n"
    },
    {
      "title": "Fonti esterne",
      "level": 2,
      "content": "- Guida per gli Amministratori di Rete Linux\n- Consultazione di Debian: Configurazione di rete\n- RHEL7: Guida per l'Amministrazione di Rete\n- Monitorare e Sintonizzare lo Stack per l'Amministrazione di Rete di Linux: Ricevere dei dati\n- Monitorare e Sintonizzare lo Stack per l'Amministrazione di Rete di Linux: Inviare dei dati\n- Tracciamento del viaggio di un pacchetto mediante punti tracciamento, perf ed eBPF\n\n"
    }
  ]
}