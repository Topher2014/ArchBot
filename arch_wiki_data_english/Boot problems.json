{
  "title": "Boot problems",
  "url": "https://wiki.archlinux.org/title/Boot_problems",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Reporting bug guidelines\n- Step-by-step debugging guide\n- Debugging/Getting traces\n\nThis article explains some methods for general troubleshooting. For application specific issues, please reference the particular wiki page for that program.\n\n"
    },
    {
      "title": "General procedures",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nIt is crucial to always read any error messages that appear. Sometimes it may be hard, e.g. with graphical applications, to get a proper error message.\n\n1. Run the application in a terminal so it is possible to inspect the output. Increase the verbosity (usually --verbose/-v/-V or --debug/-d) if there is still not enough information to debug. Sometimes there is no such parameter and it needs to be specified as a directive in the applications' configuration file. An application may also use log files, which are usually located in /var/log, $HOME/.cache or $HOME/.local If there is no way to increase the verbosity, it is always possible to run strace and similar.\n1. Check the journal. It is possible that an error may also leave traces in the journal, especially if it depends on other applications. dmesg reads from the kernel ring buffer. This is useful if the disk is for some reason inaccessible but this may also result in incomplete logs because the kernel ring buffer is not infinite in size. Use journalctl if possible. journalctl has more filtering options than dmesg and uses human-readable timestamps by default.\n1. It is always recommended to check the relevant issue trackers to see if there are known issues with already existing solutions. Depending on upstreams' choices, there is usually an issue tracker and sometimes also a forum or even e.g. an IRC channel. There is the Arch Linux bug tracker, which should be primarily used for packaging bugs.\n\n1. Increase the verbosity (usually --verbose/-v/-V or --debug/-d) if there is still not enough information to debug.\n1. Sometimes there is no such parameter and it needs to be specified as a directive in the applications' configuration file.\n1. An application may also use log files, which are usually located in /var/log, $HOME/.cache or $HOME/.local\n1. If there is no way to increase the verbosity, it is always possible to run strace and similar.\n\n1. dmesg reads from the kernel ring buffer. This is useful if the disk is for some reason inaccessible but this may also result in incomplete logs because the kernel ring buffer is not infinite in size. Use journalctl if possible.\n1. journalctl has more filtering options than dmesg and uses human-readable timestamps by default.\n\n1. Depending on upstreams' choices, there is usually an issue tracker and sometimes also a forum or even e.g. an IRC channel.\n1. There is the Arch Linux bug tracker, which should be primarily used for packaging bugs.\n\n"
    },
    {
      "title": "Additional support",
      "level": 3,
      "content": "If you require any additional support, you may ask on the forums or on IRC.\n\nWhen asking for support post the complete output/logs, not just what you think are the significant sections. Sources of information include:\n\n- Full output of any command involved - do not just select what you think is relevant.\n- systemd's journal. For more extensive output, use the systemd.log_level=debug boot parameter. This will produce a tremendous amount of output, so only enable it if it is really needed. Do not use the -x parameter because this needlessly clutters the output and makes it harder to read. Use -b unless you need logs from a previous boot. Not specifying this may lead to extremely large pastes that may even be too big for any pastebins.\n- Relevant configuration files\n- Drivers involved\n- Versions of packages involved\n- Kernel: journalctl -k or dmesg (both with root privileges).\n- Xorg: depending on the setup the display manager in use is relevant here, too. Xorg.log may be located in one of several places: the system journal, /var/log/ or $HOME/.local/share/xorg/. Some display managers like LightDM may also place the Xorg.log in its own log directory.\n- Pacman: If a recent upgrade broke something, look in /var/log/pacman.log. It may be useful to use pacman's --debug parameter.\n\n- For more extensive output, use the systemd.log_level=debug boot parameter. This will produce a tremendous amount of output, so only enable it if it is really needed.\n- Do not use the -x parameter because this needlessly clutters the output and makes it harder to read.\n- Use -b unless you need logs from a previous boot. Not specifying this may lead to extremely large pastes that may even be too big for any pastebins.\n\n- Xorg.log may be located in one of several places: the system journal, /var/log/ or $HOME/.local/share/xorg/.\n- Some display managers like LightDM may also place the Xorg.log in its own log directory.\n\n- It may be useful to use pacman's --debug parameter.\n\nOne of the better ways to post this information is to use a pastebin.\n\nA link will then be output that you can paste to the forum or IRC.\n\nAdditionally, you may wish to review how to properly report issues before asking.\n\n"
    },
    {
      "title": "Boot problems",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nWhen diagnosing boot problems, it is very important to know in which stage the boot fails.\n\n1. Firmware (UEFI or BIOS) Usually only has very basic tools for debugging. Make sure Secure Boot is disabled.\n1. Boot loader One of the most common things done here is the changing of kernel parameters. Common boot issue during the boot loader stage could be caused by ACPI.\n1. initramfs Usually provides an emergency shell. Depending on the hooks chosen, either the dmesg or the journal is available within it.\n1. The actual system Depending on how badly it is broken, a simple invocation of the debug shell may suffice here.\n\n1. Usually only has very basic tools for debugging.\n1. Make sure Secure Boot is disabled.\n\n1. One of the most common things done here is the changing of kernel parameters.\n1. Common boot issue during the boot loader stage could be caused by ACPI.\n\n1. Usually provides an emergency shell.\n1. Depending on the hooks chosen, either the dmesg or the journal is available within it.\n\n1. Depending on how badly it is broken, a simple invocation of the debug shell may suffice here.\n\nIf the debugging tools provided by any stage are not enough to fix the broken component, try using a e.g. USB stick with the latest Arch Linux ISO on it.\n\n"
    },
    {
      "title": "Console messages",
      "level": 3,
      "content": "After the boot process, the screen is cleared and the login prompt appears, leaving users unable to read init output and error messages. This default behavior may be modified using methods outlined in the sections below.\n\nNote that regardless of the chosen option, kernel messages can be displayed for inspection after booting by using journalctl -k or dmesg. To display all logs from the current boot use journalctl -b.\n\n"
    },
    {
      "title": "Flow control",
      "level": 4,
      "content": "This is basic management that applies to most terminal emulators, including virtual consoles (VC):\n\n- Press Ctrl+s to pause the output.\n- And Ctrl+q to resume it.\n\nThis pauses not only the output, but also programs which try to print to the terminal, as they will block on the write() calls for as long as the output is paused. If your init appears frozen, make sure the system console is not paused.\n\nTo see error messages which are already displayed, see Getty#Have boot messages stay on tty1.\n\n"
    },
    {
      "title": "Printing more kernel messages",
      "level": 4,
      "content": "Most kernel messages are hidden during boot. You can see more of these messages by adding different kernel parameters. The simplest ones are:\n\n- debug, which has the following effects: The kernel will raise its console logging level such that all messages in the kernel log buffer will be printed to the console. [1] systemd will raise its log level such that it will log debug messages that otherwise would not be produced anywhere. [2]\n- ignore_loglevel, which has the same effect on the kernel as debug or loglevel=8 (since debug messages are at 7), but prevents the log level from being raised later in the boot.\n\n- The kernel will raise its console logging level such that all messages in the kernel log buffer will be printed to the console. [1]\n- systemd will raise its log level such that it will log debug messages that otherwise would not be produced anywhere. [2]\n\nOther parameters you can add that might be useful in certain situations are:\n\n- earlyprintk=vga,keep prints kernel messages very early in the boot process, in case the kernel would crash before output is shown. You must change vga to efi for EFI systems.\n- log_buf_len=16M allocates a larger (16 MiB) kernel message buffer, to ensure that debug output is not overwritten.\n\n"
    },
    {
      "title": "Producing debug kernel messages",
      "level": 4,
      "content": "#Printing more kernel messages indicates how to print of the kernel log buffer to the console, but that buffer itself won't contain any messages it didn't already (aside from the debug systemd output). This heading discusses methods for getting more detailed information out of the kernel log.\n\nMessages printed with pr_debug or related functions such as dev_dbg(), drm_dbg(), and bt_dev_dbg() will not be produced unless you either:\n\n- Modify the kernel source to define DEBUG where desired.\n- Utilize the kernel's dynamic debug feature to enable debugging messages.\n\nThis section will discuss how to use dynamic debug, which is useful if you have already looked at your kernel log with everything up to informational logs, and would like even more debugging information from a particular location.\n\nFirstly, you must be running a kernel that was compiled with the CONFIG_DYNAMIC_DEBUG kernel configuration option set. This is already the case for linux, so no action is required if you are using that kernel.\n\nThen, you need to know where you want to see debug messages from. A couple of options are:\n\n- Going with the kernel module name, if the issue seems to be isolated to a module. For example, to troubleshoot Intel graphics, you might concern yourself with the i915 DRM kernel module.\n- Going with a directory in the kernel that corresponds with functionality you are interested in. You will want to check out (or navigate online) the kernel source code to understand the structure. As an example, to inspect debug messages for all DRM kernel modules, you could go with the path drivers/gpu/drm.\n\nUsing that \"source\" of messages, you have to come up with a dynamic debug query that indicates which debug messages to enable, of the format:\n\n```\nmatch_type match_parameter flags\n```\n\nWhere:\n\n- match_type is the type of match to make. Corresponding to the two options given earlier, this could be module or file.\n- match_parameter is the module or file path to watch. In the latter case, using asterisks for wildcards is permissible.\n- flags dictates what to do with the match. This could be +p to start printing its messages, or -p to undo that.\n\nSome examples of queries are:\n\n- module i915 +p to print debug messages from the i915 kernel module.\n- file drivers/gpu/drm/* +p to print debug messages from DRM drivers.\n- file * +p to print debug messages.\n\nFinally, to actually enact the query, you can either:\n\n- Do so during runtime, by running:\n\n```\n# echo \"query\" > /sys/kernel/debug/dynamic_debug/control\n```\n\n- Do so at boot, by adding the dyndbg=\"query\" kernel parameter\n\nThis is a greatly simplified overview of dynamic debug's capabilities; see the documentation for further details.\n\nThere are also a number of separate debug parameters for enabling debugging in specific subsystems e.g. bootmem_debug, sched_debug. Also, initcall_debug can be useful to investigate boot freezes. (Look for calls that did not return.) Check the kernel parameter documentation for specific information.\n\n"
    },
    {
      "title": "netconsole",
      "level": 4,
      "content": "netconsole is a kernel module that sends all kernel log messages (i.e. dmesg) over the network to another computer, without involving user space (e.g. syslogd). Name \"netconsole\" is a misnomer because it is not really a \"console\", more like a remote logging service.\n\nIt can be used either built-in or as a module. Built-in netconsole initializes immediately after NIC cards and will bring up the specified interface as soon as possible. The module is mainly used for capturing kernel panic output from a headless machine, or in other situations where the user space is no more functional.\n\n"
    },
    {
      "title": "Recovery shells",
      "level": 3,
      "content": "Getting an interactive shell at some stage in the boot process can help you pinpoint exactly where and why something is failing. There are several kernel parameters for doing so, but they all launch a normal shell which you can exit to let the kernel resume what it was doing:\n\n- rescue launches a shell shortly after the root file system is remounted read/write\n- emergency launches a shell even earlier, before most file systems are mounted\n- init=/bin/sh (as a last resort) changes the init program to a root shell. rescue and emergency both rely on systemd, but this should work even if systemd is broken.\n\nAnother option is systemd's debug-shell which adds a root shell on tty9 (accessible with Ctrl+Alt+F9). It can be enabled by either adding systemd.debug_shell to the kernel parameters, or by enabling debug-shell.service.\n\n"
    },
    {
      "title": "Debugging kernel modules",
      "level": 3,
      "content": "See Kernel modules#Obtaining information.\n\n"
    },
    {
      "title": "Debugging hardware",
      "level": 3,
      "content": "- You can display extra debugging information about your hardware by following udev#Debug output.\n- Ensure that Microcode updates are applied on your system.\n- To test the RAM, see Stress testing#MemTest86+.\n- To see if your system is overheating, use lm_sensors.\n- To check your storage health, see S.M.A.R.T.\n\n"
    },
    {
      "title": "Debugging freezes",
      "level": 2,
      "content": "Unfortunately, freezes are usually hard to debug and some of them take a lot of time to reproduce. There are some types of freezes which are easier to debug than others:\n\n- Is sound still playing? If so, just the display may be frozen. This may be a problem with the video driver.\n- Is the machine still responding? Try SSH if switching to another TTY does not work.\n- Is the disk activity LED (if present) indicating that a lot is being written to disk? Heavy swapping may temporarily freeze the system. See this StackExchange answer for information about freezes on large writes.\n\nIf nothing else helps, try a clean shutdown. Pressing the power button once may unfreeze the system and show the classic \"shutdown screen\" which displays all the units that are getting stopped. Alternatively, using the magic SysRq keys may also help to achieve a clean shutdown. This is very important because the journal may contain hints why the machine froze. The journal may not be written to disk on an unclean shutdown. Hard freezes in which the whole machine is unresponsible are harder to debug since logs can not be written to disk in time.\n\nRemote logging may help if the freeze does not permit writing anything to disk. A crude remote logging solution, which needs to be invoked from another device, can be used for basic debugging:\n\n```\n$ ssh freezing_host journalctl -f\n```\n\nMany fatal freezes in which the whole system does not respond anymore and require a forced shutdown may be related to buggy firmware, drivers or hardware. Trying a different kernel (see Kernel#Debugging regressions) or even a different Linux distribution or operating system, updating the firmware and running hardware diagnostics may help finding the problem.\n\nIf a freeze does not permit gathering any kind of logs or other information required for debugging, try reproducing the freeze in a live environment. If a graphical environment is required to reproduce the freeze or if the freeze can be reproduced on the archiso, use the live environment of a different distribution, which is preferably not based on Arch Linux to eliminate the possibility that the freeze is related to the version or patches of the kernel. Should the freeze still happen in a live environment, chances are that it may be hardware-related. If it does not happen anymore, it is necessary to be aware of the differences of both systems. Different configurations, differences in versions and kernel parameters and other, similar changes may have fixed the freeze.\n\nHowever, a blinking caps lock LED may indicate a kernel panic. Some setups may not show the TTY when a kernel panic occurred, which may be confusing and can be interpreted as another kind of freeze.\n\n"
    },
    {
      "title": "Debugging regressions",
      "level": 2,
      "content": "If an update causes an issue but downgrading the specific package fixes it, it is likely a regression. If this happened after a normal full system upgrade, check your pacman.log to determine which package(s) may have caused the issue. The most important part of debugging regressions is checking if the issue was already fixed, as this can save much time. To do so, first ensure the application is fully updated (e.g. ensure the application is the same version as in the official repositories). If it already is or if updating it does not fix the issue, try using the actual latest version, usually a -git version, which may already be packaged in the AUR. If this fixes the issue and the version with the fixes is not yet in the official repositories, wait until the new version arrives in them and then switch back to it.\n\nIf the issue still persists, debug the issue and/or bisect the application and report the bug on the upstream bug tracker so it can be fixed.\n\n"
    },
    {
      "title": "Cannot use some peripherals after kernel upgrade",
      "level": 2,
      "content": "This will manifest commonly (but probably not only) as:\n\n- newly plugged USB devices showing up with dmesg but not in /dev/,\n- file systems unable to be mounted if they were not already used before the kernel update,\n- the inability to use a wired/wireless connection on a laptop if it was not already used before the kernel update,\n- FATAL: Module module not found in directory /lib/module/kernelversion when using modprobe to load a module that was not already used before the kernel package update.\n\nAs partially covered in System maintenance#Restart or reboot after upgrades, the kernel is not updated when you update the package but only once you reboot afterwards. Meanwhile, the kernel modules, located in /usr/lib/modules/kernelversion/ are removed by pacman when installing the new kernel. As explained in FS#16702, this approach avoids leaving files on the system not handled by the package manager but leads to the aforementioned symptoms. To fix them, reboot systematically after updating the kernel. The long-term evolution, yet to be implemented, will be to use versioned kernel packages : the main blocker being how to handle the removal of the previous kernel versions once they are not needed anymore.\n\nAnother solution is available as kernel-modules-hook, where two pacman hooks use rsync to keep the kernel modules on the file system after the kernel update and linux-modules-cleanup.service that marks the old modules for removal four weeks after once enabled.\n\n"
    },
    {
      "title": "Package management",
      "level": 2,
      "content": "See Pacman#Troubleshooting for general topics, and pacman/Package signing#Troubleshooting for issues with PGP keys.\n\n"
    },
    {
      "title": "Fixing a broken system",
      "level": 3,
      "content": "If a partial upgrade was performed, try updating your whole system. A reboot may be required.\n\n```\n# pacman -Syu\n```\n\nIf you usually boot into a GUI and that is failing, perhaps you can press Ctrl+Alt+F1 through Ctrl+Alt+F6 and get to a working tty to run pacman through.\n\nIf the system is broken enough that you are unable to run pacman, boot using a monthly Arch ISO from a USB flash drive, an optical disc or a network with PXE. (Do not follow any of the rest of the installation guide.)\n\nMount your root file system:\n\n```\n# mount /dev/rootFileSystemDevice /mnt\n```\n\nMount any other partitions that you created separately, adding the prefix /mnt to all of them, i.e.:\n\n```\n# mount /dev/bootDevice /mnt/boot\n```\n\nTry using your system's pacman while chrooted:\n\n```\n# arch-chroot /mnt\n# pacman -Syu\n```\n\nIf that fails, exit the chroot, and try:\n\n```\n# pacman -Syu --sysroot /mnt\n```\n\nIf that fails, try:\n\n```\n# pacman -Syu --root /mnt --cachedir /mnt/var/cache/pacman/pkg\n```\n\n"
    },
    {
      "title": "fuser",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nfuser is a command-line utility for identifying processes using resources such as files, file systems and TCP/UDP ports.\n\nfuser is provided by the psmisc package, which should be already installed as a dependency of the base meta package. See fuser(1) for details.\n\n"
    },
    {
      "title": "Session permissions",
      "level": 2,
      "content": "First, make sure you have a valid local session within X:\n\n```\n$ loginctl show-session $XDG_SESSION_ID\n```\n\nThis should contain Remote=no and Active=yes in the output. If it does not, make sure that X runs on the same tty where the login occurred. This is required in order to preserve the logind session.\n\nBasic polkit actions do not require further set-up. Some polkit actions require further authentication, even with a local session. A polkit authentication agent needs to be running for this to work. See polkit#Authentication agents for more information on this.\n\n"
    },
    {
      "title": "Message: \"error while loading shared libraries\"",
      "level": 2,
      "content": "If, while using a program, you get an error similar to:\n\n```\nerror while loading shared libraries: libusb-0.1.so.4: cannot open shared object file: No such file or directory\n```\n\nUse pacman or pkgfile to search for the package that owns the missing library:\n\n```\n$ pacman -F libusb-0.1.so.4\n```\n\n```\nextra/libusb-compat 0.1.5-1\n    usr/lib/libusb-0.1.so.4\n```\n\nIn this case, the libusb-compat package needs to be installed. Alternatively, the program requesting the library may need to be rebuilt following a soname bump.\n\nThe error could also mean that the package that you used to install your program does not list the library as a dependency in its PKGBUILD: if it is an official package, report a bug; if it is an AUR package, report it to the maintainer using its page in the AUR website.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- A how-to in troubleshooting for newcomers\n- List of Tools for UBCD - Memtest-like tools to add to grub.cfg on UltimateBootCD.com\n- Wikipedia:BIOS Boot partition\n- REISUB\n- systemd documentation on Debug Logging to a Serial Console\n- How to Isolate Linux ACPI Issues on Archive.org\n\n"
    }
  ]
}