{
  "title": "QEMU/Advanced networking",
  "url": "https://wiki.archlinux.org/title/QEMU/Advanced_networking",
  "sections": [
    {
      "title": "Creating bridge manually",
      "level": 3,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThe following describes how to bridge a virtual machine to a host interface such as eth0, which is probably the most common configuration. This configuration makes it appear that the virtual machine is located directly on the external network, on the same Ethernet segment as the physical host machine.\n\nWe will replace the normal Ethernet adapter with a bridge adapter and bind the normal Ethernet adapter to it.\n\n- Install bridge-utils, which provides brctl to manipulate bridges.\n\n- Enable IPv4 forwarding:\n\n```\n# sysctl -w net.ipv4.ip_forward=1\n```\n\nTo make the change permanent, change net.ipv4.ip_forward = 0 to net.ipv4.ip_forward = 1 in /etc/sysctl.d/99-sysctl.conf.\n\n- Load the tun module and configure it to be loaded on boot. See Kernel modules for details.\n\n- Optionally create the bridge. See Bridge with netctl for details. Remember to name your bridge as br0, or change the scripts below to your bridge's name. In the run-qemu script below, br0 is set up if not listed, as it is assumed that by default the host is not accessing network via the bridge.\n\n- Create the script that QEMU uses to bring up the tap adapter with root:kvm 750 permissions:\n\n```\n/etc/qemu-ifup\n```\n\n```\n#!/bin/sh\n\necho \"Executing /etc/qemu-ifup\"\necho \"Bringing up $1 for bridged mode...\"\nsudo /usr/bin/ip link set $1 up promisc on\necho \"Adding $1 to br0...\"\nsudo /usr/bin/brctl addif br0 $1\nsleep 2\n```\n\n- Create the script that QEMU uses to bring down the tap adapter in /etc/qemu-ifdown with root:kvm 750 permissions:\n\n```\n/etc/qemu-ifdown\n```\n\n```\n#!/bin/sh\n\necho \"Executing /etc/qemu-ifdown\"\nsudo /usr/bin/ip link set $1 down\nsudo /usr/bin/brctl delif br0 $1\nsudo /usr/bin/ip link delete dev $1\n```\n\n- Use visudo to add the following to your sudoers file:\n\n```\nCmnd_Alias      QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl\n%kvm     ALL=NOPASSWD: QEMU\n```\n\n- You launch QEMU using the following run-qemu script:\n\n```\nrun-qemu\n```\n\n```\n#!/bin/bash\n: '\ne.g. with img created via:\nqemu-img create -f qcow2 example.img 90G\nrun-qemu -cdrom archlinux-x86_64.iso -boot order=d -drive file=example.img,format=qcow2 -m 4G -enable-kvm -cpu host -smp 4\nrun-qemu -drive file=example.img,format=qcow2 -m 4G -enable-kvm -cpu host -smp 4\n'\n\nnicbr0() {\n    sudo ip link set dev $1 promisc on up &> /dev/null\n    sudo ip addr flush dev $1 scope host &>/dev/null\n    sudo ip addr flush dev $1 scope site &>/dev/null\n    sudo ip addr flush dev $1 scope global &>/dev/null\n    sudo ip link set dev $1 master br0 &> /dev/null\n}\n_nicbr0() {\n    sudo ip link set $1 promisc off down &> /dev/null\n    sudo ip link set dev $1 nomaster &> /dev/null\n}\n\nHASBR0=\"$( ip link show | grep br0 )\"\nif [ -z $HASBR0 ] ; then\n    ROUTER=\"192.168.1.1\"\n    SUBNET=\"192.168.1.\"\n    NIC=$(ip link show | grep en | grep 'state UP' | head -n 1 | cut -d\":\" -f 2 | xargs)\n    IPADDR=$(ip addr show | grep -o \"inet $SUBNET\\([0-9]*\\)\" | cut -d ' ' -f2)\n    sudo ip link add name br0 type bridge &> /dev/null\n    sudo ip link set dev br0 up\n    sudo ip addr add $IPADDR/24 brd + dev br0\n    sudo ip route del default &> /dev/null\n    sudo ip route add default via $ROUTER dev br0 onlink\n    nicbr0 $NIC\n    sudo iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT\nfi\n\nUSERID=$(whoami)\nprecreationg=$(ip tuntap list | cut -d: -f1 | sort)\nsudo ip tuntap add user $USERID mode tap\npostcreation=$(ip tuntap list | cut -d: -f1 | sort)\nTAP=$(comm -13 <(echo \"$precreationg\") <(echo \"$postcreation\"))\nnicbr0 $TAP\n\nprintf -v MACADDR \"52:54:%02x:%02x:%02x:%02x\" $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff ))\nqemu-system-x86_64 -net nic,macaddr=$MACADDR,model=virtio \\\n    -net tap,ifname=$TAP,script=no,downscript=no,vhost=on \\\n    $@\n\n_nicbr0 $TAP\nsudo ip link set dev $TAP down &> /dev/null\nsudo ip tuntap del $TAP mode tap\n\nif [ -z $HASBR0 ] ; then\n    _nicbr0 $NIC\n    sudo ip addr del dev br0 $IPADDR/24 &> /dev/null\n    sudo ip link set dev br0 down\n    sudo ip link delete br0 type bridge &> /dev/null\n    sudo ip route del default &> /dev/null\n    sudo ip link set dev $NIC up\n    sudo ip route add default via $ROUTER dev $NIC onlink &> /dev/null\nfi\n```\n\nThen to launch a virtual machine, do something like this\n\n```\n$ run-qemu -hda myvm.img -m 512\n```\n\n- It is recommended for performance and security reasons to disable the firewall on the bridge:\n\n```\n/etc/sysctl.d/10-disable-firewall-on-bridge.conf\n```\n\n```\nnet.bridge.bridge-nf-call-ip6tables = 0\nnet.bridge.bridge-nf-call-iptables = 0\nnet.bridge.bridge-nf-call-arptables = 0\n```\n\nIn order to apply the parameters described above on boot, you will also need to load the br-netfilter module on boot. Otherwise, the parameters will not exist when sysctl will try to modify them.\n\n```\n/etc/modules-load.d/br_netfilter.conf\n```\n\n```\nbr_netfilter\n```\n\nRun sysctl -p /etc/sysctl.d/10-disable-firewall-on-bridge.conf to apply the changes immediately.\n\nSee the libvirt wiki and Fedora bug 512206. If you get errors by sysctl during boot about non-existing files, make the bridge module load at boot. See Kernel module#systemd.\n\nAlternatively, you can configure iptables to allow all traffic to be forwarded across the bridge by adding a rule like this:\n\n```\n-I FORWARD -m physdev --physdev-is-bridged -j ACCEPT\n```\n\n"
    },
    {
      "title": "Network sharing between physical device and a Tap device through iptables",
      "level": 3,
      "content": "Note: **This article or section is a candidate for merging with Internet_sharing.** This article or section is a candidate for merging with Internet_sharing.\n\nThis article or section is a candidate for merging with Internet_sharing.\n\nBridged networking works fine between a wired interface (Eg. eth0), and it is easy to setup. However if the host gets connected to the network through a wireless device, then bridging is not possible.\n\nSee Network bridge#Wireless interface on a bridge as a reference.\n\nOne way to overcome that is to setup a tap device with a static IP, making linux automatically handle the routing for it, and then forward traffic between the tap interface and the device connected to the network through iptables rules.\n\nSee Internet sharing as a reference.\n\nThere you can find what is needed to share the network between devices, included tap and tun ones. The following just hints further on some of the host configurations required. As indicated in the reference above, the client needs to be configured for a static IP, using the IP assigned to the tap interface as the gateway. The caveat is that the DNS servers on the client might need to be manually edited if they change when changing from one host device connected to the network to another.\n\nTo allow IP forwarding on every boot, one need to add the following lines to sysctl configuration file inside /etc/sysctl.d:\n\n```\nnet.ipv4.ip_forward = 1\nnet.ipv6.conf.default.forwarding = 1\nnet.ipv6.conf.all.forwarding = 1\n```\n\nThe iptables rules can look like:\n\n```\n# Forwarding from/to outside\niptables -A FORWARD -i ${INT} -o ${EXT_0} -j ACCEPT\niptables -A FORWARD -i ${INT} -o ${EXT_1} -j ACCEPT\niptables -A FORWARD -i ${INT} -o ${EXT_2} -j ACCEPT\niptables -A FORWARD -i ${EXT_0} -o ${INT} -j ACCEPT\niptables -A FORWARD -i ${EXT_1} -o ${INT} -j ACCEPT\niptables -A FORWARD -i ${EXT_2} -o ${INT} -j ACCEPT\n# NAT/Masquerade (network address translation)\niptables -t nat -A POSTROUTING -o ${EXT_0} -j MASQUERADE\niptables -t nat -A POSTROUTING -o ${EXT_1} -j MASQUERADE\niptables -t nat -A POSTROUTING -o ${EXT_2} -j MASQUERADE\n```\n\nThe prior supposes there are 3 devices connected to the network sharing traffic with one internal device, where for example:\n\n```\nINT=tap0\nEXT_0=eth0\nEXT_1=wlan0\nEXT_2=tun0\n```\n\nThe prior shows a forwarding that would allow sharing wired and wireless connections with the tap device.\n\nThe forwarding rules shown are stateless, and for pure forwarding. One could think of restricting specific traffic, putting a firewall in place to protect the guest and others. However those would decrease the networking performance, while a simple bridge does not include any of that.\n\nBonus: Whether the connection is wired or wireless, if one gets connected through VPN to a remote site with a tun device, supposing the tun device opened for that connection is tun0, and the prior iptables rules are applied, then the remote connection gets also shared with the guest. This avoids the need for the guest to also open a VPN connection. Again, as the guest networking needs to be static, then if connecting the host remotely this way, one most probably will need to edit the DNS servers on the guest.\n\n"
    },
    {
      "title": "Networking with VDE2",
      "level": 2,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\n"
    },
    {
      "title": "What is VDE?",
      "level": 3,
      "content": "VDE stands for Virtual Distributed Ethernet. It started as an enhancement of uml_switch. It is a toolbox to manage virtual networks.\n\nThe idea is to create virtual switches, which are basically sockets, and to \"plug\" both physical and virtual machines in them. The configuration we show here is quite simple; However, VDE is much more powerful than this, it can plug virtual switches together, run them on different hosts and monitor the traffic in the switches. You are invited to read the documentation of the project.\n\nThe advantage of this method is you do not have to add sudo privileges to your users. Regular users should not be allowed to run modprobe.\n\n"
    },
    {
      "title": "Basics",
      "level": 3,
      "content": "VDE support can be installed via the vde2 package.\n\nIn our config, we use tun/tap to create a virtual interface on my host. Load the tun module (see Kernel modules for details):\n\n```\n# modprobe tun\n```\n\nNow create the virtual switch:\n\n```\n# vde_switch -tap tap0 -daemon -mod 660 -group users\n```\n\nThis line creates the switch, creates tap0, \"plugs\" it, and allows the users of the group users to use it.\n\nThe interface is plugged in but not configured yet. To configure it, run this command:\n\n```\n# ip addr add 192.168.100.254/24 dev tap0\n```\n\nNow, you just have to run KVM with these -net options as a normal user:\n\n```\n$ qemu-system-x86_64 -net nic -net vde -hda [...]\n```\n\nConfigure networking for your guest as you would do in a physical network.\n\n"
    },
    {
      "title": "Startup scripts",
      "level": 3,
      "content": "Example of main script starting VDE:\n\n```\n/etc/systemd/scripts/qemu-network-env\n```\n\n```\n#!/bin/sh\n# QEMU/VDE network environment preparation script\n\n# The IP configuration for the tap device that will be used for\n# the virtual machine network:\n\nTAP_DEV=tap0\nTAP_IP=192.168.100.254\nTAP_MASK=24\nTAP_NETWORK=192.168.100.0\n\n# Host interface\nNIC=eth0\n\ncase \"$1\" in\n  start)\n        echo -n \"Starting VDE network for QEMU: \"\n\n        # If you want tun kernel module to be loaded by script uncomment here\n\t#modprobe tun 2>/dev/null\n\t## Wait for the module to be loaded\n \t#while ! lsmod | grep -q \"^tun\"; do echo \"Waiting for tun device\"; sleep 1; done\n\n        # Start tap switch\n        vde_switch -tap \"$TAP_DEV\" -daemon -mod 660 -group users\n\n        # Bring tap interface up\n        ip address add \"$TAP_IP\"/\"$TAP_MASK\" dev \"$TAP_DEV\"\n        ip link set \"$TAP_DEV\" up\n\n        # Start IP Forwarding\n        echo \"1\" > /proc/sys/net/ipv4/ip_forward\n        iptables -t nat -A POSTROUTING -s \"$TAP_NETWORK\"/\"$TAP_MASK\" -o \"$NIC\" -j MASQUERADE\n        ;;\n  stop)\n        echo -n \"Stopping VDE network for QEMU: \"\n        # Delete the NAT rules\n        iptables -t nat -D POSTROUTING -s \"$TAP_NETWORK\"/\"$TAP_MASK\" -o \"$NIC\" -j MASQUERADE\n\n        # Bring tap interface down\n        ip link set \"$TAP_DEV\" down\n\n        # Kill VDE switch\n        pgrep vde_switch | xargs kill -TERM\n        ;;\n  restart|reload)\n        $0 stop\n        sleep 1\n        $0 start\n        ;;\n  *)\n        echo \"Usage: $0 {start|stop|restart|reload}\"\n        exit 1\nesac\nexit 0\n```\n\nExample of systemd service using the above script:\n\n```\n/etc/systemd/system/qemu-network-env.service\n```\n\n```\n[Unit]\nDescription=Manage VDE Switch\n\n[Service]\nType=oneshot\nExecStart=/etc/systemd/scripts/qemu-network-env start\nExecStop=/etc/systemd/scripts/qemu-network-env stop\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n\nChange permissions for qemu-network-env to be executable.\n\nYou can start qemu-network-env.service as usual.\n\n"
    },
    {
      "title": "Alternative method",
      "level": 3,
      "content": "If the above method does not work or you do not want to mess with kernel configs, TUN, dnsmasq, and iptables you can do the following for the same result.\n\n```\n# vde_switch -daemon -mod 660 -group users\n# slirpvde --dhcp --daemon\n```\n\nThen, to start the virtual machine with a connection to the network of the host:\n\n```\n$ qemu-system-x86_64 -net nic,macaddr=52:54:00:00:EE:03 -net vde disk_image\n```\n\n"
    },
    {
      "title": "VDE2 Bridge",
      "level": 2,
      "content": "Based on quickhowto: qemu networking using vde, tun/tap, and bridge graphic. Any virtual machine connected to vde is externally exposed. For example, each virtual machine can receive DHCP configuration directly from your ADSL router.\n\n"
    },
    {
      "title": "Basics",
      "level": 3,
      "content": "Remember that you need tun module and bridge-utils package.\n\nCreate the vde2/tap device:\n\n```\n# vde_switch -tap tap0 -daemon -mod 660 -group users\n# ip link set tap0 up\n```\n\nCreate bridge:\n\n```\n# brctl addbr br0\n```\n\nAdd devices:\n\n```\n# brctl addif br0 eth0\n# brctl addif br0 tap0\n```\n\nAnd configure bridge interface:\n\n```\n# dhcpcd br0\n```\n\n"
    },
    {
      "title": "Startup scripts",
      "level": 3,
      "content": "All devices must be set up. And only the bridge needs an IP address. For physical devices on the bridge (e.g. eth0), this can be done with netctl using a custom Ethernet profile with:\n\n```\n/etc/netctl/ethernet-noip\n```\n\n```\nDescription='A more versatile static Ethernet connection'\nInterface=eth0\nConnection=ethernet\nIP=no\n```\n\nThe following custom systemd service can be used to create and activate a VDE2 tap interface for users in the users user group.\n\n```\n/etc/systemd/system/vde2@.service\n```\n\n```\n[Unit]\nDescription=Network Connectivity for %i\nWants=network.target\nBefore=network.target\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=/usr/bin/vde_switch -tap %i -daemon -mod 660 -group users\nExecStart=/usr/bin/ip link set dev %i up\nExecStop=/usr/bin/ip addr flush dev %i\nExecStop=/usr/bin/ip link set dev %i down\n\n[Install]\nWantedBy=multi-user.target\n```\n\nAnd finally, you can create the bridge interface with netctl.\n\n"
    }
  ]
}