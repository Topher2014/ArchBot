{
  "title": "Stack (Haskell)",
  "url": "https://wiki.archlinux.org/title/Stack_(Haskell)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Haskell package guidelines\n\nFrom Wikipedia:\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "There are several choices for Haskell installation. One is supported by Arch Linux, while others are officially supported by Haskell for any Linux distribution.\n\nSince version 8.0.2-1, the Arch ghc package and all haskell-* packages in extra provide only dynamically linked libraries.\n\nUsing dynamic linking typically results in faster builds and smaller disk and RAM usage (by sharing pages between multiple running Haskell programs), and will free you from troubleshooting cross-GHC mixing errors. For this reason using pacman and the official repositories is preferred for managing end-user applications. But it has its own disadvantage: all tools you install from source will break on every update of ghc, ghc-libs or haskell-* packages since libraries compiled with GHC do not provide a stable ABI. When running such broken binary, you will see the usual message:\n\nerror while loading shared libraries: libHS...so: cannot open shared object file: No such file or directory\n\nTo fix this, just rebuild and reinstall the broken tool in order to relink it to newer libraries.\n\nOn the other hand, static linking is generally easier to maintain, does not force you to rebuild all tools from source after every update of their dependencies and is currently better supported by the GHC. For these reasons, static linking is the preferred and recommended option for local development. Otherwise, if you want dynamic linking, to link successfully one must configure GHC, Cabal and Stack for this, as the default is to use static linking.\n\n- To install Haskell from Arch official repositories using pacman, continue reading #Native installation. Note that this might install several hundred haskell-* packages into your system.\n- Otherwise, skip to the section #Alternate installations.\n\nIf you wish to use ghc (from the official repositories) with static linking, it is possible, but is more complex to setup, see #Static linking.\n\n"
    },
    {
      "title": "Native installation",
      "level": 2,
      "content": "To use Haskell, install the following packages:\n\n1. ghc — A Haskell compiler. There are several implementations available, but the one used most (which is now de facto the reference) is the GHC (Glasgow Haskell Compiler).\n1. cabal-install or stack — Build tools that rely on GHC to compile Haskell sources. Cabal is the classic build tool focused on dependency resolution and source packages from Hackage (Haskell community's central package archive of open source software). Stack is another build tool focused on curated snapshots and source packages from Stackage (a stable subset of Hackage that provides curated sets (snapshots) of packages known to work well with each other).\n\n"
    },
    {
      "title": "Invoking GHC directly",
      "level": 4,
      "content": "In order to link successfully one must pass the -dynamic flag to GHC. You can try it with the following file:\n\n```\nMain.hs\n```\n\n```\nmain = putStrLn \"Hello, World\"\n```\n\nCompile and run it with:\n\n```\n$ ghc -dynamic Main.hs\n$ ./Main\n```\n\n```\nHello, World\n```\n\n"
    },
    {
      "title": "Configuring Cabal for dynamic linking",
      "level": 4,
      "content": "First, run the following command to download the latest list of packages from Hackage and create global configuration file ~/.cabal/config (or the file $CABAL_CONFIG points to):\n\n```\n$ cabal update\n```\n\nTo configure Cabal for dynamic linking, uncomment and edit the following options in ~/.cabal/config:\n\n```\n~/.cabal/config\n```\n\n```\nlibrary-vanilla: False\nshared: True\nexecutable-dynamic: True\nprogram-default-options\n  ghc-options: -dynamic\n```\n\n- library-vanilla: False suppresses the creation of static libraries (if your project contains a library).\n- shared: True enables the creation of shared libraries (if your project contains a library).\n- executable-dynamic: True causes dynamic linking to be used for executables (if your project contains executables).\n- ghc-options: -dynamic adds the -dynamic flag to every invocation of GHC (e.g. if a package has a non-trivial Setup.hs).\n\n"
    },
    {
      "title": "Configuring Stack for dynamic linking",
      "level": 4,
      "content": "You can use stack setup command to initialize Stack and create global configuration file ~/.stack/config.yaml. By default Stack will automatically download its own version of GHC to an isolated location upon first invocation. To force Stack to use system GHC installation instead, run stack setup with --system-ghc and --resolver flags:\n\n```\n$ stack setup --system-ghc --resolver resolver\n```\n\nNote that you need to specify a resolver which is compatible with your system GHC. Otherwise Stack will happily ignore --system-ghc flag and download its own copy of GHC. You can determine the version of system GHC using ghc --version command:\n\n```\n$ ghc --version\n```\n\n```\nThe Glorious Glasgow Haskell Compilation System, version 8.10.2\n```\n\nThen visit Stackage website and pick a suitable Long Term Support (LTS) or nightly snapshot matching your system GHC version. Use the selected snapshot for --resolver flag on the command line, e.g. --resolver lts-16.15 or --resolver nightly-2020-09-01.\n\nStackage typically lags behind new GHC releases. It may happen that no Stackage snapshot for your system GHC has yet been released. In this case you might want to choose a snapshot for some earlier minor version of GHC or temporarily downgrade your Haskell installation and wait until support for newer GHC releases finally lands on Stackage.\n\nTo configure Stack for dynamic linking, add the following snippet to ~/.stack/config.yaml:\n\n```\n~/.stack/config.yaml\n```\n\n```\n# Stop downloading GHCs into isolated locations under ~/.stack.\ninstall-ghc: false\n\n# Allow Stack to pick the system GHC (false by default).\nsystem-ghc: true\n\n# Allow to use, say, Stackage snapshot for GHC 8.8.2 with system GHC 8.8.3.\ncompiler-check: newer-minor\n\n# Add the -dynamic flag to every invocation of GHC.\nghc-options:\n  \"$everything\": -dynamic\n```\n\n"
    },
    {
      "title": "Package management",
      "level": 2,
      "content": "Most of Haskell libraries and executables are distributed in units of source packages available from Hackage and Stackage. Repositories used by Cabal and Stack respectively.\n\nGHC, the standard compiler for Haskell, generates machine code that can be run natively on Linux. As is common in other compiled languages, a number of popular Haskell packages are available from official Arch repositories in pre-built form.\n\nSome additional packages can be installed from AUR. This packages may need to build from source, building AUR packages or developing software require a compiler and build tools to be installed. Using the #Native installation method is discouraged for this use case, instead see #Alternate installations.\n\nTherefore there are four main sources for Haskell packages: Hackage (Cabal), Stackage (Stack), official repositories and AUR.\n\nThe following table summarizes the advantages and disadvantages of different package management styles.\n\nTable content:\nMethod | Pros | Cons\nOfficial repositories | Easier package management using pacman Already compiled dynamically linked | Not all packages available Makes difficult compiling from source\nCabal | All packages available Root not required Better support for development | Installed in home directory Difficult to remove specific packages\nStack | All packages available (favors Stackage) Root not required Better support for development | Installed in home directory Versions are pinned to snapshot Difficult to remove specific packages\nAUR | Additional packages available | Risk of unmaintained or orphaned packages Incompatible versions of packages possible\n\n- Easier package management using pacman\n- Already compiled dynamically linked\n\n- Not all packages available\n- Makes difficult compiling from source\n\n- All packages available\n- Root not required\n- Better support for development\n\n- Installed in home directory\n- Difficult to remove specific packages\n\n- All packages available (favors Stackage)\n- Root not required\n- Better support for development\n\n- Installed in home directory\n- Versions are pinned to snapshot\n- Difficult to remove specific packages\n\n- Additional packages available\n\n- Risk of unmaintained or orphaned packages\n- Incompatible versions of packages possible\n\n"
    },
    {
      "title": "Cabal",
      "level": 3,
      "content": "- Cabal file format that describes Haskell packages and their dependencies;\n- Cabal library that works with Cabal file format;\n- cabal command-line tool (provided by cabal-install or cabal-install-binAUR packages) that uses Cabal library to build Haskell packages.\n\nCabal is \"the original\" build system for Haskell. Most of libraries and tools you can find on Hackage can be installed via Cabal.\n\n"
    },
    {
      "title": "Installing packages",
      "level": 4,
      "content": "To run user-wide executables installed by Cabal, ~/.cabal/bin must be added to the $PATH environment variable.\n\n```\nPATH=\"$HOME/.cabal/bin:$PATH\"\n```\n\nRun the following command to install a Hackage package and all of its dependencies in a single step:\n\n```\n$ cabal install package\n```\n\nYou can also build and install a Haskell package from source. To do this, run cabal install without specifying any package in the directory with the sources.\n\nEach Cabal package should specify a list of its dependencies and their version constraints in the .cabal file according to the Package Versioning Policy (PVP). During the package installation, Cabal tries to find a set of dependencies that satisfies all the constraints. This process is called dependency resolution.\n\nThere are reasons why Stack exists; Cabal is known to generate a lot of friction with beginners, although it has been getting better in the past years. Most of the time dependency resolution works well but sometimes it fails. In this case you will need to figure out the cause of the problem and give Cabal some hints about how to resolve offending dependencies. For example, sometimes it is necessary to add --allow-newer to allow Cabal to ignore package's PVP-dictated upper bounds on dependency versions, effectively installing package with newer dependencies than the package author has permitted. It gets hairier for less-well maintained packages; for another example, see this thread about installing Idris (another programming language, written in Haskell), where one had to use both --allow-newer and --constraint='haskeline < 0.8.0.0' command-line flags to get a successful compile.\n\n"
    },
    {
      "title": "Removing packages",
      "level": 4,
      "content": "There is no easy way to do it. Cabal does not have support for this functionality but there are external tools like cabal-store-gc.\n\nTo reinstall the entire user-wide Haskell package system, remove ~/.cabal and ~/.ghc and start from scratch. This is often necessary when GHC is upgraded.\n\nFor more precision, it is possible to use ghc-pkg unregister package or ghc-pkg hide package/ghc-pkg expose package directly on the user package database — this makes GHC \"forget\" about an installed package (or pretend it is not there). However neither of these removes any files.\n\n"
    },
    {
      "title": "Stack",
      "level": 3,
      "content": "Stack is another tool to manage Haskell packages. It has slightly different goals than Cabal, with a slightly different philosophy. It uses Cabal library under the hood and integrates with Hackage — but maintains its own repositories of packages (snapshots) on Stackage with the promise that snapshots are curated and include packages which work well together.\n\n"
    },
    {
      "title": "Installing packages",
      "level": 4,
      "content": "In its default configuration, Stack installs compiled executables to ~/.local/bin. Add this directory to the $PATH environment variable in your shell configuration file, for instance ~/.bashrc for bash or ~/.zshrc for zsh:\n\n```\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\nRun the following command to download, build and install a Stackage package:\n\n```\nstack install package\n```\n\nYou can also build and install a Haskell package from source by running the following command from the package directory:\n\n```\nstack install --resolver resolver\n```\n\nNote that you should specify the same resolver as one used for stack setup command.\n\n"
    },
    {
      "title": "Removing packages",
      "level": 4,
      "content": "Stack does not support the \"uninstall\" operation.\n\nIf you want to reinstall the entire user-wide Haskell package system, remove ~/.stack directory and start from scratch. This is often necessary when GHC is upgraded.\n\n"
    },
    {
      "title": "haskell-language-server",
      "level": 4,
      "content": "haskell-language-server is a Language Server Protocol (LSP) implementation for Haskell. It provides IDE-like features such as code completion, \"goto definition\", documentation on hover, linting, formatting or refactoring for any editor integrating with the LSP.\n\nIf you are using dynamically linked Haskell packages from pacman, install haskell-language-server. Otherwise, if you prefer static linking, install haskell-language-server-staticAUR. This package contains statically linked binaries for each supported version of GHC. Alternatively, haskell-language-server can be installed via ghcup or by the Haskell extension for Visual Studio Code.\n\nhaskell-language-server will attempt to automatically determine the build configuration when you open your project. If automatic detection fails, you might want to configure it manually using a hie.yaml file in the project root directory.\n\n"
    },
    {
      "title": "ghcid",
      "level": 4,
      "content": "ghcid is a GHCi-based tool for Haskell development that provides simple and robust way to display compiler errors and warnings on every source code change. It can be installed via ghcidAUR package.\n\n"
    },
    {
      "title": "hoogle",
      "level": 4,
      "content": "hoogle allows you to search the Haskell libraries by either function name, or by approximate type signature. It can be installed via hoogle package.\n\nAn online version of hoogle is available at https://hoogle.haskell.org.\n\n"
    },
    {
      "title": "hlint",
      "level": 4,
      "content": "hlint suggests possible improvements to Haskell code such as using alternative functions, simplifying code and spotting redundancies. It is available through hlint package.\n\n"
    },
    {
      "title": "stan",
      "level": 4,
      "content": "stan is a Haskell static analyzer, complementary to hlint. It is in the beta phase as of June 2021.\n\n"
    },
    {
      "title": "weeder",
      "level": 4,
      "content": "weeder is an application to perform whole-program dead-code analysis.\n\n"
    },
    {
      "title": "Formatters",
      "level": 3,
      "content": "- Floskell — Fork of hindent focusing on flexibility and configurability.\n\n- Fourmolu — Fork of Ormolu that adds an ability to configure various formatting parameters.\n\n- hindent — Extensible Haskell pretty printer.\n\n- Ormolu — Formatter for Haskell source code, implementing one \"true\" formatting style which admits no configuration.\n\n- stylish-haskell — Simple Haskell code prettifier.\n\n"
    },
    {
      "title": "Visual Studio Code",
      "level": 4,
      "content": "Visual Studio Code has a Haskell extension powered by haskell-language-server. If you do not have haskell-language-server installed, the Haskell extension will automatically download and install statically linked Linux binaries for you.\n\n"
    },
    {
      "title": "IntelliJ IDEA",
      "level": 4,
      "content": "IntelliJ IDEA support for Haskell is provided by the Haskell plugin[dead link 2024-12-15 ⓘ]. It works with any edition of IntelliJ IDEA including intellij-idea-community-edition.\n\nYou will need to install Stack in order to create a new project or import an existing one into IntelliJ IDEA. As of June 2021 Cabal-only projects are not supported.\n\n"
    },
    {
      "title": "Vim",
      "level": 4,
      "content": "Basic syntax highlighting and indentation for Vim can be obtained via the haskell-vim plugin. For better IDE-like experience use one of LSP client plugins (e.g. coc.nvim, ALE, LanguageClient-neovim) together with haskell-language-server.\n\n"
    },
    {
      "title": "Emacs",
      "level": 4,
      "content": "Basic Emacs support for Haskell is provided by the official haskell-mode. For more advanced features, also use lsp-haskell with haskell-language-server.\n\n"
    },
    {
      "title": "Alternate installations",
      "level": 2,
      "content": "The methods described in this sections are best suited for Haskell development setups. It is possible to use them along packages from the official repositories, if this is the case, make sure you know which version of the Haskell package you are using, if the one installed by pacman or by one of the following methods.\n\n"
    },
    {
      "title": "ghcup",
      "level": 3,
      "content": "This is the recommended method for installing Haskell in any Linux distribution. GHCup installs GHC, tools and libraries in your home directory and allows to have multiple versions in parallel and handle them with relative ease. It is similar in scope to rustup, pyenv and jenv.\n\nInstall ghcup-hs-binAUR package. Alternatively, you may follow official installation instructions or manually download ghcup binary and place it somewhere into your $PATH.\n\nBy default, ghcup will install executables into ~/.ghcup/bin. You need to add this directory to the $PATH environment variable in your shell configuration file, for instance ~/.bashrc for bash or ~/.zshrc for zsh. If you want to run executables installed by Cabal, add ~/.cabal/bin to $PATH as well:\n\n```\nexport PATH=\"$HOME/.cabal/bin:$HOME/.ghcup/bin:$PATH\"\n```\n\nGHCup provides a convenient TUI which supports most of its functionality:\n\n```\n$ ghcup tui\n```\n\nAlternatively, you can use the following CLI commands:\n\nList available versions of GHC and Cabal:\n\n```\n$ ghcup list\n```\n\nInstall the recommended version of GHC:\n\n```\n$ ghcup install ghc\n```\n\nYou can also install a specific version of GHC, for example:\n\n```\n$ ghcup install ghc 8.10.2\n```\n\nThe commands above do not automatically make GHC available on the $PATH. You need to select which GHC version to use by default:\n\n```\n$ ghcup set ghc 8.10.2\n```\n\nInstall the recommended version of Cabal:\n\n```\n$ ghcup install cabal\n```\n\nGHCup can install haskell-language-server too, use the following command:\n\n```\n$ ghcup install hls\n```\n\nFor more information, refer to official ghcup and Cabal documentation.\n\n"
    },
    {
      "title": "Using along native installation",
      "level": 4,
      "content": "In case you decide to use GHCup and Cabal along the native installation you need to specify Cabal which GHC to use specifying the path of the GHC version to use in $HOME/.config/cabal/config, search for the line with-compiler: and uncomment it:\n\n```\nwith-compiler: path_of_your_ghc\n```\n\nRemember that the path of your GHC in case of using GHCup is going to be under $HOME/.ghcup/bin. Also GHCup, once you set the GHC version you wish, will link that version to $HOME/.ghcup/bin/ghc. If you set that path in the Cabal configuration, you can change which version of GHC Cabal uses using GHCup.\n\n"
    },
    {
      "title": "Stack",
      "level": 3,
      "content": "You can install Stack using the stack-staticAUR package or using GHCup (see #ghcup). Alternatively, you may follow official installation instructions or manually download Stack binary and place it somewhere into your $PATH.\n\nIf you want to run executables installed by Stack, add ~/.local/bin directory to the $PATH, see Environment variables for more information on how to do this.\n\nStack will use an isolated version of GHC, so it does not require any additional configuration. Run stack setup to automatically install GHC from the latest Stackage LTS snapshot:\n\n```\n$ stack setup\n```\n\nYou can now use Stack to build and install statically linked Haskell packages without any special configuration or command line flags:\n\n```\n$ stack install package\n```\n\nFor more information, refer to official Stack documentation.\n\n"
    },
    {
      "title": "Nix",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nA completely different way of installing Haskell is Nix package manager. Nix has a steeper learning curve but offers greater flexibility in managing both Haskell and non-Haskell packages in a reliable and reproducible fashion.\n\n"
    },
    {
      "title": "Static linking",
      "level": 3,
      "content": "- This section explains how to build statically linked Haskell packages on Arch, but still use GHC installed from the official repositories. Before you proceed, make sure to remove ~/.cabal and ~/.stack directories if they exist.\n- In the context of this article, static linking does not mean generating completely static ELF binaries. Only Haskell code will be linked statically into a single ELF binary, which may be dynamically linked to other system libraries such as glibc.\n\nTo use static linking, one must, at minimum, install the static boot libraries through the ghc-static package. This would allow you to build projects that depend exclusively on the boot libraries as well as on any other libraries that are not installed through the haskell-* packages from the official repositories.\n\nUnfortunately, if your project depends on any of dynamically linked haskell-* packages that you have installed, Cabal does not take the absence of static libraries into account during dependency resolution. As a result, it will try to use the existing haskell-* package and then fail with linker errors when it discovers the static libraries are missing:\n\n```\nCould not find module ‘SomePackage.SomeModule’\nThere are files missing in the ‘somepackage-0.1.0.0’ package,\ntry running 'ghc-pkg check'.\nUse -v (or `:set -v` in ghci) to see a list of the files searched for.\n```\n\nUnlike ghc-static, there are no \"haskell-*-static\" packages available for linkage. There are other ways to work around this issue though, as described in each of the sections below.\n\n"
    },
    {
      "title": "Static global package database",
      "level": 4,
      "content": "A direct approach is offered by the official ghc-static package, which exposes an alternative \"static\" global package database at /usr/lib/ghc-version/static-package.conf.d. The static database is limited to only the statically linkable boot packages, therefore if Cabal is reconfigured to use the static database instead of the default database, it would behave as though the dynamic-only haskell-* packages do not exist.\n\nThe precise path of the static database could be determined at build time using a command such as:\n\n```\n$ ghc --print-global-package-db | sed 's/\\(package\\.conf\\.d\\)$/static-\\1/'\n```\n\n```\n/usr/lib/ghc-version/static-package.conf.d\n```\n\nHere is how to enable the static database for use:\n\n- When building packages with Cabal, one can pass the following flag to limit the selection of global packages to only the boot packages:\n\n```\n$ cabal configure --ghc-pkg-option=\"--global-package-db=$(ghc --print-global-package-db | sed 's/\\(package\\.conf\\.d\\)$/static-\\1/')\"\n```\n\n- When building directly using GHC rather than Cabal, one can pass the following flags to override the global package database:\n\n```\n$ ghc -clear-package-db -package-db \"$(ghc --print-global-package-db | sed 's/\\(package\\.conf\\.d\\)$/static-\\1/')\" -user-package-db ...\n```\n\n"
    },
    {
      "title": "ghc-pristine",
      "level": 4,
      "content": "Install ghc-pristineAUR package, which wraps over an existing GHC installation to create a separate GHC distribution in /usr/share/ghc-pristine, with a package database that contains only boot libraries. This effectively creates a semi-isolated environment without dynamically linked haskell-* packages, but still makes use of the GHC compiler from the official repositories. Then, to build software with static linking, one simply needs to invoke the wrapped compiler /usr/share/ghc-pristine/bin/ghc. For Cabal, this amounts to the following configuration in ~/.cabal/config:\n\n```\n~/.cabal/config\n```\n\n```\nwith-compiler: /usr/share/ghc-pristine/bin/ghc\n```\n\nYou can also specify the path to the compiler on a per-project basis by running the following command from the project directory:\n\n```\n$ cabal configure --with-compiler=/usr/share/ghc-pristine/bin/ghc\n```\n\n"
    },
    {
      "title": "cabal-static",
      "level": 4,
      "content": "Another way to gain back static linking on Arch is to install cabal-install-binAUR package. Unlike the official cabal-install, this one does not pull dynamically linked haskell-* dependencies from the official repositories and avoids mixing static and shared Haskell libraries installed on the same system. Then you can use Cabal as usual with the following limitation: you have to make sure that the only other Haskell packages you have installed are ghc, ghc-libs and ghc-static (not cabal-install, stack and none of the haskell-* packages available in the official repositories).\n\n"
    },
    {
      "title": "stack-static",
      "level": 4,
      "content": "Install stack-staticAUR package. Similarly to cabal-static method, make sure that the only other Haskell packages you have installed from the official repositories are ghc, ghc-libs and ghc-static. Then setup Stack to use system GHC as explained in #Configuring Stack for dynamic linking:\n\n```\n$ stack setup --system-ghc --resolver resolver\n```\n\nTo make these options permanent, paste the following snippet to ~/.stack/config.yaml:\n\n```\n~/.stack/config.yaml\n```\n\n```\n# Stop downloading GHCs into isolated locations under ~/.stack.\ninstall-ghc: false\n\n# Allow Stack to pick the system GHC (false by default).\nsystem-ghc: true\n\n# Allow to use, say, Stackage snapshot for GHC 8.8.2 with system GHC 8.8.3.\ncompiler-check: newer-minor\n```\n\nThis configuration will allow you to build statically linked packages as you would normally do, but using system GHC installation instead of GHC provided by Stack.\n\n"
    },
    {
      "title": "hpack-static-bin",
      "level": 4,
      "content": "hpack-static-binAUR provides a statically linked (meaning no haskell-* dependencies) alternative to haskell-hpack. It is precompiled, so no make dependencies are needed.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Official website of the Haskell programming language\n- Haskell documentation\n- Haskell Wiki\n- GHC User Guide\n- Cabal User Guide\n- Stack User Guide\n- Haskell community's central package archive\n- Stable source of Haskell packages\n- Haskell API search engine\n- Learn You a Haskell for Great Good!\n- Real World Haskell\n- Haskell Wikibook\n- What I Wish I Knew When Learning Haskell\n- Awesome Haskell: an auxiliary list of awesome Haskell links, frameworks, libraries and software\n\n"
    }
  ]
}