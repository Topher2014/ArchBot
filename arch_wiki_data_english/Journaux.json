{
  "title": "Journaux",
  "url": "https://wiki.archlinux.org/title/Journaux",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "systemd possède son propre système de journalisation appelé journal ; il n'est pas nécessaire d'exécuter un daemon de journalisation séparé. Pour lire le journal, utilisez journalctl(1).\n\nSous Arch Linux, le répertoire /var/log/journal/ fait partie du paquet systemd, et le journal (lorsque Storage= est défini sur auto dans /etc/systemd/journald.conf) écrira dans /var/log/journal/. Si ce répertoire est supprimé, systemd ne le recréera pas automatiquement et écrira ses journaux dans /run/systemd/journal de manière non persistante. Cependant, le répertoire sera recréé si Storage=persistent est ajouté à journald.conf et systemd-journald.service est redémarré (ou si le système est redémarré).\n\nLe journal de systemd classe les messages par Niveau de priorité et Fonctionnalité. La classification des journaux correspond au protocole classique Syslog (RFC 5424).\n\n"
    },
    {
      "title": "Niveau de priorité",
      "level": 2,
      "content": "Un code de gravité syslog (appelé priorité dans systemd) est utilisé pour marquer l'importance d'un message RFC 5424 6.2.1.\n\nTable content:\nValeur | Gravité | Mot-Clef | Description | Exemples\n0 | Urgente | emerg | Système inutilisable | BUG sévère du noyau, systemd a reçu un «core dump».Ce niveau ne doit pas être utilisé par les applications.\n1 | Alerte | alert | Doit être corrigé immédiatement | Un sous-système vital ne fonctionne plus. Perte de données. kernel: BUG: unable to handle kernel paging request at ffffc90403238ffc\n2 | Critique | crit | Situations critiques | Crashs, coredumps. Un exemple habituel était Adobe Flash :systemd-coredump[25319]: Process 25310 (plugin-containe) of user 1000 dumped coreDéfaillance de l'application principale du système, comme X11.\n3 | Erreur | err | Situations d'erreurs | Erreur non grave signalée:kernel: usb 1-3: 3:1: cannot get freq at ep 0x84systemd[1]: Failed unmounting /var.libvirtd[1720]: internal error: Failed to initialize a valid firewall backend\n4 | Avertissement | warning | Peut indiquer qu'une erreur se produira si aucune action n'est entreprise. | Un système de fichiers hors racine n'a plus que 1 Go de libre.org.freedesktop. Notifications[1860]: (process:5999): Gtk-WARNING **: Locale not supported by C library. Using the fallback 'C' locale\n5 | Avis | notice | Les événements qui sont inhabituels, mais pas des situations d'erreur. | systemd[1]: var.mount: Directory /var to mount over is not empty, mounting anywaygcr-prompter[4997]: Gtk: GtkDialog mapped without a transient parent. This is discouraged\n6 | Informative | info | Messages durant un fonctionnement normal qui ne nécessitent aucune action. | lvm[585]: 7 logical volume(s) in volume group \"archvg\" now active\n7 | Débogage | debug | Informations utiles aux développeurs pour le débogage de l'application. | kdeinit5[1900] : powerdevil : Programmation de l'inhibition de \":1.14\" \"firefox\" avec le cookie 13 et la raison \"screen\"\n\nCes règles sont des recommandations, et le niveau de priorité d'une erreur donnée est à la discrétion du développeur de l'application. Il est toujours possible que l'erreur soit à un niveau plus élevé ou plus bas que prévu.\n\n"
    },
    {
      "title": "Fonctionnalité",
      "level": 2,
      "content": "Un code de fonctionnalité syslog est utilisé pour spécifier le type de programme qui enregistre le message RFC 5424 6.2.1.\n\nTable content:\nCode de fonctionnalité | Mot-clé | Description | Info\n0 | kern | Messages du noyau\n1 | user | Messages au niveau de l'utilisateur\n2 | mail | Système de messagerie | Archaïque, POSIX, encore pris en charge et parfois utilisé (voir mail(1))\n3 | daemon | Daemon système | Tous les daemons, y compris systemd et ses sous-systèmes\n4 | auth | Messages de sécurité/autorisation | Voir aussi la fonctionnalité n°10\n5 | syslog | Messages générés en interne par syslogd | Pour les implémentations de syslogd (non utilisé par systemd, voir la fonctionnalité n°3)\n6 | lpr | Sous-système d'imprimante de ligne (sous-système archaïque)\n7 | news | Sous-système d'informations réseau (sous-système archaïque)\n8 | uucp | Sous-système UUCP (sous-système archaïque)\n9 |  | Daemon horloge | systemd-timesyncd\n10 | authpriv | Messages de sécurité/autorisation | Voir aussi la fonctionnalité n°4\n11 | ftp | Daemon FTP\n12 | - | Sous-système NTP\n13 | - | Journal des audits\n14 | - | Journal des alertes\n15 | cron | Daemon de planification\n16 | local0 | Utilisation locale 0 (local0)\n17 | local1 | Utilisation locale 1 (local1)\n18 | local2 | Utilisation locale 2 (local2)\n19 | local3 | Utilisation locale 3 (local3)\n20 | local4 | Utilisation locale 4 (local4)\n21 | local5 | Utilisation locale 5 (local5)\n22 | local6 | Utilisation locale 6 (local6)\n23 | local7 | Utilisation locale 7 (local7)\n\nInstallations utiles à surveiller : 0, 1, 3, 4, 9, 10, 15.\n\n"
    },
    {
      "title": "Filtrage de la sortie",
      "level": 2,
      "content": "journalctl permet de filtrer la sortie par des champs spécifiques. S'il y a beaucoup de messages à afficher, ou si le filtrage de grandes périodes de temps doit être fait, la sortie de cette commande peut être largement retardée.\n\nExemples :\n\n- Afficher tous les messages de ce démarrage : # journalctl -b Cependant, il arrive souvent que l'on soit intéressé par des messages provenant non pas du démarrage actuel, mais du démarrage précédent (par exemple, si un crash système irrécupérable s'est produit). Ceci est possible grâce au paramètre optionnel offset de l'indicateur -b : journalctl -b -0 affiche les messages du démarrage actuel, journalctl -b -1 du démarrage précédent, journalctl -b -2 du deuxième démarrage précédent et ainsi de suite - vous pouvez voir la liste des démarrages avec leurs numéros en utilisant journalctl --list-boots. Voir journalctl(1) pour une description complète ; la sémantique est plus puissante que celle indiquée ici.\n- Inclure les explications des messages du journal à partir du catalogue de messages lorsqu'il est disponible : # journalctl -x Notez que cette fonctionnalité ne devrait pas être utilisée lorsque vous joignez des journaux à des rapports de bogues et à des fils de support, afin de limiter les sorties superflues. Vous pouvez lister toutes les entrées de catalogue connues en exécutant journalctl --list-catalog.\n- Afficher tous les messages depuis la date (et éventuellement l'heure) : # journalctl --since=\"2012-10-30 18:17:16\"\n- Afficher tous les messages depuis 20 minutes : # journalctl --since \"20 min ago\"\n- Suivre les nouveaux messages : # journalctl -f\n- Afficher tous les messages par un exécutable spécifique : # journalctl /usr/lib/systemd/systemd\n- Afficher tous les messages d'un processus spécifique : # journalctl _PID=1\n- Afficher tous les messages d'une unité spécifique : # journalctl -u man-db.service\n- Afficher tous les messages des services utilisateurs par une unité spécifique : $ journalctl --user -u dbus\n- Afficher le tampon du noyau : # journalctl -k\n- Afficher uniquement les messages d'erreur, critiques et d'alerte prioritaires : # journalctl -p err..alert Vous pouvez également utiliser un niveau de journal numérique, comme journalctl -p 3..1. Si un seul nombre/niveau de journal est utilisé, journalctl -p 3, alors tous les niveaux de journaux de priorité supérieure sont également inclus (c'est-à-dire de 0 à 3 dans ce cas).\n- Montrer l'équivalent de auth.log en filtrant sur la facilité syslog : # journalctl SYSLOG_FACILITY=10\n- Si le répertoire journal (situé par défaut sous /var/log/journal) contient une grande quantité de données de journal, journalctl peut prendre plusieurs minutes pour filtrer la sortie. Il peut être accéléré de manière significative en utilisant l'option --file pour forcer journalctl à ne regarder que dans le journal le plus récent : # journalctl --file /var/log/journal/*/system.journal -f\n\n```\n# journalctl -b\n```\n\n```\n# journalctl -x\n```\n\n```\n# journalctl --since=\"2012-10-30 18:17:16\"\n```\n\n```\n# journalctl --since \"20 min ago\"\n```\n\n```\n# journalctl -f\n```\n\n```\n# journalctl /usr/lib/systemd/systemd\n```\n\n```\n# journalctl _PID=1\n```\n\n```\n# journalctl -u man-db.service\n```\n\n```\n$ journalctl --user -u dbus\n```\n\n```\n# journalctl -k\n```\n\n```\n# journalctl -p err..alert\n```\n\n```\n# journalctl SYSLOG_FACILITY=10\n```\n\n```\n# journalctl --file /var/log/journal/*/system.journal -f\n```\n\nVoir journalctl(1), systemd.journal-fields(7), ou l'article du blog de Lennart Poettering pour plus de détails.\n\n- Par défaut, journalctl tronque les lignes plus longues que la largeur de l'écran, mais dans certains cas, il peut être préférable d'activer l'habillage au lieu de tronquer. Ceci peut être contrôlé par la SYSTEMD_LESS [qui contient les options passées à less. (le pager par défaut) et a pour valeur par défaut FRSXMK. (voir less(1) et journalctl(1) pour plus de détails).\n\n```\n$ SYSTEMD_LESS=FRXMK journalctl\n```\n\n- Bien que le journal soit stocké dans un format binaire, le contenu des messages stockés n'est pas modifié. Cela signifie qu'il est consultable avec des strings, par exemple pour la récupération dans un environnement qui n'a pas systemd installé, par exemple : $ strings /mnt/arch/var/log/journal/af4967d77fba44c6b093d0e9862f6ddd/system.journal | grep -i message\n\n```\n$ strings /mnt/arch/var/log/journal/af4967d77fba44c6b093d0e9862f6ddd/system.journal | grep -i message\n```\n\n"
    },
    {
      "title": "Limite de taille du journal",
      "level": 2,
      "content": "Si le journal est persistant (non-volatile), sa taille limite est fixée par défaut à 10 % de la taille du système de fichiers sous-jacent, mais est plafonnée à 4 Go. Par exemple, avec /var/log/journal/ situé sur une partition de 20 Go, les données du journal peuvent occuper jusqu'à 2 Go. Sur une partition de 50 Go, elles seraient limitées à 4 Go. Pour confirmer les limites actuelles sur votre système, examinez les journaux de l'unité systemd-journald :\n\n```\n# journalctl -b -u systemd-journald\n```\n\nLa taille maximale du journal persistant peut être contrôlée en décommentant et en modifiant les éléments suivants :\n\n```\n/etc/systemd/journald.conf\n```\n\n```\nSystemMaxUse=50M\n```\n\nIl est également possible d'utiliser des fichiers de substitution plutôt que de modifier le fichier de configuration global. Dans ce cas, placez les surcharges sous l'en-tête [Journal] :\n\n```\n/etc/systemd/journald.conf.d/00-journal-size.conf\n```\n\n```\n[Journal]\nSystemMaxUse=50M\n```\n\nRedémarrez le systemd-journald.service après avoir modifié ce paramètre pour appliquer la nouvelle limite.\n\nVoir journald.conf(5) pour plus d'informations.\n\n"
    },
    {
      "title": "Limite de taille par unité avec un espace de nom séparé",
      "level": 3,
      "content": "Éditez le fichier d'unité pour le service que vous souhaitez configurer (par exemple sshd) et ajoutez LogNamespace=ssh dans la section [Service].\n\nCréez ensuite /etc/systemd/journald@ssh.conf en copiant /etc/systemd/journald.conf. Après cela, éditez journald@ssh.conf et ajustez SystemMaxUse à votre convenance.\n\n[Le redémarrage du service devrait automatiquement démarrer le nouveau service de journal systemd-journald@ssh.service. Les journaux du service avec son propre espace de nom peuvent être visualisés avec journalctl --namespace ssh.\n\nVoir systemd-journald.service(8) § JOURNAL NAMESPACES pour plus de détails sur les espaces de noms des journaux.\n\n"
    },
    {
      "title": "Nettoyer les fichiers journaux manuellement",
      "level": 2,
      "content": "Les fichiers journaux peuvent être supprimés globalement de /var/log/journal/ à l'aide de rm par exemple, ou peuvent être découpés selon divers critères en utilisant journalctl. Par exemple :\n\n- Supprimez les fichiers journaux archivés jusqu'à ce que l'espace disque qu'ils utilisent tombe en dessous de 100M : # journalctl --vacuum-size=100M\n- Faites en sorte que tous les fichiers journaux ne contiennent aucune donnée datant de plus de 2 semaines. # journalctl --vacuum-time=2weeks\n\n```\n# journalctl --vacuum-size=100M\n```\n\n```\n# journalctl --vacuum-time=2weeks\n```\n\nVoir journalctl(1) pour plus d'informations.\n\n"
    },
    {
      "title": "Journald en conjonction avec syslog",
      "level": 2,
      "content": "La compatibilité avec une implémentation classique, non compatible avec Journald, de syslog peut être assurée en laissant systemd transmettre tous les messages via le socket /run/systemd/journal/syslog. Pour que le daemon syslog fonctionne avec le journal, il doit se lier à cette socket au lieu de /dev/log. (annonce officielle).\n\nLa valeur par défaut de journald.conf pour la redirection vers la socket est ForwardToSyslog=no pour éviter la surcharge du système, car rsyslog ou syslog-ng extraient les messages du journal par eux-même.\n\nVoir Syslog-ng#Overview et Syslog-ng#syslog-ng and systemd journal, ou rsyslog respectivement, pour plus de détails sur la configuration.\n\n"
    },
    {
      "title": "Transférer journald sur /dev/tty12",
      "level": 2,
      "content": "Créez un répertoire de remplacement /etc/systemd/journald.conf.d et créez-y un fichier fw-tty12.conf :\n\n```\n/etc/systemd/journald.conf.d/fw-tty12.conf\n```\n\n```\n[Journal]\nForwardToConsole=yes\nTTYPath=/dev/tty12\nMaxLevelConsole=info\n```\n\nPuis redémarrez systemd-journald.service.\n\n"
    },
    {
      "title": "Spécifier un autre journal à afficher",
      "level": 2,
      "content": "Il peut y avoir un besoin de vérifier les journaux d'un autre système qui est mort dans l'eau, comme démarrer à partir d'un système \"live\" pour récupérer un système de production. Dans ce cas, on peut monter le disque dans par exemple /mnt, et spécifier le chemin du journal via -D/--directory, comme ceci :\n\n```\n# journalctl -D /mnt/var/log/journal -e\n```\n\n"
    },
    {
      "title": "Accès au journal en tant qu'utilisateur",
      "level": 2,
      "content": "Par défaut, un utilisateur normal n'a accès qu'à son propre journal par utilisateur. Pour accorder un accès en lecture au journal du système en tant qu'utilisateur normal, vous pouvez ajouter cet utilisateur au systemd-journal groupe d'utilisateurs. Les membres des groupes adm et wheel ont également un accès en lecture.\n\nVoir journalctl(1) § DESCRIPTION et Users and groups (Français)#Groupes d'utilisateurs pour plus d'informations.\n\n"
    }
  ]
}