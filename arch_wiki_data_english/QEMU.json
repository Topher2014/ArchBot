{
  "title": "QEMU",
  "url": "https://wiki.archlinux.org/title/QEMU",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Category:Hypervisors\n- Libvirt\n- QEMU/Advanced networking\n- QEMU/Guest graphics acceleration\n- QEMU/Troubleshooting\n- PCI passthrough via OVMF\n\nAccording to the QEMU about page:\n\nQEMU can use other hypervisors like Xen or KVM to use CPU extensions (HVM) for virtualization. When used as a virtualizer, QEMU achieves near native performances by executing the guest code directly on the host CPU.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the qemu-full package (or qemu-base for the version without GUI and qemu-desktop for the version with only x86_64 emulation by default) and below optional packages for your needs:\n\n- qemu-block-gluster - Glusterfs block support\n- qemu-block-iscsi - iSCSI block support\n- samba - SMB/CIFS server support\n\nAlternatively, qemu-user-static exists as a usermode and static variant.\n\n"
    },
    {
      "title": "QEMU variants",
      "level": 3,
      "content": "QEMU is offered in several variants suited for different use cases.\n\nAs a first classification, QEMU is offered in full-system and usermode emulation modes:\n\nQEMU is offered in dynamically-linked and statically-linked variants:\n\nIn the case of Arch Linux, full-system emulation is offered as:\n\nNote that headless and non-headless versions install commands with the same name (e.g. qemu-system-x86_64) and thus cannot be both installed at the same time.\n\n"
    },
    {
      "title": "Details on packages available in Arch Linux",
      "level": 3,
      "content": "- The qemu-desktop package provides the x86_64 architecture emulators for full-system emulation (qemu-system-x86_64). The qemu-emulators-full package provides the x86_64 usermode variant (qemu-x86_64) and also for the rest of supported architectures it includes both full-system and usermode variants (e.g. qemu-system-arm and qemu-arm).\n- The headless versions of these packages (only applicable to full-system emulation) are qemu-base (x86_64-only) and qemu-emulators-full (rest of architectures).\n- Full-system emulation can be expanded with some QEMU modules present in separate packages: qemu-block-gluster, qemu-block-iscsi and qemu-guest-agent.\n- qemu-user-static provides a usermode and static variant for all target architectures supported by QEMU. The installed QEMU commands are named qemu-target_architecture-static, for example, qemu-x86_64-static for intel 64-bit CPUs.\n\n"
    },
    {
      "title": "Graphical front-ends for QEMU",
      "level": 2,
      "content": "Unlike other virtualization programs such as VirtualBox and VMware, QEMU does not provide a GUI to manage virtual machines (other than the window that appears when running a virtual machine), nor does it provide a way to create persistent virtual machines with saved settings. All parameters to run a virtual machine must be specified on the command line at every launch, unless you have created a custom script to start your virtual machine(s).\n\nLibvirt provides a convenient way to manage QEMU virtual machines. See list of libvirt clients for available front-ends.\n\n"
    },
    {
      "title": "Creating a hard disk image",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nTo run QEMU you will need a hard disk image, unless you are booting a live system from CD-ROM or the network (and not doing so to install an operating system to a hard disk image). A hard disk image is a file which stores the contents of the emulated hard disk.\n\nA hard disk image can be raw, so that it is literally byte-by-byte the same as what the guest sees, and will always use the full capacity of the guest hard drive on the host. This method provides the least I/O overhead, but can waste a lot of space, as not-used space on the guest cannot be used on the host.\n\nAlternatively, the hard disk image can be in a format such as qcow2 which only allocates space to the image file when the guest operating system actually writes to those sectors on its virtual hard disk. The image appears as the full size to the guest operating system, even though it may take up only a very small amount of space on the host system. This image format also supports QEMU snapshotting functionality (see #Creating and managing snapshots via the monitor console for details). However, using this format instead of raw will likely affect performance.\n\nQEMU provides the qemu-img command to create hard disk images. For example to create a 4 GiB image in the raw format:\n\n```\n$ qemu-img create -f raw image_file 4G\n```\n\nYou may use -f qcow2 to create a qcow2 disk instead.\n\n```\n$ qemu-img create -f qcow2 image_file -o nocow=on 4G\n```\n\n"
    },
    {
      "title": "Overlay storage images",
      "level": 4,
      "content": "You can create a storage image once (the 'backing' image) and have QEMU keep mutations to this image in an overlay image. This allows you to revert to a previous state of this storage image. You could revert by creating a new overlay image at the time you wish to revert, based on the original backing image.\n\nTo create an overlay image, issue a command like:\n\n```\n$ qemu-img create -o backing_file=img1.raw,backing_fmt=raw -f qcow2 img1.cow\n```\n\nAfter that you can run your QEMU virtual machine as usual (see #Running a virtualized system):\n\n```\n$ qemu-system-x86_64 img1.cow\n```\n\nThe backing image will then be left intact and mutations to this storage will be recorded in the overlay image file.\n\nWhen the path to the backing image changes, repair is required.\n\nMake sure that the original backing image's path still leads to this image. If necessary, make a symbolic link at the original path to the new path. Then issue a command like:\n\n```\n$ qemu-img rebase -b /new/img1.raw /new/img1.cow\n```\n\nAt your discretion, you may alternatively perform an 'unsafe' rebase where the old path to the backing image is not checked:\n\n```\n$ qemu-img rebase -u -b /new/img1.raw /new/img1.cow\n```\n\n"
    },
    {
      "title": "Resizing an image",
      "level": 4,
      "content": "The qemu-img executable has the resize option, which enables easy resizing of a hard drive image. It works for both raw and qcow2. For example, to increase image space by 10 GiB, run:\n\n```\n$ qemu-img resize disk_image +10G\n```\n\nAfter enlarging the disk image, you must use file system and partitioning tools inside the virtual machine to actually begin using the new space.\n\nWhen shrinking a disk image, you must first reduce the allocated file systems and partition sizes using the file system and partitioning tools inside the virtual machine and then shrink the disk image accordingly. For a Windows guest, this can be performed from the \"create and format hard disk partitions\" control panel.\n\nThen, to decrease image space by 10 GiB, run:\n\n```\n$ qemu-img resize --shrink disk_image -10G\n```\n\n"
    },
    {
      "title": "Converting an image",
      "level": 4,
      "content": "You can convert an image to other formats using qemu-img convert. This example shows how to convert a raw image to qcow2:\n\n```\n$ qemu-img convert -f raw -O qcow2 input.img output.qcow2\n```\n\nThis will not remove the original input file.\n\n"
    },
    {
      "title": "Preparing the installation media",
      "level": 3,
      "content": "To install an operating system into your disk image, you need the installation medium (e.g. optical disc, USB-drive, or ISO image) for the operating system. The installation medium should not be mounted because QEMU accesses the media directly.\n\n```\n$ dd if=/dev/cdrom of=cd_image.iso bs=4k\n```\n\n"
    },
    {
      "title": "Installing the operating system",
      "level": 3,
      "content": "This is the first time you will need to start the emulator. To install the operating system on the disk image, you must attach both the disk image and the installation media to the virtual machine, and have it boot from the installation media.\n\nFor example on i386 guests, to install from a bootable ISO file as CD-ROM and a raw disk image:\n\n```\n$ qemu-system-x86_64 -cdrom iso_image -boot order=d -drive file=disk_image,format=raw\n```\n\nSee qemu(1) for more information about loading other media types (such as floppy, disk images or physical drives) and #Running a virtualized system for other useful options.\n\nAfter the operating system has finished installing, the QEMU image can be booted directly (see #Running a virtualized system).\n\n- Instead of specifying -boot order=x, some users may feel more comfortable using a boot menu: -boot menu=on, at least during configuration and experimentation.\n- When running QEMU in headless mode, it starts a local VNC server on port 5900 per default. You can use TigerVNC to connect to the guest OS: vncviewer :5900\n- If you need to replace floppies or CDs as part of the installation process, you can use the QEMU machine monitor (press Ctrl+Alt+2 in the virtual machine's window) to remove and attach storage devices to a virtual machine. Type info block to see the block devices, and use the change command to swap out a device. Press Ctrl+Alt+1 to go back to the virtual machine.\n\n"
    },
    {
      "title": "Pre-made virtual machine images",
      "level": 3,
      "content": "In many cases, it's not necessary or desired to manually install your own operating system, for instance in a cloud environment. Luckily, many pre-made images are available for download from different providers.\n\nFor Arch Linux, we have the arch-boxes project with weekly image releases.\n\nThere are similar images available for Fedora and Debian.\n\n"
    },
    {
      "title": "Running a virtualized system",
      "level": 2,
      "content": "qemu-system-* binaries (for example qemu-system-i386 or qemu-system-x86_64, depending on guest's architecture) are used to run the virtualized guest. The usage is:\n\n```\n$ qemu-system-x86_64 options disk_image\n```\n\nOptions are the same for all qemu-system-* binaries, see qemu(1) for documentation of all options.\n\nUsually, if an option has many possible values, you can use\n\n```\n$ qemu-system-x86_64 option help\n```\n\nto list all possible values. If it supports properties, you can use\n\n```\n$ qemu-system-x86_64 option value,help\n```\n\nto list all available properties.\n\nFor example:\n\n```\n$ qemu-system-x86_64 -machine help\n$ qemu-system-x86_64 -machine q35,help\n$ qemu-system-x86_64 -device help\n$ qemu-system-x86_64 -device qxl,help\n```\n\nYou can use these methods and the qemu(1) documentation to understand the options used in follow sections.\n\nBy default, QEMU will show the virtual machine's video output in a window. One thing to keep in mind: when you click inside the QEMU window, the mouse pointer is grabbed. To release it, press Ctrl+Alt+g.\n\n"
    },
    {
      "title": "Enabling KVM",
      "level": 3,
      "content": "KVM (Kernel-based Virtual Machine) full virtualization must be supported by your Linux kernel and your hardware, and necessary kernel modules must be loaded. See KVM for more information.\n\nTo start QEMU in KVM mode, append -accel kvm to the additional start options. To check if KVM is enabled for a running virtual machine, enter the #QEMU monitor and type info kvm.\n\n- The argument accel=kvm of the -machine option is equivalent to the -enable-kvm or the -accel kvm option.\n- CPU model host requires KVM.\n- If you start your virtual machine with a GUI tool and experience very bad performance, you should check for proper KVM support, as QEMU may be falling back to software emulation.\n- KVM needs to be enabled in order to start Windows 7 or Windows 8 properly without a blue screen.\n\n"
    },
    {
      "title": "Enabling IOMMU (Intel VT-d/AMD-Vi) support",
      "level": 3,
      "content": "First enable IOMMU, see PCI passthrough via OVMF#Setting up IOMMU.\n\nAdd -device intel-iommu to create the IOMMU device:\n\n```\n$ qemu-system-x86_64 -enable-kvm -machine q35 -device intel-iommu -cpu host ..\n```\n\n```\nDevice at bus pcie.0 addr 09.0 requires iommu notifier which is currently not supported by intel-iommu emulation\n```\n\n"
    },
    {
      "title": "Booting in UEFI mode",
      "level": 3,
      "content": "The default firmware used by QEMU is SeaBIOS, which is a Legacy BIOS implementation. QEMU uses /usr/share/qemu/bios-256k.bin (provided by the seabios package) as a default read-only (ROM) image. You can use the -bios argument to select another firmware file. However, UEFI requires writable memory to work properly, so you need to emulate PC System Flash instead.\n\nOVMF is a TianoCore project to enable UEFI support for Virtual Machines. It can be installed with the edk2-ovmf package.\n\nThere are two ways to use OVMF as a firmware. The first is to copy /usr/share/edk2/x64/OVMF.4m.fd, make it writable and use as a pflash drive:\n\n```\n-drive if=pflash,format=raw,file=/copy/of/OVMF.4m.fd\n```\n\nAll changes to the UEFI settings will be saved directly to this file.\n\nAnother and more preferable way is to split OVMF into two files. The first one will be read-only and store the firmware executable, and the second one will be used as a writable variable store. The advantage is that you can use the firmware file directly without copying, so it will be updated automatically by pacman.\n\nUse /usr/share/edk2/x64/OVMF_CODE.4m.fd as a first read-only pflash drive. Copy /usr/share/edk2/x64/OVMF_VARS.4m.fd, make it writable and use as a second writable pflash drive:\n\n```\n-drive if=pflash,format=raw,readonly=on,file=/usr/share/edk2/x64/OVMF_CODE.4m.fd \\\n-drive if=pflash,format=raw,file=/copy/of/OVMF_VARS.4m.fd\n```\n\n"
    },
    {
      "title": "Enabling Secure Boot",
      "level": 4,
      "content": "The first requirement to enabling Secure Boot in a VM is to use the q35 machine type, and replace /usr/share/edk2/x64/OVMF_CODE.4m.fd with /usr/share/edk2/x64/OVMF_CODE.secboot.4m.fd.\n\nThe second requirement is to use an OVMF_VARS file that has Secure Boot keys installed, which is not provided by the upstream project[1].\n\nUnlike some other distributions, Arch does not yet provide (as of 2024-12-06) its own /usr/share/edk2/x64/OVMF_VARS.secboot.4m.fd file containing pre-enrolled keys: see archlinux/packaging/packages/edk2#1.\n\nA simple workaround is to use Fedora's version, as mentioned in this forum post:\n\n- download a recent noarch RPM of Fedora's edk2-ovmf for x86_64 from the builds list (direct link to latest F42 version as of 2024-12-06)\n- extract the archive and convert the desired file to a suitable format[2]:\n\n```\n$ qemu-img convert -O raw -f qcow2 edk2-ovmf-*.noarch/usr/share/edk2/ovmf/OVMF_VARS_4M.secboot.qcow2 OVMF_VARS_4M.secboot.fd\n```\n\nNow you can make copies of the created OVMF_VARS_4M.secboot.fd and use them for your Secure Boot-enabled VMs.\n\nSee also KVM#Secure Boot for how to manually enroll keys into a firmware image.\n\n"
    },
    {
      "title": "Trusted Platform Module emulation",
      "level": 3,
      "content": "QEMU can emulate Trusted Platform Module, which is required by some systems such as Windows 11 (which requires TPM 2.0).\n\nInstall the swtpm package, which provides a software TPM implementation. Create some directory for storing TPM data (/path/to/mytpm will be used as an example). Run this command to start the emulator:\n\n```\n$ swtpm socket --tpm2 --tpmstate dir=/path/to/mytpm --ctrl type=unixio,path=/path/to/mytpm/swtpm-sock\n```\n\n/path/to/mytpm/swtpm-sock will be created by swtpm: this is a UNIX socket to which QEMU will connect. You can put it in any directory.\n\nBy default, swtpm starts a TPM version 1.2 emulator. The --tpm2 option enables TPM 2.0 emulation.\n\nFinally, add the following options to QEMU:\n\n```\n-chardev socket,id=chrtpm,path=/path/to/mytpm/swtpm-sock \\\n-tpmdev emulator,id=tpm0,chardev=chrtpm \\\n-device tpm-tis,tpmdev=tpm0\n```\n\nand TPM will be available inside the virtual machine. After shutting down the virtual machine, swtpm will be automatically terminated.\n\nSee the QEMU documentation for more information.\n\nIf guest OS still does not recognize the TPM device, try to adjust CPU Models and Topology options. It might cause problem.\n\n"
    },
    {
      "title": "Network",
      "level": 3,
      "content": "Data can be shared between the host and guest OS using any network protocol that can transfer files, such as NFS, SMB, NBD, HTTP, FTP, or SSH, provided that you have set up the network appropriately and enabled the appropriate services.\n\nThe default SLIRP-based user-mode networking allows the guest to access the host OS at the IP address 10.0.2.2. Any servers that you are running on your host OS, such as a SSH server or SMB server, will be accessible at this IP address. So on the guests, you can mount directories exported on the host via SMB or NFS, or you can access the host's HTTP server, etc. It will not be possible for the host OS to access servers running on the guest OS, but this can be done with other network configurations (see #Tap networking with QEMU).\n\n"
    },
    {
      "title": "QEMU's port forwarding",
      "level": 3,
      "content": "QEMU can forward ports from the host to the guest to enable e.g. connecting from the host to an SSH server running on the guest.\n\nFor example, to bind port 60022 on the host with port 22 (SSH) on the guest, start QEMU with a command like:\n\n```\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::60022-:22\n```\n\nMake sure the sshd is running on the guest and connect with:\n\n```\n$ ssh guest-user@127.0.0.1 -p 60022\n```\n\nYou can use SSHFS to mount the guest's file system at the host for shared read and write access.\n\nTo forward several ports, you just repeat the hostfwd in the -nic argument, e.g. for VNC's port:\n\n```\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::60022-:22,hostfwd=tcp::5900-:5900\n```\n\n"
    },
    {
      "title": "Accessing SSH via vsock",
      "level": 3,
      "content": "A secure and convenient way to connect to the VM is to use SSH over vsock(7). Your VM needs to be systemd-based for this to work out of the box.\n\nFirst, launch QEMU with a special device:\n\n```\n-device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=555\n```\n\nThe cid needs to be picked by the user to be a valid 32-bit number (see vsock(7)). When systemd detects the VM has been launched with a vhost-vsock device, it will automatically launch an SSH server via systemd-ssh-generator.\n\nYou can then connect to the VM like this:\n\n```\n$ ssh user@vsock/555\n```\n\nThis works because of /etc/ssh/ssh_config.d/20-systemd-ssh-proxy.conf which tells your SSH client to use systemd-ssh-proxy to allow SSH to use vsock.\n\nFurthermore, using systemd.system-credentials(7) we can inject an authorized keys file for the root user which is very convenient in case we are trying to run a downloaded image. This can be done like so:\n\n```\n-smbios type=11,value=io.systemd.credential.binary:ssh.authorized_keys.root=c3NoLWVkMjU1MTkgQUFBQUMzTnphQzFsWkRJMU5URTVBQUFBSU9sVFE4ejlpeWxoMTMreCtFVFJ1R1JEaHpIVVRnaCt2ekJLOGY3TEl5eTQ=\n```\n\nThe public key line has be provided as a base64-encoded string. This can be done like so:\n\n```\necho \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOlTQ8z9iylh13+x+ETRuGRDhzHUTgh+vzBK8f7LIyy4\" | base64\n```\n\nThe same mechanism via -smbios type=11,value=io.systemd... can be used to inject a variety of other magical variables that will get acted on by systemd. See also systemd docs: System and Service Credentials.\n\n"
    },
    {
      "title": "QEMU's built-in SMB server",
      "level": 3,
      "content": "QEMU's documentation says it has a \"built-in\" SMB server, but actually it just starts up Samba on the host with an automatically generated smb.conf file located in /tmp/qemu-smb.random_string and makes it accessible to the guest at a different IP address (10.0.2.4 by default). This only works for user networking, and is useful when you do not want to start the normal Samba service on the host, which the guest can also access if you have set up shares on it.\n\nOnly a single directory can be set as shared with the option smb=, but adding more directories (even while the virtual machine is running) could be as easy as creating symbolic links in the shared directory if QEMU configured SMB to follow symbolic links. It does not do so, but the configuration of the running SMB server can be changed as described below.\n\nSamba must be installed on the host. To enable this feature, start QEMU with a command like:\n\n```\n$ qemu-system-x86_64 -nic user,id=nic0,smb=shared_dir_path disk_image\n```\n\nwhere shared_dir_path is a directory that you want to share between the guest and host.\n\nThen, in the guest, you will be able to access the shared directory on the host 10.0.2.4 with the share name \"qemu\". For example, in Windows Explorer you would go to \\\\10.0.2.4\\qemu.\n\n- If you are using sharing options multiple times like -net user,smb=shared_dir_path1 -net user,smb=shared_dir_path2 or -net user,smb=shared_dir_path1,smb=shared_dir_path2 then it will share only the last defined one.\n- If you cannot access the shared folder and the guest system is Windows, check that the NetBIOS protocol is enabled and that a firewall does not block ports used by the NetBIOS protocol.\n- If you cannot access the shared folder and the guest system is Windows 10 Enterprise or Education or Windows Server 2016, enable guest access.\n- If you use #Tap networking with QEMU, use -device virtio-net,netdev=vmnic -netdev user,id=vmnic,smb=shared_dir_path to get SMB.\n\nOne way to share multiple directories and to add or remove them while the virtual machine is running, is to share an empty directory and create/remove symbolic links to the directories in the shared directory. For this to work, the configuration of the running SMB server can be changed with the following script, which also allows the execution of files on the guest that are not set executable on the host:\n\n```\n#!/bin/sh\neval $(ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk '{print \"pid=\"$1\";conf=\"$6}')\necho \"[global]\nallow insecure wide links = yes\n[qemu]\nfollow symlinks = yes\nwide links = yes\nacl allow execute always = yes\" >> \"$conf\"\n# in case the change is not detected automatically:\nsmbcontrol --configfile=\"$conf\" \"$pid\" reload-config\n```\n\nThis can be applied to the running server started by qemu only after the guest has connected to the network drive the first time. An alternative to this method is to add additional shares to the configuration file like so:\n\n```\necho \"[myshare]\npath=another_path\nread only=no\nguest ok=yes\nforce user=username\" >> $conf\n```\n\nThis share will be available on the guest as \\\\10.0.2.4\\myshare.\n\n"
    },
    {
      "title": "Host file sharing with 9pfs VirtFS",
      "level": 3,
      "content": "See the QEMU documentation.\n\n"
    },
    {
      "title": "Host file sharing with virtiofsd",
      "level": 3,
      "content": "virtiofsd is shipped with the virtiofsd package. It's a modern and high-performance way to conveniently share files between host and guest. See the online documentation or /usr/share/doc/virtiofsd/README.md for a full list of available options.\n\nYou can choose to either run virtiofsd as root or as a regular user.\n\n"
    },
    {
      "title": "Running virtiofsd as a regular user",
      "level": 4,
      "content": "First, make sure that there is a subuid(5) and subgid(5) configuration entry for the user that will execute virtiofsd. See also the relevant section in the Podman article.\n\nThen, start virtiofsd:\n\n```\n$ unshare -r --map-auto -- /usr/lib/virtiofsd --socket-path=/tmp/vm-share.sock --shared-dir /tmp/vm-share --sandbox chroot\n```\n\n- unshare -r causes the command after it to be launched in a new user namespace with the current user getting mapped to root in the new command. This is important because virtiofsd expects to be running as root from its point of view.\n- /tmp/vm-share.sock is a socket file\n- /tmp/vm-share is a shared directory between the host and the guest virtual machine\n\n"
    },
    {
      "title": "Running virtiofsd as root",
      "level": 4,
      "content": "Add the user that runs QEMU to the kvm user group, because it needs to access the virtiofsd socket. You might have to logout for change to take effect.\n\nStart virtiofsd as root:\n\n```\n# /usr/lib/virtiofsd --socket-path /tmp/vm-share.sock --socket-group kvm --shared-dir /tmp/vm-share\n```\n\nwhere\n\n- /tmp/vm-share.sock is a socket file\n- /tmp/vm-share is a shared directory between the host and the guest virtual machine\n\n"
    },
    {
      "title": "Launching QEMU",
      "level": 4,
      "content": "Add the following configuration options when starting the virtual machine:\n\n```\n-m 4G\n-object memory-backend-memfd,id=mem,size=4G,share=on\n-numa node,memdev=mem \\\n-chardev socket,id=char0,path=/tmp/vm-share.sock\n-device vhost-user-fs-pci,chardev=char0,tag=myfs\n```\n\nwhere\n\n- size=4G must match the size specified with -m 4G option\n- /tmp/vm-share.sock points to socket file started earlier\n- myfs is an identifier that you will use later in the guest to mount the share\n\n"
    },
    {
      "title": "Boot rootfs directly",
      "level": 4,
      "content": "You may also boot a rootfs directly via virtiofsd. In addition to the above arguments, append:\n\n```\n-kernel /path/to/vmlinux\n-initrd /path/to/initramfs\n-append 'rootfstype=virtiofs root=myfs rootflags=rw,noatime'\n```\n\n"
    },
    {
      "title": "Using the share in a Linux guest",
      "level": 4,
      "content": "Once logged into the guest as root, you can simply mount the share on any modern distribution:\n\n```\n# mount -t virtiofs myfs /mnt\n```\n\nThis directory should now be shared between host and guest.\n\n"
    },
    {
      "title": "Using the share in a Windows guest",
      "level": 4,
      "content": "See relevant Windows section.\n\n"
    },
    {
      "title": "Mounting a partition of the guest on the host",
      "level": 3,
      "content": "It can be useful to mount a drive image under the host system, it can be a way to transfer files in and out of the guest. This should be done when the virtual machine is not running.\n\nThe procedure to mount the drive on the host depends on the type of qemu image, raw or qcow2. We detail thereafter the steps to mount a drive in the two formats in #Mounting a partition from a raw image and #Mounting a partition from a qcow2 image. For the full documentation see Wikibooks:QEMU/Images#Mounting an image on the host.\n\n"
    },
    {
      "title": "Mounting a partition from a raw image",
      "level": 4,
      "content": "It is possible to mount partitions that are inside a raw disk image file by setting them up as loopback devices.\n\nOne way to mount a disk image partition is to mount the disk image at a certain offset using a command like the following:\n\n```\n# mount -o loop,offset=32256 disk_image mountpoint\n```\n\nThe offset=32256 option is actually passed to the losetup program to set up a loopback device that starts at byte offset 32256 of the file and continues to the end. This loopback device is then mounted. You may also use the sizelimit option to specify the exact size of the partition, but this is usually unnecessary.\n\nDepending on your disk image, the needed partition may not start at offset 32256. Run fdisk -l disk_image to see the partitions in the image. fdisk gives the start and end offsets in 512-byte sectors, so multiply by 512 to get the correct offset to pass to mount.\n\nThe Linux loop driver actually supports partitions in loopback devices, but it is disabled by default. To enable it, do the following:\n\n- Get rid of all your loopback devices (unmount all mounted images, etc.).\n- Unload the loop kernel module, and load it with the max_part=15 parameter set. Additionally, the maximum number of loop devices can be controlled with the max_loop parameter.\n\nSet up your image as a loopback device:\n\n```\n# losetup -f -P disk_image\n```\n\nThen, if the device created was /dev/loop0, additional devices /dev/loop0pX will have been automatically created, where X is the number of the partition. These partition loopback devices can be mounted directly. For example:\n\n```\n# mount /dev/loop0p1 mountpoint\n```\n\nTo mount the disk image with udisksctl, see Udisks#Mount loop devices.\n\nkpartx from the multipath-tools package can read a partition table on a device and create a new device for each partition. For example:\n\n```\n# kpartx -a disk_image\n```\n\nThis will setup the loopback device and create the necessary partition(s) device(s) in /dev/mapper/.\n\n"
    },
    {
      "title": "Mounting a partition from a qcow2 image",
      "level": 4,
      "content": "We will use qemu-nbd, which lets us use the NBD (network block device) protocol to share the disk image.\n\nFirst, we need the nbd module loaded:\n\n```\n# modprobe nbd max_part=16\n```\n\nThen, we can share the disk and create the device entries:\n\n```\n# qemu-nbd -c /dev/nbd0 /path/to/image.qcow2\n```\n\nDiscover the partitions:\n\n```\n# partprobe /dev/nbd0\n```\n\nfdisk can be used to get information regarding the different partitions in nbd0:\n\n```\n# fdisk -l /dev/nbd0\n```\n\n```\nDisk /dev/nbd0: 25.2 GiB, 27074281472 bytes, 52879456 sectors\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisklabel type: dos\nDisk identifier: 0xa6a4d542\n\nDevice      Boot   Start      End  Sectors  Size Id Type\n/dev/nbd0p1 *       2048  1026047  1024000  500M  7 HPFS/NTFS/exFAT\n/dev/nbd0p2      1026048 52877311 51851264 24.7G  7 HPFS/NTFS/exFAT\n```\n\nThen mount any partition of the drive image, for example the partition 2:\n\n```\n# mount /dev/nbd0p2 mountpoint\n```\n\nAfter the usage, it is important to unmount the image and reverse previous steps, i.e. unmount the partition and disconnect the nbd device:\n\n```\n# umount mountpoint\n# qemu-nbd -d /dev/nbd0\n```\n\n"
    },
    {
      "title": "Networking",
      "level": 2,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThe performance of virtual networking should be better with tap devices and bridges than with user-mode networking or vde because tap devices and bridges are implemented in-kernel.\n\nIn addition, networking performance can be improved by assigning virtual machines a virtio network device rather than the default emulation of an e1000 NIC. See #Using virtio drivers for more information.\n\n"
    },
    {
      "title": "Link-level address caveat",
      "level": 3,
      "content": "By giving the -net nic argument to QEMU, it will, by default, assign a virtual machine a network interface with the link-level address 52:54:00:12:34:56. However, when using bridged networking with multiple virtual machines, it is essential that each virtual machine has a unique link-level (MAC) address on the virtual machine side of the tap device. Otherwise, the bridge will not work correctly, because it will receive packets from multiple sources that have the same link-level address. This problem occurs even if the tap devices themselves have unique link-level addresses because the source link-level address is not rewritten as packets pass through the tap device.\n\nMake sure that each virtual machine has a unique link-level address, but it should always start with 52:54:. Use the following option, replace X with arbitrary hexadecimal digit:\n\n```\n$ qemu-system-x86_64 -net nic,macaddr=52:54:XX:XX:XX:XX -net vde disk_image\n```\n\nGenerating unique link-level addresses can be done in several ways:\n\n- Manually specify unique link-level address for each NIC. The benefit is that the DHCP server will assign the same IP address each time the virtual machine is run, but it is unusable for large number of virtual machines.\n- Generate random link-level address each time the virtual machine is run. Practically zero probability of collisions, but the downside is that the DHCP server will assign a different IP address each time. You can use the following command in a script to generate random link-level address in a macaddr variable:\n\n```\nprintf -v macaddr \"52:54:%02x:%02x:%02x:%02x\" $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff ))\nqemu-system-x86_64 -net nic,macaddr=\"$macaddr\" -net vde disk_image\n```\n\n- Use the following script qemu-mac-hasher.py to generate the link-level address from the virtual machine name using a hashing function. Given that the names of virtual machines are unique, this method combines the benefits of the aforementioned methods: it generates the same link-level address each time the script is run, yet it preserves the practically zero probability of collisions.\n\n```\nqemu-mac-hasher.py\n```\n\n```\n#!/usr/bin/env python\n# usage: qemu-mac-hasher.py <VMName>\n\nimport sys\nimport zlib\n\ncrc = str(hex(zlib.crc32(sys.argv[1].encode(\"utf-8\")))).replace(\"x\", \"\")[-8:]\nprint(\"52:54:%s%s:%s%s:%s%s:%s%s\" % tuple(crc))\n```\n\nIn a script, you can use for example:\n\n```\nvm_name=\"VM Name\"\nqemu-system-x86_64 -name \"$vm_name\" -net nic,macaddr=$(qemu-mac-hasher.py \"$vm_name\") -net vde disk_image\n```\n\n"
    },
    {
      "title": "SLIRP",
      "level": 4,
      "content": "By default, without any -netdev arguments, QEMU will use SLIRP-based user-mode networking with a built-in DHCP server. Your virtual machines will be assigned an IP address when they run their DHCP client, and they will be able to access the physical host's network through IP masquerading done by QEMU.\n\nThis default configuration allows your virtual machines to easily access the Internet, provided that the host is connected to it, but the virtual machines will not be directly visible on the external network, nor will virtual machines be able to talk to each other if you start up more than one concurrently.\n\nQEMU's user-mode networking can offer more capabilities such as built-in TFTP or SMB servers, redirecting host ports to the guest (for example to allow SSH connections to the guest) or attaching guests to VLANs so that they can talk to each other. See the QEMU documentation on the -net user flag for more details.\n\nHowever, SLIRP-based user-mode networking has limitations in both utility and performance. More advanced network configurations require the use of tap devices or other methods.\n\n- To use the virtio driver with user-mode networking, the option is: -nic user,model=virtio-net-pci.\n- You can isolate user-mode networking from the host and the outside world by adding restrict=y, for example: -net user,restrict=y\n\n"
    },
    {
      "title": "passt",
      "level": 4,
      "content": "Users can choose to use passt-based user-mode networking. passt has several advantages over SLIRP such as better performance, full IPv6 support (including ICMPv6), better security, and more control.\n\nTo get started, install passt. There are two ways to launch it: Either via socket-based communication or via shared vhost-user. The latter method has better performance.\n\nFor the socket-based way, first launch passt:\n\n```\n$ passt -f\n```\n\nThen, for your QEMU command, add these parameters:\n\n```\n-device virtio-net-pci,netdev=s\n-netdev stream,id=s,server=off,addr.type=unix,addr.path=/tmp/passt_1.socket\n```\n\nFor the vhost-user way, launch passt with --vhost-user\n\n```\n$ passt -f --vhost-user\n```\n\nThen, for your QEMU command, add these parameters:\n\n```\n-m 4G\n-chardev socket,id=chr0,path=/tmp/passt_1.socket\n-netdev vhost-user,id=netdev0,chardev=chr0\n-device virtio-net,netdev=netdev0\n-object memory-backend-memfd,id=memfd0,share=on,size=4G\n-numa node,memdev=memfd0\n```\n\nNotice the memory sizes of -m 4G and size=4G have to match exactly.\n\n"
    },
    {
      "title": "Tap networking with QEMU",
      "level": 3,
      "content": "Tap devices are a Linux kernel feature that allows you to create virtual network interfaces that appear as real network interfaces. Packets sent to a tap interface are delivered to a userspace program, such as QEMU, that has bound itself to the interface.\n\nQEMU can use tap networking for a virtual machine so that packets sent to the tap interface will be sent to the virtual machine and appear as coming from a network interface (usually an Ethernet interface) in the virtual machine. Conversely, everything that the virtual machine sends through its network interface will appear on the tap interface.\n\nTap devices are supported by the Linux bridge drivers, so it is possible to bridge together tap devices with each other and possibly with other host interfaces such as eth0. This is desirable if you want your virtual machines to be able to talk to each other, or if you want other machines on your LAN to be able to talk to the virtual machines.\n\nAs indicated in the user-mode networking section, tap devices offer higher networking performance than user-mode. If the guest OS supports virtio network driver, then the networking performance will be increased considerably as well. Supposing the use of the tap0 device, that the virtio driver is used on the guest, and that no scripts are used to help start/stop networking, next is part of the qemu command one should see:\n\n```\n-device virtio-net,netdev=network0 -netdev tap,id=network0,ifname=tap0,script=no,downscript=no\n```\n\nBut if already using a tap device with virtio networking driver, one can even boost the networking performance by enabling vhost, like:\n\n```\n-device virtio-net,netdev=network0 -netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on\n```\n\nSee [4] for more information.\n\n"
    },
    {
      "title": "Host-only networking",
      "level": 4,
      "content": "If the bridge is given an IP address and traffic destined for it is allowed, but no real interface (e.g. eth0) is connected to the bridge, then the virtual machines will be able to talk to each other and the host system. However, they will not be able to talk to anything on the external network, provided that you do not set up IP masquerading on the physical host. This configuration is called host-only networking by other virtualization software such as VirtualBox.\n\n- If you want to set up IP masquerading, e.g. NAT for virtual machines, see the Internet sharing#Enable NAT page.\n- See Network bridge for information on creating bridge.\n- You may want to have a DHCP server running on the bridge interface to service the virtual network. For example, to use the 172.20.0.1/16 subnet with dnsmasq as the DHCP server:\n\n```\n# ip addr add 172.20.0.1/16 dev br0\n# ip link set br0 up\n# dnsmasq -C /dev/null --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254\n```\n\n"
    },
    {
      "title": "Internal networking",
      "level": 4,
      "content": "If you do not give the bridge an IP address and add an iptables rule to drop all traffic to the bridge in the INPUT chain, then the virtual machines will be able to talk to each other, but not to the physical host or to the outside network. This configuration is called internal networking by other virtualization software such as VirtualBox. You will need to either assign static IP addresses to the virtual machines or run a DHCP server on one of them.\n\nBy default iptables would drop packets in the bridge network. You may need to use such iptables rule to allow packets in a bridged network:\n\n```\n# iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT\n```\n\n"
    },
    {
      "title": "Bridged networking using qemu-bridge-helper",
      "level": 4,
      "content": "This method does not require a start-up script and readily accommodates multiple taps and multiple bridges. It uses /usr/lib/qemu/qemu-bridge-helper binary, which allows creating tap devices on an existing bridge.\n\n- See Network bridge for information on creating bridge.\n- See https://wiki.qemu.org/Features/HelperNetworking for more information on QEMU's network helper.\n\nFirst, create a configuration file containing the names of all bridges to be used by QEMU:\n\n```\n/etc/qemu/bridge.conf\n```\n\n```\nallow br0\nallow br1\n...\n```\n\nMake sure /etc/qemu/ has 755 permissions. QEMU issues and GNS3 issues may arise if this is not the case.\n\nNow start the virtual machine; the most basic usage to run QEMU with the default network helper and default bridge br0:\n\n```\n$ qemu-system-x86_64 -nic bridge [...]\n```\n\nUsing the bridge br1 and the virtio driver:\n\n```\n$ qemu-system-x86_64 -nic bridge,br=br1,model=virtio-net-pci [...]\n```\n\n"
    },
    {
      "title": "Advanced network configuration",
      "level": 4,
      "content": "If you need more control over your virtual machine's networking or you have very specific needs that arent covered in the previous setctions, see QEMU/Advanced networking.\n\n"
    },
    {
      "title": "Shorthand configuration",
      "level": 3,
      "content": "If you are using QEMU with various networking options a lot, you probably have created a lot of -netdev and -device argument pairs, which gets quite repetitive. You can instead use the -nic argument to combine -netdev and -device together, so that, for example, these arguments:\n\n```\n-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0\n```\n\nbecome:\n\n```\n-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci\n```\n\nNotice the lack of network IDs, and that the device was created with model=. The first half of the -nic parameters are -netdev parameters, whereas the second half (after model=) are related with the device. The same parameters (for example, smb=) are used. To completely disable the networking use -nic none.\n\nSee QEMU networking documentation for more information on parameters you can use.\n\n"
    },
    {
      "title": "Graphics card",
      "level": 2,
      "content": "QEMU can emulate a standard graphics card text mode using -display curses command line option. This allows to type text and see text output directly inside a text terminal. Alternatively, -nographic serves a similar purpose.\n\nQEMU can emulate several types of VGA card. The card type is passed in the -vga type command line option and can be std, qxl, vmware, virtio, cirrus or none.\n\n"
    },
    {
      "title": "std",
      "level": 3,
      "content": "With -vga std you can get a resolution of up to 2560 x 1600 pixels without requiring guest drivers. This is the default since QEMU 2.2.\n\n"
    },
    {
      "title": "qxl",
      "level": 3,
      "content": "QXL is a paravirtual graphics driver with 2D support. To use it, pass the -vga qxl option and install drivers in the guest. You may want to use #SPICE for improved graphical performance when using QXL.\n\nOn Linux guests, the qxl and bochs_drm kernel modules must be loaded in order to gain a decent performance.\n\nDefault VGA memory size for QXL devices is 16M which is sufficient to drive resolutions approximately up to QHD (2560x1440). To enable higher resolutions, increase vga_memmb.\n\n"
    },
    {
      "title": "vmware",
      "level": 3,
      "content": "Although it is a bit buggy, it performs better than std and cirrus. Install the VMware drivers xf86-video-vmware and xf86-input-vmmouse for Arch Linux guests.\n\n"
    },
    {
      "title": "virtio",
      "level": 3,
      "content": "virtio-vga / virtio-gpu is a paravirtual 3D graphics driver based on virgl. It's mature, currently supporting only Linux guests with mesa compiled with the option gallium-drivers=virgl.\n\nTo enable 3D acceleration on the guest system, select this vga with -device virtio-vga-gl and enable the OpenGL context in the display device with -display sdl,gl=on or -display gtk,gl=on for the SDL and GTK display output respectively. Successful configuration can be confirmed looking at the kernel log in the guest:\n\n```\n# dmesg | grep drm\n```\n\n```\n[drm] pci: virtio-vga detected\n[drm] virgl 3d acceleration enabled\n```\n\n"
    },
    {
      "title": "cirrus",
      "level": 3,
      "content": "The cirrus graphical adapter was the default before 2.2. It should not be used on modern systems.\n\n"
    },
    {
      "title": "none",
      "level": 3,
      "content": "This is like a PC that has no VGA card at all. You would not even be able to access it with the -vnc option. Also, this is different from the -nographic option which lets QEMU emulate a VGA card, but disables the SDL display.\n\n"
    },
    {
      "title": "SPICE",
      "level": 2,
      "content": "The SPICE project aims to provide a complete open source solution for remote access to virtual machines in a seamless way.\n\n"
    },
    {
      "title": "Enabling SPICE support on the host",
      "level": 3,
      "content": "The following is an example of booting with SPICE as the remote desktop protocol, including the support for copy and paste from host:\n\n```\n$ qemu-system-x86_64 -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent\n```\n\nThe parameters have the following meaning:\n\n1. -device virtio-serial-pci adds a virtio-serial device\n1. -spice port=5930,disable-ticketing=on set TCP port 5930 for spice channels listening and allow client to connect without authenticationTip: Using Unix sockets instead of TCP ports does not involve using network stack on the host system. It does not imply that packets are encapsulated and decapsulated to use the network and the related protocol. The sockets are identified solely by the inodes on the hard drive. It is therefore considered better for performance. Use instead -spice unix=on,addr=/tmp/vm_spice.socket,disable-ticketing=on.\n1. -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 opens a port for spice vdagent in the virtio-serial device,\n1. -chardev spicevmc,id=spicechannel0,name=vdagent adds a spicevmc chardev for that port. It is important that the chardev= option of the virtserialport device matches the id= option given to the chardev option (spicechannel0 in this example). It is also important that the port name is com.redhat.spice.0, because that is the namespace where vdagent is looking for in the guest. And finally, specify name=vdagent so that spice knows what this channel is for.\n\n"
    },
    {
      "title": "Connecting to the guest with a SPICE client",
      "level": 3,
      "content": "A SPICE client is necessary to connect to the guest. In Arch, the following clients are available:\n\n- virt-viewer — SPICE client recommended by the protocol developers, a subset of the virt-manager project.\n\n- spice-gtk — SPICE GTK client, a subset of the SPICE project. Embedded into other applications as a widget.\n\nFor clients that run on smartphone or on other platforms, refer to the Other clients section in spice-space download.\n\n"
    },
    {
      "title": "Manually running a SPICE client",
      "level": 4,
      "content": "One way of connecting to a guest listening on Unix socket /tmp/vm_spice.socket is to manually run the SPICE client using $ remote-viewer spice+unix:///tmp/vm_spice.socket or $ spicy --uri=\"spice+unix:///tmp/vm_spice.socket\", depending on the desired client. Since QEMU in SPICE mode acts similarly to a remote desktop server, it may be more convenient to run QEMU in daemon mode with the -daemonize parameter.\n\nNote: This example connects spicy to the local port 5999 which is forwarded through SSH to the guest's SPICE server located at the address my.domain.org, port 5930. Note the -f option that requests ssh to execute the command sleep 10 in the background. This way, the ssh session runs while the client is active and auto-closes once the client ends.\n\n```\n$ ssh -fL 5999:localhost:5930 my.domain.org sleep 10; spicy -h 127.0.0.1 -p 5999\n```\n\nThis example connects spicy to the local port 5999 which is forwarded through SSH to the guest's SPICE server located at the address my.domain.org, port 5930. Note the -f option that requests ssh to execute the command sleep 10 in the background. This way, the ssh session runs while the client is active and auto-closes once the client ends.\n\n"
    },
    {
      "title": "Running a SPICE client with QEMU",
      "level": 4,
      "content": "QEMU can automatically start a SPICE client with an appropriate socket, if the display is set to SPICE with the -display spice-app parameter. This will use the system's default SPICE client as the viewer, determined by your mimeapps.list files.\n\n"
    },
    {
      "title": "Enabling SPICE support on the guest",
      "level": 3,
      "content": "For Arch Linux guests, for improved support for multiple monitors or clipboard sharing, the following packages should be installed:\n\n- spice-vdagent: Spice agent xorg client that enables copy and paste between client and X-session and more. (Refer to this issue, until fixed, for workarounds to get this to work on non-GNOME desktops.)\n- xf86-video-qxl: Xorg X11 qxl video driver\n- x-resizeAUR: Desktop environments other than GNOME do not react automatically when the SPICE client window is resized. This package uses a udev rule and xrandr to implement auto-resizing for all X11-based desktop environments and window managers.\n\nFor guests under other operating systems, refer to the Guest section in spice-space download.\n\n"
    },
    {
      "title": "Password authentication with SPICE",
      "level": 3,
      "content": "If you want to enable password authentication with SPICE you need to remove disable-ticketing from the -spice argument and instead add password=yourpassword. For example:\n\n```\n$ qemu-system-x86_64 -vga qxl -spice port=5900,password=yourpassword -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent\n```\n\nYour SPICE client should now ask for the password to be able to connect to the SPICE server.\n\n"
    },
    {
      "title": "TLS encrypted communication with SPICE",
      "level": 3,
      "content": "You can also configure TLS encryption for communicating with the SPICE server. First, you need to have a directory which contains the following files (the names must be exactly as indicated):\n\n- ca-cert.pem: the CA master certificate.\n- server-cert.pem: the server certificate signed with ca-cert.pem.\n- server-key.pem: the server private key.\n\nAn example of generation of self-signed certificates with your own generated CA for your server is shown in the Spice User Manual.\n\nAfterwards, you can run QEMU with SPICE as explained above but using the following -spice argument: -spice tls-port=5901,password=yourpassword,x509-dir=/path/to/pki_certs, where /path/to/pki_certs is the directory path that contains the three needed files shown earlier.\n\nIt is now possible to connect to the server using virt-viewer:\n\n```\n$ remote-viewer spice://hostname?tls-port=5901 --spice-ca-file=/path/to/ca-cert.pem --spice-host-subject=\"C=XX,L=city,O=organization,CN=hostname\" --spice-secure-channels=all\n```\n\nKeep in mind that the --spice-host-subject parameter needs to be set according to your server-cert.pem subject. You also need to copy ca-cert.pem to every client to verify the server certificate.\n\n```\n$ openssl x509 -noout -subject -in server-cert.pem | cut -d' ' -f2- | sed 's/\\///' | sed 's/\\//,/g'\n```\n\nThe equivalent spice-gtk command is:\n\n```\n$ spicy -h hostname -s 5901 --spice-ca-file=ca-cert.pem --spice-host-subject=\"C=XX,L=city,O=organization,CN=hostname\" --spice-secure-channels=all\n```\n\n"
    },
    {
      "title": "VNC",
      "level": 2,
      "content": "One can add the -vnc :X option to have QEMU redirect the VGA display to the VNC session. Substitute X for the number of the display (0 will then listen on 5900, 1 on 5901...).\n\n```\n$ qemu-system-x86_64 -vnc :0\n```\n\nAn example is also provided in the #Starting QEMU virtual machines on boot section.\n\n"
    },
    {
      "title": "Basic password authentication",
      "level": 3,
      "content": "An access password can be setup easily by using the password option. The password must be indicated in the QEMU monitor and connection is only possible once the password is provided.\n\n```\n$ qemu-system-x86_64 -vnc :0,password -monitor stdio\n```\n\nIn the QEMU monitor, password is set using the command change vnc password and then indicating the password.\n\nThe following command line directly runs vnc with a password:\n\n```\n$ printf \"change vnc password\\n%s\\n\" MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio\n```\n\n"
    },
    {
      "title": "Creating an audio backend",
      "level": 3,
      "content": "The -audiodev flag sets the audio backend driver on the host and its options.\n\nTo list availabe audio backend drivers:\n\n```\n$ qemu-system-x86_64 -audiodev help\n```\n\nTheir optional settings are detailed in the qemu(1) man page.\n\nAt the bare minimum, one need to choose an audio backend and set an id, for PulseAudio for example:\n\n```\n-audiodev pa,id=snd0\n```\n\n"
    },
    {
      "title": "Intel HD Audio",
      "level": 4,
      "content": "For Intel HD Audio emulation, add both controller and codec devices. To list the available Intel HDA Audio devices:\n\n```\n$ qemu-system-x86_64 -device help | grep hda\n```\n\nAdd the audio controller:\n\n```\n-device ich9-intel-hda\n```\n\nAlso, add the audio codec and map it to a host audio backend id:\n\n```\n-device hda-output,audiodev=snd0\n```\n\n"
    },
    {
      "title": "Intel 82801AA AC97",
      "level": 4,
      "content": "For AC97 emulation just add the audio card device and map it to a host audio backend id:\n\n```\n-device AC97,audiodev=snd0\n```\n\n- If the audiodev backend is not provided, QEMU looks up for it and adds it automatically, this only works for a single audiodev. For example -device intel-hda -device hda-duplex will emulate intel-hda on the guest using the default audiodev backend.\n- Video graphics card emulated drivers for the guest machine may also cause a problem with the sound quality. Test one by one to make it work. You can list possible options with qemu-system-x86_64 -h | grep vga.\n\n"
    },
    {
      "title": "VirtIO sound",
      "level": 4,
      "content": "VirtIO sound is also available since QEMU 8.2.0. The usage is:\n\n```\n-device virtio-sound-pci,audiodev=my_audiodev -audiodev alsa,id=my_audiodev\n```\n\nMore information can be found in QEMU documentation.\n\n"
    },
    {
      "title": "Using virtio drivers",
      "level": 2,
      "content": "QEMU offers guests the ability to use paravirtualized block and network devices using the virtio drivers, which provide better performance and lower overhead.\n\n- A virtio block device requires the option -drive for passing a disk image, with parameter if=virtio:\n\n```\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio\n```\n\n- Almost the same goes for the network:\n\n```\n$ qemu-system-x86_64 -nic user,model=virtio-net-pci\n```\n\n"
    },
    {
      "title": "Preparing an Arch Linux guest",
      "level": 3,
      "content": "To use virtio devices after an Arch Linux guest has been installed, the following modules must be loaded in the guest: virtio, virtio_pci, virtio_blk, virtio_net, and virtio_ring. For 32-bit guests, the specific \"virtio\" module is not necessary.\n\nIf you want to boot from a virtio disk, the initial ramdisk must contain the necessary modules. By default, this is handled by mkinitcpio's autodetect hook. Otherwise use the MODULES array in /etc/mkinitcpio.conf to include the necessary modules and rebuild the initial ramdisk.\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nMODULES=(virtio virtio_blk virtio_pci virtio_net)\n```\n\nVirtio disks are recognized with the prefix v (e.g. vda, vdb, etc.); therefore, changes must be made in at least /etc/fstab and /boot/grub/grub.cfg when booting from a virtio disk.\n\nFurther information on paravirtualization with KVM can be found here.\n\nYou might also want to install qemu-guest-agent to implement support for QMP commands that will enhance the hypervisor management capabilities.\n\n"
    },
    {
      "title": "Memory ballooning",
      "level": 4,
      "content": "In order to allow the guest's memory foot print to shrink as seen from the host, it needs to report to the host which pages are not needed anymore by the guest. The kernel has an API for that called Free Page Reporting and since it's built-in it's as easy as starting QEMU like this:\n\n```\n$ qemu-system-x86_64 ... -device virtio-balloon,free-page-reporting=on\n```\n\nAfter this, you should see the guest memory increasing and then shrinking again after running workloads in it.\n\nHowever, while this parameter will indeed take care of shrinking the guest's memory usage from the host's perspective when pages are freed, it will not be able to automatically make use of memory that the guest is using for cache. This is an important consideration as a guest is likely to eventually use its entire unused memory for caching, making free-page-reporting=on useless. Read the next section to mitigate this problem.\n\n"
    },
    {
      "title": "Using virtio pmem to bypass the guest's page cache",
      "level": 4,
      "content": "You might want to rely on the host's page cache instead of the guest's in order to allow for more efficient memory usage. Coupled with KSM, this allows you to make your virtual machines quite memory efficient, duplicating only few pages.\n\nOne way to achieve this is to use a virtio pmem device. Add this config to your QEMU:\n\n```\n-object memory-backend-file,id=mem1,share,mem-path=./virtio_pmem.img,size=32G\n-device virtio-pmem-pci,memdev=mem1,id=nv1\n-m 64G,maxmem=96G\n```\n\nwhereby virtio_pmem.img is a local file on the host that will serve as our memory backend in side the guest. The -m part is important here: Set the maxmem parameter so that it is regular memory + memory-backend-file size. In this case: 64G + 32G = 96G.\n\nStart the guest with those options. Inside the guest, you will find a new device at /dev/pmem0 which we will need to format with a filesystem such as ext4 (btrfs is not supported):\n\n```\n# mkfs.ext4 /dev/pmem0\nmount /dev/pmem0 /mnt -o dax=always\n```\n\nAny files you write into /mnt will then bypass the guest's page cache.\n\nIt's also possible to have the whole root filesystem DAX-enabled in this way.\n\n"
    },
    {
      "title": "Virtio drivers for Windows",
      "level": 4,
      "content": "Windows does not come with the virtio drivers. The latest and stable versions of the drivers are regularly built by Fedora, details on downloading the drivers are given on virtio-win on GitHub. In the following sections we will mostly use the stable ISO file provided here: virtio-win.iso. Alternatively, use virtio-winAUR.\n\n"
    },
    {
      "title": "Block device drivers",
      "level": 4,
      "content": "The drivers need to be loaded during installation, the procedure is to load the ISO image with the virtio drivers in a cdrom device along with the primary disk device and the Windows ISO install media:\n\n```\n$ qemu-system-x86_64 ... \\\n-drive file=disk_image,index=0,media=disk,if=virtio \\\n-drive file=windows.iso,index=2,media=cdrom \\\n-drive file=virtio-win.iso,index=3,media=cdrom \\\n...\n```\n\nDuring the installation, at some stage, the Windows installer will ask \"Where do you want to install Windows?\", it will give a warning that no disks are found. Follow the example instructions below (based on Windows Server 2012 R2 with Update).\n\n- Select the option Load Drivers.\n- Uncheck the box for Hide drivers that are not compatible with this computer's hardware.\n- Click the browse button and open the CDROM for the virtio iso, usually named \"virtio-win-XX\".\n- Now browse to E:\\viostor\\[your-os]\\amd64, select it, and confirm.\n\nYou should now see your virtio disk(s) listed here, ready to be selected, formatted and installed to.\n\nModifying an existing Windows guest for booting from virtio disk requires that the virtio driver is loaded by the guest at boot time. We will therefore need to teach Windows to load the virtio driver at boot time before being able to boot a disk image in virtio mode.\n\nTo achieve that, first create a new disk image that will be attached in virtio mode and trigger the search for the driver:\n\n```\n$ qemu-img create -f qcow2 dummy.qcow2 1G\n```\n\nRun the original Windows guest with the boot disk still in IDE mode, the fake disk in virtio mode and the driver ISO image.\n\n```\n$ qemu-system-x86_64 -m 4G -drive file=disk_image,if=ide -drive file=dummy.qcow2,if=virtio -cdrom virtio-win.iso\n```\n\nWindows will detect the fake disk and look for a suitable driver. If it fails, go to Device Manager, locate the SCSI drive with an exclamation mark icon (should be open), click Update driver and select the virtual CD-ROM. Do not navigate to the driver folder within the CD-ROM, simply select the CD-ROM drive and Windows will find the appropriate driver automatically (tested for Windows 7 SP1).\n\nRequest Windows to boot in safe mode next time it starts up. This can be done using the msconfig.exe tool in Windows. In safe mode all the drivers will be loaded at boot time including the new virtio driver. Once Windows knows that the virtio driver is required at boot it will memorize it for future boot.\n\nOnce instructed to boot in safe mode, you can turn off the virtual machine and launch it again, now with the boot disk attached in virtio mode:\n\n```\n$ qemu-system-x86_64 -m 4G -drive file=disk_image,if=virtio\n```\n\nYou should boot in safe mode with virtio driver loaded, you can now return to msconfig.exe disable safe mode boot and restart Windows.\n\n"
    },
    {
      "title": "Network drivers",
      "level": 4,
      "content": "Using virtio network drivers is a bit easier, simply add the -nic argument.\n\n```\n$ qemu-system-x86_64 -m 4G -drive file=windows_disk_image,if=virtio -nic user,model=virtio-net-pci -cdrom virtio-win.iso\n```\n\nWindows will detect the network adapter and try to find a driver for it. If it fails, go to the Device Manager, locate the network adapter with an exclamation mark icon (should be open), click Update driver and select the virtual CD-ROM. Do not forget to select the checkbox which says to search for directories recursively.\n\n"
    },
    {
      "title": "Balloon driver",
      "level": 4,
      "content": "If you want to track you guest memory state (for example via virsh command dommemstat) or change guest's memory size in runtime (you still will not be able to change memory size, but can limit memory usage via inflating balloon driver) you will need to install guest balloon driver.\n\nFor this you will need to go to Device Manager, locate PCI standard RAM Controller in System devices (or unrecognized PCI controller from Other devices) and choose Update driver. In opened window you will need to choose Browse my computer... and select the CD-ROM (and do not forget the Include subdirectories checkbox). Reboot after installation. This will install the driver and you will be able to inflate the balloon (for example via hmp command balloon memory_size, which will cause balloon to take as much memory as possible in order to shrink the guest's available memory size to memory_size). However, you still will not be able to track guest memory state. In order to do this you will need to install Balloon service properly. For that open command line as administrator, go to the CD-ROM, Balloon directory and deeper, depending on your system and architecture. Once you are in amd64 (x86) directory, run blnsrv.exe -i which will do the installation. After that virsh command dommemstat should be outputting all supported values.\n\n"
    },
    {
      "title": "Using a virtiofsd share",
      "level": 4,
      "content": "Before you progress in this section, make sure you followed the section about setting up host file sharing with virtiofsd first.\n\nFirst, follow the upstream instructions. Once configured, Windows will have the Z: drive mapped automatically with shared directory content.\n\nYour Windows 11 guest system is properly configured if it has:\n\n- VirtioFSSService windows service,\n- WinFsp.Launcher windows service,\n- VirtIO FS Device driver under \"System devices\" in Windows \"Device Manager\".\n\nIf the above installed and Z: drive is still not listed, try repairing \"Virtio-win-guest-tools\" in Windows Add/Remove programs.\n\n"
    },
    {
      "title": "Preparing a FreeBSD guest",
      "level": 3,
      "content": "Install the emulators/virtio-kmod port if you are using FreeBSD 8.3 or later up until 10.0-CURRENT where they are included into the kernel. After installation, add the following to your /boot/loader.conf file:\n\n```\nvirtio_load=\"YES\"\nvirtio_pci_load=\"YES\"\nvirtio_blk_load=\"YES\"\nif_vtnet_load=\"YES\"\nvirtio_balloon_load=\"YES\"\n```\n\nThen modify your /etc/fstab by doing the following:\n\n```\n# sed -ibak \"s/ada/vtbd/g\" /etc/fstab\n```\n\nAnd verify that /etc/fstab is consistent. If anything goes wrong, just boot into a rescue CD and copy /etc/fstab.bak back to /etc/fstab.\n\n"
    },
    {
      "title": "QEMU monitor",
      "level": 2,
      "content": "While QEMU is running, a monitor console is provided in order to provide several ways to interact with the virtual machine running. The QEMU monitor offers interesting capabilities such as obtaining information about the current virtual machine, hotplugging devices, creating snapshots of the current state of the virtual machine, etc. To see the list of all commands, run help or ? in the QEMU monitor console or review the relevant section of the official QEMU documentation.\n\n"
    },
    {
      "title": "Graphical view",
      "level": 4,
      "content": "When using the std default graphics option, one can access the QEMU monitor by pressing Ctrl+Alt+2 or by clicking View > compatmonitor0 in the QEMU window. To return to the virtual machine graphical view either press Ctrl+Alt+1 or click View > VGA.\n\nHowever, the standard method of accessing the monitor is not always convenient and does not work in all graphic outputs QEMU supports.\n\n"
    },
    {
      "title": "Telnet",
      "level": 4,
      "content": "To enable telnet, run QEMU with the -monitor telnet:127.0.0.1:port,server,nowait parameter. When the virtual machine is started you will be able to access the monitor via telnet:\n\n```\n$ telnet 127.0.0.1 port\n```\n\n"
    },
    {
      "title": "UNIX socket",
      "level": 4,
      "content": "Run QEMU with the -monitor unix:socketfile,server,nowait parameter. Then you can connect with either socat, nmap or openbsd-netcat.\n\nFor example, if QEMU is run via:\n\n```\n$ qemu-system-x86_64 -monitor unix:/tmp/monitor.sock,server,nowait [...]\n```\n\nIt is possible to connect to the monitor with:\n\n```\n$ socat - UNIX-CONNECT:/tmp/monitor.sock\n```\n\nOr with:\n\n```\n$ nc -U /tmp/monitor.sock\n```\n\nAlternatively with nmap:\n\n```\n$ ncat -U /tmp/monitor.sock\n```\n\n"
    },
    {
      "title": "TCP",
      "level": 4,
      "content": "You can expose the monitor over TCP with the argument -monitor tcp:127.0.0.1:port,server,nowait. Then connect with netcat, either openbsd-netcat or gnu-netcat by running:\n\n```\n$ nc 127.0.0.1 port\n```\n\n"
    },
    {
      "title": "Standard I/O",
      "level": 4,
      "content": "It is possible to access the monitor automatically from the same terminal QEMU is being run by running it with the argument -monitor stdio.\n\n"
    },
    {
      "title": "Sending keyboard presses to the virtual machine using the monitor console",
      "level": 3,
      "content": "Some combinations of keys may be difficult to perform on virtual machines due to the host intercepting them instead in some configurations (a notable example is the Ctrl+Alt+F* key combinations, which change the active tty). To avoid this problem, the problematic combination of keys may be sent via the monitor console instead. Switch to the monitor and use the sendkey command to forward the necessary keypresses to the virtual machine. For example:\n\n```\n(qemu) sendkey ctrl-alt-f2\n```\n\n"
    },
    {
      "title": "Creating and managing snapshots via the monitor console",
      "level": 3,
      "content": "Note: **only** \n\nIt is sometimes desirable to save the current state of a virtual machine and having the possibility of reverting the state of the virtual machine to that of a previously saved snapshot at any time. The QEMU monitor console provides the user with the necessary utilities to create snapshots, manage them, and revert the machine state to a saved snapshot.\n\n- Use savevm name in order to create a snapshot with the tag name.\n- Use loadvm name to revert the virtual machine to the state of the snapshot name.\n- Use delvm name to delete the snapshot tagged as name.\n- Use info snapshots to see a list of saved snapshots. Snapshots are identified by both an auto-incremented ID number and a text tag (set by the user on snapshot creation).\n\n"
    },
    {
      "title": "Running the virtual machine in immutable mode",
      "level": 3,
      "content": "It is possible to run a virtual machine in a frozen state so that all changes will be discarded when the virtual machine is powered off just by running QEMU with the -snapshot parameter. When the disk image is written by the guest, changes will be saved in a temporary file in /tmp and will be discarded when QEMU halts.\n\nHowever, if a machine is running in frozen mode it is still possible to save the changes to the disk image if it is afterwards desired by using the monitor console and running the following command:\n\n```\n(qemu) commit all\n```\n\nIf snapshots are created when running in frozen mode they will be discarded as soon as QEMU is exited unless changes are explicitly commited to disk, as well.\n\n"
    },
    {
      "title": "Pause and power options via the monitor console",
      "level": 3,
      "content": "Some operations of a physical machine can be emulated by QEMU using some monitor commands:\n\n- system_powerdown will send an ACPI shutdown request to the virtual machine. This effect is similar to the power button in a physical machine.\n- system_reset will reset the virtual machine similarly to a reset button in a physical machine. This operation can cause data loss and file system corruption since the virtual machine is not cleanly restarted.\n- stop will pause the virtual machine.\n- cont will resume a virtual machine previously paused.\n\n"
    },
    {
      "title": "Taking screenshots of the virtual machine",
      "level": 3,
      "content": "Screenshots of the virtual machine graphic display can be obtained in the PPM format by running the following command in the monitor console:\n\n```\n(qemu) screendump file.ppm\n```\n\n"
    },
    {
      "title": "QEMU machine protocol",
      "level": 2,
      "content": "The QEMU machine protocol (QMP) is a JSON-based protocol which allows applications to control a QEMU instance. Similarly to the #QEMU monitor it offers ways to interact with a running machine and the JSON protocol allows to do it programmatically. The description of all the QMP commands can be found in qmp-commands.\n\n"
    },
    {
      "title": "Start QMP",
      "level": 3,
      "content": "The usual way to control the guest using the QMP protocol, is to open a TCP socket when launching the machine using the -qmp option. Here it is using for example the TCP port 4444:\n\n```\n$ qemu-system-x86_64 [...] -qmp tcp:localhost:4444,server,nowait\n```\n\nThen one way to communicate with the QMP agent is to use netcat:\n\n```\nnc localhost 4444\n```\n\n```\n{\"QMP\": {\"version\": {\"qemu\": {\"micro\": 0, \"minor\": 1, \"major\": 3}, \"package\": \"\"}, \"capabilities\": []} }\n```\n\nAt this stage, the only command that can be recognized is qmp_capabilities, so that QMP enters into command mode. Type:\n\n```\n{\"execute\": \"qmp_capabilities\"}\n```\n\nNow, QMP is ready to receive commands, to retrieve the list of recognized commands, use:\n\n```\n{\"execute\": \"query-commands\"}\n```\n\n"
    },
    {
      "title": "Live merging of child image into parent image",
      "level": 3,
      "content": "It is possible to merge a running snapshot into its parent by issuing a block-commit command. In its simplest form the following line will commit the child into its parent:\n\n```\n{\"execute\": \"block-commit\", \"arguments\": {\"device\": \"devicename\"}}\n```\n\nUpon reception of this command, the handler looks for the base image and converts it from read only to read write mode and then runs the commit job.\n\nOnce the block-commit operation has completed, the event BLOCK_JOB_READY will be emitted, signalling that the synchronization has finished. The job can then be gracefully completed by issuing the command block-job-complete:\n\n```\n{\"execute\": \"block-job-complete\", \"arguments\": {\"device\": \"devicename\"}}\n```\n\nUntil such a command is issued, the commit operation remains active. After successful completion, the base image remains in read write mode and becomes the new active layer. On the other hand, the child image becomes invalid and it is the responsibility of the user to clean it up.\n\nNote: **ide0-hd0** \n\n```\n{\"execute\": \"query-block\"}\n```\n\n```\n{\"return\": [{\"io-status\": \"ok\", \"device\": \"ide0-hd0\", \"locked\": false, \"removable\": false, \"inserted\": {\"iops_rd\": 0, \"detect_zeroes\": \"off\", \"image\": {\"backing-image\": {\"virtual-size\": 27074281472, \"filename\": \"parent.qcow2\", ... }\n```\n\n"
    },
    {
      "title": "Live creation of a new snapshot",
      "level": 3,
      "content": "To create a new snapshot out of a running image, run the command:\n\n```\n{\"execute\": \"blockdev-snapshot-sync\", \"arguments\": {\"device\": \"devicename\",\"snapshot-file\": \"new_snapshot_name.qcow2\"}}\n```\n\nThis creates an overlay file named new_snapshot_name.qcow2 which then becomes the new active layer.\n\n"
    },
    {
      "title": "Improve virtual machine performance",
      "level": 3,
      "content": "There are a number of techniques that you can use to improve the performance of the virtual machine. For example:\n\n- Apply #Enabling KVM for full virtualization.\n- Use the -cpu host option to make QEMU emulate the host's exact CPU rather than a more generic CPU.\n- Especially for Windows guests, enable Hyper-V enlightenments: -cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time. See the QEMU documentation for more information and flags.\n- multiple cores can be assigned to the guest using the -smp cores=x,threads=y,sockets=1,maxcpus=z option. The threads parameter is used to assign SMT cores. Leaving a physical core for QEMU, the hypervisor and the host system to operate unimpeded is highly beneficial.\n- Make sure you have assigned the virtual machine enough memory. By default, QEMU only assigns 128 MiB of memory to each virtual machine. Use the -m option to assign more memory. For example, -m 1024 runs a virtual machine with 1024 MiB of memory.\n- If supported by drivers in the guest operating system, use virtio for network and/or block devices, see #Using virtio drivers.\n- Use TAP devices instead of user-mode networking, see #Tap networking with QEMU.\n- If the guest OS is doing heavy writing to its disk, you may benefit from certain mount options on the host's file system. For example, you can mount an ext4 file system with the option barrier=0. You should read the documentation for any options that you change because sometimes performance-enhancing options for file systems come at the cost of data integrity.\n- If you have a raw disk or partition, you may want to disable the cache: $ qemu-system-x86_64 -drive file=/dev/disk,if=virtio,cache=none\n- Use the native Linux AIO: $ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on\n- If you are running multiple virtual machines concurrently that all have the same operating system installed, you can save memory by enabling kernel same-page merging. See #Enabling KSM.\n- In some cases, memory can be reclaimed from running virtual machines by running a memory ballooning driver in the guest operating system. See #Memory ballooning.\n- It is possible to use a emulation layer for an ICH-9 AHCI controller (although it may be unstable). The AHCI emulation supports NCQ, so multiple read or write requests can be outstanding at the same time: $ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0\n\n```\n$ qemu-system-x86_64 -drive file=/dev/disk,if=virtio,cache=none\n```\n\n```\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on\n```\n\n```\n$ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0\n```\n\nSee https://www.linux-kvm.org/page/Tuning_KVM for more information.\n\n"
    },
    {
      "title": "Using any real partition as the single primary partition of a hard disk image",
      "level": 3,
      "content": "Sometimes, you may wish to use one of your system partitions from within QEMU. Using a raw partition for a virtual machine will improve performance, as the read and write operations do not go through the file system layer on the physical host. Such a partition also provides a way to share data between the host and guest.\n\nIn Arch Linux, device files for raw partitions are, by default, owned by root and the disk group. If you would like to have a non-root user be able to read and write to a raw partition, you must either change the owner of the partition's device file to that user, add that user to the disk group, or use ACL for more fine-grained access control.\n\n- Although it is possible, it is not recommended to allow virtual machines to alter critical data on the host system, such as the root partition.\n- You must not mount a file system on a partition read-write on both the host and the guest at the same time. Otherwise, data corruption will result.\n\nAfter doing so, you can attach the partition to a QEMU virtual machine as a virtual disk.\n\nHowever, things are a little more complicated if you want to have the entire virtual machine contained in a partition. In that case, there would be no disk image file to actually boot the virtual machine since you cannot install a boot loader to a partition that is itself formatted as a file system and not as a partitioned device with an MBR. Such a virtual machine can be booted either by: #Specifying kernel and initrd manually, #Simulating a virtual disk with MBR, #Using the device-mapper, #Using a linear RAID or #Using a Network Block Device.\n\n"
    },
    {
      "title": "Specifying kernel and initrd manually",
      "level": 4,
      "content": "QEMU supports loading Linux kernels and init ramdisks directly, thereby circumventing boot loaders such as GRUB. It then can be launched with the physical partition containing the root file system as the virtual disk, which will not appear to be partitioned. This is done by issuing a command similar to the following:\n\nNote: **host's** \n\n```\n$ qemu-system-x86_64 -kernel /boot/vmlinuz-linux -initrd /boot/initramfs-linux.img -append root=/dev/sda /dev/sda3\n```\n\nIn the above example, the physical partition being used for the guest's root file system is /dev/sda3 on the host, but it shows up as /dev/sda on the guest.\n\nYou may, of course, specify any kernel and initrd that you want, and not just the ones that come with Arch Linux.\n\nWhen there are multiple kernel parameters to be passed to the -append option, they need to be quoted using single or double quotes. For example:\n\n```\n... -append 'root=/dev/sda1 console=ttyS0'\n```\n\n"
    },
    {
      "title": "Simulating a virtual disk with MBR",
      "level": 4,
      "content": "A more complicated way to have a virtual machine use a physical partition, while keeping that partition formatted as a file system and not just having the guest partition the partition as if it were a disk, is to simulate an MBR for it so that it can boot using a boot loader such as GRUB.\n\nFor the following, suppose you have a plain, unmounted /dev/hdaN partition with some file system on it you wish to make part of a QEMU disk image. The trick is to dynamically prepend a master boot record (MBR) to the real partition you wish to embed in a QEMU raw disk image. More generally, the partition can be any part of a larger simulated disk, in particular a block device that simulates the original physical disk but only exposes /dev/hdaN to the virtual machine.\n\nA virtual disk of this type can be represented by a VMDK file that contains references to (a copy of) the MBR and the partition, but QEMU does not support this VMDK format. For instance, a virtual disk created by\n\n```\n$ VBoxManage internalcommands createrawvmdk -filename /path/to/file.vmdk -rawdisk /dev/hda\n```\n\nwill be rejected by QEMU with the error message\n\n```\nUnsupported image type 'partitionedDevice'\n```\n\nNote that VBoxManage creates two files, file.vmdk and file-pt.vmdk, the latter being a copy of the MBR, to which the text file file.vmdk points. Read operations outside the target partition or the MBR would give zeros, while written data would be discarded.\n\nA method that is similar to the use of a VMDK descriptor file uses the device-mapper to prepend a loop device attached to the MBR file to the target partition. In case we do not need our virtual disk to have the same size as the original, we first create a file to hold the MBR:\n\n```\n$ dd if=/dev/zero of=/path/to/mbr count=2048\n```\n\nHere, a 1 MiB (2048 * 512 bytes) file is created in accordance with partition alignment policies used by modern disk partitioning tools. For compatibility with older partitioning software, 63 sectors instead of 2048 might be required. The MBR only needs a single 512 bytes block, the additional free space can be used for a BIOS boot partition and, in the case of a hybrid partitioning scheme, for a GUID Partition Table. Then, we attach a loop device to the MBR file:\n\n```\n# losetup --show -f /path/to/mbr\n```\n\n```\n/dev/loop0\n```\n\nIn this example, the resulting device is /dev/loop0. The device mapper is now used to join the MBR and the partition:\n\n```\n# echo \"0 2048 linear /dev/loop0 0\n2048 `blockdev --getsz /dev/hdaN` linear /dev/hdaN 0\" | dmsetup create qemu\n```\n\nThe resulting /dev/mapper/qemu is what we will use as a QEMU raw disk image. Additional steps are required to create a partition table (see the section that describes the use of a linear RAID for an example) and boot loader code on the virtual disk (which will be stored in /path/to/mbr).\n\nThe following setup is an example where the position of /dev/hdaN on the virtual disk is to be the same as on the physical disk and the rest of the disk is hidden, except for the MBR, which is provided as a copy:\n\n```\n# dd if=/dev/hda count=1 of=/path/to/mbr\n# loop=`losetup --show -f /path/to/mbr`\n# start=`blockdev --report /dev/hdaN | tail -1 | awk '{print $5}'`\n# size=`blockdev --getsz /dev/hdaN`\n# disksize=`blockdev --getsz /dev/hda`\n# echo \"0 1 linear $loop 0\n1 $((start-1)) zero\n$start $size linear /dev/hdaN 0\n$((start+size)) $((disksize-start-size)) zero\" | dmsetup create qemu\n```\n\nThe table provided as standard input to dmsetup has a similar format as the table in a VMDK descriptor file produced by VBoxManage and can alternatively be loaded from a file with dmsetup create qemu --table table_file. To the virtual machine, only /dev/hdaN is accessible, while the rest of the hard disk reads as zeros and discards written data, except for the first sector. We can print the table for /dev/mapper/qemu with dmsetup table qemu (use udevadm info -rq name /sys/dev/block/major:minor to translate major:minor to the corresponding /dev/blockdevice name). Use dmsetup remove qemu and losetup -d $loop to delete the created devices.\n\nA situation where this example would be useful is an existing Windows XP installation in a multi-boot configuration and maybe a hybrid partitioning scheme (on the physical hardware, Windows XP could be the only operating system that uses the MBR partition table, while more modern operating systems installed on the same computer could use the GUID Partition Table). Windows XP supports hardware profiles, so that that the same installation can be used with different hardware configurations alternatingly (in this case bare metal vs. virtual) with Windows needing to install drivers for newly detected hardware only once for every profile. Note that in this example the boot loader code in the copied MBR needs to be updated to directly load Windows XP from /dev/hdaN instead of trying to start the multi-boot capable boot loader (like GRUB) present in the original system. Alternatively, a copy of the boot partition containing the boot loader installation can be included in the virtual disk the same way as the MBR.\n\nYou can also do this using software RAID in linear mode (you need the linear.ko kernel driver) and a loopback device:\n\nFirst, you create some small file to hold the MBR:\n\n```\n$ dd if=/dev/zero of=/path/to/mbr count=32\n```\n\nHere, a 16 KiB (32 * 512 bytes) file is created. It is important not to make it too small (even if the MBR only needs a single 512 bytes block), since the smaller it will be, the smaller the chunk size of the software RAID device will have to be, which could have an impact on performance. Then, you setup a loopback device to the MBR file:\n\n```\n# losetup -f /path/to/mbr\n```\n\nLet us assume the resulting device is /dev/loop0, because we would not already have been using other loopbacks. Next step is to create the \"merged\" MBR + /dev/hdaN disk image using software RAID:\n\n```\n# modprobe linear\n# mdadm --build --verbose /dev/md0 --chunk=16 --level=linear --raid-devices=2 /dev/loop0 /dev/hdaN\n```\n\nThe resulting /dev/md0 is what you will use as a QEMU raw disk image (do not forget to set the permissions so that the emulator can access it). The last (and somewhat tricky) step is to set the disk configuration (disk geometry and partitions table) so that the primary partition start point in the MBR matches the one of /dev/hdaN inside /dev/md0 (an offset of exactly 16 * 512 = 16384 bytes in this example). Do this using fdisk on the host machine, not in the emulator: the default raw disc detection routine from QEMU often results in non-kibibyte-roundable offsets (such as 31.5 KiB, as in the previous section) that cannot be managed by the software RAID code. Hence, from the host:\n\n```\n# fdisk /dev/md0\n```\n\nPress X to enter the expert menu. Set number of 's'ectors per track so that the size of one cylinder matches the size of your MBR file. For two heads and a sector size of 512, the number of sectors per track should be 16, so we get cylinders of size 2x16x512=16k.\n\nNow, press R to return to the main menu.\n\nPress P and check that the cylinder size is now 16k.\n\nNow, create a single primary partition corresponding to /dev/hdaN. It should start at cylinder 2 and end at the end of the disk (note that the number of cylinders now differs from what it was when you entered fdisk.\n\nFinally, 'w'rite the result to the file: you are done. You now have a partition you can mount directly from your host, as well as part of a QEMU disk image:\n\n```\n$ qemu-system-x86_64 -hdc /dev/md0 [...]\n```\n\nYou can, of course, safely set any boot loader on this disk image using QEMU, provided the original /dev/hdaN partition contains the necessary tools.\n\nWith Network Block Device, Linux can use a remote server as one of its block device. You may use nbd-server (from the nbd package) to create an MBR wrapper for QEMU.\n\nAssuming you have already set up your MBR wrapper file like above, rename it to wrapper.img.0. Then create a symbolic link named wrapper.img.1 in the same directory, pointing to your partition. Then put the following script in the same directory:\n\n```\n#!/bin/sh\ndir=\"$(realpath \"$(dirname \"$0\")\")\"\ncat >wrapper.conf <<EOF\n[generic]\nallowlist = true\nlistenaddr = 127.713705\nport = 10809\n\n[wrap]\nexportname = $dir/wrapper.img\nmultifile = true\nEOF\n\nnbd-server \\\n    -C wrapper.conf \\\n    -p wrapper.pid \\\n    \"$@\"\n```\n\nThe .0 and .1 suffixes are essential; the rest can be changed. After running the above script (which you may need to do as root to make sure nbd-server is able to access the partition), you can launch QEMU with:\n\n```\nqemu-system-x86_64 -drive file=nbd:127.713705:10809:exportname=wrap [...]\n```\n\n"
    },
    {
      "title": "With libvirt",
      "level": 4,
      "content": "If a virtual machine is set up with libvirt, it can be configured with virsh autostart or through the virt-manager GUI to start at host boot by going to the Boot Options for the virtual machine and selecting \"Start virtual machine on host boot up\".\n\n"
    },
    {
      "title": "With systemd service",
      "level": 4,
      "content": "To run QEMU virtual machines on boot, you can use following systemd unit and config.\n\n```\n/etc/systemd/system/qemu@.service\n```\n\n```\n[Unit]\nDescription=QEMU virtual machine\n\n[Service]\nEnvironment=\"haltcmd=kill -INT $MAINPID\"\nEnvironmentFile=/etc/conf.d/qemu.d/%i\nExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args\nExecStop=/usr/bin/bash -c ${haltcmd}\nExecStop=/usr/bin/bash -c 'while nc localhost 7100; do sleep 1; done'\n\n[Install]\nWantedBy=multi-user.target\n```\n\nThen create per-VM configuration files, named /etc/conf.d/qemu.d/vm_name, with the variables args and haltcmd set. Example configs:\n\n```\n/etc/conf.d/qemu.d/one\n```\n\n```\nargs=\"-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \\\n -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0\"\n\nhaltcmd=\"echo 'system_powerdown' | nc localhost 7100\" # or netcat/ncat\n```\n\n```\n/etc/conf.d/qemu.d/two\n```\n\n```\nargs=\"-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1\"\n\nhaltcmd=\"ssh powermanager@vm2 sudo poweroff\"\n```\n\nThe description of the variables is the following:\n\n- args - QEMU command line arguments to be used.\n- haltcmd - Command to shut down a virtual machine safely. In the first example, the QEMU monitor is exposed via telnet using -monitor telnet:.. and the virtual machines are powered off via ACPI by sending system_powerdown to monitor with the nc command. In the other example, SSH is used.\n\nTo set which virtual machines will start on boot-up, enable the qemu@vm_name.service systemd unit.\n\n"
    },
    {
      "title": "Mouse integration",
      "level": 3,
      "content": "To prevent the mouse from being grabbed when clicking on the guest operating system's window, add the options -usb -device usb-tablet. This means QEMU is able to report the mouse position without having to grab the mouse. This also overrides PS/2 mouse emulation when activated. For example:\n\n```\n$ qemu-system-x86_64 -hda disk_image -m 512 -usb -device usb-tablet\n```\n\nIf that does not work, try using -vga qxl parameter, also look at the instructions #Mouse cursor is jittery or erratic.\n\n"
    },
    {
      "title": "Pass-through host USB device",
      "level": 3,
      "content": "It is possible to access the physical device connected to a USB port of the host from the guest. The first step is to identify where the device is connected, this can be found running the lsusb command. For example:\n\n```\n$ lsusb\n```\n\n```\n...\nBus 003 Device 007: ID 0781:5406 SanDisk Corp. Cruzer Micro U3\n```\n\nThe outputs in bold above will be useful to identify respectively the host_bus and host_addr or the vendor_id and product_id.\n\nIn qemu, the idea is to emulate an EHCI (USB 2) or XHCI (USB 1.1 USB 2 USB 3) controller with the option -device usb-ehci,id=ehci or -device qemu-xhci,id=xhci respectively and then attach the physical device to it with the option -device usb-host,... We will consider that controller_id is either ehci or xhci for the rest of this section.\n\nThen, there are two ways to connect to the USB of the host with qemu:\n\n1. Identify the device and connect to it on any bus and address it is attached to on the host, the generic syntax is: -device usb-host,bus=controller_id.0,vendorid=0xvendor_id,productid=0xproduct_idApplied to the device used in the example above, it becomes:-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,vendorid=0x0781,productid=0x5406One can also add the ...,port=port_number setting to the previous option to specify in which physical port of the virtual controller the device should be attached, useful in the case one wants to add multiple USB devices to the virtual machine. Another option is to use the new hostdevice property of usb-host which is available since QEMU 5.1.0, the syntax is: -device qemu-xhci,id=xhci -device usb-host,hostdevice=/dev/bus/usb/003/007\n1. Attach whatever is connected to a given USB bus and address, the syntax is:-device usb-host,bus=controller_id.0,hostbus=host_bus,host_addr=host_addrApplied to the bus and the address in the example above, it becomes:-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,hostbus=3,hostaddr=7\n\n```\n-device usb-host,bus=controller_id.0,vendorid=0xvendor_id,productid=0xproduct_id\n```\n\n```\n-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,vendorid=0x0781,productid=0x5406\n```\n\n```\n-device qemu-xhci,id=xhci -device usb-host,hostdevice=/dev/bus/usb/003/007\n```\n\n```\n-device usb-host,bus=controller_id.0,hostbus=host_bus,host_addr=host_addr\n```\n\n```\n-device usb-ehci,id=ehci -device usb-host,bus=ehci.0,hostbus=3,hostaddr=7\n```\n\nSee QEMU/USB emulation for more information.\n\n"
    },
    {
      "title": "USB redirection with SPICE",
      "level": 3,
      "content": "When using #SPICE it is possible to redirect USB devices from the client to the virtual machine without needing to specify them in the QEMU command. It is possible to configure the number of USB slots available for redirected devices (the number of slots will determine the maximum number of devices which can be redirected simultaneously). The main advantages of using SPICE for redirection compared to the previously-mentioned -usbdevice method is the possibility of hot-swapping USB devices after the virtual machine has started, without needing to halt it in order to remove USB devices from the redirection or adding new ones. This method of USB redirection also allows us to redirect USB devices over the network, from the client to the server. In summary, it is the most flexible method of using USB devices in a QEMU virtual machine.\n\nWe need to add one EHCI/UHCI controller per available USB redirection slot desired as well as one SPICE redirection channel per slot. For example, adding the following arguments to the QEMU command you use for starting the virtual machine in SPICE mode will start the virtual machine with three available USB slots for redirection:\n\n```\n-device ich9-usb-ehci1,id=usb \\\n-device ich9-usb-uhci1,masterbus=usb.0,firstport=0,multifunction=on \\\n-device ich9-usb-uhci2,masterbus=usb.0,firstport=2 \\\n-device ich9-usb-uhci3,masterbus=usb.0,firstport=4 \\\n-chardev spicevmc,name=usbredir,id=usbredirchardev1 -device usb-redir,chardev=usbredirchardev1,id=usbredirdev1 \\\n-chardev spicevmc,name=usbredir,id=usbredirchardev2 -device usb-redir,chardev=usbredirchardev2,id=usbredirdev2 \\\n-chardev spicevmc,name=usbredir,id=usbredirchardev3 -device usb-redir,chardev=usbredirchardev3,id=usbredirdev3\n```\n\nSee SPICE/usbredir for more information.\n\nBoth spicy from spice-gtk (Input > Select USB Devices for redirection) and remote-viewer from virt-viewer (File > USB device selection) support this feature. Please make sure that you have installed the necessary SPICE Guest Tools on the virtual machine for this functionality to work as expected (see the #SPICE section for more information).\n\n"
    },
    {
      "title": "Automatic USB forwarding with udev",
      "level": 4,
      "content": "Normally, forwarded devices must be available at the boot time of the virtual machine to be forwarded. If that device is disconnected, it will not be forwarded anymore.\n\nYou can use udev rules to automatically attach a device when it comes online. Create a hostdev entry somewhere on disk. chown it to root to prevent other users modifying it.\n\n```\n/usr/local/hostdev-mydevice.xml\n```\n\n```\n<hostdev mode='subsystem' type='usb'>\n  <source>\n    <vendor id='0x03f0'/>\n    <product id='0x4217'/>\n  </source>\n</hostdev>\n```\n\nThen create a udev rule which will attach/detach the device:\n\n```\n/usr/lib/udev/rules.d/90-libvirt-mydevice\n```\n\n```\nACTION==\"add\", \\\n    SUBSYSTEM==\"usb\", \\\n    ENV{ID_VENDOR_ID}==\"03f0\", \\\n    ENV{ID_MODEL_ID}==\"4217\", \\\n    RUN+=\"/usr/bin/virsh attach-device GUESTNAME /usr/local/hostdev-mydevice.xml\"\nACTION==\"remove\", \\\n    SUBSYSTEM==\"usb\", \\\n    ENV{ID_VENDOR_ID}==\"03f0\", \\\n    ENV{ID_MODEL_ID}==\"4217\", \\\n    RUN+=\"/usr/bin/virsh detach-device GUESTNAME /usr/local/hostdev-mydevice.xml\"\n```\n\nSource and further reading.\n\n"
    },
    {
      "title": "Enabling KSM",
      "level": 3,
      "content": "Kernel Samepage Merging (KSM) is a feature of the Linux kernel that allows for an application to register with the kernel to have its pages merged with other processes that also register to have their pages merged. The KSM mechanism allows for guest virtual machines to share pages with each other. In an environment where many of the guest operating systems are similar, this can result in significant memory savings.\n\nTo enable KSM:\n\n```\n# echo 1 > /sys/kernel/mm/ksm/run\n```\n\nTo make it permanent, use systemd's temporary files:\n\n```\n/etc/tmpfiles.d/ksm.conf\n```\n\n```\nw /sys/kernel/mm/ksm/run - - - - 1\n```\n\nIf KSM is running, and there are pages to be merged (i.e. at least two similar virtual machines are running), then /sys/kernel/mm/ksm/pages_shared should be non-zero. See https://docs.kernel.org/admin-guide/mm/ksm.html for more information.\n\n```\n$ grep -r . /sys/kernel/mm/ksm/\n```\n\n"
    },
    {
      "title": "Multi-monitor support",
      "level": 3,
      "content": "The Linux QXL driver supports four heads (virtual screens) by default. This can be changed via the qxl.heads=N kernel parameter.\n\nThe default VGA memory size for QXL devices is 16M (VRAM size is 64M). This is not sufficient if you would like to enable two 1920x1200 monitors since that requires 2 × 1920 × 4 (color depth) × 1200 = 17.6 MiB VGA memory. This can be changed by replacing -vga qxl by -vga none -device qxl-vga,vgamem_mb=32. If you ever increase vgamem_mb beyond 64M, then you also have to increase the vram_size_mb option.\n\n"
    },
    {
      "title": "Custom display resolution",
      "level": 3,
      "content": "A custom display resolution can be set with -device VGA,edid=on,xres=1280,yres=720 (see EDID and display resolution).\n\n"
    },
    {
      "title": "SPICE",
      "level": 4,
      "content": "One way to share the clipboard between the host and the guest is to enable the SPICE remote desktop protocol and access the client with a SPICE client. One needs to follow the steps described in #SPICE. A guest run this way will support copy paste with the host.\n\n"
    },
    {
      "title": "qemu-vdagent",
      "level": 4,
      "content": "QEMU provides its own implementation of the spice vdagent chardev called qemu-vdagent. It interfaces with the spice-vdagent guest service and allows the guest and host share a clipboard.\n\nTo access this shared clipboard with QEMU's GTK display, you will need to compile QEMU from source with the --enable-gtk-clipboard configure parameter. It is sufficient to replace the installed qemu-ui-gtk package.\n\n- Feature request FS#79716 submitted to enable the functionality in the official package.\n- The shared clipboard in qemu-ui-gtk has been pushed back to experimental as it can freeze guests under certain circumstances. A fix has been proposed to solve the issue upstream.\n\nAdd the following QEMU command line arguments:\n\n```\n-device virtio-serial,packed=on,ioeventfd=on\n-device virtserialport,name=com.redhat.spice.0,chardev=vdagent0\n-chardev qemu-vdagent,id=vdagent0,name=vdagent,clipboard=on,mouse=off\n```\n\nThese arguments are also valid if converted to libvirt form.\n\nOn linux guests, you may start the spice-vdagent.service user unit manually. On Windows guests, set the spice-agent startup type to automatic.\n\n"
    },
    {
      "title": "Windows-specific notes",
      "level": 3,
      "content": "QEMU can run any version of Windows from Windows 95 through Windows 11.\n\nIt is possible to run Windows PE in QEMU.\n\n"
    },
    {
      "title": "Fast startup",
      "level": 4,
      "content": "For Windows 8 (or later) guests it is better to disable \"Turn on fast startup (recommended)\" from the Power Options of the Control Panel as explained in the following forum page, as it causes the guest to hang during every other boot.\n\nFast Startup may also need to be disabled for changes to the -smp option to be properly applied.\n\n"
    },
    {
      "title": "Remote Desktop Protocol",
      "level": 4,
      "content": "If you use a MS Windows guest, you might want to use RDP to connect to your guest virtual machine. If you are using a VLAN or are not in the same network as the guest, use:\n\n```\n$ qemu-system-x86_64 -nographic -nic user,hostfwd=tcp::5555-:3389\n```\n\nThen connect with either rdesktop or freerdp to the guest. For example:\n\n```\n$ xfreerdp -g 2048x1152 localhost:5555 -z -x lan\n```\n\n"
    },
    {
      "title": "Clone Linux system installed on physical equipment",
      "level": 3,
      "content": "Linux system installed on physical equipment can be cloned for running on a QEMU virtual machine. See Clone Linux system from hardware for QEMU virtual machine\n\n"
    },
    {
      "title": "Chrooting into arm/arm64 environment from x86_64",
      "level": 3,
      "content": "Sometimes it is easier to work directly on a disk image instead of the real ARM based device. This can be achieved by mounting an SD card/storage containing the root partition and chrooting into it.\n\nAnother use case for an ARM chroot is building ARM packages on an x86_64 machine. Here, the chroot environment can be created from an image tarball from Arch Linux ARM - see [5] for a detailed description of this approach.\n\nEither way, from the chroot it should be possible to run pacman and install more packages, compile large libraries etc. Since the executables are for the ARM architecture, the translation to x86 needs to be performed by QEMU.\n\nInstall qemu-user-static on the x86_64 machine/host, and qemu-user-static-binfmt to register the qemu binaries to binfmt service.\n\nqemu-user-static is used to allow the execution of compiled programs from other architectures. This is similar to what is provided by qemu-emulators-full, but the \"static\" variant is required for chroot. Examples:\n\n```\nqemu-arm-static path_to_sdcard/usr/bin/ls\nqemu-aarch64-static path_to_sdcard/usr/bin/ls\n```\n\nThese two lines execute the ls command compiled for 32-bit ARM and 64-bit ARM respectively. Note that this will not work without chrooting, because it will look for libraries not present in the host system.\n\nqemu-user-static-binfmt allows automatically prefixing the ARM executable with qemu-arm-static or qemu-aarch64-static.\n\nMake sure that the ARM executable support is active:\n\n```\n$ ls /proc/sys/fs/binfmt_misc\n```\n\n```\nqemu-aarch64  qemu-arm\t  qemu-cris  qemu-microblaze  qemu-mipsel  qemu-ppc64\t    qemu-riscv64  qemu-sh4    qemu-sparc\tqemu-sparc64  status\nqemu-alpha    qemu-armeb  qemu-m68k  qemu-mips\t      qemu-ppc\t   qemu-ppc64abi32  qemu-s390x\t  qemu-sh4eb  qemu-sparc32plus\tregister\n```\n\nEach executable must be listed.\n\nIf it is not active, restart systemd-binfmt.service.\n\nMount the SD card to /mnt/sdcard (the device name may be different).\n\n```\n# mount --mkdir /dev/mmcblk0p2 /mnt/sdcard\n```\n\nMount boot partition if needed (again, use the suitable device name):\n\n```\n# mount /dev/mmcblk0p1 /mnt/sdcard/boot\n```\n\nFinally chroot into the SD card root as described in Change root#Using chroot:\n\n```\n# chroot /mnt/sdcard /bin/bash\n```\n\nAlternatively, you can use arch-chroot from arch-install-scripts, as it will provide an easier way to get network support:\n\n```\n# arch-chroot /mnt/sdcard /bin/bash\n```\n\nYou can also use systemd-nspawn to chroot into the ARM environment:\n\n```\n# systemd-nspawn -D /mnt/sdcard -M myARMMachine --bind-ro=/etc/resolv.conf\n```\n\n--bind-ro=/etc/resolv.conf is optional and gives a working network DNS inside the chroot\n\n"
    },
    {
      "title": "sudo in chroot",
      "level": 4,
      "content": "If you install sudo in the chroot and receive the following error when trying to use it:\n\n```\nsudo: effective uid is not 0, is /usr/bin/sudo on a file system with the 'nosuid' option set or an NFS file system without root privileges?\n```\n\nthen you may need to modify the binfmt flags, for example for aarch64:\n\n```\n# cp /usr/lib/binfmt.d/qemu-aarch64-static.conf /etc/binfmt.d/\n# vi /etc/binfmt.d/qemu-aarch64-static.conf\n```\n\nand add a C at the end of this file:\n\n```\n:qemu-aarch64:M::\\x7fELF\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xb7\\x00:\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff:/usr/bin/qemu-aarch64-static:FPC\n```\n\nThen restart systemd-binfmt.service and check that the changes have taken effect (note the C on the flags line):\n\n```\n# cat /proc/sys/fs/binfmt_misc/qemu-aarch64\n```\n\n```\nenabled\ninterpreter /usr/bin/qemu-aarch64-static\nflags: POCF\noffset 0\nmagic 7f454c460201010000000000000000000200b700\nmask ffffffffffffff00fffffffffffffffffeffffff\n```\n\nSee the \"flags\" section of the kernel binfmt documentation for more information.\n\n"
    },
    {
      "title": "Not grabbing mouse input",
      "level": 3,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nTablet mode has side effect of not grabbing mouse input in QEMU window:\n\n```\n-usb -device usb-tablet\n```\n\nIt works with several -vga backends one of which is virtio.\n\n"
    },
    {
      "title": "Troubleshooting",
      "level": 2,
      "content": "See QEMU/Troubleshooting.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Official QEMU website\n- Official KVM website\n- QEMU Emulator User Documentation\n- QEMU Wikibook\n- Hardware virtualization with QEMU by AlienBOB (last updated in 2008)\n- Building a Virtual Army by Falconindy\n- QEMU documentation\n- QEMU on Windows\n- Wikipedia\n- Debian Wiki - QEMU\n- Networking QEMU Virtual BSD Systems\n- QEMU on gnu.org\n- QEMU on FreeBSD as host\n- Managing Virtual Machines with QEMU - openSUSE documentation\n- KVM on IBM Knowledge Center\n\n"
    }
  ]
}