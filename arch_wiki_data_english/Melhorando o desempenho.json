{
  "title": "Melhorando o desempenho",
  "url": "https://wiki.archlinux.org/title/Melhorando_o_desempenho",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- /Processo de inicialização\n- Pacman/Dicas e truques#Desempenho\n- OpenSSH#Speeding up SSH\n- Openoffice#Speed up OpenOffice\n- Laptop (Português)\n- Preload (Português)\n\nEste artigo oferece informação sobre diagnósticos básicos do sistema relacionados com desempenho e também passos que podem ser tomados para reduzir o consumo de recursos ou otimizar o sistema com o objetivo final de melhorias perceptíveis ou documentadas.\n\n"
    },
    {
      "title": "Conheça o seu sistema",
      "level": 3,
      "content": "A melhor maneira de aprimorar um sistema é ter como alvo os gargalos, ou subsistemas que limitam o desempenho médio. As especificações do sistema podem ajudar a identificá-las.\n\n- Se o computador se torna lento quando aplicações grandes (como LibreOffice e Firefox) rodam ao mesmo tempo, verifique se a quantidade de RAM é suficiente. Use o seguinte comando e verifique a coluna \"available\" (ou \"disponível\" em português):\n\n```\n$ free -h\n```\n\n- Se a inicialização é lenta, e programas demoram muito tempo para carregar na primeira vez (apenas) que são executados, então possivelmente é culpa do disco rígido. A velocidade dele pode ser mensurada com o comando hdparm:\n\n```\n# hdparm -t /dev/sdX\n```\n\n- Se o carregamento da CPU é consistemente alto até mesmo com bastante RAM disponível, tente diminuir o uso da CPU ao desabilitar daemons que estão rodando e/ou processos. Isto pode ser monitorado de algumas formas, por exemplo com htop, pstree ou qualquer outra ferramenta de monitoração do sistema:\n\n```\n$ htop\n```\n\n- Se aplicações usam renderização direta estão lentas (exemplo, estas que usam a GPU, tais como players de vídeo, jogos, ou até mesmo um gerenciador de janelas), então melhorar o desempenho da GPU deve ajudar. O primeiro passo é verificar se a renderização direta está habilitada. Isto é indicado pelo comando glxinfo, parte do pacote mesa-utils:\n\n```\n$ glxinfo | grep \"direct rendering\"\n```\n\n```\ndirect rendering: Yes\n```\n\n- Ao usar um ambiente de desktop, desabilitar efeitos visuais (não usados) pode reduzir o uso da GPU. Use um ambiente mais leve ou crie um personalizado, se o atual não é compatível com seu hardware e/ou preferências pessoais.\n\n"
    },
    {
      "title": "Fazer benchmark",
      "level": 3,
      "content": "Os efeitos de otimização são normalmente dificieis de julgar. No entanto estes podem ser mensurados por ferramentas de benchmark.\n\n"
    },
    {
      "title": "Múltiplas conexões de hardware",
      "level": 3,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nUm caminho interno do hardware é como o dispositivo de armazenamento é conectado para sua placa-mãe. Existem diferentes maneiras de se conectar a ela como: TCP/IP atravês de uma NIC, plugado diretamente com PCIe/PCI, Fireware, Raid Card, USB, etc. Ao espalhar seus dispositivos de armazenamento por estes múltiplos pontos de conexão, você maximiza as capacidades de sua placa-mãe, por exemplo 6 discos rígidos conectados por USB devem ser bem mais lentos que 3 pelo USB e 3 pelo Firewire. O motivo disso é que cada conexão de entrada na placa-mãe é como um tubo, e existe um limite de quanto você pode transmitir por vez. A boa notícia é que ela normalmente tem vários tubos.\n\nMais exemplos\n\n1. Diretamente na placa-mãe usando PCI/PCIe/ATA\n1. Usando uma capa externa para guardar o disco por USB/Firewire\n1. Jogar o dispositivo no dispositivo de armazenamento da rede ao conectar com TCP/IP\n\nNote também que se você tem duas portas USB na frente da sua máquina, e 4 portas USB atrás, e possui 4 discos, deve ser mais rápido/eficiente colocar 2 na frente e 2 atrás do que 3 atrás e 1 na frente. Devido a portas da frente provavelmente possuírem um Hub USB separado, significando que você pode enviar duas vezes mais dados do que somente usar 1. Use os seguintes comandos para determinar as várias conexões de hardware de sua máquina.\n\n```\nUSB Device Tree\n```\n\n```\n$ lsusb -t\n```\n\n```\nPCI Device Tree\n```\n\n```\n$ lspci -tv\n```\n\n"
    },
    {
      "title": "Particionamento",
      "level": 3,
      "content": "Garanta que suas partições estão apropriadamente alinhadas.\n\n"
    },
    {
      "title": "Múltiplas unidades de armazenamento",
      "level": 4,
      "content": "Se você têm múltiplos discos disponíveis, você pode configurar um RAID de software para sérias melhorias na velocidade.\n\nCriar uma swap em um disco separado pode ajudar, especialmente se sua máquina envia dados frequentemente para a swap.\n\n"
    },
    {
      "title": "Particionamento em HDDs",
      "level": 4,
      "content": "Se você está usando o tradicional HDD rotacional, seu particionamento pode influenciar a performance do sistema. Setores no começo do disco (mais próximos de fora do disco) são mais rápidos que estes no fim. Também, uma menor partição precisa de menos movimentos da cabeça da unidade de armazenamento, e consequentemente acelera as operações no disco. É recomendado criar partições menores (10GB, mais ou menos dependendo de suas necessidades) somente para seu sistema, tão próximo do começo do disco quanto possível. Outros dados (imagens, vídeos) devem ser mantidos em uma partição separada, isto normalmente é feito ao separar o diretório home (/home/usuário) do sistema (/).\n\n"
    },
    {
      "title": "Escolhendo e aumentando o desempenho do seu sistema de arquivos",
      "level": 3,
      "content": "Escolher o melhor sistema de arquivos para seu sistema específico é muito importante, pois cada um tem suas especificidades. Os artigos dos sistemas de arquivos oferecem um pequeno sumário dos mais populares. Você pode também encontrar artigos relevantes em Category:File systems (Português).\n\n"
    },
    {
      "title": "Opções de montagem",
      "level": 4,
      "content": "A opção noatime é conhecida por melhorar o desempenho de sistemas de arquivos.\n\nOutras opções são específicas para cada sistema de arquivos, então veja os artigos relevantes de cada um deles:\n\n- Ext3\n- Ext4#Melhorando o desempenho\n- JFS Filesystem#Optimizations\n- XFS (Português)#Desempenho\n- Btrfs (Português)#Desfragmentação, Btrfs (Português)#Compressão, e btrfs(5)\n- ZFS (Português)#Refinamento\n\nA opção de montagem data=writeback melhora a velocidade, mas pode corromper dados durante uma queda de energia. A opção de montagem notail aumenta o espaço usado pelo sistema de arquivos por volta de 5%, mas melhora o desempenho geral. Você pode reduzir o carregamento do disco ao colocar o journal e dados em unidades de armazenamento separadas. Isto é feito ao criar o sistema de arquivos:\n\n```\n# mkreiserfs –j /dev/sda1 /dev/sdb1\n```\n\nSubstitua o /dev/sda1 com a partição reservada para o journal, e /dev/sdb1 com a partição para dados. Você pode aprender mais sobre reiserfs com este artigo.\n\n"
    },
    {
      "title": "Parâmetros do kernel que melhoram o desempenho",
      "level": 3,
      "content": "Existem algumas chaves habilitáveis que afetam positivamente o desempenho de dispositivos de bloco, veja sysctl#Virtual memory para mais informações.\n\n"
    },
    {
      "title": "Informações básicas",
      "level": 4,
      "content": "O escalonador (scheduler) de entrada/saída (E/S) (input/output ou I/O, em inglês) é o componente do kernel que decide em que ordem as operações de bloco de E/S são submetidas para dispositivos de armazenamento. É útil se lembrar de algumas especificações dos dois principais tipos de unidades de armazenamento devido ao objetivo do escalonador de E/S, que é otimizar a maneira de lidar com os pedidos de leitura:\n\n- Um HDD tem discos giratórios e uma cabeça que se move fisicamente para a localização solicitada. Latência randômica é muito alta estando entre 3 e 12ms (não importando se é um dispositivo de armazenamento de um servidor de última geração ou de notebook e ignorando o buffer de escrita controlador do disco) enquanto o acesso sequencial oferece uma taxa de transferência muito maior. O HDD típico faz em torno de 200 operações de E/S por segundo (IOPS, I/O operations per second).\n\n- Um SSD não tem partes móveis, acesso randômico é tão rápido quanto sequencial, tipicamente abaixo de 0.1ms, e pode manusear múltiplas solicitações concorrentes. A velocidade de saída do SSD típico é maior que 10.000 IOPS, que é mais do que o necessário para situações comuns de grande trabalho.\n\nSe existem muitos processos fazendo solicitações de E/S para diferentes partes do armazenamento, milhares de IOPS podem ser gerados enquanto o HDD típico pode manusear em torno de somente 200 IOPS. Existe uma fila de solicitações que terão de esperar para acessar o disco. Esta situação é onde escalonadores de E/S entram com a tarefa de otimização.\n\n"
    },
    {
      "title": "Os algoritmos de escalonamento de processos",
      "level": 4,
      "content": "Uma maneira de melhorar a taxa de transferência é linearizar o acesso: ao ordenar as solicitações ociosas por seu endereço lógico e agrupar os mais próximos. Historicamente isto foi o primeiro escalonador de E/S chamado elevator (elevador).\n\nUm problema com o algoritmo elevator é sua falta de otimização para processos que fazem acessos sequenciais: lê um bloco de dados, o processa por alguns microssegundos, e então vai para o próximo. O elevator não sabe que o processo vai ler outro bloco próximo e, então, vai para a próxima solicitação de outro processo em outra localização. O escalonador de E/S anticipatory (antecipatório) supera este problema: pausa por alguns milissegundos em antecipação de outra operação de leitura próxima antes de lidar com outras solicitações.\n\nEnquanto estes escalonadores tentam melhorar a taxa de transferência total, eles podem deixar algumas solicitações sem sorte em espera por um longo período de tempo. Por exemplo, imagine que a maioria do processos fazem solicitações no começo do espaço de armazenamento enquanto um processo sem sorte faz um no final do espaço. O processo pode potencialmente ser adiado infinitamente, isto é chamado de inanição ou \"starvation\", em inglês. Pensando nesse problema, o algoritmo de deadline foi desenvolvido. Existe uma fila ordenada por endereço, similar ao elevator, mas se a solicitação fica em espera por muito tempo, ela é movida para a fila \"expired\", ordenada pelo tempo de expiração. O escalonador verifica a fila \"expired\" primeiro e processa os seus pedidos e somente então vai para a fila elevator. Note que isto tem um efeito negativo na taxa de transferência geral.\n\nO Completely Fair Queuing (CFQ) (fila completamente justa) aborda o problema diferentemente ao alocar um período fixo de tempo e um número de solicitações permitidas por vez dependendo da prioridade do processo submetendo elas. Suporta o cgroup que permite a reserva de alguma quantidade de E/S para um grupo específico de processos. É particularmente útil para hosting compartilhado e nuvem: usuários que pagam por alguns IOPS querem sua parte quando necessários. Além disso, ele fica ocioso no final da E/S síncrona, aguardando outras operações próximas, assumindo esse recurso do escalonador anticipatory e trazendo algumas melhorias. Ambos, anticipatory e elevator foram descomissionados do kernel Linux e substituídos pelas alternativas mais avançadas apresentadas nesta seção.\n\nO Budget Fair Queuing (BFQ)[link inativo 2024-12-15 ⓘ] (carteira de fila justa) é baseado no código do CFQ e trás algumas melhorias. Não garante o disco para cada processo por um período fixo de tempo mas uma \"budget\" (carteira) mensurada no número de setores para os processos e usa heurísticas. É relativamente complexo, pode ser mais adaptado a unidades de armazenamento rotacionais e SSDs lentos por causa de seu alto uso de recursos por operação, especialmente se associado com uma CPU lenta, pode diminuir o desempenho de dispositivos rápidos. O objetivo do BFQ em sistemas pessoais é esse, em tarefas interativas, o dispositivo de armazenamento é virtualmente tão responsivo quanto se estivesse ocioso. Na configuração padrão se foca em entregar a latência mais baixa do que a taxa de transferência máxima.\n\nKyber é um escalonador recente inspirado pelas técnicas de gerenciamento ativo de fila usado para roteamento de rede. A implementação é baseada em \"tokens\" que servem como um mecanismo para limitar solicitações. Um token de fila é necessário para alocar uma solicitação, para prevenir a inanição de solicitações. Um token de despacho é também necessário e limita as operações de certa prioridade para dado dispositivo. Finalmente, uma latência alvo de leitura é definida e o escalonador se otimiza para chegar nela. A implementação do algoritmo é relativamente simples e é considerada eficiente para dispositivos rápidos.\n\n"
    },
    {
      "title": "Escalonadores de E/S do kernel",
      "level": 4,
      "content": "Enquanto alguns algoritmos iniciais já foram descomissionados, o kernel oficial do Linux suporta um número de escalonadores de E/S que podem ser divididos em duas categorias:\n\n- Os multi-queue schedulers (escalonadores de filas múltiplas) estão disponíveis por padrão no kernel. O Multi-Queue Block I/O Queuing Mechanism (blk-mq), em português mecanismo de empilhamento de blocos de E/S de várias filas, mapeia solicitações de E/S para múltiplas filas, as tarefas são distribuídas pelas threads, e consequentemente, núcleos da CPU. Os seguintes escalonadores estão disponíveis: None, onde nenhum algoritmo de fila é aplicado. mq-deadline, o algoritmo do escalonador \"deadline\" (veja abaixo) para multithreads. Kyber BFQ\n\n- None, onde nenhum algoritmo de fila é aplicado.\n- mq-deadline, o algoritmo do escalonador \"deadline\" (veja abaixo) para multithreads.\n- Kyber\n- BFQ\n\n- Os single-queue schedulers (escalonadores de única fila) são datados: NOOP é o escalonador mais simples, ele insere todas as solicitações que chegam em uma simples fila FIFO e implementa a sua execução. Neste algoritmo, não existe reordenação da solicitação baseada no número do setor. Ela pode ser feita em outra camada, por exemplo no nível do dispositivo, ou se isto não importa, ignorada como em SSDs. Deadline CFQ\n\n- NOOP é o escalonador mais simples, ele insere todas as solicitações que chegam em uma simples fila FIFO e implementa a sua execução. Neste algoritmo, não existe reordenação da solicitação baseada no número do setor. Ela pode ser feita em outra camada, por exemplo no nível do dispositivo, ou se isto não importa, ignorada como em SSDs.\n- Deadline\n- CFQ\n\n"
    },
    {
      "title": "Mudando o escalonador de E/S",
      "level": 4,
      "content": "- A melhor escolha de qual escalonador usar depende de ambos, o dispositivo e o que vai ser utilizado. Também, a taxa de transferência em MB/s não é o único fator para mensurar o desempenho: tempo limite ou igualdade para processos pioram a taxa de transferência geral mas podem melhorar a responsividade do sistema. Fazer benchmark pode ser útil para indicar o desempenho de cada escalonador de E/S.\n\nPara listar os escalonadores disponíveis para um dispositivo e o atualmente ativo (em colchetes):\n\n```\n$ cat /sys/block/sda/queue/scheduler\n```\n\n```\nmq-deadline kyber [bfq] none\n```\n\nPara listar os escalonadores disponíveis para todos os dispositivos:\n\n```\n$ grep \"\" /sys/block/*/queue/scheduler\n```\n\n```\n/sys/block/pktcdvd0/queue/scheduler:none\n/sys/block/sda/queue/scheduler:mq-deadline kyber [bfq] none\n/sys/block/sr0/queue/scheduler:[mq-deadline] kyber bfq none\n```\n\nPara mudar o escalonador ativo para bfq no dispositivo sda, execute:\n\n```\n# echo bfq > /sys/block/sda/queue/scheduler\n```\n\nO processo para mudar o escalonador de E/S, dependendo se o disco é rotativo ou não, pode ser automatizado e persistir entre reinicializações. Por exemplo a regra do udev abaixo define o escalonador como none para NVMe, mq-deadline para SSD/eMMC, e bfq para unidades de armazenamento rotativas:\n\n```\n/etc/udev/rules.d/60-ioschedulers.rules\n```\n\n```\n# define o escalonador para NVMe\nACTION==\"add|change\", KERNEL==\"nvme[0-9]*\", ATTR{queue/scheduler}=\"none\"\n# define o escalonador para SSD e eMMC\nACTION==\"add|change\", KERNEL==\"sd[a-z]|mmcblk[0-9]*\", ATTR{queue/rotational}==\"0\", ATTR{queue/scheduler}=\"mq-deadline\"\n# define o escalonador para discos rotativos\nACTION==\"add|change\", KERNEL==\"sd[a-z]\", ATTR{queue/rotational}==\"1\", ATTR{queue/scheduler}=\"bfq\"\n```\n\nReinicie ou force o udev a carregar as novas regras.\n\n"
    },
    {
      "title": "Otimizando o escalonador de E/S",
      "level": 4,
      "content": "Cada um dos escalonadores de E/S do kernel tem suas próprias variáveis modificáveis, tais como tempo de latência, tempo de expiração ou parâmetros FIFO. Eles ajudam a ajustar o algoritmo para uma combinação particular do dispositivo e carga de trabalho. Isto é tipicamente usado para conseguir uma maior taxa de transferência ou diminuir a latência.\n\nAs variáveis modificáveis e suas descrições podem ser encontradas na documentação do kernel.\n\nPara listar as váriaveis modificáveis para um dispositivo, no exemplo abaixo é usado o sdb que está usando o deadline, execute:\n\n```\n$ ls /sys/block/sdb/queue/iosched\n```\n\n```\nfifo_batch  front_merges  read_expire  write_expire  writes_starved\n```\n\nPara melhorar a taxa de transferência do deadline ao custo de latência, você pode aumentar o fifo_batch com o comando:\n\n```\n# echo 32 > /sys/block/sdb/queue/iosched/fifo_batch\n```\n\n"
    },
    {
      "title": "Configuração de gerenciamento de energia",
      "level": 3,
      "content": "Ao lidar com discos rotacionais tradicionais (HDDs) você pode querer diminuir ou desabilitar funcionalidades de economia de energia completamente.\n\n"
    },
    {
      "title": "Reduzir leituras/escritas no disco",
      "level": 3,
      "content": "Evitar acessos desnecessários em unidades de armazenamento lentas é bom para a performance e também aumenta a vida útil dos dispositivos, apesar que em hardware moderno a diferença é normalmente insignificante.\n\nNote: **10GB de dados escritos por dia** \n\n"
    },
    {
      "title": "Mostrar escritas no disco",
      "level": 4,
      "content": "O pacote iotop pode ordenar programas por escritas no disco, e mostrar quanto e quão frequentemente estes estão escrevendo no disco. Veja iotop(8) para detalhes.\n\n"
    },
    {
      "title": "Realocar arquivos para tmpfs",
      "level": 4,
      "content": "Realocar arquivos, tais como perfil do navegador, para um sistema de arquivos tmpfs, melhora a responsividade do programa já que todos os arquivo estão guardados na RAM:\n\n- Veja Profile-sync-daemon para sincronizar perfis do navegador. Certos navegadores podem precisar de atenção especial, veja por exemplo Firefox on RAM.\n- Veja Anything-sync-daemon para sincronizar qualquer diretório específico.\n- Veja Makepkg#Melhorando os tempos de compilação para melhorar tempo de compilação ao compilar pacotes no tmpfs.\n\n"
    },
    {
      "title": "Sistema de arquivos",
      "level": 4,
      "content": "Veja a página correspondente do seu sistema de arquivos para possíveis instruções que melhoram a performance, exemplo ext4#Melhorando o desempenho e XFS (Português)#Desempenho.\n\n"
    },
    {
      "title": "Espaço swap",
      "level": 4,
      "content": "Veja swap#Desempenho.\n\n"
    },
    {
      "title": "Intervalo de writeback e tamanho do buffer",
      "level": 4,
      "content": "Veja Sysctl#Virtual memory para detalhes.\n\n"
    },
    {
      "title": "Agendando tarefas de E/S com ionice",
      "level": 3,
      "content": "Muitas tarefas como backup não dependem de um pequeno atraso de E/S ou uma grande banda de armazenamento de E/S para seu objetivo, eles podem ser classificados como tarefas de segundo plano. O E/S rápido é necessário para boa responsividade da interface do usuário no desktop. Então, é benéfico reduzir a quantidade de banda de armazenamento disponível para tarefas de segundo plano, enquanto outras precisam de prioridade. Isto pode ser alcançado ao fazer uso do escalonador de E/S CFQ do linux, que permite configurar diferentes prioridades para os processos.\n\nA prioridade de E/S de um processo de segundo plano pode ser reduzida para o nível \"idle\" (ocioso) com o comando:\n\n```\n# ionice -c 3 seu_comando_aqui\n```\n\nVeja ionice(1) e [2] para mais informação.\n\n"
    },
    {
      "title": "Overclocking",
      "level": 3,
      "content": "Overclocking melhora a performance computacional da CPU ao aumentar o pico da frequência do clock. A habilidade para fazer overclock depende da combinação do modelo da CPU e placa-mãe. É mais frequentemente feito através da BIOS. Fazer overclock também tem desvantagens e riscos, não é nem recomendado nem desencorajado aqui.\n\nMuitos chips da Intel não vão reportar corretamente a frequência do clock para acpi_cpufreq e a maioria dos utilitários. Isto resulta em excessivas mensagens no dmesg, que podem ser evitados ao descarregar ou colocar o módulo do kernel apcu_cpufreq na blacklist. Para ler a velocidade do seu clock, use i7z do pacote i7z. Para verificar se a CPU com overclock está operando corretamente, é recomendado fazer um teste de estresse.\n\n"
    },
    {
      "title": "Escala de frequência",
      "level": 3,
      "content": "Veja Escala de frequência do CPU.\n\n"
    },
    {
      "title": "Escalonadores alternativos da CPU",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nO escalonador padrão da CPU que está na mainline do kernel Linux é o CFS. Existem alternativas.\n\nUm escalonador alternativo focado na interatividade e responsividade é o MuQSS, desenvolvido por Con Kolivas. MuQSS está incluído no pacote do kernel linux-zen. Está também disponível como um patch independente ou como parte do conjunto de patches -ck. Veja Linux-ck and Linux-pf para mais informações sobre.\n\n"
    },
    {
      "title": "Real-time kernel",
      "level": 3,
      "content": "Algumas aplicações como usar uma placa sintonizadora de televisão na resolução FULL HD (1080p) podem se beneficiar do uso do realtime kernel.\n\n"
    },
    {
      "title": "Ajustando as prioridades dos processos",
      "level": 3,
      "content": "Veja também nice(1) e renice(1).\n\n"
    },
    {
      "title": "Ananicy",
      "level": 4,
      "content": "Ananicy é um daemon, disponível no pacote ananicy-gitAUR[link quebrado: package not found], para auto ajustar o nível nice dos executáveis. Os níveis nice representam a prioridade dos executáveis quando alocam recursos da CPU.\n\n"
    },
    {
      "title": "cgroups",
      "level": 4,
      "content": "Veja cgroups (Português).\n\n"
    },
    {
      "title": "Cpulimit",
      "level": 4,
      "content": "Cpulimit é um programa que limita o uso da CPU de um processo específico. Depois de instalar cpulimitAUR, você pode limitar o PID de um processo usando uma escala de 0 a 100 vezes o número de núcleos da CPU que o computador têm. Por exemplo, com oito núcleos a porcentagem vai ser de 0 a 800. Uso:\n\n```\n$ cpulimit -l 50 -p 5081\n```\n\n"
    },
    {
      "title": "irqbalance",
      "level": 3,
      "content": "A proposta do irqbalance é distribuir interrupção de hardware entre processadores em um sistema com múltiplos processadores para aumentar o desempenho. Pode ser controlado com irqbalance.service.\n\n"
    },
    {
      "title": "Desligar as mitigações das falhas da CPU",
      "level": 3,
      "content": "Desligar as mitigações de falhas da CPU melhoram o desempenho (algumas vezes mais de 50%). Use o parâmetro do kernel abaixo para desabilitá-las:\n\n```\nmitigations=off\n```\n\nA explicação de todos os switches que são passados está no kernel.org. Você pode usar spectre-meltdown-checkerAUR para checar vulnerabilidade.\n\n"
    },
    {
      "title": "Configuração do Xorg",
      "level": 3,
      "content": "O desempenho gráfico pode depender das configurações presentes no xorg.conf(5); veja os artigos da NVIDIA (Português), AMDGPU e Intel graphics (Português). Configurações erradas podem fazer o Xorg deixar de funcionar, tome cuidado.\n\n"
    },
    {
      "title": "Configuração do Mesa",
      "level": 3,
      "content": "O desempenho dos drivers Mesa pode ser configurado com drirc. As seguintes ferramentas gráficas estão disponíveis:\n\n- adriconf (Advanced DRI Configurator) — Ferramenta gráfica para configurar os drivers Mesa ao definir opções e escrevê-las para o arquivo drirc padrão.\n\n- DRIconf — Applet de configuração para Direct Rendering Infrastructure, DRI (Inflaestrutura de Renderização Direta, em português). Permite customizar o desempenho e configurações da qualidade visual dos drivers OpenGL em um nível por unidade de armazenamento, por tela e/ou por aplicação.\n\n"
    },
    {
      "title": "Overclocking",
      "level": 3,
      "content": "Assim como acontece com CPUs, overclocking pode diretamente melhorar o desempenho, mas geralmente não é recomendado. Existem pacotes no AUR, tais como amdoverdrivectrlAUR[link quebrado: package not found] (placas antigas da AMD/ATI), rocm-smiAUR[link quebrado: package not found] (placas recentes da AMD), nvclockAUR (placas antigas da NVIDIA - até o Geforce 9), e nvidia-utils para placas recentes da NVIDIA.\n\nVeja AMDGPU#Overclocking ou NVIDIA/Tips and tricks#Enabling overclocking in nvidia-settings.\n\n"
    },
    {
      "title": "Tempos e frequência de clock",
      "level": 3,
      "content": "A RAM pode rodar em diferentes tempos e clock, isto pode ser configurado na BIOS. O desempenho da memória depende de ambos os valores. Selecionar o valor mais alto presente na BIOS normalmente melhora o desempenho em comparação com o valor padrão. Note que aumentar a frequência para valores maiores que os suportados pelos fabricantes da placa-mãe e RAM é overclocking, riscos e desvantagens similares se aplicam nesse caso, veja #Overclocking.\n\n"
    },
    {
      "title": "Raiz na RAM",
      "level": 3,
      "content": "Se está usando um dispositivo com lenta capacidade de escrita (USB, HDDs rotativos) e os requerimentos de armazenamento são baixos, a raiz pode rodar na RAM em cima de uma raiz somente leitura (no disco). Isto pode aumentar significamente o desempenho ao custo de um limitado espaço modificável na raiz do sistema. Veja liverootAUR.\n\n"
    },
    {
      "title": "Zram ou zswap",
      "level": 3,
      "content": "O módulo zram do kernel (antigamente chamado de compcache) oferece um dispositivo de bloco comprimido na RAM. Se você usa isto como um dispositivo swap, A RAM pode guardar muito mais informações mas usa mais CPU. Apesar disso, é muito mais rápido que usar um disco rígido. Se um sistema regularmente recorre a swap, isto pode aumentar a responsividade. Usar zram é também uma boa maneira de reduzir ciclos de leitura/escrita no disco que ocorrem por causa da swap em SSDs.\n\nBenefícios similares (em custos similares) podem ser alcançados usando zswap. Os dois são geralmente similares em intenção mas não em implementação: zswap opera como um cache da RAM comprimida e nem precisa (nem permite) extensiva configuração no userspace.\n\nExemplo: Para definir um dispositivo zram com capacidade de 32GiB, comprimido com lz4 e prioridade maior que o normal (somente para a atual sessão):\n\n```\n# modprobe zram\n# echo lz4 > /sys/block/zram0/comp_algorithm\n# echo 32G > /sys/block/zram0/disksize\n# mkswap --label zram0 /dev/zram0\n# swapon --priority 100 /dev/zram0\n```\n\nPara desabilitá-lo, reinicie o sistema ou execute:\n\n```\n# swapoff /dev/zram0\n# rmmod zram\n```\n\nUma explicação detalhada de todos os passos, opções e potenciais problemas pode ser encontrada na documentação oficial do módulo zram.\n\nO pacote systemd-swapAUR oferece a unit systemd-swap.service para automaticamente inicializar dispositivos zram. É possível configurar em /etc/systemd/swap.conf.\n\nO pacote zramswapAUR oferece um script automatizado para configurar uma swap com uma maior prioridade e um tamanho padrão de 20% da RAM do seu sistema. Para fazer isto automaticamente em toda inicialização, habilite o zramswap.service.\n\n"
    },
    {
      "title": "Swap na zRAM usando uma regra do udev",
      "level": 4,
      "content": "O exemplo abaixo descreve como configurar swap na zRAM automaticamente na inicialização com uma única regra do udev. Nenhum pacote precisa ser instalado.\n\nPrimeiro, habilite o módulo:\n\n```\n/etc/modules-load.d/zram.conf\n```\n\n```\nzram\n```\n\nConfigure o número de células da /dev/zram que você precisa.\n\n```\n/etc/modprobe.d/zram.conf\n```\n\n```\noptions zram num_devices=2\n```\n\nCrie a regra do udev como mostrado no exemplo.\n\n```\n/etc/udev/rules.d/99-zram.rules\n```\n\n```\nKERNEL==\"zram0\", ATTR{disksize}=\"512M\" RUN=\"/usr/bin/mkswap /dev/zram0\", TAG+=\"systemd\"\nKERNEL==\"zram1\", ATTR{disksize}=\"512M\" RUN=\"/usr/bin/mkswap /dev/zram1\", TAG+=\"systemd\"\n```\n\nAdicione /dev/zram para seu fstab.\n\n```\n/etc/fstab\n```\n\n```\n/dev/zram0 none swap defaults 0 0\n/dev/zram1 none swap defaults 0 0\n```\n\n"
    },
    {
      "title": "Usando a RAM da placa de vídeo",
      "level": 3,
      "content": "No cenário pouco provável onde você tem pouca RAM e excedente memória de vídeo, você pode usar a última como swap. Veja Swap on video RAM.\n\n"
    },
    {
      "title": "Melhorando a responsividade do sistema em condições de baixa memória",
      "level": 3,
      "content": "Em sistemas GNU/Linux tradicionais, especialmente para estações de trabalho gráficas, quando a memória alocada é comprometida, a responsividade média do sistema pode se degradar para um estado quase inusável antes que o OOM-killer do kernel seja ativado ou uma quantidade suficiente de memória for liberada (difícil de acontecer rapidamente quando o sistema está irresponsívo, já que você dificilmente pode fechar uma aplicação pesada que pode continuar a alocar memória). O comportamento também depende de configurações e condições específicas, retornar para um estado responsivo pode demorar desde alguns segundos a mais de meia hora, isto pode ser penoso em cenários sérios como durante uma apresentação de conferência.\n\nEnquanto o comportamento do kernel como também programas do userspace em situações de baixa memória pode melhorar no futuro como discutido nas listas de discussão do kernel[3] e fedora[4], usuários podem usar opções mais viáveis e efetivas que desligar o sistema ou aprimorar os parâmetros do sysctl vm.overcommit_*, como:\n\n- Ativar manualmente o OOM-killer do kernel com Magic SysRq key, nomeadamente Alt+SysRq+f.\n- Usar um serviço de gerenciamento da falta de memória no userspace para derrubar eles automaticamente (ou interativamente).\n\nAlgumas vezes um usuário pode preferir um serviço OOM ao invês do SysRq porquê com o OOM-killer do kernel você não pode priorizar o processo a ser terminado (ou não). Lista de algumas implementações:\n\n- earlyoom — Simples implementação do OOM-killer no userspace escrito em C. Fedora vai usá-lo em sua instalação Workstation padrão [5].\n\n- oomd — Implementação do OOM-killer baseado no PSI, precisa da versão 4.20+ do kernel Linux. Configuração é feita em JSON e é muito complexa. Funciona no ambiente de produção do Facebook.\n\n- nohang — Sofisticado gerenciador da falta de memória escrito em Python, com suporte opcional para PSI, mais configurável que o earlyoom.\n\n- low-memory-monitor — Esforço de um desenvolvedor do GNOME com o objetivo de oferecer melhor comunicação em programas do userspace para indicar estado de baixa memória, pode ser configurado para ativar o OOM-killer do kernel. Baseado no PSI, precisa do Linux 5.2+.\n\n"
    },
    {
      "title": "Rede",
      "level": 2,
      "content": "- Gerenciador de rede do Kernel: veja Sysctl#Improving performance\n- NIC: veja Configuração de rede#Definindo o MTU do dispositivo e o tamanho da fila\n- DNS: considere usar um servidor de cache do resolvedor DNS, veja Resolução de nome de domínio#Servidores DNS\n- Samba: veja Samba#Melhorar o desempenho\n\n"
    },
    {
      "title": "Watchdogs",
      "level": 2,
      "content": "De acordo com Wikipedia:Watchdog timer (traduzido):\n\nMuitos usuários precisam desta funcionalidade devido a cargos críticos do sistema (exemplo, servidores), ou devido a falta de of power reset (exemplo, dispositivos embarcados). Nessas situações, esta funcionalidade é necessária para uma boa operação do sistema. No entanto, usuários normais (exemplo, desktop e notebooks) não precisam disso e podem desabilitá-la.\n\nPara desabilitar temporizadores watchdog (ambos em software e hardware), adicione nowatchdog para seus parâmetros de inicialização.\n\nPara verificar a nova configuração, execute:\n\n```\n# cat /proc/sys/kernel/watchdog\n```\n\nou use:\n\n```\n# wdctl\n```\n\nDepois que você desabilitou os watchdogs, você pode opcionalmente evitar o carregamento do módulo responsável pelo watchdog de hardware, também. Basta adicionar à lista negra o módulo, por exemplo, iTCO_wdt.\n\nQualquer ação vai aumentar a acelerar a inicialização e desligar a máquina, devido a ser um módulo a menos carregado. Também, desabilitar temporizadores do watchdog aumenta a performance e abaixa o consumo de energia.\n\nVeja [6], [7], [8], e [9] para mais informações.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- Red Hat Performance Tuning Guide\n- Linux Performance Measurements using vmstat\n\n"
    }
  ]
}