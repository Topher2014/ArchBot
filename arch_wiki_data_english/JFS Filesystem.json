{
  "title": "JFS Filesystem",
  "url": "https://wiki.archlinux.org/title/JFS_Filesystem",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- File systems\n\nThe Journaled File System (JFS) is a journaling file system that was open-sourced by IBM in 1999 and support for which has been available in the Linux kernel since 2002.\n\nThis article introduces the reader to the JFS file system. In particular, procedures for implementation, maintenance and optimization will be presented along with background information on the file system itself and some cautionary notes on precarious implementations.\n\n"
    },
    {
      "title": "Background",
      "level": 2,
      "content": "- In 1990, JFS1, (then simply called JFS), was released for AIX version 3.1. The filesystem was closely tied to its targeted hardware, IBM's AIX line of UNIX servers, being a proprietary design.\n- In 1995, heavy development began on improving JFS, focusing on scalability and expanded features.\n- In 1997, parallel development began on moving the improved JFS source back to AIX.\n- In 1999, the improved JFS design was released for OS/2.\n- In 2001, the improved filesystem (newly termed JFS2), was released for AIX 5L.\n- The current GNU/Linux version is a port based on JFS for OS/2.\n\nWhile it is difficult to make general comparisons between JFS and other file systems available on UNIX and UNIX-like operating systems, it is claimed that JFS uses less CPU resources than other GNU/Linux file systems [2]. With certain optimizations, JFS has also been claimed to be faster for certain file operations, as compared to other GNU/Linux file systems (see [3],Benchmarks).\n\n"
    },
    {
      "title": "GNU/Linux development team",
      "level": 3,
      "content": "The development of the GNU/Linux JFS port is headed by\n\n- Dave Kleikamp (dave dot kleikamp at oracle dot com)\n- HP: https://jfs.sourceforge.net/\n\n"
    },
    {
      "title": "Technical features",
      "level": 3,
      "content": "JFS is a modern file system supporting many features, a few of which are listed here.\n\n- fully 64-bit.\n- dynamic space allocation for i-nodes, i.e. no running out of i-nodes on file systems with large number of small files.\n- Directory structures designed for speed and efficiency: directories with eight or fewer entries have their contents storied inline within that directory's i-node. directories with more than eight entries have their contents stored in a B+ tree keyed on name.\n- JFS utilizes extents for allocating blocks for large files.\n- Support for extended attributes in addition to standard Unix-style permissions.\n- Support for both internal and external logs (see below).\n- Extremely Scalable; Consistent performance from minimum file size up to 4 petabytes.\n- Algorithms designed for high performance on very large systems.\n- Performance tuned for GNU/Linux.\n- Designed from the ground up to provide Transaction/Log (not an add-on).\n- Restarts after a system failure < 1 sec.\n- Proven Journaling FS technology (10+ years in AIX).\n- Original design goals: Performance, Robustness, SMP.\n- Team members from the original AIX JFS Designed/Developed this file system.\n- Designed to operate on SMP hardware, with code optimized for at least a 4-way SMP machine.\n- TRIM support (since Kernel 3.7).\n\n- directories with eight or fewer entries have their contents storied inline within that directory's i-node.\n- directories with more than eight entries have their contents stored in a B+ tree keyed on name.\n\nA more comprehensive (and technical) overview of the features in JFS can be found in the JFS Overview authored by developer Steve Best.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "The JFS driver is built as a module in the standard Arch kernel packages.\n\nThe jfsutils package must be installed to perform all file system related tasks.\n\nCreation of a JFS file system can be done with the either:\n\n```\n# mkfs.jfs /dev/target_dev\n```\n\nor:\n\n```\n# jfs_mkfs /dev/target_dev\n```\n\nBoth commands are equivalent.\n\n"
    },
    {
      "title": "Optimizations",
      "level": 2,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nThere are several concepts that can be implemented with a JFS filesystem to boost its performance:\n\n- Periodic defragmentation of the file system.\n- Using the deadline I/O scheduler.\n- Utilizing an external journal.\n\n"
    },
    {
      "title": "Defragmenting JFS",
      "level": 3,
      "content": "JFS, like all file systems, will degrade in performance over time due to file fragmentation [5]. While there is in-place defragmentation code in the JFS utilities, this is code held over from the OS/2 port and has yet to be implemented [6]. For file systems that can be taken off-line for a time, one can execute a script like the following to defragment their JFS file system\n\nNote: **dangerous** \n\n```\numount /dev/hdc1\ndd bs=4k if=/dev/hdc1 of=/dev/hdj1\njfs_fsck /dev/hdj1\nmount -o ro /dev/hdj1 /fs/hdj1\njfs_mkfs /dev/hdc1\nmount -o rw /dev/hdc1 /fs/hdc1\n(cd /fs/hdj1 && tar -cS -b8 --one-file-system -f - .) | (cd /fs/hdc1 && tar -xS -b8 -p -f -)\numount /dev/hdj1\n```\n\nIn this example, /dev/hdc1 is the device with the data that needs backing up and /dev/hdj1 is the device that holds the backup.\n\nBasically, this script copies the data off the JFS file system to a backup drive, formats the original JFS file system and finally writes back the data from the backup to the freshly formatted drive in a way that JFS will write its allocation trees in a defragmentated way.\n\n"
    },
    {
      "title": "Deadline I/O scheduler",
      "level": 3,
      "content": "JFS seems to perform better when the kernel has been configured to use the Deadline I/O Scheduler. Indeed, JFS's performance seems to exceed that of other GNU/Linux file systems with this particular scheduler being employed [7].\n\n"
    },
    {
      "title": "External journal",
      "level": 3,
      "content": "As with any journaled file system, a journal is constantly accessed in accordance with disk activity. Having the journal log on the same device as the its corresponding file system thus can cause a degradation in I/O throughput. This degradation can be alleviated by putting the journal log on a separate device all together.\n\nTo make a journal device, first create a partition that is 128MB. Using a partition that is bigger than 128MB results in the excess being ignored, according to mkfs.jfs. You can either create an external log for an already-existing JFS file system by executing the following:\n\n```\n# mkfs.jfs -J journal_dev /dev/external_journal             # creates a journal on device /dev/external_journal\n# mkfs.jfs -J device=/dev/external_journal /dev/jfs_device  # attaches the external journal to the existing file \n                                                          #   system on /dev/jfs_device\n```\n\nor a command can be issued to create both a new external journal and its corresponding JFS file system:\n\n```\n# mkfs.jfs -j /dev/external_journal /dev/jfs_device\n```\n\nThis last command formats BOTH the external journal and the JFS file system.\n\n"
    },
    {
      "title": "noatime fstab attribute",
      "level": 3,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nEvery time a file is accessed (read or write) the default for most file systems is to append the metadata associated with that file with an updated access time. Thus, even read operations incur an overhead associated with a write to the file system. This can lead to a significant degradation in performance in some usage scenarios. Appending noatime to the fstab line for a JFS file system stops this action from happening. As access time is of little importance in most scenarios, this alteration has been widely touted as a fast and easy way to get a performance boost out of one's hardware. Even Linus Torvalds seems to be a proponent of this optimization [8].\n\nNote: **relatime** \n\n- One may also specify a relatime option which updates the atime if the previous atime is older than the mtime or ctime [9]. In terms of performance, this will not be as fast as the noatime mount option, but is useful if using applications that need to know when files were last read (like mutt).\n- Using the noatime/relatime option can improve disk performance with any file system, not just JFS.\n\nHere is an example /etc/fstab entry with the noatime tag:\n\n```\n/dev/sdb1 /media/backup jfs rw,users,noauto,noatime 0  0\n```\n\nOne may also mount a file system with the noatime attribute by invoking something similar to the following:\n\n```\n# mount -o noatime -t jfs /dev/jfs_dev /mnt/jfs_fs\n```\n\n"
    },
    {
      "title": "Journal modes",
      "level": 3,
      "content": "JFS does not support various journal modes like ext3. Thus, passing the mount option data=writeback with mount or in /etc/fstab will have no effect on a JFS file system. JFS's current journaling mode is similar to Ext3's default journaling mode: ordered [10].\n\n"
    },
    {
      "title": "Variable block sizes",
      "level": 3,
      "content": "While the OS/2 port of JFS supports block sizes of 512, 1024, 2048, and 4096 bytes, the Linux port of JFS is only able to use 4k blocks. Even though code exists in JFS utilities that correspond to file systems using variable size blocks, this has yet to be implemented [11]. As larger block sizes tend to favor performance (smaller ones favor efficient space usage), implementing smaller block sizes for JFS in Linux has been given a low priority for implementation by JFS developers.\n\n"
    },
    {
      "title": "fsck and recovery",
      "level": 2,
      "content": "In the event that the file system does not get properly unmounted before being powered down, one will usually have to run fsck on a JFS file system in order to be able to remount it. This procedure usually only takes a few seconds, unless the log has been damaged. If running fsck returns an unrecognized file system error, try running fsck.jfs on the target device. Normally, fsck is all that is needed.\n\n"
    },
    {
      "title": "Cautionary notes",
      "level": 2,
      "content": "While JFS is very stable in its current stage of development, there are some cautionary notes on using this file system.\n\n"
    },
    {
      "title": "JFS root mounts read only on startup",
      "level": 3,
      "content": "Occasionally, a JFS root partition will be unable to mount in normal read-write mode. This is usually due to the fact that the JFS root file system fails its fsck after an unclean shutdown. It is rare that JFS fails out of fsck, and it is usually due to the JFS log itself being corrupted.\n\nAll that is required in this scenario is to boot your machine with a relatively recent Arch Linux LiveCD. Booting an Arch Linux livecd will give you access to all the JFS utilities and will load a kernel that is able to recognize JFS file systems. After booting the CD simply run fsck (or possibly fsck.jfs) on your JFS root and it should recover just fine (even though the fsck will probably take longer than normal due to the log probably being damaged). Once the fsck finishes, you should be able to boot your machine like normal.\n\n"
    },
    {
      "title": "JFS and secure deletions",
      "level": 3,
      "content": "The effectiveness of deleting files by overwriting their corresponding file system blocks with random data (i.e. using utilities like shred) can not be assured [12]. Given the design of journaled file systems, maintenance issues, and performance liabilities; reliable shredding of files as a deletion method does not sit highly on the priority list for implementation on any journaled file system.\n\n"
    },
    {
      "title": "Forced fsck on JFS root file system",
      "level": 3,
      "content": "One may force a fsck (file system check) on the root file system by entering:\n\n```\n# touch /forcefsck\n```\n\nand rebooting. On Arch linux systems with a JFS root on a partition under control of device-mapper (i.e. the root device is a lvm or a LUKS encrypted one), forcing an fsck can sometimes remove the /usr/man/man3/ directory. The reason for this issue is not clear, but the problem has been replicated [13].\n\nIt is suggested to get a list of Arch Packages that use /usr/man/man3/ by issuing a command similar to\n\n```\n# find /var/lib/pacman/local/ -name files | xargs grep -F \"/man/man3/\" | cut -d: -f1 | sort -u | awk -F/ '{print $6}' > man3_pkg_list\n```\n\nbefore attempting a forced fsck on a JFS root partition [14]. If /usr/man/man3 does indeed disappear, simply reinstall all the packages listed in man3_pkg_list.\n\nAs stated above, the reason for this issue is not clear at the moment; but it may have something to do with the fact that a forced fsck runs through higher phases of file system checks that only happen when a JFS log gets damaged in an improper dismounting of the partition.\n\n"
    },
    {
      "title": "JFS losing files",
      "level": 3,
      "content": "In JFS; journal writes are indefinitely postponed until there is another trigger such as memory pressure or an unmount operation. This infinite write delay limits reliability, as a crash can result in data loss even for data that was written minutes or hours before.[16]\n\n"
    },
    {
      "title": "Benchmarks",
      "level": 2,
      "content": "As benchmarks measuring file system performance tend to be focused at specific types of disk usage, it is difficult to decipher good general comparisons rating how well JFS performs against other files systems. As mentioned before, it has been noted that JFS has a tendency to use less CPU resources than other GNU/Linux file systems and (with the right optimizations) is faster than other GNU/Linux file systems for certain types of file operations. It has been noted that JFS slows down when working with many files, however[17][18]. In the references are some links to benchmarks; but as always, it is best to test and see what works best for your own system and work load.\n\n"
    },
    {
      "title": "Conclusions",
      "level": 2,
      "content": "JFS is a stable, feature-rich file system that has not been publicized as much as some of the other Linux file systems. With optimizations, JFS is stable, CPU efficient and fast. In particular, VMWare sessions stand to benefit enormously from a properly optimized and defragmented, underlying JFS file system.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- A more technical overview of JFS\n- 30 days with JFS\n- JFS Sourceforge page\n- Note on defragmenting JFS file systems\n- JFS Recovery Sourceforge page\n- Presentation on JFS given by Steve Best (pdf)\n- Debian file system comparison\n- Wikipedia:JFS (file system)\n- Some filesystem benchmarks\n\n"
    }
  ]
}