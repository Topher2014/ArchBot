{
  "title": "SED",
  "url": "https://wiki.archlinux.org/title/SED",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Data-at-rest encryption\n- Trusted Platform Module\n- dm-crypt/Encrypting an entire system\n\nHardware-based full-disk encryption (FDE) is now available from many hard disk (HDD) vendors, becoming increasingly common especially for solid state drives. The term \"self-encrypting drive\" (SED) is now common when referring to HDDs or SSDs with built-in full-disk encryption. OPAL is a set of specifications for self-encrypting drives developed by the Trusted Computing Group.\n\n"
    },
    {
      "title": "Overview",
      "level": 2,
      "content": "Many self-encrypting drives available today implement the OPAL, Ruby or Enterprise standards developed by the Trusted Computing Group (TCG). Other standards such as Opalite and Pyrite only offer a subset of the functionalities offered by OPAL, and might not even offer any actual encryption of data at rest [1]. The hardware manufactured according to the standards is labeled accordingly.\n\nUnlocking of the drive can be done during operating system runtime using software utilities, in a pre-boot authentication environment, or with a #BIOS based ATA-password on power up.\n\nRefer to the #Advantages and #Disadvantages sections to better understand and decide if hardware-based full-disk encryption is what you want.\n\n"
    },
    {
      "title": "Key management technical implementation",
      "level": 3,
      "content": "Key management takes place within the disk controller and encryption keys are usually 128 or 256 bit Advanced Encryption Standard (AES).\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nSelf-encrypting drives adhering to the TCG OPAL 2.0 standard specification (almost all modern self-encrypting drives) implement key management via an authentication key, and a 2nd-level data encryption key. The data encryption key is the key against which data on the drive is actually encrypted. The authentication key is the user-facing 1st-level passphrase which decrypts the data encryption key (which in turn decrypts the data). This approach has specific advantages:\n\n- Allows the user to change the passphrase without losing the existing encrypted data on the disk This improves security, as it is fast and easy to respond to security threats and revoke a compromised passphrase\n- Facilitates near-instant and cryptographically secure full disk erasure.\n\n- This improves security, as it is fast and easy to respond to security threats and revoke a compromised passphrase\n\nFor those who are familiar, this concept is similar to the LUKS key management layer often used in a dm-crypt deployment. Using LUKS, the user can have multiple different keys (passphrases or keyfiles) to decrypt the master-key, which in turn decrypts the underlying data. This approach allows the user to change or revoke these keys as required without needing to re-encrypt the data, as the master 2nd-level encryption key is unchanged (itself being re-encrypted by the new passphrase).\n\nIn fact, in drives featuring full-disk encryption, data is always encrypted with the data encryption key when stored to disk, even if there is no password set (e.g. a new drive). Manufacturers do this to make it easier for users who do not wish to enable the security features of the self-encrypting drive. These self-encrypting drives can be thought of as having a zero-length password by default that always transparently encrypts the data (similar to how passwordless SSH keys can provide somewhat secure access without user intervention).\n\nIf a user wishes to \"enable\" encryption at a later stage, they are able to configure an authentication key (such as a passphrase) which encrypts the existing data encryption key. The user will then be prompted for their passphrase when decrypting the data encryption key in the future. Crucially, because the existing data encryption key is not regenerated, setting a passphrase allows for the drive to be locked while preserving existing encrypted data on the disk, avoiding the need for the drive to be re-encrypted. On the flip-side, there is no way to re-encrypt the data itself, other than a secure full disk erasure.\n\n"
    },
    {
      "title": "Advantages",
      "level": 3,
      "content": "- Easier to setup (compared to software-based encryption)\n- Notably transparent to the user, except for initial bootup authentication\n- Data-at-Rest protection\n- Increased performance (CPU is freed up from calculations to encrypt and decrypt)\n- The main CPU and RAM are eliminated as possible attack targets\n- Optimally fast and #Secure disk erasure (sanitation) (regardless of disk size)\n- Protection from alternative boot methods due to the possibility to encrypt the MBR, rendering the drive inaccessible before pre-boot authentication\n\n"
    },
    {
      "title": "Disadvantages",
      "level": 3,
      "content": "- The configuration of suspend and hibernate modes is difficult and may be impossible, depending on the systems' EFI implementation.\n\n- A re-encryption of the data is not possible without a secure disk erasure.\n\n- Exploitations\n\n- Constant-power exploits\n\n- Key-in-memory exploits\n\n- Compromised firmware\n\n"
    },
    {
      "title": "Linux support",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nThe kernel supports OPAL self-encrypting drives via the BLK_SED_OPAL option.[5] All officially supported kernels are built with this option enabled.\n\nsedutil, under the umbrella of The Drive Trust Alliance (DTA), is \"an Open Source (GPLv3) effort to make core Self Encrypting Drive technology freely available to developers.\"[6]\n\ncryptsetup, the command line utility for dm-crypt, gained limited OPAL support. See the cryptsetup 2.7.0 release notes to check whether its capabilities suffice for your purpose.\n\n"
    },
    {
      "title": "Using sedutil",
      "level": 2,
      "content": "Install the sedutilAUR package, which contains the sedutil-cli tool, and helper scripts to create a custom pre-boot authorization (PBA) image based off the current operating system in use (e.g. for setting a custom console keymap). Alternatively, you can install sedutil solely for acquiring the sedutil-cli toolset, but download and use the precompiled PBA image (for BIOS or UEFI) provided by the Drive Trust Alliance.\n\nFor devices connected via SATA, libata.allow_tpm must be set to 1 (true) in order to use sedutil. Either add libata.allow_tpm=1 to the kernel parameters, or by setting /sys/module/libata/parameters/allow_tpm to 1 on a running system.\n\n"
    },
    {
      "title": "Encrypting the root (boot) drive",
      "level": 3,
      "content": "These instructions assume you have the sedutil-cli tool installed (via the AUR, or by other means)\n\n"
    },
    {
      "title": "Check if your disk supports OPAL",
      "level": 4,
      "content": "```\n# sedutil-cli --scan\n```\n\nIf you get something like\n\n```\nScanning for Opal compliant disks\n/dev/sda No  LITEONIT LMT-256L9M-11 MSATA 256GB       HM8110B\n```\n\nthen your disk does not support OPAL. On the contrary, the following output means OPAL standards 1.0 and 2.0 are supported, as the drive has a 2 (or a 12) in the second column indicating OPAL 2 support:\n\n```\n/dev/sda 12  Samsung SSD 850 EVO 500GB                EMT02B6Q\n```\n\nWindows version of sedutils output:\n\n```\n\\\\.\\PhysicalDrive0 12  Samsung SSD 850 PRO 512GB                EXM02B6Q\n```\n\n"
    },
    {
      "title": "Download the rescue image (optional)",
      "level": 4,
      "content": "Note that this rescue image was built in 2017 and its PBA-Image, on newer AMD-Laptops causes the internal keyboard-input to fail - thus requiring an external keyboard to enter the Disk Password. You might want to build your own PBA instead.\n\nDownload a rescue system for a machine provided by the Drive Trust Alliance, e.g. RESCUE64.img.gz.\n\nDecompress the rescue image (if required):\n\n```\n$ gunzip RESCUE64.img.gz\n```\n\nCreate a bootable drive using the downloaded rescue image, for example using dd:\n\n```\n# dd bs=4M if=path/to/RESCUE64.img of=/dev/sdx status=progress conv=fsync oflag=direct\n```\n\n"
    },
    {
      "title": "Using Pre-boot Authorisation (PBA)",
      "level": 4,
      "content": "The following steps will install a PBA image in your EFI/BIOS which will start before your system and prompt you for a password. If the password is correct, it will unlock the drive and reboot into the normal operating system boot loader.\n\n- These steps must be executed from the rescue system.\n- These steps will enable encryption for the entire drive (locking range 0). Whilst this does not usually delete the data, always make sure to have a backup.\n\nBoot into the rescue system and use the output of blkid to help identify the correct drive, e.g. /dev/sdx.\n\nSetup the drive initially, which will be set both SID and Admin1 passwords to the same PASSWORD of your choice:\n\n```\n# sedutil-cli --initialsetup PASSWORD DRIVE\n```\n\nThen enable the global locking range 0 (i.e. the entire drive):\n\n```\n# sedutil-cli --enablelockingrange 0 PASSWORD DRIVE\n# sedutil-cli --setmbrdone off PASSWORD DRIVE\n```\n\nTo optionally change the PASSWORD from initial setup prior to continuing with setup:\n\n```\n# sedutil-cli --setsidpassword PASSWORD NEW_SID_PASSWORD DRIVE\n```\n\nwill change both the SID and Admin1 to NEW_SID_PASSWORD. To only change the Admin1 password:\n\n```\n# sedutil-cli --setadmin1pwd PASSWORD NEW_ADMIN1_PASSWORD DRIVE\n```\n\nInstall the Pre-boot Authorisation (PBA) image:\n\n```\n# gunzip /usr/sedutil/UEFI64-*.img.gz\n# sedutil-cli --loadPBAimage PASSWORD /usr/sedutil/UEFI64-*.img DRIVE\n```\n\nPower off the computer to lock the drive.\n\nWhen the computer is next powered on, the PBA should ask for your password; then unlock the drive and chain-load the decrypted operating system.\n\nIn some cases, the PBA will load, accept the password, and unlock the drives but when chain-loading to the decrypted operating system it will do a \"cold\" reboot which powers off the disks for a moment and result in the drives locking again. So you get stuck in a loop of always unlocking the drives but never booting from them.\n\nIf this is the case, you will need to edit the UEFI-*.img to guarantee it does a \"warm\" reboot:\n\n```\n# losetup --find --show ./UEFI64-*.img \n# partprobe /dev/loop0\n# mount /dev/loop0p1 /mnt\n# cd /mnt/EFI/boot\n# $EDITOR syslinux.cfg # add \" reboot=warm\" (no quotes) to the end of the line starting with  \"append\"\n# cd -\n# sync\n# umount /mnt\n# losetup -D\n```\n\nNow you can copy the image to the drive again with:\n\n```\n# sedutil-cli --loadPBAimage PASSWORD ./UEFI64-*.img DRIVE\n```\n\nIf you are using the recovery image the above might not work (losetup -f ./UIEFI64-*.img fails with no such file), you can edit the file on your computer and copy it on the recovery USB drive (but after the end of the recovery image)\n\n```\n# dd bs=4M if=UEFI64.img of=DRIVE seek=100\n```\n\nseek=100 will skip 400 MiB from the start of the drive to avoid overwriting the recovery image itself.\n\nThen, once the recovery is started you can get your image:\n\n```\n# dd bs=4M if=DRIVE of=UEFI64.img skip=100 count=10\n```\n\ncount×bs should be more then the file size.\n\nTruncate file to actual size:\n\n```\n# truncate -s IMGSIZE UEFI64.img\n```\n\nIf you use an EFI boot stub and configured UEFI to boot your kernel directly, after the disk is unlocked the firmware might forget all its configuration (and it loses it on every unlock). In that case you can install an UEFI boot loader to the default/fallback boot path esp/EFI/BOOT/BOOTx64.EFI and then the firmware would be able to boot it with its default configuration.\n\nIt will be helpful to have an USB flash installation medium: if you plug it in after unlocking the disk, it will auto-boot and let you configure your now-unlocked boot disk.\n\n"
    },
    {
      "title": "Using a mkinitcpio hook",
      "level": 4,
      "content": "Instead of using a PBA, the drive can be setup to only encrypt the root partition whilst leaving the /boot partition accessible. This way, the system can boot and a mkinitcpio hook used to unlock the drive before the rest of the boot sequence is completed. This has the advantage of not needing to install a PBA and reboot, and also allows for easier support of resume from S3 sleep.\n\nFollow the steps outlined above to create a rescue system, then boot into it.\n\n- These steps must be executed from the rescue system, or a live system with sedutil-cli installed.\n- These steps will destroy all data on the drive. Make sure to have a backup before starting!\n\nThe first command will delete everything off of the drive. Omitting it will not save your data, because setting up the new locking range will destroy it anyway.\n\n```\n# sedutil-cli --yesIreallywanttoERASEALLmydatausingthePSID PSID DRIVE\n# sedutil-cli --initialsetup PASSWORD DRIVE\n# sedutil-cli --setMBREnable off PASSWORD DRIVE\n```\n\nThe PSID (physical security identifier) can only be found on the physical drive label (the sticker on top of the drive).\n\nPartition the drive as desired, making sure the EFI and/or /boot partitions are at the start of the disk, immediately followed by the root partition. For example:\n\n1. 1G, FAT32, /boot\n1. ext4, /\n\nOr a slightly more complex setup:\n\n1. 100M, FAT32, EFI\n1. 2G, ext4, /boot\n1. ext4, /\n1. Swap\n\nIt is important the EFI and/or /boot partitions have enough space to hold all of the kernel images you may want to install. It will not be possible to expand these later without destroying all of the data in the root partition, as the encryption headers would be overwritten.\n\nUse lsblk --fs to help identify the correct drive, e.g. /dev/sdx, then use lsblk --f DRIVE to find:\n\n- RANGE_START = \"Start\" of the root partition\n- RANGE_LENGTH = \"Sectors\" of the root partition\n\nIn the example below, RANGE_START would be 2097152 and RANGE_LENGTH 974675968. It is important that these numbers are divisible by 8 to work with sedutil-cli, rounding may be necessary.\n\n```\nDevice       Start       End   Sectors   Size Type\n/dev/sda1     2048   2097151   2095104  1023M EFI System\n/dev/sda2  2097152 976773119 974675968 464.8G Linux filesystem\n```\n\nCreate locking range 1 to only cover the root partition (and optionally swap):\n\n```\n# sedutil-cli --setupLockingRange 1 RANGE_START RANGE_LENGTH PASSWORD DRIVE\n# sedutil-cli --enablelockingrange 1 PASSWORD DRIVE\n```\n\nFor extra security, the EFI and/or /boot partitions can be locked as read-only. Identify the RANGE_START and RANGE_LENGTH in the same manner as for the root partition, then issue the following commands:\n\n```\n# sedutil-cli --setupLockingRange 2 RANGE_START RANGE_LENGTH PASSWORD DRIVE\n# sedutil-cli --readonlyLockingRange 2 PASSWORD DRIVE\n```\n\nNote: Then proceed to reboot the system without powering off.\n\n```\n# sedutil-cli --setlockingrange 1 rw PASSWORD DRIVE\n```\n\nThen proceed to reboot the system without powering off.\n\nYou may now install the operating system, taking care to use the existing partitions and not alter them in any way. Once done, reboot into the new system without powering off first.\n\nNote: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nCreate a custom mkinitcpio hook to ask for the drive password on boot:\n\n```\n/etc/initcpio/install/sedutil\n```\n\n```\n#!/bin/bash\n\nhelp() {\n    cat <<HELPEOF\nUnlock OPAL drives by prompting for password\nHELPEOF\n}\n\nbuild() {\n    add_binary sedutil-cli\n    add_binary clear\n    add_binary find\n    add_binary gawk\n    add_binary grep\n    add_binary readlink\n    add_binary stty\n    add_binary xargs\n    add_binary partprobe\n\n    add_runscript\n}\n```\n\nThe following script also contains code for unlocking the boot range, which can be uncommented if needed. Additionally, if you need to be able to resume from sleep, you may need to slightly modify the below script. See #Preparing drive for sleep for more information and caveats about S3 sleep.\n\n```\n/etc/initcpio/hooks/sedutil\n```\n\n```\n#!/usr/bin/ash\n\nrun_hook() {\n\tmsg  \"OPAL Drives Unlock\"\n\n\tfor block_device in $(list_block_devices) ; do\n\t\tif ! is_opal_drive \"$block_device\" ; then\n\t\t\tcontinue\n\t\tfi\n\t\topal_unlock \"$block_device\" \"$(get_block_device_info $block_device)\"\n\tdone\n\t\n\tpartprobe\n}\n\nlist_block_devices() {\n\tfor glob in 'sd[a-z]' 'nvme[0-9]n[0-9]' 'nvme[0-9][0-9]n[0-9][0-9]' ; do\n\t\tfind /dev/ -name \"$glob\"\n\tdone\n\tif [ $? != 0 ] ; then\n\t\tmsg \"Unable to list block devices\"\n\tfi\n}\n\nis_opal_drive() {\n\tsedutil-cli --query \"$1\" > /dev/null 2> /dev/null\n\treturn $?\n}\n\nget_block_device_info() {\n\tsedutil-cli --query \"$1\" | gawk '/^\\//{print;exit}'\n\tif [ $? != 0 ] ; then\n\t\tmsg \"Unable to query $1\"\n\tfi\n}\n\nopal_unlock() {\n\twhile true ; do\n\t\tstty -echo\n\t\techo \"Password for\"\n\t\techo -n \"$2 ($1): \"\n\t\tread pass\n\t\tstty echo\n\n\t\t# Unlock root range for read/write\n\t\tsedutil-cli --setlockingrange 1 rw \"$pass\" \"$1\"\n        # Uncomment to also unlock boot range\n\t\t# sedutil-cli --setlockingrange 2 rw \"$pass\" \"$1\"\n\t\tif [ $? != 0 ] ; then\n\t\t\techo \"Failed to unlock!\"\n\t\t\tcontinue\n\t\tfi\n        \n\t\techo  \"Unlocked!\"\n\t\tbreak\n\tdone\n}\n```\n\nEdit you mkinitcpio configuration to add the sedutil hook before udev. It is important the hook runs before udev, otherwise udev will get stuck trying to access the encrypted drive and cause I/O errors.\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nHOOKS=(base keymap consolefont sedutil udev autodetect microcode modconf kms keyboard block filesystems fsck)\n```\n\nFinally, regenerate the initramfs.\n\nYou may now reboot your system. If all goes well, the hook will prompt for a password to unlock your drive and then proceed with the rest of the boot process. If something went wrong, you can boot into the rescue system, manually unlock the drive, then reboot into your normal system using the default initcpio image and proceed to debug your system.\n\n"
    },
    {
      "title": "Accessing the drive from a live distribution",
      "level": 4,
      "content": "The easiest way is to boot the encrypted SSD first, in order to run the shadow MBR. Then press the key that prompts the boot menu and boot whatever device you prefer. Such a way the SED will be completely transparent.\n\nAnother way is to directly boot into the live distribution and use sedutil to unlock the SSD:\n\n```\n# sedutil-cli --setlockingrange 0 rw password drive\n# sedutil-cli --setmbrdone on password drive\n# partprobe drive\n```\n\nVerify that you followed the instructions after the note in #Linux support.\n\n"
    },
    {
      "title": "Disable locking",
      "level": 4,
      "content": "If you want to turn off Locking and the PBA:\n\n```\n# sedutil-cli --disableLockingRange 0 password drive\n# sedutil-cli --setMBREnable off password drive\n```\n\n"
    },
    {
      "title": "Re-enable locking and the PBA",
      "level": 4,
      "content": "You can later re-enable locking and the PBA using this command sequence\n\n```\n# sedutil-cli --enableLockingRange 0 password drive\n# sedutil-cli --setMBREnable on password drive\n```\n\n"
    },
    {
      "title": "Encrypting a non-root drive",
      "level": 3,
      "content": "A secondary drive that is not used for the system root, for example a separate drive hosting a permanent /data partition or a portable USB-drive, can be setup.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nA non-root drive does not require loading a PBA. So, activating the encryption is as simple as running:\n\n```\n# sedutil-cli --initialsetup password drive\n# sedutil-cli --enableLockingRange 0 password drive\n# sedutil-cli --setMBREnable off password drive\n```\n\nIf it is a portable drive and/or you want to unlock the drive manually, you should do the as in #Accessing the drive from a live distribution, but you need just the first command, because MBR shadowing has not been enabled:\n\n```\n# sedutil-cli --setlockingrange 0 rw password drive\n```\n\nThis will unlock the drive until it is disconnected or your machine goes into suspend, beware that this may cause loss of data.\n\n"
    },
    {
      "title": "Changing the passphrase",
      "level": 3,
      "content": "Changing the passphrase does not lose existing data on the drive, and does not require re-encryption of data.\n\n```\n# sedutil-cli --setSIDPassword password newpassword device\n# sedutil-cli --setAdmin1Pwd password newpassword device\n```\n\nRead the #Key management technical implementation section above to learn about how this is implemented securely within the drive, and why it is possible to change the passphrase without losing the existing encrypted data on the drive.\n\n"
    },
    {
      "title": "Waking up from suspend",
      "level": 3,
      "content": "Suspending the system results in a crash by default, because power is being cut from the drive and that causes it to lock itself. In order to wake up from suspend the kernel should know a hashed password for the disk. This functionality is in-kernel since 4.11, but it is only available via a fork of sedutil, either sedutil-sleep-gitAUR or sedutil-ladarAUR. Note the latter has additional features but a slightly different command syntax [7].\n\nGenerate a hashed password for the block device specified as /dev/device:\n\n```\n# sedutil-sleep --printPasswordHash password /dev/device\n```\n\n"
    },
    {
      "title": "Preparing drive for sleep",
      "level": 4,
      "content": "If already using a mkinitcpio hook to unlock the drive on boot, then you can simply add code as below to the hook to also prepare the drive for sleep. Make sure this code is placed after the command that unlocks the ranges sedutil-cli --setlockingrange, otherwise it will fail. In this example, $pass is a variable containing the password for unlocking, while $1 is a variable containing the device to prepare for sleep, typically the root partition (e.g. /dev/sda1).\n\n```\n/etc/initcpio/hooks/sedutil\n```\n\n```\nsedutil-cli --prepareForS3Sleep 1 \"$pass\" \"$1\"\nif [ $? != 0 ] ; then\n\tmsg \"Prepare for S3 failed for $1\"\nfi\n```\n\nCreate a systemd service, inserting hashes for each device:\n\n```\n/etc/systemd/system/sedutil-sleep.service\n```\n\n```\n[Unit]\nDescription=sedutil-sleep\n\n[Service]\nType=oneshot\n#Add as many ExecStart lines as needed here\nExecStart=-+/usr/bin/sedutil-sleep -n -x --prepareForS3Sleep 0 hash /dev/device\n#ExecStart=-+/usr/bin/sedutil-sleep -n -x --prepareForS3Sleep 0 hash2 /dev/device\nRemainAfterExit=true\n\n[Install]\nWantedBy=multi-user.target\n```\n\n"
    },
    {
      "title": "Using cryptsetup",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\ncryptsetup can be used to perform the initial setup of OPAL equivalent to the example of sedutil, albeit not for USB-drives. cryptsetup is always used on block devices, i.e. an individual partition, and adds a LUKS header to it which includes a LUKS encrypted OPAL key to unlock it. See cryptsetup(8) § SED (SELF ENCRYPTING DRIVE) OPAL EXTENSION for details.\n\ncryptsetup's advantage over sedutil is that, besides the initial luksFormat command, no special setup is required. It is just a LUKS device like any other which allows using all features LUKS provides and the option of using systemd-cryptenroll.\n\nSee the cryptsetup 2.7.0 release notes for command examples with OPAL related output of the LUKS header.\n\n"
    },
    {
      "title": "Encrypting a partition",
      "level": 3,
      "content": "Encrypting a partition with OPAL requires the OPAL admin password. If you have not previously set one, you will need to erase all data on the drive with cryptsetup-erase(8) to be able to create a new OPAL admin password. Follow the instructions in #Secure disk erasure to perform the erase.\n\nOPAL hardware encryption can be set up on a partition using cryptsetup-luksFormat(8) option --hw-opal-only. This will avoid the performance penalty that software encryption brings to an encrypted partition and the CPU.\n\nAlternatively, the --hw-opal option can be used to setup both OPAL hardware encryption and dm-crypt software encryption at the same time. The default dm-crypt encryption options for LUKS2 apply and can be configured.\n\nFor example, with /dev/sdXY as the partition on a drive with OPAL support:\n\n```\n# cryptsetup luksFormat --hw-opal-only /dev/sdXY\n```\n\n```\nWARNING!\n========\nThis will overwrite data on /dev/sdXY irrevocably.\n\nAre you sure? (Type 'yes' in capital letters): YES\nEnter passphrase for /dev/sdXY: \nVerify passphrase: \nEnter OPAL Admin password: \nVerify passphrase:\n```\n\nSubsequent to the setup, the block device can be opened and formatted with a filesystem, see dm-crypt/Device encryption#Unlocking/Mapping LUKS partitions with the device mapper. Only the LUKS passphrase is required from now on, because the header automatically unlocks the OPAL encryption.\n\n"
    },
    {
      "title": "Removing a locking range",
      "level": 3,
      "content": "Since OPAL locking ranges are neither readable nor writable while in a locked state, an encrypted partition cannot be repurposed until the OPAL locking range spanning it is removed.\n\nTo remove OPAL encryption from a partition use cryptsetup-erase(8):\n\n```\n# cryptsetup erase -v /dev/sdXY\n```\n\n```\nEnter OPAL Admin password:\nCommand successful.\n```\n\n"
    },
    {
      "title": "Secure disk erasure",
      "level": 3,
      "content": "Whole disk erasure is very fast, and remarkably simple for a self-encrypting drive. Simply passing a cryptographic disk erasure (or crypto erase) command (after providing the correct authentication credentials) will have the drive self-generate a new random data encryption key internally. This will permanently discard the old key, thus rendering the encrypted data irrevocably un-decryptable. The drive will now be in a 'new drive' state.\n\nRead the #Key management technical implementation section above to learn more about how this is implemented securely within the drive.\n\nThe Solid state drive/Memory cell clearing article covers comprehensive guides to perform the erasure securely.\n\nNote: **all data on the drive** \n\nThe following shows an example output by using cryptsetup-erase(8) to perform it:\n\n```\n# cryptsetup erase -v --hw-opal-factory-reset /dev/sdX\n```\n\n```\nEnter OPAL PSID: \n\nWARNING!\n========\nWARNING: WHOLE disk will be factory reset and all data will be lost! Continue?\n\nAre you sure? (Type 'yes' in capital letters): YES\nCommand successful.\n```\n\nThe -v option returns the Command successful output.\n\nThe PSID (physical security identifier) can only be found on the physical drive label (the sticker on top of the drive).\n\n- For NVMe drives use the namespace form of the device name, i.e. use /dev/nvmeXnY rather than /dev/nvmeX.\n- The PSID must be written without any dashes, spaces or underscores.\n\n"
    },
    {
      "title": "Suspend/hibernation support",
      "level": 3,
      "content": "Nothing special is required, they work exactly as with regular LUKS since OPAL reuses the existing LUKS framework.\n\nSee dm-crypt/Swap encryption.\n\n"
    },
    {
      "title": "BIOS based ATA-password",
      "level": 2,
      "content": "Previous to the industry's TCG OPAL 2.0 standard initiative, the relevant ATA standard defined an \"ATA security feature set\" for full-disk encryption using self-encrypting drives. This relies on the PC BIOS, not the drive, to feature an unlocking mechanism utilizing the BIOS to setup the user's encryption passphrase. This legacy BIOS-based (ATA) method was considered more unreliable to setup and prone to error with regard to interoperability between PC vendors.[8] Typical errors include, for example, inabilities to unlock a device once it is plugged into a system from a different hardware vendor. Hence, the availability of BIOS support for the legacy password mechanism decreases in availability, particularly for consumer hardware.\n\nSee Solid state drive#Security for more information.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- sedutil (github)\n- sedutil official docs\n- sedutil-cli commands usage\n- sedutil-sleep\n\n"
    }
  ]
}