{
  "title": "Systemd/timer",
  "url": "https://wiki.archlinux.org/title/Systemd/timer",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- systemd\n- systemd/User\n- systemd FAQ\n- cron\n\nTimers are systemd unit files whose name ends in .timer that control .service files or events. Timers can be used as an alternative to cron (read #As a cron replacement). Timers have built-in support for calendar time events, monotonic time events, and can be run asynchronously.\n\n"
    },
    {
      "title": "Timer units",
      "level": 2,
      "content": "Timers are systemd unit files with a suffix of .timer. Timers are like other unit configuration files and are loaded from the same paths but include a [Timer] section which defines when and how the timer activates. Timers are defined as one of two types:\n\n- Realtime timers (a.k.a. wallclock timers) activate on a calendar event, the same way that cronjobs do. The option OnCalendar= is used to define them.\n- Monotonic timers activate after a time span relative to a varying starting point. They stop if the computer is temporarily suspended or shut down. There are number of different monotonic timers but all have the form: OnTypeSec=. Common monotonic timers include OnBootSec and OnUnitActiveSec.\n\nFor a full explanation of timer options, see the systemd.timer(5). The argument syntax for calendar events and time spans is defined in systemd.time(7).\n\n"
    },
    {
      "title": "Service units",
      "level": 2,
      "content": "For each .timer file, a matching .service file exists (e.g. foo.timer and foo.service). The .timer file activates and controls the .service file. The .service does not require an [Install] section as it is the timer units that are enabled. If necessary, it is possible to control a differently-named unit using the Unit= option in the timer's [Timer] section.\n\n"
    },
    {
      "title": "Management",
      "level": 2,
      "content": "To use a timer unit enable and start it like any other unit (remember to add the .timer suffix). To view all started timers, run:\n\n```\n$ systemctl list-timers\n```\n\n```\nNEXT                          LEFT        LAST                          PASSED     UNIT                         ACTIVATES\nThu 2014-07-10 19:37:03 CEST  11h left    Wed 2014-07-09 19:37:03 CEST  12h ago    systemd-tmpfiles-clean.timer systemd-tmpfiles-clean.service\nFri 2014-07-11 00:00:00 CEST  15h left    Thu 2014-07-10 00:00:13 CEST  8h ago     logrotate.timer              logrotate.service\n```\n\n- To list all timers (including inactive), use systemctl list-timers --all.\n- The status of a service started by a timer will likely be inactive unless it is currently being triggered.\n- If a timer gets out of sync, it may help to delete its stamp-* file in /var/lib/systemd/timers (or ~/.local/share/systemd/ in case of user timers). These are zero length files which mark the last time each timer was run. If deleted, they will be reconstructed on the next start of their timer.\n\n"
    },
    {
      "title": "Examples",
      "level": 2,
      "content": "A service unit file can be scheduled with a timer out-of-the-box. The following examples schedule foo.service to be run with a corresponding timer called foo.timer.\n\n"
    },
    {
      "title": "Monotonic timer",
      "level": 3,
      "content": "A timer which will start 15 minutes after boot and again every week while the system is running.\n\n```\n/etc/systemd/system/foo.timer\n```\n\n```\n[Unit]\nDescription=Run foo weekly and on boot\n\n[Timer]\nOnBootSec=15min\nOnUnitActiveSec=1w\n\n[Install]\nWantedBy=timers.target\n```\n\n"
    },
    {
      "title": "Realtime timer",
      "level": 3,
      "content": "A timer which starts once a week (at 12:00am on Monday). When activated, it triggers the service immediately if it missed the last start time (option Persistent=true), for example due to the system being powered off:\n\n```\n/etc/systemd/system/foo.timer\n```\n\n```\n[Unit]\nDescription=Run foo weekly\n\n[Timer]\nOnCalendar=weekly\nPersistent=true\n\n[Install]\nWantedBy=timers.target\n```\n\nWhen more specific dates and times are required, OnCalendar events uses the following format:\n\n```\nDayOfWeek Year-Month-Day Hour:Minute:Second\n```\n\nAn asterisk may be used to specify any value and commas may be used to list possible values. Two values separated by .. indicate a contiguous range.\n\nIn the below example the service is run the first four days of each month at 12:00 PM, but only if that day is a Monday or a Tuesday.\n\n```\nOnCalendar=Mon,Tue *-*-01..04 12:00:00\n```\n\nTo run a service on the first Saturday of every month, use:\n\n```\nOnCalendar=Sat *-*-1..7 18:00:00\n```\n\nWhen using the DayOfWeek part, at least one weekday has to be specified. If you want something to run every day at 4am, use:\n\n```\nOnCalendar=*-*-* 4:00:00\n```\n\nTo run a service at different times, OnCalendar may be specified more than once. In the example below, the service runs at 22:30 on weekdays and at 20:00 on weekends.\n\n```\nOnCalendar=Mon..Fri 22:30\nOnCalendar=Sat,Sun 20:00\n```\n\nYou can also specify a timezone at the end of the directive (use timedatectl list-timezones to list accepted values)\n\n```\nOnCalendar=*-*-* 02:00:00 Europe/Paris\n```\n\nMore information is available in systemd.time(7).\n\n- OnCalendar time specifications can be tested in order to verify their validity and to calculate the next time the condition would elapse when used on a timer unit file with the calendar option of the systemd-analyze utility. For example, one can use systemd-analyze calendar weekly or systemd-analyze calendar \"Mon,Tue *-*-01..04 12:00:00\". Add --iterations=N to ask for more iterations to be printed.\n- The faketime command is especially useful to test various scenarios with the above command; it comes with the libfaketime package.\n- Special event expressions like daily and weekly refer to specific start times and thus any timers sharing such calendar events will start simultaneously. Timers sharing start events can cause poor system performance if the timers' services compete for system resources. The RandomizedDelaySec option in the [Timer] section avoids this problem by randomly staggering the start time of each timer. See systemd.timer(5).\n- Add the option AccuracySec=1us to the [Timer] section, to avoid the inaccuracy of the 1m default value of AccuracySec. Also see systemd.timer(5).\n- Some options (WakeSystem) may require specific system capabilities and prevent a timer from starting, resulting in the following error messages: \"Failed to enter waiting state: Operation not supported\" and \"Failed with result 'resources'.\".\n\n"
    },
    {
      "title": "Transient timer units",
      "level": 2,
      "content": "One can use systemd-run to create transient .timer units. That is, one can set a command to run at a specified time without having a service file. For example the following command touches a file after 30 seconds:\n\n```\n# systemd-run --on-active=30 /bin/touch /tmp/foo\n```\n\nOne can also specify a pre-existing service file that does not have a timer file. For example, the following starts the systemd unit named someunit.service after 12.5 hours have elapsed:\n\n```\n# systemd-run --on-active=\"12h 30m\" --unit someunit.service\n```\n\nSee systemd-run(1) for more information and examples.\n\n"
    },
    {
      "title": "As a cron replacement",
      "level": 2,
      "content": "Although cron is arguably the most well-known job scheduler, systemd timers can be an alternative.\n\n"
    },
    {
      "title": "Benefits",
      "level": 3,
      "content": "The main benefits of using timers come from each job having its own systemd service. Some of these benefits are:\n\n- Jobs can be easily started independently of their timers. This simplifies debugging.\n- Each job can be configured to run in a specific environment (see systemd.exec(5)).\n- Jobs can be attached to cgroups.\n- Jobs can be set up to depend on other systemd units.\n- Jobs are logged in the systemd journal for easy debugging.\n\n"
    },
    {
      "title": "Caveats",
      "level": 3,
      "content": "Some things that are easy to do with cron are difficult to do with timer units alone:\n\n- Creation: to set up a timed job with systemd you need to create two files and run systemctl commands, compared to adding a single line to a crontab.\n- Emails: there is no built-in equivalent to cron's MAILTO for sending emails on job failure. See systemd#Notifying with e-mail for an example of setting up a similar functionality using OnFailure=.\n\nAlso note that user timer units will only run during an active user login session by default. However, lingering can enable services to run at boot even when the user has no active login session.\n\n"
    },
    {
      "title": "Using a crontab",
      "level": 3,
      "content": "Several of the caveats can be worked around by installing a package that parses a traditional crontab to configure the timers. systemd-cron-next-gitAUR and systemd-cronAUR are two such packages. These can provide the missing MAILTO feature.\n\nAlso, like with crontabs, a unified view of all scheduled jobs can be obtained with systemctl. See #Management.\n\n"
    },
    {
      "title": "Manually",
      "level": 3,
      "content": "Outside of migrating from an existing crontab, using the same periodicity as cron can be desired. To avoid the tedious task of creating a timer for each service to start periodically, use a template unit, for example:\n\n```\n/etc/systemd/system/monthly@.timer\n```\n\n```\n[Unit]\nDescription=Monthly Timer for %i service\n\n[Timer]\nOnCalendar=*-*-1 02:00:00\nAccuracySec=6h\nRandomizedDelaySec=1h\nPersistent=true\nUnit=%i.service\n\n[Install]\nWantedBy=default.target\n```\n\nThen one only needs to enable/start monthly@unit_name.timer.\n\n"
    },
    {
      "title": "Handling \"time to live\"",
      "level": 3,
      "content": "Some software will track the time elapsed since they last ran, for example blocking the update of a database if the last download ended less than 24 hours ago.\n\nBy default, timers do not track when the task they launched has ended. To work around this, we can use OnUnitInactiveSeconds:\n\n```\n/etc/systemd/system/daily-inactive@.timer\n```\n\n```\n[Unit]\nDescription=Launch %i service 24hours after it deactivated\n\n[Timer]\nOnUnitInactiveSec=1day1sec\nUnit=%i.service\nPersistent=true\n\n[Install]\nWantedBy=default.target\n```\n\n"
    },
    {
      "title": "Desktop notifications",
      "level": 3,
      "content": "The systemd-timer-notifyAUR provides an automatic desktop notification that helps you notice when a systemd service is triggered by a timer and is running. The notification will automatically close when the service finishes.\n\nThis can be helpful for understanding why CPU usage is high or for preventing a shutdown when a backup service hasn't finished.\n\nFor more details and configuration options, visit https://gitlab.com/Zesko/systemd-timer-notify\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- systemd.timer(5)\n- Fedora:Features/SystemdCalendarTimers\n- Gentoo:Systemd#Timer services\n- systemd-cron — provides systemd units to run cron scripts; using systemd-crontab-generator to convert crontabs\n\n- systemd-cron-next — tool to generate timers/services from crontab and anacrontab files\n\n- Systemd Timers for Scheduling Tasks\n\n"
    }
  ]
}