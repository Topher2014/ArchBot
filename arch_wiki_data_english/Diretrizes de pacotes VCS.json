{
  "title": "Diretrizes de pacotes VCS",
  "url": "https://wiki.archlinux.org/title/Diretrizes_de_pacotes_VCS",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Fonte – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust – Shell – VCS – Web – Wine\n\nSistema de controle de versões pode ser usado para obter o código-fonte para tanto pacotes versionados estaticamente quanto a última versão (trunk) de um ramo de desenvolvimento. Esse artigo cobre ambos casos.\n\n"
    },
    {
      "title": "Protótipos",
      "level": 2,
      "content": "Use apenas os protótipos de PKGBUILD fornecidos pelo pacote pacman (PKGBUILD-split.proto, PKGBUILD-vcs.proto e PKGBUILD.proto em /usr/share/pacman).\n\n"
    },
    {
      "title": "Nomenclatura de pacote",
      "level": 3,
      "content": "- Adicione um sufixo a pkgname com -cvs, -svn, -hg, -darcs, -bzr, -git etc. a menos que o pacote obtenha uma versão específica.\n\n"
    },
    {
      "title": "Versionamento",
      "level": 3,
      "content": "- Se o pacote resultante for diferente depois de alterar, por exemplo, as dependências, URL ou fontes, atualize o pkgrel para a versão mais recente. Se o pkgver não tiver alterado desde a última atualização do PKGBUILD, aumente o pkgrel.\n\n"
    },
    {
      "title": "Conflitos e dependências",
      "level": 3,
      "content": "- Inclua o que o pacote conflita com e fornece (p.ex. para fluxbox-gitAUR: conflicts=('fluxbox') e provides=('fluxbox')).\n- replaces=() geralmente causa problemas desnecessários e deve ser evitado.\n- Inclua a ferramenta de VCS apropriada em makedepends=() (cvs, subversion, git, ...).\n\n"
    },
    {
      "title": "Autenticação e segurança",
      "level": 3,
      "content": "- Ao usar o cvsroot, use anonymous:@ em vez de anonymous@ para evitar ter que digitar uma senha em branco ou anonymous:senha@, se uma for exigida.\n- Porque os fontes não são estáticos, ignore a verificação de soma em sha256sums=() adicionando 'SKIP'.\n\n"
    },
    {
      "title": "Fontes VCS",
      "level": 3,
      "content": "A partir do pacman 4.1, os fontes VCS devem ser especificados no vetor source=() e será tratado como qualquer outro fonte. makepkg vai realizar clone/checkout/branch do repositório para $SRCDEST (mesmo que $startdir se não definido no makepkg.conf(5)) e vai copiá-lo para $srcdir (em uma forma específica para cada VCS). O repositório local é deixado intocado, portanto passando a ser desnecessário ter um diretório -build.\n\nO formato geral de um vetor source=() de VCS é:\n\n```\nsource=('[pasta::][vcs+]url[#fragmento]')\n```\n\n- pasta (opcional) é usada para alterar o nome do repositório padrão para algo mais relevante (p. ex., do que trunk) ou para preservar os fontes anteriores.\n- vcs+ é necessário para URLs que não refletem o tipo VCS, p. ex., git+http://algum_repo.\n- url é o URL para o repositório distante ou local.\n- #fragmento (opcional) é necessário para fazer pull um branch ou commit específico. Veja PKGBUILD(5) § USING VCS SOURCES para uma lista de VCS suportados e os respectivos fragmentos disponíveis.\n\nUm exemplo de vetor fonte de Git:\n\n```\nsource=('nome_projeto::git+https://url_projeto#branch=ramo_projeto')\n```\n\n"
    },
    {
      "title": "A função pkgver()",
      "level": 3,
      "content": "O autoincremento de pkgver agora é alcançado através de uma função pkgver() dedicada. Isso permite um melhor controle sobre o pkgver, e os mantenedores devem favorecer um pkgver que faça sentido. Para usar pkgver(), você ainda precisa declarar a variável pkgver com o valor mais recente. O makepkg irá invocar a função pkgver() e atualizar a variável pkgver de acordo.\n\nRecomenda-se ter o seguinte formato de versão: LANÇAMENTO.rREVISÃO onde REVISÃO é um número monotonicamente crescente que identifica exclusivamente a árvore de fonte (revisões VCS fazem isso). Se não houver lançamentos públicos e nenhuma tag de repositório, o zero pode ser usado como um número de release ou você pode descartar LANÇAMENTO e usar o número da versão que se parece com rREVISÃO. Se houver lançamentos públicos, mas o repositório não tiver tags, o desenvolvedor deve obter a versão de lançamento de alguma forma, por exemplo, analisando os arquivos do projeto.\n\nO delimitador do número de revisão (\"r\" logo antes da REVISÃO) é importante. Esse delimitador permite evitar problemas caso o upstream decida fazer seu primeiro lançamento ou use versões com diferentes números de componentes. Por exemplo, se na revisão \"455\" o upstream decidir lançar a versão 0.1, o delimitador de revisão preservará a monotonicidade da versão - 0.1.r456 > r454. Sem o delimitador, a monotonicidade falha - 0.1.456 < 454.\n\nVeja PKGBUILD-vcs.proto para exemplos genéricos mostrando a saúde visada.\n\n"
    },
    {
      "title": "Git",
      "level": 4,
      "content": "Usando a tag anotada mais recente alcançável do último commit:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  git describe --long --abbrev=7 | sed 's/\\([^-]*-g\\)/r\\1/;s/-/./g'\n}\n```\n\n```\n2.0.r6.ga17a017\n```\n\nUsando a tag não anotada mais recente alcançável do último commit:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  git describe --long --tags --abbrev=7 | sed 's/\\([^-]*-g\\)/r\\1/;s/-/./g'\n}\n```\n\n```\n0.71.r115.gd95ee07\n```\n\nNo caso, se a tag git não contém traços, então pode-se usar uma expressão sed mais simples, como sed 's/-/.r/;s/-/./'.\n\nSe a tag contiver um prefixo, como v ou o nome do projeto, ele deverá ser cortado:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  # cortando o prefixo \"foo-\" apresentado na tag do git\n  git describe --long --abbrev=7 | sed 's/^foo-//;s/\\([^-]*-g\\)/r\\1/;s/-/./g'\n}\n```\n\n```\n6.1.r3.gd77e105\n```\n\nSe não houver tags, use o número de revisões desde o início do histórico:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  printf \"r%s.%s\" \"$(git rev-list --count HEAD)\" \"$(git rev-parse --short=7 HEAD)\"\n}\n```\n\n```\nr1142.a17a017\n```\n\nVersão e somente o commit/número da revisão (SHA1 omitido; no entanto, sem uma referência rápida SHA1 de uma revisão exata, ela é perdida se não estiver atento ao controle de versão):\n\n```\ngit describe --long --abbrev=7 --tags | sed 's/\\([^-]*\\)-g.*/r\\1/;s/-/./g'\n```\n\nAmbos os métodos também podem ser combinados, para suportar repositórios que iniciam sem uma tag, mas são marcados mais tarde (use um \"bashismo\"):\n\n```\npkgver() {\n  cd \"$pkgname\"\n  ( set -o pipefail\n    git describe --long --abbrev=7 2>/dev/null | sed 's/\\([^-]*-g\\)/r\\1/;s/-/./g' ||\n    printf \"r%s.%s\" \"$(git rev-list --count HEAD)\" \"$(git rev-parse --short=7 HEAD)\"\n  )\n}\n```\n\n```\n0.9.9.r27.g2b039da  # se tags existirem\nr1581.2b039da       # do contrário\n```\n\n"
    },
    {
      "title": "Subversion",
      "level": 4,
      "content": "```\npkgver() {\n  cd \"$pkgname\"\n  local ver=\"$(svnversion)\"\n  printf \"r%s\" \"${ver//[[:alpha:]]}\"\n}\n```\n\n```\nr8546\n```\n\n"
    },
    {
      "title": "Mercurial",
      "level": 4,
      "content": "```\npkgver() {\n  cd \"$pkgname\"\n  printf \"r%s.%s\" \"$(hg identify -n)\" \"$(hg identify -i)\"\n}\n```\n\n```\nr2813.75881cc5391e\n```\n\n"
    },
    {
      "title": "Bazaar",
      "level": 4,
      "content": "```\npkgver() {\n  cd \"$pkgname\"\n  printf \"r%s\" \"$(bzr revno)\"\n}\n```\n\n```\nr830\n```\n\n"
    },
    {
      "title": "Reserva",
      "level": 4,
      "content": "Caso nenhum pkgver satisfatório possa ser extraído do repositório, a data atual pode ser usada:\n\n```\npkgver() {\n  date +%Y%m%d\n}\n```\n\n```\n20130408\n```\n\nEmbora não identifique o estado da árvore de fonte de forma exclusiva, então evite-o, se possível.\n\n"
    },
    {
      "title": "Submódulos git",
      "level": 3,
      "content": "Submódulos de Git são um pouco complicados de se fazer. A ideia é adicionar as URLs dos submódulos diretamente ao vetor de fontes e, em seguida, referenciá-las durante o prepare().\n\nOs desenvolvedores de projetos downstream podem não nomear seu submódulo com o mesmo nome do repositório do módulo upstream. Para visualizar o nome dos submódulos git, acesse o arquivo .gitmodules no repositório do projeto e visualize-o. Por exemplo, um repositório denominado biblioteca-dependência pelos desenvolvedores upstream pode ser registrado como um submódulo denominado libs/libdep no .gitmodules do downstream.\n\n```\n[submodule \"lib/libdep\"]\n  path = lib/libdep\n  url = https://example.org/biblioteca-dependência/biblioteca-dependência.git\n```\n\n```\nsource=(\"git+https://example.org/projeto-principal/projeto-principal.git\"\n        \"git+https://example.org/biblioteca-dependência/biblioteca-dependência.git\")\n\nprepare() {\n  cd projeto-principal\n  git submodule init\n  git config submodule.libs/libdep.url \"$srcdir/biblioteca-dependência\"\n  git -c protocol.file.allow=always submodule update\n}\n```\n\n"
    }
  ]
}