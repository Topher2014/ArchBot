{
  "title": "Fvwm",
  "url": "https://wiki.archlinux.org/title/Fvwm",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Window manager\n\nNote: **This article or section is a candidate for moving to Fvwm.** This article or section is a candidate for moving to Fvwm.\n\nThis article or section is a candidate for moving to Fvwm.\n\nNote: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nFvwm3 was created as a fork of Fvwm2 for any future development with the intent to break compatibility with Fvwm2 to allow major changes. Fvwm3 version 1.0.0 was published on 3 September 2020.\n\nFvwm is an ICCCM-compliant multiple virtual desktop window manager for the X Window system. It is configured by editing text-based configuration files. Although using FVWM does not require any knowledge of programming languages, it is possible to extend FVWM with M4, C, and Perl preprocessing. FVWM also has a Perl library which allows one to create modules. FVWM stands for F Virtual Window Manager with the preferred interpretation being that the F does not stand for anything in particular [1].\n\n"
    },
    {
      "title": "Installing",
      "level": 2,
      "content": "Note: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nInstall the fvwmAUR package.\n\nThe following packages provide themes and icons for FVWM: fvwm-crystalAUR, fvwm-iconsAUR, fvwm-themesAUR, fvwm-themes-extraAUR. FVWM Crystal provides a separate session for a desktop environment like experience.\n\n"
    },
    {
      "title": "Starting",
      "level": 2,
      "content": "Select FVWM from the session menu in a display manager of choice. Otherwise, add exec fvwm to your user's .xinitrc.\n\nFor FVWM Crystal, select FVWM-Crystal from the session menu or add exec fvwm-crystal to your user's .xinitrc.\n\nSee xinitrc for details, such as preserving the logind session.\n\n"
    },
    {
      "title": "Autostart",
      "level": 3,
      "content": "FVWM provides a number of functions to start modules or applications when initialising, restarting or exiting the window manager.\n\n- StartFunction - executed when FVWM is first initialised and on restarts.\n- InitFunction - executed only when FVWM is first initialised.\n- RestartFunction - executed only when FVWM is restarted.\n- ExitFunction - executed when exiting FVWM.\n\nYou can add your own actions to any of these functions using the AddToFunc command. For example, if one wanted to start network-manager-applet on startup (but not for any subsequent restarts of the window manager) one could add the nm-applet command to the InitFunction:\n\n```\nAddToFunc InitFunction\n+ I Exec nm-applet\n```\n\nYou can also use just StartFunction and prepend your commands with Test commands which check whether the window manager has started or restarted and run the action only if the test is true. Using this method, nm-applet could be started in the following manner:\n\n```\nAddToFunc StartFunction\n+ I Test (Init) Exec nm-applet\n```\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "The following configuration file locations are supported:\n\n- $HOME/.fvwm/config\n- /usr/local/share/fvwm/config\n\nThe following configuration locations are supported as of version 2.6.8, but may not be supported in the future:\n\n- $HOME/.fvwm/.fvwm2rc\n- $HOME/.fvwm2rc\n- /usr/local/share/fvwm/.fvwm2rc\n- /usr/local/share/fvwm/system.fvwm2rc\n- /etc/system.fvwm2rc\n\nAs of version 2.6.7, FVWM ships with a new default configuration, located in /usr/share/fvwm/default-config. As such, the older sample configuration files are no longer provided. However, they can still be viewed on GitHub. The fvwm-themes project also provides ready-made configurations though it should be noted that these have not been updated since 2003 and may require modifications to work correctly with more recent FVWM versions.\n\n"
    },
    {
      "title": "The virtual desktop",
      "level": 3,
      "content": "For its virtual desktop, FVWM implements both workspaces (used by window managers such as Metacity and Openbox) and viewports (used by window managers such as Compiz). See [2] for a description of the differences between workspaces and viewports. FVWM refers to workspaces as desks and viewports as pages.\n\nPages in FVWM are arranged in a grid. The number of pages used can be defined with the DesktopSize command. For instance, adding DesktopSize 3x3 to your configuration file will give you 9 pages, arranged in a 3x3 grid. Pages can be navigated using the pager module or with the GoToPage command which could be mapped to a keyboard shortcut or menu entry. For instance, the command GoToPage -1p +0p will move the viewport 1 page to the left of the current page.\n\nThe number of desks available in FVWM is very large, the minimum desk number is -2147483648 and the maximum is 2147483647. By default, FVWM starts on desk 0. Desks can be navigated using the pager module (if it is configured to show a number of desks) or with the GoToDesk command - GoToDesk +1 will move to the next desk, relative to the currently used desk.\n\n"
    },
    {
      "title": "Keyboard and mouse bindings",
      "level": 3,
      "content": "Keyboard or bindings can be defined in the configuration file with the Key or Mouse command. The syntax of the command takes the following form: Key/Mouse (window) button/key name context modifiers action. For instance, the following example will launch an XTerm on an Alt+F2 keypress: Key F2 A 1 Exec xterm. Note that the (window) argument is optional.\n\nThe context value defines where the binding will be applied. The following contexts are valid: R (root window), W (application window), D (desktop manager window - PCManFM desktop manager for instance), T (title bar), S (window side, top, bottom), [ ] - _ (left side, right side, top, bottom respectively), F (window frame corners), < > ^ v (left, right, top, bottom corners respectively), I (icon window), 0-9 (titlebar buttons) and A (all contexts). Any combination of these letters is also acceptable.\n\nThe modifier value can be one of the following: A (any), C (control), S (shift), M (meta), N (none), or 1-5, representing the X Modifiers - run xmodmap to see which X modifier is which. Multiple modifiers should not be spaced. For instance, to use the modifier Control+Alt, you would supply as the modifier argument C1.\n\nThe action must be an FVWM function to run, such as the Quit function or Menu function. Execution of external commands, such as xterm, can be achieved with the Exec function, as shown above.\n\n"
    },
    {
      "title": "Titlebar buttons",
      "level": 4,
      "content": "FVWM can provide up to 10 window buttons. These are numbered 0-9. Even numbers indicate buttons located on the right hand side of the titlebar whilst odd numbers indicate buttons located on the left. The layout is as follows:\n\n```\n1 3 5 7 9    0 8 6 4 2\n```\n\nWindow buttons will remain hidden unless a Mouse command is used which specifies one of the titlebar buttons as the context. For instance, to activate the rightmost titlebar button and make it close the window on a left click, one would use the following command:\n\n```\nMouse 1 2 A Close\n```\n\nMouse is the name of the command, 1 is the mouse button, 2 is the number of the rightmost titlebar button, A is the modifier (any) and Close is the action to be taken. See #Keyboard and mouse bindings for more information.\n\n"
    },
    {
      "title": "Button styles",
      "level": 4,
      "content": "The style of your titlebar buttons can be configured with the ButtonStyle command. This takes the following syntax:\n\n```\nButtonStyle button-number state style -- flag\n```\n\nThe state can be one of ActiveUp, ActiveDown, InactiveUp, InactiveDown. ActiveUp and ActiveDown refer to the un-pressed and pressed button states of the active window. Likewise for the Inactive states. One can also use just Active or Inactive which are shortcuts for both the pressed and un-pressed button states.\n\nThe style argument can be one of the following:\n\n- Simple - does nothing.\n- Default - takes argument of button number for default style to load.\n- Solid - fill button a solid color.\n- ColorSet - fill button with the ColorSet specified - takes an alpha argument between 0 and 100.\n- Vector - draws a line pattern - using the keyword Vector is optional as this is a standard style.\n- ?Gradient - fills the button with a gradient - see the Color Gradients section of [dead link 2023-10-29 ⓘ] fvwm(1) for the syntax.\n- Pixmap - fills the button with a given pixmap - see also the following variants: AdjustedPixmap, ShrunkPixmap, StretchedPixmap, TiledPixmap.\n- MiniIcon - fills the button with the window's mini icon.\n\nA number of vector styles are documented here. You can also create your own vector buttons using this vector buttons viewer. Finally, see this page for some example decoration configurations that use pixmaps, including imitations of Crux (a Sawfish theme), Mac OS and Windows 98.\n\nThe flag affects the state for a button. Some examples of flags include Raised, Sunk and Flat. For more information, see [dead link 2023-10-29 ⓘ] fvwm(1) and look for the ButtonStyle section.\n\n"
    },
    {
      "title": "Title and border styles",
      "level": 4,
      "content": "The window titles and borders can be configured with the TitleStyle and BorderStyle commands respectively.\n\nTitleStyle can take the following arguments:\n\n```\nTitleStyle justify Height height-in-pixels\n```\n\nThe justify argument can be LeftJustified, RightJustified or Centered. TitleStyle and BorderStyle can take the following arguments:\n\n```\nTitleStyle/BorderStyle state style -- flag\n```\n\nSee #Button styles for the state, style and flag arguments.\n\n"
    },
    {
      "title": "Menus",
      "level": 3,
      "content": "Menus can be created with the AddToMenu command. This takes the following syntax:\n\n```\nAddToMenu menu-name menu-title Title\n```\n\nRemove the menu-title and Title arguments to create a menu with no title. Subsequent entries in the menu take the following syntax:\n\n```\n+ entry-name action\n```\n\nSee the following example:\n\n```\nAddToMenu \"Web\" \"Web Browsers\" Title\n+ \"Firefox\" Exec firefox\n+ \"Chromium Exec chromium\n+ \"Opera\"   Exec opera\n```\n\nUse the Popup command to show other menus. For instance, to include the menu defined above in another menu one could use the following syntax:\n\n```\n+ \"Web Browsers\" Popup \"Web\"\n```\n\nFVWM menus also support icons. To give a menu entry an icon, provide the path to the icon enclosed in % signs after the entry name - see below:\n\n```\n+ \"Chromium %/usr/share/icons/hicolor/16x16/apps/chromium.png%\" Exec chromium\n```\n\nUse the xdg_menu tool, provided by archlinux-xdg-menu, to automatically generate menus - see Xdg-menu#Fvwm2.\n\n"
    },
    {
      "title": "Dynamic menus",
      "level": 4,
      "content": "Menus in FVWM can be dynamic, meaning that their content is refreshed every time the menu is opened. This can be useful when using a menu generator, such as one that constructs a menu of applications from XDG desktop entries, and you want the content to always be up to date.\n\nDynamic menus can be created in FVWM by using the DynamicPopUpAction and DynamicPopDownAction keywords. The former can be used to create/recreate the menu when it is opened whilst the latter can be used to clear the menu when it is closed. It is important to note that for a submenu to be dynamic, the parent menu that it is included in must also be created dynamically even if it does not contain any dynamic content.\n\nConsider a hypothetical menu generator called my-menu which generates output of the sort below.\n\n```\nDestroyMenu recreate Submenu1\nAddToMenu Submenu1 \"Submenu 1\" Title\n+ \"Item 1\" Nop\n+ \"Item 2\" Nop\n\nDestroyMenu recreate MyMenu\nAddToMenu MyMenu \"My Menu\" Title\n+ \"Submenu 1\" Popup Submenu1\n```\n\nNote: **all** \n\nNow suppose that we wished to incorporate my-menu into our root menu dynamically. This means that the root menu must also be created dynamically. To accomplish this, we need to define a function that constructs the root menu and a function that calls the dynamic menu generator using the PipeRead command. Then in the menu definitions themselves, DynamicPopUpAction can be used to call those functions. See the example below.\n\n```\nDestroyMenu RootMenu\nAddToMenu RootMenu\n+ DynamicPopUpAction Function CreateRootMenu\n+ DynamicPopDownAction DestroyMenu recreate RootMenu\n\nDestroyFunc CreateRootMenu\nAddToFunc CreateRootMenu\n+ I DestroyMenu recreate RootMenu\n+ I AddToMenu RootMenu \"Root Menu\" Title\n+ I AddToMenu RootMenu \"My Menu\" PopUp MyMenu\n+ I AddToMenu RootMenu \"XTerm\" Exec xterm\n+ I AddToMenu RootMenu \"Firefox\" Exec firefox\n\nDestroyMenu MyMenu\nAddToMenu MyMenu\n+ DynamicPopUpAction Function CreateMyMenu\n+ DynamicPopDownAction DestroyMenu recreate MyMenu\n\nDestroyFunc CreateMyMenu\nAddToFunc CreateMyMenu\n+ I DestroyMenu recreate MyMenu\n+ I PipeRead 'my-menu'\n```\n\n"
    },
    {
      "title": "Style command",
      "level": 3,
      "content": "The Style command allows one to configure various aspects of the window manager itself and also to set behaviors for certain windows. The syntax is Style window-name stylename. The window-name argument can be a window name, class, title name or resource string. Use * to match all windows. See [dead link 2023-10-29 ⓘ] fvwm(1) for all available styles - some examples are provided below:\n\n- Style \"*\" CascadePlacement - make the window manager use the cascade placement algorithm for all new windows.\n- Style \"Chromium\" PositionPlacement center - ensure that all new Chromium windows are placed in the center of the screen.\n- Style \"xterm\" StartIconic - ensure that all new XTerm windows start iconified.\n- Style \"*\" HilightBack indianred - set the frame background of any focused window to the color indianred.\n\n"
    },
    {
      "title": "Functions",
      "level": 3,
      "content": "FVWM provides many built in functions, examples being Close to close a window or Exec which allows the execution of an external command. Users can also define their own functions or add to existing functions using the AddToFunc command. This uses the following syntax: AddToFunc func-name I|M|C|H|D action. The letter codes stand for the following: I - execute immediately, M - execute when the user moves the mouse, C - execute on mouse click, H - execute when the user holds the mouse button, D - execute when the user double clicks the mouse button. Below is a trivial example of a function:\n\n```\nAddToFunc VolumeFunc\n+ I Exec xterm -e alsamixer\n```\n\nOne can also use conditional commands (see [dead link 2023-10-29 ⓘ] fvwm(1) and look for the Conditional Commands section). For instance, suppose one wanted a function that would close all windows in the current page other than the one which has focus. That function can be defined as below:\n\n```\nAddToFunc CloseAllButThis\n+ I All (CurrentPage, !Focused) Close\n```\n\nThe All conditional matches all windows that meet the conditions defined in parenthesis. Functions can execute more than one action, just add one line for each action beginning with a plus sign:\n\n```\nAddToFunc MyFunc\n+ I action1\n+ D action2\n+ I action3\n```\n\n"
    },
    {
      "title": "Modules",
      "level": 3,
      "content": "Modules are separate programs, spawned by FVWM that can add extra functionality. Modules can be spawned using the following syntax: Module ModuleName (identifier) ModuleArgs.\n\nSometimes, one might want to spawn multiple instances of the same type of module, each with their own separate configuration. In this case, one should spawn the module with an identifier, for instance:\n\n```\nAddToFunc StartFunction\n+ I Module FvwmButtons Panel1\n+ I Module FvwmButtons Panel2\n```\n\nwhere Panel1 and Panel2 are the identifiers.\n\nMost modules will have a number of module commands which can be used to configure the module's appearance or behavior. Use the following syntax:\n\n```\n*ModuleName/Identifier: module-command command-args\n```\n\nFor instance, if one spawned an FvwmPager with the identifier MyPager then one could configure it in the following fashion:\n\n```\n*MyPager: Geometry 135x90+0+0\n*MyPager: Back midnightblue\n```\n\n"
    },
    {
      "title": "FvwmPager",
      "level": 4,
      "content": "The FvwmPager is a module which provides a visual representation of the desks and pages provided by the window manager. Like all modules, it must be spawned by FVWM. To start an FvwmPager, add something similar to the following to your StartFunction:\n\n```\n+ I Module FvwmPager\n```\n\nWith no arguments, the FvwmPager will only display the viewports for desk 0. With the arguments 0 9, FvwmPager will show the 10 desks from 0-9.\n\n```\n+ I Module FvwmPager 0 9\n```\n\nWith the argument * the FvwmPager will show only one desk but it will always be the desk that is currently being used.\n\n```\n+ I Module FvwmPager *\n```\n\nSee [dead link 2023-10-29 ⓘ] FvwmPager(1) for a list of module commands.\n\n"
    },
    {
      "title": "FvwmButtons",
      "level": 4,
      "content": "FvwmButtons is a module which can create a box of buttons which can perform actions when pressed. FvwmButtons can also \"swallow\" application windows. This might be useful for swallowing a system tray window or a clock window. The size of the panel is automatically determined (the panel will resize to accommodate all elements) however it is also possible to manually set a size using the Geometry command. This takes a standard X geometry. The basic commands needed to create an FvwmButtons panel are outlined below.\n\nSet the number of rows and columns:\n\n```\n*FvwmButtons: Rows x\n*FvwmButtons: Columns x\n```\n\nNote that items are added by filling each row from left to right, from the top row to the bottom one.\n\nCreate a button (this example creates a button with a title and an icon which launches an XTerm when left clicked):\n\n```\n*FvwmButtons: (Title \"Xterm\", Icon /usr/share/pixmaps/mini.xterm_48x48.xpm, Action (Mouse1) Exec xterm)\n```\n\nYou can omit any of these arguments if you so choose.\n\nSwallow a window (this example swallows a stalonetray):\n\n```\n*FvwmButtons: (Swallow(UseOld, NoClose) \"stalonetray\" \"Nop\")\n```\n\nThe Swallow command takes a number of \"hangon\" arguments. Here, the UseOld and NoClose arguments have been used. UseOld means that an existing window will be swallowed if it exists. NoClose means that the window will not be closed if the FvwmButtons process is terminated. The stalonetray argument is the class of the window that we want to swallow. Replace as appropriate. The last argument is a command to start the application that is to be swallowed. In this example, it is assumed that the application has already been started so the argument provided is Nop which is a function that does nothing. One could replace this with \"Exec stalonetray\" to start the application from the FvwmButtons module instead of assuming that the application has been started elsewhere.\n\nContainers are spaces defined which can span multiple rows and columns or subdivide a row or column into more rows or columns. This can be useful for instance if one wants to allocate a certain percentage of space to an element. Say one wants to swallow an XClock and allocate 100% of the width and 80% of the height to the XClock. This can be defined as such:\n\n```\n*FvwmButtons: Rows 5\n*FvwmButtons: Columns 1\n*FvwmButtons: (1x4, Container)\n*FvwmButtons: (Swallow(UseOld, NoClose) \"xclock\" \"Nop\")\n*FvwmButtons: (End)\n```\n\nNote that a container is created by defining a certain number of columns and rows and then using the keyword container. Elements inside the container are defined underneath this line and the container is then closed with the End command.\n\nFor a full list of options, see [dead link 2023-10-29 ⓘ] FvwmButtons(1).\n\n"
    },
    {
      "title": "FvwmEvent",
      "level": 4,
      "content": "FvwmEvent is a module which can be used to bind a function or an audio file to a window manager event (such as the closing of a window). In the case of an audio file, the audio will be played when the event that it is bound to occurs. FvwmEvent can be spawned from within Fvwm by adding the following to your StartFunction:\n\n```\n+ I Module FvwmEvent\n```\n\nFvwmEvent can also be spawned with an identifier - see #Modules. Once spawned, FvwmEvent will run in the background, waiting for events that it has been configured to recognize. Events can be configured in the following form:\n\n```\n* FvwmEvent: windowshade Lower\n```\n\nwhere windowshade is the event and Lower is the command to be executed when that event occurs. In the case where you wish to execute a function with arguments, that function and its arguments need to be quoted - see below:\n\n```\n* FvwmEvent: new_page \"Exec xterm\"\n```\n\nFor a full list of events, see [dead link 2023-10-29 ⓘ] FvwmEvent(1).\n\n"
    },
    {
      "title": "FvwmIdent",
      "level": 4,
      "content": "FvwmIdent is a module which can display many items of information about a particular window that it is called on, such as the window's class name, resource name, layer, geometry and more. This information is displayed in a separate window which is created by the module. FvwmIdent can be started using the Module FvwmIdent command. This could be bound to a menu entry or a hotkey. When an FvwmIdent is started in the context of a window, that window's information will be displayed. Otherwise, the user will be prompted to select a window manually.\n\n"
    },
    {
      "title": "Colors",
      "level": 3,
      "content": "FVWM color styles can take a number of color code types such as hexcolors (#ffffff for instance), rbg colors (rgb:ff/ff/ff for instance) as well as the pre-defined X11 colors.\n\nThe following styles might be useful:\n\n- Color - this takes two arguments, the color of the unfocused window title text and the color of the unfocused window frame separated by a forward slash, black/lightgrey for example.\n- HilightBack - takes a single argument, the color of the focused window frame.\n- HilightFore - takes a single argument, the color of the focused window title text.\n\n"
    },
    {
      "title": "Colorsets",
      "level": 4,
      "content": "Colorsets in FVWM are a set of four colors (a foreground color, a background color, a shadow color and a highlight color) as well as an optional background pixmap. Any part of FVWM that uses a particular colorset will be affected if that colorset is changed.\n\nAll colorsets are identified by a number. Any numbering convention can be used; the fvwm-themes project documents one such convention that uses the first 40 colorsets (0-39). See [4].\n\nColorsets can be created with the ColorSet command - syntax: ColorSet number options. See [dead link 2023-10-29 ⓘ] fvwm(1) - the Colorsets section - for more information.\n\n"
    },
    {
      "title": "Fonts",
      "level": 3,
      "content": "For styles such as Font, use xorg-xfontsel to determine the correct font names for X11 fonts - see X Logical Font Description and Font configuration for more information. You can also specify xft fonts, for example: \"xft:DejaVu Sans:size=10\".\n\n"
    },
    {
      "title": "Icons",
      "level": 3,
      "content": "Windows in FVWM can be iconified (minimized). This means that the window will disappear from view and be replaced by an icon on the desktop, similar to the behavior in Microsoft Windows 3.1.\n\nThe program itself will supply the icon. One can also set a default icon to be used, in case a program does not have an icon to supply: Style \"*\" Icon /path/to/default/icon.png.\n\nTo disable icons altogether, use the following style: Style \"*\" NoIcon. This means that the window will simply disappear when iconified.\n\nThe positioning of icons can be controlled using the IconBox style - note that this is not the same thing as the FvwmIconBox module - along with the IconFill style. Use Style \"*\" IconBox none to disable the IconBox. This means that icons will be placed at the position of the top left corner of the window. Else, use Style \"*\" IconBox l t r b where l t r b stand for left, top, right and bottom respectively. These arguments should be the number of pixels away from the screen edge that the IconBox edge should be. Hence, arguments of +0 +0 -0 -0 means that the IconBox will fill the entire screen.\n\nMultiple IconBox styles can be defined but they must be defined on the same line, for instance:\n\n```\nStyle \"*\" IconBox +0 +800 -100 -0, IconBox -200 +0 -0 -120\n```\n\nWhen the first IconBox overflows, icons will then be placed in the second IconBox. Note that if the last IconBox overflows then the default IconBox will be used which covers the entire screen and fills from top to bottom - left to right.\n\nUse the IconFill style to control how icons will be filled. A style of Style \"*\" IconFill left bottom means that icons will be filled from left to right - bottom to top (Motif Window Manager behavior). A style of Style \"*\" IconFill top left means that icons will be filled from top to bottom - left to right. Note that the IconFill style should be defined on the same line as the IconBox style, for instance:\n\n```\nStyle \"*\" IconBox +0 +0 -0 -0, IconFill left bottom\n```\n\n"
    },
    {
      "title": "MWM compatibility options",
      "level": 3,
      "content": "FVWM provides a number of options that allow it to mimic the appearance and behaviour of MWM (Motif Window Manager).\n\n- Emulate Mwm - this commands places the geometry feedback window in the center of the screen.\n- MenuStyle Mwm - this command gives menus the appearance of Motif menus.\n- MwmButtons - this style makes the maximize button look pressed in when a window is maximized.\n- MwmBorder - this style makes the window border bevel more closely match the style of Mwm window borders\n- MwmDecor - this style makes FVWM attempt to honor MWM hints that some applications might set.\n- MwmFunctions - this style make FVWM attempt to recognize and respect functions that MWM would prohibit.\n- HintOverride - this style is similar to MwmFunctions but instead it shades out the prohibited functions but allows the user to perform them anyway.\n\n"
    },
    {
      "title": "Force icon size and background",
      "level": 3,
      "content": "The sizing of icons is not regular as different programs provide icons of differing sizes. Use the IconSize style to force a regular size: Style \"*\" IconSize 48 48 for instance. Note that icons larger than the given size will be clipped.\n\nBy default, icons also have no background. You can use the IconBackgroundColorset style to force icons to have a background. See #Colorsets.\n\n"
    },
    {
      "title": "Do not use a wireframe when moving or resizing windows",
      "level": 3,
      "content": "Use the OpaqueMoveSize unlimited command to view the window itself when moving.\n\nUse Style \"*\" ResizeOpaque to view the window itself when resizing.\n\n"
    },
    {
      "title": "Disable edge scrolling",
      "level": 3,
      "content": "To disable scrolling to the next viewport when moving the mouse pointer to the screen edge, use the following command: EdgeScroll 0 0.\n\n"
    },
    {
      "title": "Use ClickToFocus",
      "level": 3,
      "content": "Ensure that perl-tk and perl-x11-protocol are installed. The use the following style command: Style \"*\" ClickToFocus. See [dead link 2023-10-29 ⓘ] fvwm(1) for other focus behaviors.\n\n"
    },
    {
      "title": "Window tiling",
      "level": 3,
      "content": "The following functions can tile a window to the left half, right half, top half or bottom half of the screen, or to each corner of the screen, when called and return the window to its original position and size when called again.\n\n```\nDestroyFunc TileLeft\nAddToFunc TileLeft\n+ I ThisWindow (!Shaded, !Iconic) Maximize 50 100\n+ I ThisWindow (Maximized, !Shaded, !Iconic) Move +0 +0\n\nDestroyFunc TileRight\nAddToFunc TileRight\n+ I ThisWindow (!Shaded, !Iconic) Maximize 50 100\n+ I ThisWindow (Maximized, !Shaded, !Iconic) Move -0 +0\n\nDestroyFunc TileTop\nAddToFunc TileTop\n+ I ThisWindow (!Shaded, !Iconic) Maximize 100 50\n+ I ThisWindow (Maximized, !Shaded, !Iconic) Move +0 +0\n\nDestroyFunc TileBottom\nAddToFunc TileBottom\n+ I ThisWindow (!Shaded, !Iconic) Maximize 100 50\n+ I ThisWindow (Maximized, !Shaded, !Iconic) Move +0 -0\n\nDestroyFunc TileTopLeft\nAddToFunc TileTopLeft\n+ I ThisWindow (!Shaded, !Iconic) Maximize 50 50\n+ I ThisWindow (Maximized, !Shaded, !Iconic) Move +0 +0\n\nDestroyFunc TileTopRight\nAddToFunc TileTopRight\n+ I ThisWindow (!Shaded, !Iconic) Maximize 50 50\n+ I ThisWindow (Maximized, !Shaded, !Iconic) Move -0 +0\n\nDestroyFunc TileBottomLeft\nAddToFunc TileBottomLeft\n+ I ThisWindow (!Shaded, !Iconic) Maximize 50 50\n+ I ThisWindow (Maximized, !Shaded, !Iconic) Move +0 -0\n\nDestroyFunc TileBottomRight\nAddToFunc TileBottomRight\n+ I ThisWindow (!Shaded, !Iconic) Maximize 50 50\n+ I ThisWindow (Maximized, !Shaded, !Iconic) Move -0 -0\n```\n\n"
    },
    {
      "title": "Transfer focus on page or desk switch",
      "level": 3,
      "content": "- Using FvwmEvent allows for a window in a page to be automatically focused when clicking on that page in the FvwmPager. However, it breaks the right-click and drag panning functionality of the pager. For this reason, you might prefer to call GoToPage and Focus-Previous from within another function bound to a hotkey instead of using FvwmEvent.\n- If you are not using ClickToFocus, you will need to temporarily set the focus method to ClickToFocus before the desk switch is initiated. If you do not do this, any window under the pointer in the new desk will immediately receive focus, even if it is not the previously focused window. Note that this means you cannot use the FvwmEvent approach. Instead, create a function that changes the focus method and then calls GoToDesk and Focus-Previous.\n\nIf you are using ClickToFocus, you might wish to automatically transfer keyboard focus when switching pages or desks to the previously focused window in that page or desk. Otherwise, you will have to click on the window you wish to interact with on every page or desk switch. This can be accomplished by using the FvwmEvent module to bind a function which focuses the currently or previous focused window to the new_page and new_desk events.\n\nBelow is an example of such a function:\n\n```\nDestroyFunc Focus-Previous\nAddToFunc Focus-Previous\n+ I All ($0, Focused) FlipFocus $1\n+ I TestRc (NoMatch) Prev ($0, AcceptsFocus) FlipFocus $1\n```\n\nThe $0 argument should be either CurrentPage or CurrentDesk. The $1 argument is for supplying the NoWarp argument to FlipFocus - by default, FlipFocus will initiate a page switch to the page containing the focused window. This behaviour is useful when switching desks but must be disabled when switching pages because windows can span more than one page.\n\nWith the function appropriately configured, ensure that FvwmEvent is started and then bind it to the required events as show below:\n\n```\n* FvwmEvent: new_page \"Focus-Previous CurrentPage NoWarp\"\n* FvwmEvent: new_desk \"Focus-Previous CurrentDesk\"\n```\n\n"
    },
    {
      "title": "Toggle window decorations",
      "level": 3,
      "content": "Window decorations (borders and titlebars) can be toggled on or off for a selected window using the function defined below.\n\n```\nDestroyFunc UndecorateWin\nAddToFunc UndecorateWin\n+ I ThisWindow (HasHandles) WindowStyle !Title, !Borders\n+ I ThisWindow (!HasHandles) WindowStyle Title, Borders\n```\n\n"
    },
    {
      "title": "Maximized applications do not fully cover screen",
      "level": 3,
      "content": "Some applications, such as XTerm, supply a maximum size to the window manager that might be smaller than the screen size. This means that if such an application is maximized, it will not cover the whole screen. To force FVWM to ignore these hints, use the following: Style \"*\" ResizeHintOverride.\n\n"
    },
    {
      "title": "Stop modifiers from interfering with mouse and key bindings",
      "level": 3,
      "content": "NumLock, CapsLock and ScrollLock can intefere with ClickToFocus as well as mouse and key bindings. To disable this behavior, use the following command: IgnoreModifiers L25.\n\n"
    },
    {
      "title": "Window start position changes on launch",
      "level": 3,
      "content": "You may find that with some programs the starting position of its window changes every time the program is launched. Similarly some windows automatically resize themselves which can also affect their position.\n\nThis is typically due to PPosition (program position) or USPosition (user specified position) hints which applications can set and which FVWM respects by default. For troublesome windows, you can configure FVWM to ignore the hints that are causing the problem. The first step is to get the class name or resource name of the window in question - use the #FvwmIdent module for this. Then try disabling either the PPosition or USPosition hints for the window. For example:\n\n```\nStyle chromium !UsePPosition\n```\n\nFor windows whose position is affected by resizing this can typically be fixed by setting the FixedPPosition style on the window which causes FVWM to ignore attempts by the window to change its position. This can be set in conjunction with ignoring USPosition hints if necessary, see below:\n\n```\nStyle VirtualBox !UseUSPosition, FixedPPosition\n```\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- FVWM on GitHub.\n- FVWM beginners guide - still works but is somewhat outdated.\n- FVWM Homepage - includes documentation and a FAQ.\n- FVWM Wiki.\n- FVWM Forums.\n- [dead link 2023-10-29 ⓘ] fvwm(1)\n- FVWM Themes - Box-Look.org.\n- FVWM Configurations - threads in the FVWM forums.\n- FVWM Tips - forum post by Thomas Adam - an FVWM developer.\n\n"
    }
  ]
}