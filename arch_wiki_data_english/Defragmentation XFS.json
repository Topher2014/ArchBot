{
  "title": "Defragmentation XFS",
  "url": "https://wiki.archlinux.org/title/Defragmentation_XFS",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- File systems\n\nXFS is a high-performance journaling file system created by Silicon Graphics, Inc. XFS is particularly proficient at parallel IO due to its allocation group based design. This enables extreme scalability of IO threads, filesystem bandwidth, file and filesystem size when spanning multiple storage devices.\n\n"
    },
    {
      "title": "Preparation",
      "level": 2,
      "content": "For XFS userspace utilities install the xfsprogs package. It contains the tools necessary to manage an XFS file system.\n\n"
    },
    {
      "title": "Creation",
      "level": 2,
      "content": "To create a new filesystem on device use:\n\n```\n# mkfs.xfs device\n```\n\nIn general, the default options are optimal for common use.[1][2]\n\nSample output:\n\n```\nmeta-data=/dev/device            isize=256    agcount=4, agsize=3277258 blks\n         =                       sectsz=512   attr=2\ndata     =                       bsize=4096   blocks=13109032, imaxpct=25\n         =                       sunit=0      swidth=0 blks\nnaming   =version 2              bsize=4096   ascii-ci=0\nlog      =internal log           bsize=4096   blocks=6400, version=2\n         =                       sectsz=512   sunit=0 blks, lazy-count=1\nrealtime =none                   extsz=4096   blocks=0, rtextents=0\n```\n\nNote: **This operation will destroy all data contained in the previous filesystem** \n\n- One can optionally assign a label to the filesystem by using the -L label option.\n- When using mkfs.xfs on a block device containing an existing file system, add the -f option to overwrite that file system.[3]. This operation will destroy all data contained in the previous filesystem.\n\n"
    },
    {
      "title": "Checksumming",
      "level": 3,
      "content": "xfsprogs 3.2.0 introduced a new on-disk format (v5) that includes a metadata checksum scheme called Self-Describing Metadata. Based on CRC32, it provides additional protection against metadata corruption (e.g. on unexpected power losses). Checksums are enabled by default when using xfsprogs 3.2.3 or later, but can be disabled (necessary for read-write mounts on older kernels) using the -m crc=0 switch when calling mkfs.xfs(8):\n\n```\n# mkfs.xfs -m crc=0 /dev/target_partition\n```\n\nThe XFS v5 on-disk format is considered stable for production workloads starting in Linux Kernel 3.15.\n\n"
    },
    {
      "title": "Free inode btree",
      "level": 3,
      "content": "Starting in Linux 3.16, XFS has added a btree that tracks free inodes. It is equivalent to the existing inode allocation btree with the exception that the free inode btree tracks inode chunks with at least one free inode. The purpose is to improve lookups for free inode clusters for inode allocation. It improves performance on aged filesystems i.e. months or years down the track when you have added and removed millions of files to/from the filesystem. Using this feature does not impact overall filesystem reliability level or recovery capabilities.\n\nThis feature relies on the new v5 on-disk format that has been considered stable for production workloads starting Linux Kernel 3.15. It does not change existing on-disk structures, but adds a new one that must remain consistent with the inode allocation btree; for this reason older kernels will only be able to mount read-only filesystems with the free inode btree feature.\n\nThe feature is enabled by default when using xfsprogs 3.2.3 or later. If you need a writable filesystem for older kernels, it can be disable with the finobt=0 switch when formatting an XFS partition. You will need crc=0 together:\n\n```\n# mkfs.xfs -m crc=0,finobt=0 /dev/target_partition\n```\n\nor shortly (because finobt depends on crc):\n\n```\n# mkfs.xfs -m crc=0 /dev/target_partition\n```\n\n"
    },
    {
      "title": "Reverse mapping btree",
      "level": 3,
      "content": "The reverse mapping btree is at its core:\n\nFrom mkfs.xfs(8) ยง OPTIONS:\n\nSee also [5] and [6] for more information.\n\nThis feature is enabled by default for new filesystems as of xfsprogs 6.5.0.\n\n"
    },
    {
      "title": "Big timestamps",
      "level": 3,
      "content": "Starting in Linux 5.10, XFS supports using refactored \"timestamp and inode encoding functions to handle timestamps as a 64-bit nanosecond counter and bit shifting to increase the effective size. This now allows XFS to run well past the Year 2038 problem to now the Year 2486. Making a new XFS file-system with bigtime enabled allows a timestamp range from December 1901 to July 2486 rather than December 1901 to January 2038.\" The feature will also allow quota timer expirations from January 1970 to July 2486 rather than January 1970 to February 2106.\n\nBig timestamps are enabled by default for new filesystems as of xfsprogs 5.15.\n\n"
    },
    {
      "title": "Upgrading",
      "level": 4,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nVerify whether an existing filesystem has bigtime enabled with xfs_info(8):\n\n```\n# xfs_info / | grep bigtime\n... bigtime=0 ...\n```\n\nWith xfsprogs 5.11 and newer you can upgrade an existing (unmounted) filesystem with xfs_admin(8):\n\n```\n# xfs_admin -O bigtime=1 device\n```\n\nOr with xfs_repair(8):\n\n```\n# xfs_repair -c bigtime=1 device\n```\n\nWhile there, you may want to enable inobtcount as well (another new default).\n\n"
    },
    {
      "title": "Performance",
      "level": 2,
      "content": "From XFS FAQ:\n\n(see #Stripe size and width)\n\n- https://www.beegfs.io/wiki/StorageServerTuning\n- https://help.marklogic.com/Knowledgebase/Article/View/505/0/recommended-xfs-settings-for-marklogic-server\n\nTherefore for optimal performance, in most cases you can just follow #Creation.\n\n"
    },
    {
      "title": "Stripe size and width",
      "level": 3,
      "content": "If this filesystem will be on a striped RAID you can gain significant speed improvements by specifying the stripe size to the mkfs.xfs(8) command.\n\nXFS can sometimes detect the geometry under software RAID, but in case you reshape it or you are using hardware RAID see how to calculate the correct sunit,swidth values for optimal performance.\n\n"
    },
    {
      "title": "Access time",
      "level": 3,
      "content": "On some filesystems you can increase performance by adding the noatime mount option to the /etc/fstab file. For XFS filesystems \"the default atime behaviour is relatime, which has almost no overhead compared to noatime but still maintains sane atime values. All Linux filesystems use this as the default now (since around 2.6.30), but XFS has used relatime-like behaviour since 2006, so no-one should really need to ever use noatime on XFS for performance reasons.\"[7]\n\nSee Fstab#atime options for more on this topic.\n\n"
    },
    {
      "title": "Discard",
      "level": 3,
      "content": "Despite XFS supporting async discard[8] since kernel 4.7[9][10], xfs(5) still recommends \"that you use the fstrim application to discard unused blocks rather than the discard mount option because the performance impact of this option is quite severe.\"\n\nSee Solid state drive#Periodic TRIM.\n\n"
    },
    {
      "title": "Defragmentation",
      "level": 3,
      "content": "Although the extent-based nature of XFS and the delayed allocation strategy it uses significantly improves the file system's resistance to fragmentation problems, XFS provides a filesystem defragmentation utility (xfs_fsr, short for XFS filesystem reorganizer) that can defragment the files on a mounted and active XFS filesystem. It can be useful to view XFS fragmentation periodically.\n\nxfs_fsr(8) improves the organization of mounted filesystems. The reorganization algorithm operates on one file at a time, compacting or otherwise improving the layout of the file extents (contiguous blocks of file data).\n\n"
    },
    {
      "title": "Inspect fragmentation levels",
      "level": 4,
      "content": "To see how much fragmentation your file system currently has:\n\n```\n# xfs_db -c frag -r /dev/partition\n```\n\n"
    },
    {
      "title": "Perform defragmentation",
      "level": 4,
      "content": "To begin defragmentation, use the xfs_fsr(8) command:\n\n```\n# xfs_fsr /dev/partition\n```\n\n"
    },
    {
      "title": "Deduplication",
      "level": 3,
      "content": "The reflink feature, available since kernel version 4.9 and enabled by default since mkfs.xfs version 5.1.0, allows creating fast reflink'ed copies of files as well as deduplication after the fact, in the same way as btrfs:\n\n"
    },
    {
      "title": "Reflink copies",
      "level": 4,
      "content": "Reflink copies initially use no additional space:\n\n```\n$ cp --reflink bigfile1 bigfile2\n```\n\nUntil either file is edited, and a copy-on-write takes place. This can be very useful to create snapshots of (large) files.\n\n"
    },
    {
      "title": "Deduplication",
      "level": 4,
      "content": "Existing filesystems can be deduped using tools like duperemove or hardlink(1) from util-linux.\n\n"
    },
    {
      "title": "External XFS Journal",
      "level": 3,
      "content": "Using an external log (metadata journal) on for instance a SSD may be useful to improve performance [11]. See mkfs.xfs(8) for details about the logdev parameter.\n\nTo reserve an external journal with a specified size when you create an XFS file system, specify the -l logdev=device,size=size option to the mkfs.xfs command. If you omit the size parameter, a journal size based on the size of the file system is used. To mount the XFS file system so that it uses the external journal, specify the -o logdev=device option to the mount command.\n\n"
    },
    {
      "title": "Sync interval",
      "level": 3,
      "content": "XFS has a dedicated sysctl variable for setting the writeback interval with a default value of 3000.\n\n```\n/etc/sysctl.d/20-xfs-sync-interval.conf\n```\n\n```\nfs.xfs.xfssyncd_centisecs = 10000\n```\n\n"
    },
    {
      "title": "Resize",
      "level": 3,
      "content": "XFS can be resized online using xfs_growfs(8):\n\n```\n# xfs_growfs -D size /path/to/mnt/point\n```\n\nIf -D size is omitted, the filesystem is automatically grown to the largest size possible, i.e. the size of the partition.\n\n"
    },
    {
      "title": "Online metadata checking (scrub)",
      "level": 3,
      "content": "Note: **experimental** \n\nxfs_scrub asks the kernel to scrub all metadata objects in the XFS filesystem. Metadata records are scanned for obviously bad values and then cross-referenced against other metadata. The goal is to establish a reasonable confidence about the consistency of the overall filesystem by examining the consistency of individual metadata records against the other metadata in the filesystem. Damaged metadata can be rebuilt from other metadata if there exists redundant data structures which are intact.\n\nEnable/start xfs_scrub_all.timer to periodic check online metadata for all XFS filesystems.\n\n"
    },
    {
      "title": "Repair",
      "level": 3,
      "content": "From Checking and Repairing an XFS File System (emphasis ours):\n\n```\n# xfs_repair device\n```\n\n- The xfs_repair utility cannot repair an XFS file system with a dirty log. To clear the log, mount and unmount the XFS file system. If the log is corrupt and cannot be replayed, use the -L option (\"force log zeroing\") to clear the log, that is, xfs_repair -L /dev/device. Be aware that this may result in further corruption or data loss.[13]\n- Resetting the log can leave the file system in an inconsistent state, resulting in data loss and data corruption. Unless you're experienced with debugging and repairing XFS file systems by using the xfs_db, it is recommended that you instead recreate the file system and restore its contents from a backup.[14]\n\n```\n# xfs_db [-x] device\n```\n\nSee also Which factors influence the memory usage of xfs_repair? and XFS Repair.\n\n"
    },
    {
      "title": "Data rescue",
      "level": 3,
      "content": "Even when being mounted read-only with mount -o ro an XFS file system's log will be replayed if it has not been unmounted cleanly.\n\nThere may be situations where a compromised XFS file system on a damaged storage device should be mounted read-only, so that files may be copied off it hopefully without causing further damage, yet it cannot be mounted because it has not been unmounted cleanly and is damaged to such an extent that the log cannot be replayed. Also, consider that replaying the log means writing to the compromised file system, which might be a bad idea in itself.\n\nTo mount an XFS file system without writing to it in any way and without replaying the log, use mount -o ro,norecovery.\n\n"
    },
    {
      "title": "Undelete",
      "level": 3,
      "content": "xfs_undelete-gitAUR can recover (under certain conditions) deleted files on an unmounted or read-only mounted XFS filesystem. See https://github.com/ianka/xfs_undelete for more information.\n\n"
    },
    {
      "title": "Root file system quota",
      "level": 3,
      "content": "XFS quota mount options (uquota, gquota, prjquota, etc.) fail during re-mount of the file system. To enable quota for root file system, the mount option must be passed to initramfs as a kernel parameter rootflags=. Subsequently, it should not be listed among mount options in /etc/fstab for the root (/) filesystem.\n\n"
    },
    {
      "title": "xfs_scrub_all fails if user \"nobody\" can not access the mountpoint",
      "level": 3,
      "content": "When running xfs_scrub_all, it will launch xfs_scrub@.service for each mounted XFS file system. The service is run as user nobody, so if nobody can not navigate to the directory, it will fail with the error:\n\n```\nxfs_scrub@mountpoint.service: Changing to the requested working directory failed: Permission denied\nxfs_scrub@mountpoint.service: Failed at step CHDIR spawning /usr/bin/xfs_scrub: Permission denied\nxfs_scrub@mountpoint.service: Main process exited, code=exited, status=200/CHDIR\n```\n\nTo allow the service to run, change the permissions of the mountpoint so that user nobody has execute permissions.\n\n"
    },
    {
      "title": "fsck.xfs fails in systemd-based initramfs",
      "level": 3,
      "content": "When using a mkinitcpio-generated systemd based initramfs without the base hook, you will see the following messages in the journal:\n\n```\nsystemd-fsck[288]: fsck: /usr/bin/fsck.xfs: execute failed: No such file or directory\nsystemd-fsck[286]: fsck failed with exit status 8.\nsystemd-fsck[286]: Ignoring error.\n```\n\nThis is because fsck.xfs(8) is a shell script and requires /bin/sh to execute. /usr/bin/sh is provided by the base hook, so the solution is to prepend it to the HOOKS array in /etc/mkinitcpio.conf. E.g.:\n\n```\nHOOKS=(base systemd ... )\n```\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- XFS wiki (archive\n- XFS FAQ\n- Improving Metadata Performance By Reducing Journal Overhead\n- XFS Wikipedia Entry\n- XFS User Guide[dead link 2024-03-03 โ] XFS User Guide no longer exists but has a link to the git repository\n\n"
    }
  ]
}