{
  "title": "GRUB/Tips and tricks",
  "url": "https://wiki.archlinux.org/title/GRUB/Tips_and_tricks",
  "sections": [
    {
      "title": "BIOS",
      "level": 4,
      "content": "Assume your USB stick's first partition is FAT32 and its partition is /dev/sdy1\n\n```\n# mount --mkdir /dev/sdy1 /mnt/usb\n# grub-install --target=i386-pc --debug --boot-directory=/mnt/usb/boot /dev/sdy\n# grub-mkconfig -o /mnt/usb/boot/grub/grub.cfg\n```\n\nOptionally backup configuration files of grub.cfg:\n\n```\n# mkdir -p /mnt/usb/etc/default\n# cp /etc/default/grub /mnt/usb/etc/default\n# cp -a /etc/grub.d /mnt/usb/etc\n```\n\n```\n# sync; umount /mnt/usb\n```\n\n"
    },
    {
      "title": "EFI",
      "level": 4,
      "content": "For removable installations you have to use --removable and specify both --boot-directory and --efi-directory. [1]\n\n```\n# grub-install --target=x86_64-efi --bootloader-id=GRUB --efi-directory=/mnt/usb --boot-directory=/mnt/usb/boot --removable\n```\n\n"
    },
    {
      "title": "Install to partition or partitionless disk",
      "level": 3,
      "content": "Note: **strongly discourages** \n\nTo set up grub to a partition boot sector, to a partitionless disk (also called superfloppy) or to a floppy disk, run (using for example /dev/sdaX as the /boot partition):\n\n```\n# chattr -i /boot/grub/i386-pc/core.img\n# grub-install --target=i386-pc --debug --force /dev/sdaX\n# chattr +i /boot/grub/i386-pc/core.img\n```\n\n- /dev/sdaX used for example only.\n- --target=i386-pc instructs grub-install to install for BIOS systems only. It is recommended to always use this option to remove ambiguity in grub-install.\n\nYou need to use the --force option to allow usage of blocklists and should not use --grub-setup=/bin/true (which is similar to simply generating core.img).\n\ngrub-install will give out warnings like which should give you the idea of what might go wrong with this approach:\n\n```\n/sbin/grub-setup: warn: Attempting to install GRUB to a partitionless disk or to a partition. This is a BAD idea.\n/sbin/grub-setup: warn: Embedding is not possible. GRUB can only be installed in this setup by using blocklists.\n                        However, blocklists are UNRELIABLE and their use is discouraged.\n```\n\nWithout --force you may get the below error and grub-setup will not setup its boot code in the partition boot sector:\n\n```\n/sbin/grub-setup: error: will not proceed with blocklists\n```\n\nWith --force you should get:\n\n```\nInstallation finished. No error reported.\n```\n\nThe reason why grub-setup does not by default allow this is because in case of partition or a partitionless disk is that GRUB relies on embedded blocklists in the partition bootsector to locate the /boot/grub/i386-pc/core.img file and the prefix directory /boot/grub. The sector locations of core.img may change whenever the file system in the partition is being altered (files copied, deleted etc.). For more info, see https://bugzilla.redhat.com/show_bug.cgi?id=728742 and https://bugzilla.redhat.com/show_bug.cgi?id=730915.\n\nThe workaround for this is to set the immutable flag on /boot/grub/i386-pc/core.img (using chattr command as mentioned above) so that the sector locations of the core.img file in the disk is not altered. The immutable flag on /boot/grub/i386-pc/core.img needs to be set only if GRUB is installed to a partition boot sector or a partitionless disk, not in case of installation to MBR or simple generation of core.img without embedding any bootsector (mentioned above).\n\nUnfortunately, the grub.cfg file that is created will not contain the proper UUID in order to boot, even if it reports no errors. see https://bbs.archlinux.org/viewtopic.php?pid=1294604#p1294604. In order to fix this issue the following commands:\n\n```\n# mount /dev/sdxY /mnt        #Your root partition.\n# mount /dev/sdxZ /mnt/boot   #Your boot partition (if you have one).\n# arch-chroot /mnt\n```\n\nNow, install linux, then:\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\n"
    },
    {
      "title": "Generate core.img alone",
      "level": 3,
      "content": "To populate the /boot/grub directory and generate a /boot/grub/i386-pc/core.img file without embedding any GRUB bootsector code in the MBR, post-MBR region, or the partition bootsector, add --grub-setup=/bin/true to grub-install:\n\n```\n# grub-install --target=i386-pc --grub-setup=/bin/true --debug /dev/sda\n```\n\n- /dev/sda used for example only.\n- --target=i386-pc instructs grub-install to install for BIOS systems only. It is recommended to always use this option to remove ambiguity in grub-install.\n\nYou can then chainload GRUB's core.img from GRUB Legacy or syslinux as a Linux kernel or as a multiboot kernel (see also Syslinux#Chainloading).\n\n"
    },
    {
      "title": "GUI configuration tools",
      "level": 2,
      "content": "- grub-customizer â€” GTK customizer for GRUB or BURG\n\n"
    },
    {
      "title": "drop-in configuration",
      "level": 2,
      "content": "Instead of editing /boot/grub/grub.cfg configuration file, it's possible to use your custom settings as drop-in file like /etc/default/grub.d/00-custom.cfg. Note that you have to create /etc/default/grub.d/ drop-in directory manually. Do not confuse this directory with /etc/grub.d/.\n\n"
    },
    {
      "title": "Visual configuration",
      "level": 2,
      "content": "In GRUB it is possible, by default, to change the look of the menu. Make sure to initialize the GRUB graphical terminal, gfxterm, in /etc/default/grub:\n\n```\nGRUB_TERMINAL_OUTPUT=\"gfxterm\"\n```\n\n"
    },
    {
      "title": "Setting the framebuffer resolution",
      "level": 3,
      "content": "GRUB can set the framebuffer for both GRUB itself (GFXMODE) and the kernel (GFXPAYLOAD). The old vga= way is deprecated. The preferred method is editing /etc/default/grub to set width (pixels) x height (pixels) x color depth:\n\n```\nGRUB_GFXMODE=1024x768x32\nGRUB_GFXPAYLOAD_LINUX=keep\n```\n\nMultiple resolutions can be specified, including the default auto, so it is recommended that you edit the line to resemble GRUB_GFXMODE=desired_resolution,fallback_such_as_1024x768,auto. For more information, refer to the GRUB gfxmode documentation. The gfxpayload property will make sure the kernel keeps the resolution.\n\n- Only the modes supported by the graphics card via VESA BIOS Extensions can be used. To view the list of supported modes, install hwinfo and run hwinfo --framebuffer as root. Alternatively, enter the GRUB command line and run the command videoinfo.\n- Earlier versions of the NVIDIA proprietary driver (tested with GeForce GTX 970, driver: nvidia 370) accepts GRUB_GFXMODE in format widthxheight-depth (e.g. 1920x1200-24, but not 1920x1200x24). This does not appear to apply to newer cards and drivers. Pascal cards with more recent drivers (tested with GeForce GTX 1060 and nvidia 381.22) will not work with the suggested format and attempting to use it results in serious issues, including but not limited to system crashes and hard locks. The current driver and cards are best configured with GRUB_GFXMODE in the standard widthxheightxdepth format.\n- Make sure to run grub-mkconfig -o /boot/grub/grub.cfg after making changes.\n\nIf this method does not work for you, the deprecated vga= method will still work. Just add it next to the \"GRUB_CMDLINE_LINUX_DEFAULT=\" line in /etc/default/grub for example: \"GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash vga=792\" will give you a 1024x768 resolution.\n\n"
    },
    {
      "title": "Background image and bitmap fonts",
      "level": 3,
      "content": "GRUB comes with support for background images and bitmap fonts in pf2 format. The GNU Unifont font is included in the grub package under the filename unicode.pf2, or, as only ASCII characters under the name ascii.pf2. Run pacman -Ql grub | grep pf2 to get the file paths.\n\nImage formats supported include JPEG, PNG and TGA, providing the correct modules are loaded. The maximum supported resolution depends on your hardware.\n\nMake sure you have set up the proper framebuffer resolution.\n\nEdit /etc/default/grub like this:\n\n```\nGRUB_BACKGROUND=\"/boot/grub/myimage\"\n#GRUB_THEME=\"/path/to/gfxtheme\"\nGRUB_FONT=\"/path/to/font.pf2\"\n```\n\nRe-generate grub.cfg to apply the changes. If adding the splash image was successful, the user will see \"Found background image...\" in the terminal as the command is executed. If this phrase is not seen, the image information was probably not incorporated into the grub.cfg file.\n\nIf the image is not displayed, check:\n\n- The path and the filename in /etc/default/grub are correct\n- The image is of the proper size and format (tga, png, 8-bit jpg)\n- The image was saved in the RGB mode, and is not indexed\n- The console mode is not enabled in /etc/default/grub\n- The command grub-mkconfig must be executed to place the background image information into the /boot/grub/grub.cfg file\n- The grub-mkconfig scripts will not quote the file name in grub.cfg so make sure it does not contain spaces\n\n"
    },
    {
      "title": "Theme",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nHere is an example for configuring Starfield theme which was included in GRUB package.\n\nEdit /etc/default/grub:\n\n```\nGRUB_THEME=\"/usr/share/grub/themes/starfield/theme.txt\"\n```\n\nRe-generate grub.cfg to apply the changes. If configuring the theme was successful, you will see Found theme: /usr/share/grub/themes/starfield/theme.txt in the terminal.\n\nYour splash image will usually not be displayed when using a theme.\n\n"
    },
    {
      "title": "Menu colors",
      "level": 3,
      "content": "You can set the menu colors in GRUB. The available colors for GRUB can be found in the GRUB Manual. Here is an example:\n\nEdit /etc/default/grub:\n\n```\nGRUB_COLOR_NORMAL=\"light-blue/black\"\nGRUB_COLOR_HIGHLIGHT=\"light-cyan/blue\"\n```\n\n"
    },
    {
      "title": "Hidden menu",
      "level": 3,
      "content": "One of the unique features of GRUB is hiding/skipping the menu and showing it by holding Esc when needed. You can also adjust whether you want to see the timeout counter.\n\nEdit /etc/default/grub as you wish. Here are the lines you need to add to enable this feature, the timeout has been set to five seconds and to be shown to the user:\n\n```\nGRUB_TIMEOUT=5\nGRUB_TIMEOUT_STYLE='countdown'\n```\n\nGRUB_TIMEOUT is how many seconds before displaying menu.\n\n"
    },
    {
      "title": "Disable framebuffer",
      "level": 3,
      "content": "Users who use NVIDIA proprietary driver might wish to disable GRUB's framebuffer as it can cause problems with the binary driver.\n\nTo disable framebuffer, edit /etc/default/grub and uncomment the following line:\n\n```\nGRUB_TERMINAL_OUTPUT=console\n```\n\nAnother option if you want to keep the framebuffer in GRUB is to revert to text mode just before starting the kernel. To do that modify the variable in /etc/default/grub:\n\n```\nGRUB_GFXPAYLOAD_LINUX=text\n```\n\n"
    },
    {
      "title": "Booting ISO9660 image file directly via GRUB",
      "level": 2,
      "content": "GRUB supports booting from ISO images directly via loopback devices, see Multiboot USB drive#Using GRUB and loopback devices for examples.\n\n"
    },
    {
      "title": "Password protection of GRUB menu",
      "level": 2,
      "content": "If you want to secure GRUB so it is not possible for anyone to change boot parameters or use the command line, you can add a username and password to GRUB's configuration files. To do this, run the command grub-mkpasswd-pbkdf2, then enter a password and confirm it:\n\n```\n$ grub-mkpasswd-pbkdf2\n```\n\n```\n[...]\nPBKDF2 hash of your password is grub.pbkdf2.sha512.10000.C8ABD3E93C4DFC83138B0C7A3D719BC650E6234310DA069E6FDB0DD4156313DA3D0D9BFFC2846C21D5A2DDA515114CF6378F8A064C94198D0618E70D23717E82.509BFA8A4217EAD0B33C87432524C0B6B64B34FBAD22D3E6E6874D9B101996C5F98AB1746FE7C7199147ECF4ABD8661C222EEEDB7D14A843261FFF2C07B1269A\n```\n\nThen, adjust permissions on /etc/grub.d/40_custom such that only root can read it by running chmod o-r /etc/grub.d/40_custom. Then modify the file as following:\n\n```\n/etc/grub.d/40_custom\n```\n\n```\nset superusers=\"username\"\npassword_pbkdf2 username password-hash\n```\n\nwhere password-hash is the string starting with grub.pbkdf2 generated by grub-mkpasswd_pbkdf2.\n\nRegenerate your configuration file with grub-mkconfig. Accessing the GRUB command line, boot parameters and also booting an entry now require the specified username and password. The latter can be prevented by following #Password protection of GRUB edit and console options only.\n\nThis can be relaxed and further customized with configuring more users as described in the \"Security\" part of the GRUB manual.\n\n"
    },
    {
      "title": "Password protection of GRUB edit and console options only",
      "level": 3,
      "content": "Adding --unrestricted to a menu entry will allow any user to boot the OS while preventing the user from editing the entry and preventing access to the grub command console. Only a superuser or users specified with the --user switch will be able to edit the menu entry.\n\n```\n/boot/grub/grub.cfg\n```\n\n```\nmenuentry 'Arch Linux' --unrestricted --class arch --class gnu-linux --class os ...\n```\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nIn order to make Linux entries --unrestricted, the CLASS variable in the beginning of /etc/grub.d/10_linux can be modified.\n\n```\n/etc/grub.d/10_linux\n```\n\n```\nCLASS=\"--class gnu-linux --class gnu --class os --unrestricted\"\n```\n\n"
    },
    {
      "title": "Hide GRUB unless the Shift key is held down",
      "level": 2,
      "content": "In order to achieve the fastest possible boot, instead of having GRUB wait for a timeout, it is possible for GRUB to hide the menu, unless the Shift key is held down during GRUB's start-up.\n\nIn order to achieve this, you should add the following line to /etc/default/grub:\n\n```\nGRUB_FORCE_HIDDEN_MENU=\"true\"\n```\n\nThen create the file /etc/grub.d/31_hold_shift containing [3], make it executable, and regenerate the grub configuration:\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\n"
    },
    {
      "title": "Combining the use of UUIDs and basic scripting",
      "level": 2,
      "content": "If you like the idea of using UUIDs to avoid unreliable BIOS mappings or are struggling with GRUB's syntax, here is an example boot menu item that uses UUIDs and a small script to direct GRUB to the proper disk partitions for your system. All you need to do is replace the UUIDs in the sample with the correct UUIDs for your system. The example applies to a system with a boot and root partition. You will obviously need to modify the GRUB configuration if you have additional partitions:\n\n```\nmenuentry \"Arch Linux 64\" {\n    # Set the UUIDs for your boot and root partition respectively\n    set the_boot_uuid=ece0448f-bb08-486d-9864-ac3271bd8d07\n    set the_root_uuid=c55da16f-e2af-4603-9e0b-03f5f565ec4a\n\n    # (Note: This may be the same as your boot partition)\n\n    # Get the boot/root devices and set them in the root and grub_boot variables\n    search --fs-uuid $the_root_uuid --set=root\n    search --fs-uuid $the_boot_uuid --set=grub_boot\n\n    # Check to see if boot and root are equal.\n    # If they are, then append /boot to $grub_boot (Since $grub_boot is actually the root partition)\n    if [ $the_boot_uuid == $the_root_uuid ]Â ; then\n        set grub_boot=($grub_boot)/boot\n    else\n        set grub_boot=($grub_boot)\n    fi\n\n    # $grub_boot now points to the correct location, so the following will properly find the kernel and initrd\n    linux $grub_boot/vmlinuz-linux root=/dev/disk/by-uuid/$the_root_uuid ro\n    initrd $grub_boot/initramfs-linux.img\n}\n```\n\n"
    },
    {
      "title": "Disable submenu",
      "level": 3,
      "content": "If you have multiple kernels installed, say linux and linux-lts, by default grub-mkconfig groups them in a submenu. If you do not like this behaviour you can go back to one single menu by adding the following line to /etc/default/grub:\n\n```\nGRUB_DISABLE_SUBMENU=y\n```\n\n"
    },
    {
      "title": "Recall previous entry",
      "level": 3,
      "content": "GRUB can remember the last entry you booted from and use this as the default entry to boot from next time. This is useful if you have multiple kernels (i.e., the current Arch one and the LTS kernel as a fallback option) or operating systems. To do this, edit /etc/default/grub and change the value of GRUB_DEFAULT:\n\n```\nGRUB_DEFAULT=saved\n```\n\nThis ensures that GRUB will default to the saved entry. To enable saving the selected entry, add the following line to /etc/default/grub:\n\n```\nGRUB_SAVEDEFAULT=true\n```\n\nThis will only work if /boot is not a btrfs, because grub cannot write to btrfs. But it will generate a misleading error message: \"sparse file not allowed. Press any key to continue.\".\n\n"
    },
    {
      "title": "Changing the default menu entry",
      "level": 3,
      "content": "To change the default selected entry, edit /etc/default/grub and change the value of GRUB_DEFAULT:\n\nUsing menu titles:\n\n```\nGRUB_DEFAULT='Advanced options for Arch Linux>Arch Linux, with Linux linux'\n```\n\nUsing numbers:\n\n```\nGRUB_DEFAULT=\"1>2\"\n```\n\nGrub identifies entries in the generated menu (i.e. /boot/grub/grub.cfg) counted from zero. That means 0 for the first entry which is the default value, 1 for the second and so on. Main and submenu entries are separated by a > and are both identified by a number, title, or ID.\n\nThe example above boots the third entry from the main menu 'Advanced options for Arch Linux'.\n\nUsing IDs (see value after --id or $menuentry_id_option in grub.cfg if generating your grub.cfg):\n\n```\nGRUB_DEFAULT=\"gnulinux-advanced-39c666d6-c7fc-4fa6-8287-9540056f5a02>gnulinux-linux-zen-advanced-39c666d6-c7fc-4fa6-8287-9540056f5a02\"\n```\n\nDocumentation of all three identifier methods: https://www.gnu.org/software/grub/manual/grub/html_node/default.html\n\n"
    },
    {
      "title": "Boot non-default entry only once",
      "level": 3,
      "content": "The command grub-reboot is very helpful to boot another entry than the default only once. GRUB loads the entry passed in the first command line argument, when the system is rebooted the next time. Most importantly GRUB returns to loading the default entry for all future booting. Changing the configuration file or selecting an entry in the GRUB menu is not necessary.\n\n"
    },
    {
      "title": "Play a tune",
      "level": 2,
      "content": "You can play a tune through the PC-speaker while booting (right before the menu appears) by modifying the variable GRUB_INIT_TUNE:\n\n```\nGRUB_INIT_TUNE=\"tempo [note_pitch note_duration] [second_note_pitch second_note_duration] ...\"\n```\n\nNote: **will not be displayed** \n\nYou can add a menu entry to play each of these common GRUB_INIT_TUNE samples by creating the linked /etc/grub.d/91_tune_demo and then re-running grub-mkconfig.\n\nFor information on this, you can look at info grub -n play, while some collections exist.\n\n"
    },
    {
      "title": "Manual configuration of core image for early boot",
      "level": 2,
      "content": "If you require a special keymap or other complex steps that GRUB is not able to configure automatically in order to make /boot available to the GRUB environment, you can generate a core image yourself. On UEFI systems, the core image is the grubx64.efi file that is loaded by the firmware on boot. Building your own core image will allow you to embed any modules required for very early boot, as well as a configuration script to bootstrap GRUB.\n\nFirstly, taking as an example a requirement for the dvorak keymap embedded in early-boot in order to enter a password for an encrypted /boot on a UEFI system:\n\nDetermine from the generated /boot/grub/grub.cfg file what modules are required in order to mount the crypted /boot. For instance, under your menuentry you should see lines similar to:\n\n```\ninsmod diskfilter cryptodisk luks gcry_rijndael gcry_rijndael gcry_sha256\ninsmod ext2\ncryptomount -u 1234abcdef1234abcdef1234abcdef\nset root='cryptouuid/1234abcdef1234abcdef1234abcdef'\n```\n\nTake note of all of those modules: they will need to be included in the core image. Now, create a tarball containing your keymap. This will be bundled in the core image as a memdisk:\n\n```\n# grub-kbdcomp -o dvorak.gkb dvorak\n# tar cf memdisk.tar dvorak.gkb\n```\n\nNow create a configuration file to be used in the GRUB core image. This is in the same format as your regular grub config, but need contain only a few lines to find and load the main configuration file on the /boot partition:\n\n```\nearly-grub.cfg\n```\n\n```\nset root=(memdisk)\nset prefix=($root)/\n\nterminal_input at_keyboard\nkeymap /dvorak.gkb\n\ncryptomount -u 1234abcdef1234abcdef1234abcdef\nset root='cryptouuid/1234abcdef1234abcdef1234abcdef'\nset prefix=($root)/grub\n\nconfigfile grub.cfg\n```\n\nFinally, generate the core image, listing all of the modules determined to be required in the generated grub.cfg, along with any modules used in the early-grub.cfg script. The example above needs memdisk, tar, at_keyboard, keylayouts and configfile.\n\n```\n# grub-mkimage -c early-grub.cfg -o grubx64.efi -O x86_64-efi -m memdisk.tar diskfilter cryptodisk luks gcry_rijndael gcry_sha256 ext2 memdisk tar at_keyboard keylayouts configfile\n```\n\nThe generated EFI core image can now be used in the same way as the image that is generated automatically by grub-install: place it in your EFI system partition and enable it with efibootmgr, or configure as appropriate for your system firmware.\n\nSee also Debian cryptsetup docs.\n\n"
    },
    {
      "title": "UEFI further reading",
      "level": 2,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nBelow is other relevant information regarding installing Arch via UEFI.\n\n"
    },
    {
      "title": "Alternative install method",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nUsually, GRUB keeps all files, including configuration files, in /boot, regardless of where the EFI system partition is mounted.\n\nIf you want to keep these files inside the EFI system partition itself, add --boot-directory=esp to the grub-install command:\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=grub --boot-directory=esp --debug\n```\n\nThis puts all GRUB files in esp/grub, instead of in /boot/grub. When using this method, make sure you have grub-mkconfig put the configuration file in the same place:\n\n```\n# grub-mkconfig -o esp/grub/grub.cfg\n```\n\nConfiguration is otherwise the same.\n\n"
    },
    {
      "title": "UEFI firmware workaround",
      "level": 3,
      "content": "See GRUB#Default/fallback boot path.\n\n"
    },
    {
      "title": "GRUB standalone",
      "level": 3,
      "content": "This section assumes you are creating a standalone GRUB for x86_64 systems (x86_64-efi). For 32-bit (IA32) EFI systems, replace x86_64-efi with i386-efi where appropriate.\n\nIt is possible to create a grubx64_standalone.efi application which has all the modules embedded in a tar archive within the UEFI application, thus removing the need to have a separate directory populated with all of the GRUB UEFI modules and other related files. This is done using the grub-mkstandalone command (included in grub) as follows:\n\n```\n# echo 'configfile ${cmdpath}/grub.cfg' > /tmp/grub.cfg\n# grub-mkstandalone -d /usr/lib/grub/x86_64-efi/ -O x86_64-efi --modules=\"part_gpt part_msdos\" --locales=\"en@quot\" --themes=\"\" -o \"esp/EFI/grub/grubx64_standalone.efi\" \"boot/grub/grub.cfg=/tmp/grub.cfg\" -v\n```\n\nThen copy the GRUB configuration file to esp/EFI/grub/grub.cfg and create a UEFI Boot Manager entry for esp/EFI/grub/grubx64_standalone.efi using efibootmgr.\n\n- You may find that the grub.cfg file is not loaded due to ${cmdpath} missing a slash (i.e. (hd1,msdos2)EFI/Boot instead of (hd1,msdos2)/EFI/Boot) and so you are dropped into a GRUB shell. If this happens determine what ${cmdpath} is set to (echo ${cmdpath} ) and then load the configuration file manually (e.g. configfile (hd1,msdos2)/EFI/Boot/grub.cfg).\n- If Secure Boot with shim is used, remember to add the SBAT section using --sbat /usr/share/grub/sbat.csv.\n\n"
    },
    {
      "title": "Technical information",
      "level": 4,
      "content": "The GRUB EFI file always expects its configuration file to be at ${prefix}/grub.cfg. However in the standalone GRUB EFI file, the ${prefix} is located inside a tar archive and embedded inside the standalone GRUB EFI file itself (inside the GRUB environment, it is denoted by \"(memdisk)\", without quotes). This tar archive contains all the files that would be stored normally at /boot/grub in case of a normal GRUB EFI install.\n\nDue to this embedding of /boot/grub contents inside the standalone image itself, it does not rely on actual (external) /boot/grub for anything. Thus in case of standalone GRUB EFI file ${prefix}==(memdisk)/boot/grub and the standalone GRUB EFI file reads expects the configuration file to be at ${prefix}/grub.cfg==(memdisk)/boot/grub/grub.cfg.\n\nHence to make sure the standalone GRUB EFI file reads the external grub.cfg located in the same directory as the EFI file (inside the GRUB environment, it is denoted by ${cmdpath} ), we create a simple /tmp/grub.cfg which instructs GRUB to use ${cmdpath}/grub.cfg as its configuration (configfile ${cmdpath}/grub.cfg command in (memdisk)/boot/grub/grub.cfg). We then instruct grub-mkstandalone to copy this /tmp/grub.cfg file to ${prefix}/grub.cfg (which is actually (memdisk)/boot/grub/grub.cfg) using the option \"boot/grub/grub.cfg=/tmp/grub.cfg\".\n\nThis way, the standalone GRUB EFI file and actual grub.cfg can be stored in any directory inside the EFI system partition (as long as they are in the same directory), thus making them portable.\n\n"
    },
    {
      "title": "UEFI and BIOS installation",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nIf your arch installation should be bootable on both UEFI and BIOS systems, install GRUB using both methods. Partition the disk as GPT, create an EFI system partition and a BIOS boot partition as well, mount the ESP at /efi and run the GRUB install commands for both ways.\n\n```\n# grub-install --target=i386-pc --recheck /dev/sdx\n# grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB --recheck\n```\n\nIn a BIOS system the EFI variables are not present, thus the UEFI NVRAM boot entries cannot be set and the 2nd command will report an error. By using the --no-nvram and --removable option the system will have a good chance to be bootable in UEFI mode too:\n\n```\n# grub-install --target=i386-pc --recheck /dev/sdx\n# grub-install --target=x86_64-efi --efi-directory=/efi --recheck --removable --no-nvram\n```\n\nFor some BIOS implementations it may be necessary to set the PMBRâ€™s boot flag, e.g. with parted\n\n```\n(parted) disk_set pmbr_boot on\n```\n\n"
    },
    {
      "title": "Speeding up LUKS decryption in GRUB",
      "level": 2,
      "content": "Upon boot GRUB may in some cases take a long time to verify the password. This can be due to a high cost parameters of the key derivation function, which you can check as follows:\n\n```\n# cryptsetup luksDump /dev/sda3\n```\n\nThe problem is that the cost parameters for a given keyslot are generated when the key is added to ensure a balance between being high enough to protect against brute force attacks and low enough to allow for fast key derivation by estimating the capabilities of your computer. However, when GRUB is started, it might not have the same computational resources at hand, thus being vastly slower.\n\nIf your password provides enough entropy to counter common attacks by itself, you can lower the parameters. For example to lower the iteration count of PBKDF2, use:\n\n```\n# cryptsetup luksChangeKey --pbkdf-force-iterations 1000 /dev/sda3\n```\n\nA minimum of 1000 iterations is recommended as per RFC 2898, but you should aim for higher values if you can (The cost for an attacker as well as the time for key derivation scale linearly).\n\nRecommended parameters for Argon2 are discussed in RFC 9106.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- GRUB 2 theme tutorial\n\n"
    }
  ]
}