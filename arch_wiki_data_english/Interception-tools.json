{
  "title": "Interception-tools",
  "url": "https://wiki.archlinux.org/title/Interception-tools",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Linux console/Keyboard configuration\n- Xbindkeys\n- Xmodmap\n\ninterception-tools is a set of utilities to control and customize the behavior of keyboard input mappings.\n\nInterception-tools operates at a lower level compared to other similar tools (xcape, xmodmap) by using libevdev and libudev(3). This makes it one of the only options available for customizing the keyboard behavior across X11, Wayland, and the Linux console.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install interception-tools.\n\nMany plugins are available:\n\n- interception-caps2esc to switch CapsLock with Ctrl/Esc\n- interception-caps2esc-delay-gitAUR\n- interception-caps2esc-nocaps-gitAUR\n- interception-dual-function-keys to modify the behavior of a key when held.\n- interception-hideawayAUR\n- interception-k2k-gitAUR\n- interception-ralt2hyperAUR\n- interception-space2metaAUR\n- interception-uswitchAUR\n- interception-vimproved-gitAUR\n- interception-xswitchAUR\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "The tools comprise commandline tools and a systemd service.\n\nA configuration in /etc/interception/udevmon.yaml needs to be added before starting the packaged udevmon.service.\n\n"
    },
    {
      "title": "How it works",
      "level": 3,
      "content": "Interception-tool makes use of libevdev, which according to its wiki is essentially a read(2) on steroids for /dev/input/eventX devices. It sits in between the kernel and the process handling an event. In the simplest scenario would look like this:\n\n```\nkernel | libevdev | evtest\n```\n\nFor X.Org input modules, the stack would look like this:\n\n```\nkernel | libevdev | xf86-input-evdev | X server | X client\n```\n\nFor Wayland, the stack would look like this:\n\n```\nkernel | libevdev | Compositor | Wayland client\n```\n\nIn other words, libevdev is so low level that it does not have knowledge of X/Wayland clients.\n\n"
    },
    {
      "title": "Practical examples",
      "level": 3,
      "content": "Interception-tools makes 4 utilities available:\n\n- intercept: redirect device input events to stdout,\n- mux: combine streams of input events,\n- udevmon: monitor input devices for launching tasks,\n- uinput: redirect device input events from stdin to virtual device.\n\n"
    },
    {
      "title": "Increase niceness",
      "level": 4,
      "content": "Since the tool is going to be sitting down at the lowest level of the device inputs, make sure it will behave consistently by increasing udevmon priority:\n\n```\n# nice -n -20 udevmon -c udevmon.yaml > udevmon.log 2> udevmon.err &\n```\n\n"
    },
    {
      "title": "Simple redirection",
      "level": 4,
      "content": "The simplest way or redirecting the event to the stdin (without doing nothing) is:\n\n```\n$ intercept -g DEVNODE | uinput -d DEVNODE\n```\n\nwhere DEVNODE is the path to the actual device: e.g. /dev/input/by-path/platform-i8042-serio-0-event-kbd.\n\n"
    },
    {
      "title": "Embed commands",
      "level": 4,
      "content": "To actually perform an operation in between the key event and the input, simply pipe it in between intercept and uinput.\n\nE.g. with the interception-caps2esc plugin installed:\n\n```\n$ intercept -g DEVNODE | caps2esc | uinput -d DEVNODE\n```\n\nIf we omitted the -g flag, then device event would have been just observed, not grabbed.\n\n"
    },
    {
      "title": "Feed as YAML",
      "level": 4,
      "content": "This way of intercepting the input can quickly become sub-optimal, this is where udevmon comes in handy. udevmon accepts a YAML configuration with a list of jobs (sh commands by default) to be executed.\n\nIn case the device matches a given description:\n\n```\n$ udevmon -c caps2esc.conf.yml\n```\n\n```\n- JOB: intercept -g DEVNODE | caps2esc | uinput -d DEVNODE\n  DEVICE:\n    LINK: /dev/input/by-path/platform-i8042-serio-0-event-kbd\n```\n\nThe LINK configuration will match a device with a specific name, but it will accept also a regex option. This can be combined with multiple job specifications to create a default behavior, in each case only the first matching job is going to be executed:\n\n```\n- JOB: intercept -g DEVNODE | caps2esc -m 2 | uinput -d DEVNODE\n  DEVICE:\n    LINK: /dev/input/by-id/usb-SEMITEK_USB-HID_Gaming_Keyboard_SN0000000001-event-kbd\n- JOB: intercept -g DEVNODE | caps2esc | uinput -d DEVNODE\n  DEVICE:\n    EVENTS:\n      EV_KEY: [[KEY_CAPSLOCK, KEY_ESC]]\n    LINK: .*-event-kbd\n```\n\n"
    },
    {
      "title": "Combine devices",
      "level": 4,
      "content": "Beside input emulation, the uinput tool also serves purpose to print a device's description in YAML format:\n\n```\n$ uinput -p -d /dev/input/by-id/my-kbd\n```\n\nwhich itself can be fed back to uinput as:\n\n```\n$ uinput -c my-kbd.yaml\n```\n\nIt can also merge device and YAML characteristics, which can be used for instance to combine events coming from keyboard and mouse:\n\ne.g. instance CapsLock+Click as Ctrl+Click\n\n```\n$ uinput -p -d /dev/input/by-id/my-kbd -d /dev/input/by-id/my-mouse -c my-extra.yaml\n```\n\n"
    },
    {
      "title": "Handle multiple jobs",
      "level": 4,
      "content": "The mux is used to combine multiple pipelines into a single one. A muxer needs to be created first, and it can later be used as the input or the output of a given pipeline. In a YAML specification file, the muxer is created using the CMD key:\n\n```\n- CMD: mux -c caps2esc\n- JOB: mux -i caps2esc | caps2esc | uinput -c /etc/interception/gaming-keyboard.yaml\n- JOB: intercept -g DEVNODE | mux -o caps2esc\n  DEVICE:\n    LINK: /dev/input/by-id/my-kbd\n- JOB: intercept DEVNODE | mux -o caps2esc\n  DEVICE:\n    LINK: /dev/input/by-id/my-mouse\n```\n\nIn the example above, when the keyboard is connected, it's grabbed and its input events are sent to the caps2esc muxer that was initially created. Observed input (not grabbed) from mouse is also sent to the same muxer. The buttons of the mouse generate EV_KEY events, so caps2esc will accept them.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Input remap utilities - Lists similar software.\n- Official website\n- kmonad - advanced keyboard remapping tool daemon\n\n"
    }
  ]
}