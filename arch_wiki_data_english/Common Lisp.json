{
  "title": "Common Lisp",
  "url": "https://wiki.archlinux.org/title/Common_Lisp",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Common Lisp is a highly dynamic, multi-paradigm language that emphasizes interactivity and performance. Being fully standardized, there are multiple independent implementations from which to choose.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "sbcl (http://www.sbcl.org/) is the most popular FOSS implementation and generally has the highest compatibility across the ecosystem. Its compiler produces native machine code and the project has monthly releases.\n\nIt is configured in Lisp within ~/.sbclrc, but you may not need this depending on the dependency management strategy you choose.\n\n"
    },
    {
      "title": "Alternate Implementations",
      "level": 3,
      "content": "There are numerous other implementations available. Apart from the options below, there are two major commercial Lisp implementations, Allegro and LispWorks, but they have strict licensing terms are not packaged within the Arch Linux ecosystem.\n\n"
    },
    {
      "title": "Active",
      "level": 4,
      "content": "These function seamlessly with modern tooling and can be used for serious projects.\n\n- ABCL — Armed Bear Common Lisp: runs on the Java Virtual Machine.\n\n- CCL — Clozure Common Lisp: based on Open Macintosh Common Lisp and is known for its fast compiling times.\n\n- Clasp — Clasp: a newer Common Lisp implementation that interoperates with C++ libraries and uses LLVM for compilation to native code.\n\n- ECL — Embeddable Common Lisp: compiles to C code, thus offering good C integration and embeddability.\n\n"
    },
    {
      "title": "Historical",
      "level": 4,
      "content": "While packages are available for these, library and tooling compatibility is sometimes dubious, and some implementations are no longer actively maintained.\n\n- CLISP — ANSI Common Lisp interpreter, compiler and debugger: offers good C integration and embeddability.\n\n- CMUCL — CMU Common Lisp: a POSIX-only implementation originally developed at Carnegie Mellon.\n\n- GCL — GNU Common Lisp: A descendant of Kyoto Common Lisp from the 80s and a sibling to ECL.\n\n- MKCL — Mankai Common Lisp: A similar descendant of Kyoto Common Lisp.\n\n"
    },
    {
      "title": "Dependency Management",
      "level": 2,
      "content": "Dependency management in Common Lisp has traditionally involved Quicklisp, but in recent years modern alternatives have emerged.\n\n"
    },
    {
      "title": "Vend",
      "level": 3,
      "content": "Vend is a simple tool for downloading and accessing dependencies directly within your project repository. It requires no special configuration.\n\nAfter installing the vendAUR package, you can run vend get from the top directory of your project:\n\n```\n[vend] Downloading dependencies.\n[vend] Fetching FN-MACRO\n[vend] Fetching ARROW-MACROS\n[vend] Fetching TRANSDUCERS\n...\n[vend] Done.\n```\n\nAfter which vend repl will start a REPL session.\n\n"
    },
    {
      "title": "Editor Integration",
      "level": 4,
      "content": "For Emacs users of Sly/Slime, the in-editor REPL can be configured via:\n\n```\n(setq sly-default-lisp 'sbcl\n      sly-lisp-implementations '((sbcl (\"vend\" \"repl\" \"sbcl\")  :coding-system utf-8-unix)\n                                 (ecl  (\"vend\" \"repl\" \"ecl\")   :coding-system utf-8-unix)))\n```\n\nYou're free to add other compilers in a similar manner. Adjust as necessary for Slime.\n\nUsers of Lem can open a REPL with:\n\n```\nC-u M-x slime <RET> vend repl\n```\n\nUnlike Emacs which supports multiple running Lisps, Slimv requires one standalone server that persists through Vim restarts.\n\nIf we want our dependencies in vendored/ to be visible to Slimv, we must start its server manually from our project directory:\n\n```\n> cd project/\n> vend repl ecl --load /home/YOU/.vim/pack/common-lisp/start/slimv/slime/start-swank.lisp\n```\n\nNow, ,c (REPL Connect) within Vim will automatically find the running server, and you can load any system available in your project and in vendored/.\n\nIf you want to switch projects, you would need to quit the REPL server manually and restart it as above. You may also wish to set a shell alias or create a wrapper script for the long invocation shown above.\n\n"
    },
    {
      "title": "OCICL",
      "level": 3,
      "content": "OCICL is a modern alternative to Quicklisp that distributes packages as OCI-compliant artifacts from centralised package repositories. Similar to Quicklisp, it must be configured by the user to take over and manage dependency loading.\n\nAfter installing ociclAUR, run ocicl setup, which adds the following to your compiler configuration files:\n\n```\n#-ocicl\n(when (probe-file #P\"/home/green/.local/share/ocicl/ocicl-runtime.lisp\")\n  (load #P\"/home/green/.local/share/ocicl/ocicl-runtime.lisp\"))\n(asdf:initialize-source-registry\n  (list :source-registry (list :directory (uiop:getcwd)) :inherit-configuration))\n```\n\nNow, within a REPL, any attempt to run (asdf:load-system :foo) on an unknown dependency will automatically download it. Further project configuration is done with a systems.csv file, which you're intended to commit to your project repository. See the README for more setup and usage details.\n\n"
    },
    {
      "title": "Quicklisp",
      "level": 3,
      "content": "Quicklisp is the original method for fetching and loading libraries into a Common Lisp program. By default it has a single, global package cache shared by all programs on your machine, and it pulls packages from a conservatively updated repository also called (perhaps confusingly) Quicklisp.\n\nAfter installing the quicklisp package, it can be registered for a particular compiler as follows:\n\n```\n> sbcl --load /usr/share/quicklisp/quicklisp.lisp\n* (quicklisp-quickstart:install)\n* (ql:add-to-init-file)\n```\n\nAfter which (ql:quickload \"foo\") can be used in all future REPL sessions to load a dependency, downloading it if necessary.\n\nTo update all packages installed through Quicklisp, run the following in a REPL:\n\n```\n(ql:update-all-dists)\n```\n\n"
    },
    {
      "title": "Ultralisp",
      "level": 4,
      "content": "Ultralisp is an alternate Quicklisp repository that offers rolling releases of all packages, generally up-to-date with what is available on Github, etc.\n\nTo register it, run the following in a REPL:\n\n```\n(ql-dist:install-dist \"http://dist.ultralisp.org/\" :prompt nil)\n```\n\nThen, if a package you load via ql:quickload is newer in Ultralisp, it will be loaded from there instead of Quicklisp.\n\n"
    },
    {
      "title": "Qlot",
      "level": 3,
      "content": "Alternatively, if you're fine with Quicklisp but want project-local dependencies, you can use Qlot (qlotAUR).\n\nOnce installed, a project repository can be initialized to use it via:\n\n```\nqlot init\n```\n\n"
    },
    {
      "title": "Custom Dependencies",
      "level": 4,
      "content": "With Qlot, all custom dependency locations are declared within a qlfile. For instance, to declare Ultralisp usage, simply add:\n\n```\ndist http://dist.ultralisp.org\n```\n\nOr to specify a dependency on your local filesystem:\n\n```\nlocal foobar /home/you/code/common-lisp/foobar\n```\n\nSee Qlot's README for more options.\n\nTo install declared dependencies, run:\n\n```\nqlot install\n```\n\n"
    },
    {
      "title": "Invoking a REPL",
      "level": 4,
      "content": "To load a REPL with the current Qlot environment, run:\n\n```\nqlot exec sbcl\n```\n\nFor Emacs users of Sly/Slime, consider configuring how your in-editor REPL is launched via:\n\n```\n(setq sly-default-lisp 'qlot-sbcl\n      sly-lisp-implementations '((qlot-sbcl (\"qlot\" \"exec\" \"sbcl\") :coding-system utf-8-unix)))\n```\n\nAdjust as necessary for Slime.\n\n"
    },
    {
      "title": "Emacs",
      "level": 3,
      "content": "Common Lisp development is often done in Emacs, through slime or the newer sly. Both are widely adopted in the community and have a similar usage interface.\n\n"
    },
    {
      "title": "Portacle",
      "level": 4,
      "content": "Portacle is an Emacs-based, all-in-one environment for Common Lisp development. Its aim is to easily on-ramp beginners to Lisp.\n\n"
    },
    {
      "title": "Lem",
      "level": 3,
      "content": "Lem (lem-editor-gitAUR) is a newer editor in the style of Emacs, but written and configured entirely in Common Lisp. It has terminal and GUI frontends, and supports many languages.\n\n"
    },
    {
      "title": "Vim",
      "level": 3,
      "content": "Slimv is a port of Slime from Emacs that utilizes Slime’s Swank backend server for a very similar experience to Emacs. To install the plugin manually:\n\n```\nmkdir -p ~/.vim/pack/common-lisp/start\ncd ~/.vim/pack/common-lisp/start\ngit clone --depth 1 https://github.com/kovisoft/slimv.git\n```\n\nRestart Vim and open a Common Lisp file. Slimv should be active, and ,c will start a REPL server and connect you to it.\n\n"
    },
    {
      "title": "VSCode",
      "level": 3,
      "content": "Support for Common Lisp in VSCode is weakest among the editors, but still possible. The Alive plugin serves as a complete development environment alongside its own LSP, which requires manual installation.\n\n"
    },
    {
      "title": "Managing Init Files",
      "level": 3,
      "content": "Library authors often test their code with multiple compiler implementations. However, each implementation has their own uniquely named init file, such as .sbclrc or .eclrc, but the content of these files is often identical. Rather than handwrite these files for each compiler, you can create one master file and symlink the others to it. For instance, if you consider .sbclrc to be your \"master config\", then:\n\n```\nln -s /home/you/.sbclrc .eclrc\nln -s /home/you/.sbclrc .abclrc\n```\n\nAnd so on. The main init files are:\n\n```\n~/.sbclrc          # for SBCL\n~/.abclrc          # for ABCL\n~/.ccl-init.lisp   # for CCL\n~/.clasprc         # for CLASP\n~/.eclrc           # for ECL\n~/.clisprc.lisp    # for CLISP\n~/.cmucl-init.lisp # for CMUCL\n~/.mkclrc          # for MKCL\n~/.clinit.cl       # for Allegro\n```\n\n"
    },
    {
      "title": "Less Verbose Compilation Output",
      "level": 3,
      "content": "SBCL in particular can be quite enthusiastic about the number of compiler \"notes\" it outputs. To silence these notes, while still displaying the usual errors and warnings, set the following in your ~/.sbclrc:\n\n```\n(declaim (sb-ext:muffle-conditions sb-ext:compiler-note))\n```\n\n"
    },
    {
      "title": "Quicklisp can't load a local project",
      "level": 3,
      "content": "(ql:quickload \"...\") is used to load both external dependencies but also local projects. However, if your local project is not located under ~/common-lisp/, it will fail to load (or may even be pulled from online if you've published it).\n\nIn truth, Quicklisp is just fetching and organizing packages. Internally, it uses the ASDF build system to actually load them. It's also possible to load any local project or a package you've already downloaded via (asdf:load-system \"foo\"), and by default ASDF only looks in ~/common-lisp/ for local projects.\n\nWhile configurable, a simpler way around this is to use a symlink:\n\n```\nln -s /home/you/code/common-lisp/ common-lisp\n```\n\n"
    },
    {
      "title": "What are Projects, Systems, and Packages?",
      "level": 3,
      "content": "The rest of this article has used the term \"package\" in the way it is usually used in other programming languages, synonymous with \"library\". However, although standardized in the mid-90s, the earliest forms of Common Lisp date from the 80s, and so terms involving project management differ. In essence:\n\n- Project: A group of systems. Sometimes called a \"workspace\" in other languages.\n- System: A group of packages. These can represent both libraries and \"executables\".\n- Package: A group of functions and type definitions. Often called a \"module\" in other languages, but can span multiple files.\n\nAs you can see, what is usually called a library elsewhere is known as a \"system\" in Common Lisp. Hence the name asdf:load-system. See here for an example of an inter-depending, multi-system project.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Common Lisp Docs Modernized online documentation.\n- The Community Spec: More online stdlib documentation.\n- The Common Lisp Cookbook: HOWTOs for many topics.\n- Awesome CL: An overview of the ecosystem.\n- Quickdocs: Quicklisp library lookup.\n- Portability: Compiler implementation compatibility listing.\n- Wikipedia:Common Lisp\n- Cliki: The Common Lisp Wiki\n\n"
    }
  ]
}