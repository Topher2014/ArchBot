{
  "title": "Stress Test",
  "url": "https://wiki.archlinux.org/title/Stress_Test",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Benchmarking\n\nStress testing is the process of running various work loads on a computer to assess its stability. This is often used to reliably check the stability of overclocked/undervolted hardware and monitor the thermal behavior of the system (e.g. maximum temperatures, throttling, noise levels). There are several programs available to stress test various parts of the system such as CPU, GPU, RAM, and storage, using different types of work loads.\n\n"
    },
    {
      "title": "Stress testing tasks",
      "level": 2,
      "content": "The table below lists some stress testing software based on the kind of test and the overall intensity of the work load. It is important to stress test using mixed loads to verify stability under many use cases.\n\nNote: **highly** \n\nTable content:\nWork load | Tested hardware1 | Task | Description\nLight2\nCPU, storage | Updating patches | Custom script Refreshing hundreds of kernel patches in the OpenWRT project. See #Updating patches for OpenWRT.\nCPU, storage | Writing a disk image | See #Writing to an image file.\nRAM | Memory stressing | See #MemTest86+.\nRealistic3\nCPU, RAM, storage | Compilation | Parallel compilation is a good way to stress test the CPU. See #GCC.\nCPU, RAM | Video encoding | ffmpeg, x264, handbrake-cli, etc. can be used to encode video. See #Video encoding.\nCPU, RAM | Cryptocurrencies mining | xmrig - xmrig --stress will use different cryptocurrency mining algorithms (based on CPU model) to generate the highest possible load. A good way to test stability and temperatures.\nGPU | 3D rendering | unigine-heavenAUR is a GPU benchmark that runs in a loop. It is a decent stress test for GPUs. See Benchmarking#Graphics.\nSynthetic4 | CPU, RAM, storage | Synthetic stressing | stress is a simple CPU, memory, I/O, and disk workload generator implemented in C. See #stress.\nCPU, RAM | Prime numbers calculation | mprimeAUR factors large numbers and is an excellent way to stress CPU and memory. See #MPrime.\nCPU | Algebra calculation | linpackAUR - Linpack makes use of the BLAS (Basic Linear Algebra Subprograms) libraries for performing basic vector and matrix operations and is an excellent way to stress CPUs for stability. See #Linpack.\nCPU | Pi decimals calculation | systesterAUR Systester is a multithreaded piece of software capable of deriving values of pi out to 128,000,000 decimal places. It has built in check for system stability. See #Systester.\nRAM | Memory stressing | stressapptestAUR is a memory interface test.\nCPU | Various | strainAUR A multi-function stress-testing utility. Written in Rust.\n\n- 1 The main target of the test, virtually all testing will also involve the CPU and RAM to some extent.\n- 2 Light tests do not push the components very hard (in terms of power/heat limits). These tests are still useful to test how the hardware behaves in lower power levels (P states), in particular for undervolted systems.\n- 3 Realistic tests are based on real world workloads.\n- 4 Synthetic tests are explicitly designed to torture the hardware as much as possible and may not be representative of real-world workloads.\n\n"
    },
    {
      "title": "Updating patches for OpenWRT",
      "level": 3,
      "content": "A good stability test of a low load workload is to run though updating the patch sets in the OpenWRT project. Follow these steps.\n\n```\ngit clone --depth 1 https://github.com/openwrt/openwrt.git\ncd openwrt\nmkdir -p staging_dir/host/bin\ncp /usr/bin/sed ./staging_dir/host/bin\ncurl -Os https://raw.githubusercontent.com/KanjiMonster/maintainer-tools/master/update_kernel.sh\nchmod +x update_kernel.sh\n./update_kernel.sh -v -u 6.6\n```\n\n"
    },
    {
      "title": "stress",
      "level": 3,
      "content": "stress performs a loop that calculates the square root of a random number in order to stress the CPU. It can run simultaneously several workers to load all the cores of a CPU for example. It can also generate memory, I/O or disk workload depending on the parameters passed. The FAQ provides examples and explanations.\n\nTo spawn 4 workers working on calculating a square root, use the command:\n\n```\n$ stress --cpu 4\n```\n\n"
    },
    {
      "title": "s-tui",
      "level": 3,
      "content": "s-tui is terminal-based CPU stress and monitoring utility. It can both monitor CPU usage and temperatures and can also stress the CPU. It is a one stop shop tool where you can see all the information needed in one single screen, with a terminal graphical interface.\n\n"
    },
    {
      "title": "MPrime",
      "level": 3,
      "content": "MPrime (also known as Prime95 in its Windows and MacOS implementation) is recognised universally as one defacto measure of system stability. MPrime under torture test mode will perform a series of very CPU intensive calculations and compare the values it gets to known good values.\n\nThe Linux implementation is called mprimeAUR.\n\nTo run mprime, simply open a shell and type \"mprime\":\n\n```\n$ mprime\n```\n\nWhen the software loads, simply answer 'N' to the first question to begin the torture testing:\n\n```\nMain Menu\n\n1.  Test/Primenet\n2.  Test/Worker threads\n3.  Test/Status\n4.  Test/Continue\n5.  Test/Exit\n6.  Advanced/Test\n7.  Advanced/Time\n8.  Advanced/P-1\n9.  Advanced/ECM\n10.  Advanced/Manual Communication\n11.  Advanced/Unreserve Exponent\n12.  Advanced/Quit Gimps\n13.  Options/CPU\n14.  Options/Preferences\n15.  Options/Torture Test\n16.  Options/Benchmark\n17.  Help/About\n18.  Help/About PrimeNet Server\n```\n\nThere are several options for the torture test (menu option 15).\n\n- Small FFTs (option 1) to stress the CPU\n- In-place large FFTs (option 2) to test the CPU and memory controller\n- Blend (option 3) is the default and constitutes a hybrid mode which stresses the CPU and RAM.\n\nErrors will be reported should they occur both to stdout and to ~/results.txt for review later. Many do not consider a system as 'stable' unless it can run the Large FFTs for a 24 hour period.\n\nExample ~/results.txt; note that the two runs from 26-June indicate a hardware failure. In this case, due to insufficient vcore to the CPU:\n\n```\n[Sun Jun 26 20:10:35 2011]\nFATAL ERROR: Rounding was 0.5, expected less than 0.4\nHardware failure detected, consult stress.txt file.\nFATAL ERROR: Rounding was 0.5, expected less than 0.4\nHardware failure detected, consult stress.txt file.\n[Sat Aug 20 10:50:45 2011]\nSelf-test 480K passed!\nSelf-test 480K passed!\n[Sat Aug 20 11:06:02 2011]\nSelf-test 128K passed!\nSelf-test 128K passed!\n[Sat Aug 20 11:22:10 2011]\nSelf-test 560K passed!\nSelf-test 560K passed!\n...\n```\n\n"
    },
    {
      "title": "Linpack",
      "level": 3,
      "content": "linpackAUR makes use of the BLAS (Basic Linear Algebra Subprograms) libraries for performing basic vector and matrix operations. It is an excellent way to stress CPUs for stability (only Intel CPUs are supported). After installation, users should copy /usr/share/linpack/linpack.conf to ~/.config/linpack.conf and adjust it according to the amount of memory on the system.\n\n"
    },
    {
      "title": "Systester",
      "level": 3,
      "content": "SystesterAUR (aka SuperPi for Windows) is available in both CLI and GUI version. It tests system stability by calculating up to 128 millions of Pi digits and includes error checking. Note that one can select from two different calculation algorithms: Quadratic Convergence of Borwein and Gauss-Legendre. The latter being the same method that the popular SuperPi for Windows uses.\n\nA CLI example using 8 threads is given:\n\n```\n$ systester-cli -gausslg 64M -threads 8\n```\n\n"
    },
    {
      "title": "MemTest86+",
      "level": 3,
      "content": "Use MemTest86 (proprietary) or Memtest86+ (GPL) to test your memory (RAM).\n\n- The GPL version is available on the Arch Linux install image. It can be installed: for EFI systems with memtest86+-efi, for BIOS systems with memtest86+\n- The proprietary versions does not support BIOS. Install it as memtest86-efiAUR.\n- After installation, its users can update GRUB: it will auto-detect the package and allow users to boot directly to it.\n\n- for EFI systems with memtest86+-efi,\n- for BIOS systems with memtest86+\n\n- A reliable source of the version history is the History of MemTest86 section in memtest86.com, in particular the section \"2002 - 2004\" and following. Notice the proprietary MemTest86 from version 5 through 7 claims to support both BIOS and UEFI, but they simply bundle old and new versions.\n- Allowing tests to run for at least 10 cycles without errors is usually sufficient.\n\n"
    },
    {
      "title": "Writing to an image file",
      "level": 3,
      "content": "A good stability test under a low load workload is using dd to format an image. This can be a physical disk or a loop mounted image. The script below uses mounted image and cycles through each core one-by-one. Note that you should adjust the variables in the top of script to match your system. By default the script will run the command just once per core. It can be easily customised to run on known-weak cores rather than scanning all core 0 through n by altering the for loop. Run the script as root.\n\n```\nformat-test.sh\n```\n\n```\n#!/bin/bash\n\n# define the path to store the image, recommended to be a tmpfs mounted location to avoid read/writes\nimg=/scratch/image.img\n\n# define the mount point\nmnt=/mnt/loop\n\n# size of time arg to pass to truncate, make sure you select something less than the free memory on the system\n# see truncate --help for available options\nsize=40G\n\n# defaults to 1 less than the number of virtual cores, manually redefine if desired\nmax=$(($(nproc) - 1))\n\nif [[ ! -f $img ]]; then\n  truncate -s $size $img\n  mkfs.ext4 $img\n  [[ -d $mnt ]] || mkdir -p $mnt\n  if ! mountpoint -q $mnt; then\n    mount -o loop $img $mnt || exit 1\n  fi\nfi\n\nfor i in $(eval echo \"{0..$max}\"); do\n  echo \"using core $i of $max\"\n  taskset -c \"$i\" time dd if=/dev/zero of=$mnt/zerofill status=progress\ndone\n\numount $mnt\nrm $img\n```\n\n"
    },
    {
      "title": "GCC",
      "level": 3,
      "content": "Parallel compilation using GCC (or other compilers) will generate a heavy load on the CPU and memory. To avoid I/O bottlenecking, compile on a SSD or in a tmpfs.\n\nA good example would be compiling the kernel: see Kernel/Arch build system for detailed instructions, run makepkg -sf MAKEFLAGS=\"-j$(nproc)\" at Kernel/Arch build system#Compiling.\n\n"
    },
    {
      "title": "Video encoding",
      "level": 3,
      "content": "Most video encoders are highly parallel and are designed to use most of a CPU's capabilities. The example below will encode noise using x265, and discard the result. This will heavily load the CPU.\n\n```\nffmpeg -y -f rawvideo -video_size 1920x1080 -pixel_format yuv420p -framerate 60 -i /dev/urandom -c:v libx265 -preset placebo -f matroska /dev/null\n```\n\n"
    },
    {
      "title": "Discovering errors",
      "level": 2,
      "content": "Some stressing applications like #MPrime or #Linpack have built in consistency checks to discover errors due to non-matching results. A more general and simple method for measuring hardware instabilities can be found in the kernel itself. To use it, simply filter the journal on a crash like so:\n\n```\n# journalctl -k --grep=mce\n```\n\nMulticore chips can also give info as to which physical/logical core gave the error. This can be important if users are optimizing settings on a per-core basis.\n\nThe kernel can throw these errors while the stressing application is running, before it ends the calculation and reports the error, thus providing a very sensitive method to assess stability. Consider the following from a Ryzen 5900X:\n\n```\nmce: [Hardware Error]: Machine check events logged\nmce: [Hardware Error]: CPU 21: Machine Check: 0 Bank 5: baa0000000030150\nmce: [Hardware Error]: TSC 0 MISC d012000100000000 SYND 4d000002 IPID 500b000000000\nmce: [Hardware Error]: PROCESSOR 2:a20f10 TIME 1625265814 SOCKET 0 APIC 4 microcode a201016\n```\n\nThis chip as 12 physical cores. In this case, CPU 21 can be traced back to physical core 10. Use lstopo from hwloc to print the hardware topology.\n\n```\nCore 0 = CPU 0 + CPU 1\nCore 1 = CPU 2 + CPU 3\nCore 2 = CPU 4 + CPU 5\nCore 3 = CPU 6 + CPU 7\nCore 4 = CPU 8 + CPU 9\nCore 5 = CPU 10 + CPU 11\nCore 6 = CPU 12 + CPU 13\nCore 7 = CPU 14 + CPU 15\nCore 8 = CPU 16 + CPU 17\nCore 9 = CPU 18 + CPU 19\nCore 10 = CPU 20 + CPU 21\nCore 11 = CPU 22 + CPU 23\n```\n\n"
    }
  ]
}