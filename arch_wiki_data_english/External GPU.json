{
  "title": "External GPU",
  "url": "https://wiki.archlinux.org/title/External_GPU",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Xorg\n- PRIME\n- Thunderbolt\n- NVIDIA Optimus\n- NVIDIA/Tips and tricks\n- Docking\n\nOn computers equipped with Thunderbolt 3+ or USB4, it is possible to attach a desktop-grade external graphics card (eGPU) using a GPU enclosure. eGPU.io is a good resource with buyer's guide and a community forum. While some manual configuration (shown below) is needed for most modes of operation, Linux support for eGPUs is generally good.\n\n"
    },
    {
      "title": "Thunderbolt",
      "level": 3,
      "content": "The eGPU enclosure Thunderbolt device may need to be authorized first after plugging in (based on your BIOS/UEFI Firmware configuration). Follow Thunderbolt#User device authorization. If successful, the external graphics card should show up in lspci:\n\n```\n$ lspci -d ::03xx\n```\n\n```\n00:02.0 VGA compatible controller: Intel Corporation UHD Graphics 620 (rev 07)             # internal GPU\n1a:10.3 VGA compatible controller: NVIDIA Corporation GP107 [GeForce GTX 1050] (rev a1)    # external GPU\n```\n\nDepending on your computer, its firmware and enclosure firmware, Thunderbolt will limit host <-> eGPU bandwidth to some extent due to the number of PCIe lanes and OPI Mode:\n\n```\n# dmesg | grep PCIe\n```\n\n```\n[19888.928225] pci 0000:1a:10.3: 8.000 Gb/s available PCIe bandwidth, limited by 2.5 GT/s PCIe x4 link at 0000:05:01.0 (capable of 126.016 Gb/s with 8.0 GT/s PCIe x16 link)\n```\n\n"
    },
    {
      "title": "Drivers",
      "level": 3,
      "content": "A driver compatible with your GPU model should be installed:\n\n- AMDGPU\n- NVIDIA proprietary NVIDIA drivers\n- Nouveau open-source NVIDIA drivers\n\nIf installed successfully, lspci -k should show that a driver has been associated with your card:\n\n```\n$ lspci -k -d ::03xx\n```\n\n```\n1a:10.3 VGA compatible controller: NVIDIA Corporation GP107 [GeForce GTX 1050] (rev a1)\n        Subsystem: NVIDIA Corporation GP107 [GeForce GTX 1050]\n        Kernel driver in use: nvidia\n        Kernel modules: nouveau, nvidia_drm, nvidia\n```\n\n"
    },
    {
      "title": "AMDGPU",
      "level": 4,
      "content": "Note that the AMDGPU driver (with either Thunderbolt or USB4) might in some cases set the wrong pcie_gen_cap option and fall back to PCIe gen 1.1 speed, with possibly serious performance issues. In this case the proper value can be set as module option (see Kernel module#Using modprobe.d) or even passed as kernel parameters:\n\n```\n/etc/modprobe.d/amd-egpu-pcie-speed.conf\n```\n\n```\noptions amdgpu pcie_gen_cap=0x40000\n```\n\nThis will set PCIe gen 3 speed. A full list of options can be found in amd_pcie.h.\n\n"
    },
    {
      "title": "NVIDIA",
      "level": 4,
      "content": "For NVIDIA eGPUs on some systems you may need to early load the thunderbolt kernel module to ensure it is loaded before nvidia_drm.\n\n- If you use mkinitcpio initramfs, follow mkinitcpio#MODULES to add modules.\n- If you use Booster, follow Booster#Early module loading.\n- If you use dracut, follow dracut#Early kernel module loading.\n\n"
    },
    {
      "title": "Compute-only workloads",
      "level": 2,
      "content": "Right after completing installation steps, compute-only workloads like GPGPU#CUDA that do not need to display anything should work without any extra configuration. The nvidia-smi utility (provided by the nvidia-utils package) should work with the proprietary NVIDIA driver. Proprietary NVENC/NVDEC should work (without OpenGL interop).\n\nThis use-case should also support full hotplug. Hot-unplug should be also possible (probably depending on drivers used). On NVIDIA, active nvidia-persistenced is expected to prevent clean hot-unplug.\n\n"
    },
    {
      "title": "Xorg",
      "level": 2,
      "content": "Multiple setups combining internal (iGPU) and external (eGPU) cards are possible, each with own advantages and disadvantages.\n\n"
    },
    {
      "title": "Xorg rendered on eGPU, PRIME display offload to iGPU",
      "level": 3,
      "content": "- Most programs that make use of GPU run out-of-the-box on eGPU: glxinfo/glxgears, eglinfo/eglgears_x11, NVENC/NVDEC (including OpenGL interop).\n- Xorg only starts with the eGPU plugged in.\n- Monitors attached to eGPU work out-of-the-box, PRIME display offload can be used for monitors attached to iGPU (i.e. internal laptop screen).\n\nMain article is PRIME#Reverse PRIME. Also documented in NVIDIA driver docs Chapter 34. Offloading Graphics Display with RandR 1.4.\n\nUse Xorg configuration snippet like this one:\n\n```\n/etc/X11/xorg.conf.d/80-egpu-primary-igpu-offload.conf\n```\n\n```\nSection \"Device\"\n    Identifier \"Device0\"\n    Driver     \"nvidia\"\n    BusID      \"PCI:26:16:3\"                 # Edit according to lspci, translate from hex to decimal.\n    Option     \"AllowExternalGpus\" \"True\"    # Required for proprietary NVIDIA driver.\nEndSection\n\nSection \"Module\"\n    # Load modesetting module for the iGPU, which should show up in XrandR 1.4 as a provider.\n    Load \"modesetting\"\nEndSection\n```\n\nTo validate this setup, use xrandr --listproviders, which should display\n\n```\nProviders: number : 2\nProvider 0: id: 0x1b8 cap: 0x1, Source Output crtcs: 4 outputs: 4 associated providers: 0 name:NVIDIA-0\nProvider 1: id: 0x1f3 cap: 0xf, Source Output, Sink Output, Source Offload, Sink Offload crtcs: 3 outputs: 5 associated providers: 0 name:modesetting\n```\n\nTo output to internal laptop screen and/or other monitors attached to iGPU, RandR 1.4 PRIME display offload can be used, using names from above xrandr --listproviders output:\n\n```\nxrandr --setprovideroutputsource modesetting NVIDIA-0 && xrandr --auto\n```\n\nYou may want to run this command before a display manager shows login prompt or before desktop environment starts, see xrandr#Configuration and xinit.\n\nVulkan may enumerate GPUs independently of Xorg, so in order to run for example vkcube in this setup, one may need to pass --gpu_number 1 option. Alternatively, a layer to reorder GPUs during enumeration can be activated with the same effect: __NV_PRIME_RENDER_OFFLOAD=1 vkcube or equivalently prime-run vkcube.\n\n"
    },
    {
      "title": "Xorg rendered on iGPU, PRIME render offload to eGPU",
      "level": 3,
      "content": "- Programs are rendered on iGPU by default, but PRIME render offload can be used to render them on eGPU.\n- Xorg starts even with eGPU disconnected, but render/display offload will not work until it is restarted.\n- Monitors attached to iGPU (i.e. internal laptop screen) work out-of-the-box, PRIME display offload can be used for monitors attached to eGPU.\n\nMain article is PRIME#PRIME GPU offloading. Also documented in NVIDIA driver docs Chapter 35. PRIME Render Offload.\n\nWith many discrete GPU drivers, this mode should be the default without any manual Xorg configuration. If that does not work, or if you use proprietary NVIDIA drivers, use the following:\n\n```\n/etc/X11/xorg.conf.d/80-igpu-primary-egpu-offload.conf\n```\n\n```\nSection \"Device\"\n    Identifier \"Device0\"\n    Driver     \"modesetting\"\nEndSection\n\nSection \"Device\"\n    Identifier \"Device1\"\n    Driver     \"nvidia\"\n    BusID      \"PCI:26:16:3\"                 # Edit according to lspci, translate from hex to decimal.\n    Option     \"AllowExternalGpus\" \"True\"    # Required for proprietary NVIDIA driver.\nEndSection\n```\n\nTo validate this setup, use xrandr --listproviders, which should display\n\n```\n$ xrandr --listproviders\n```\n\n```\nProviders: number : 2\nProvider 0: id: 0x47 cap: 0xf, Source Output, Sink Output, Source Offload, Sink Offload crtcs: 3 outputs: 5 associated providers: 0 name:modesetting\nProvider 1: id: 0x24a cap: 0x2, Sink Output crtcs: 4 outputs: 4 associated providers: 0 name:NVIDIA-G0\n```\n\nNote: **This article or section is a candidate for merging with PRIME#Configure applications to render using GPU.** This article or section is a candidate for merging with PRIME#Configure applications to render using GPU.\n\nThis article or section is a candidate for merging with PRIME#Configure applications to render using GPU.\n\nTo render some_program on the eGPU, PRIME render offload can be used:\n\n- for proprietary NVIDIA drivers: $ __NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only __GLX_VENDOR_LIBRARY_NAME=nvidia some_program\n- for proprietary NVIDIA drivers (convenience wrapper): $ prime-run some_program\n- for open-source drivers: $ DRI_PRIME=1 some_program\n\n```\n$ __NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only __GLX_VENDOR_LIBRARY_NAME=nvidia some_program\n```\n\n```\n$ prime-run some_program\n```\n\n```\n$ DRI_PRIME=1 some_program\n```\n\nTo output to monitors connected to eGPU, RandR 1.4 PRIME display offload can be again used:\n\n```\n$ xrandr --setprovideroutputsource NVIDIA-G0 modesetting && xrandr --auto\n```\n\nNVIDIA drivers 460.27.04+ implement an optimization for a special case of combined render and display offloads:\n\n"
    },
    {
      "title": "Separate Xorg instance for eGPU",
      "level": 3,
      "content": "Main article is nvidia-xrun#External GPU setup.\n\n"
    },
    {
      "title": "Known issues with eGPUs on Xorg",
      "level": 3,
      "content": "- hotplug is not supported with most discrete GPU Xorg drivers: the eGPU needs to be plugged in when Xorg starts. Logging out and in again should suffice to restart Xorg.\n- hot-unplug is not supported at all: doing so leads to system instability or outright freezes (as acknowledged in the NVIDIA documentation).\n\n"
    },
    {
      "title": "Wayland",
      "level": 2,
      "content": "Wayland support for eGPUs (or multiple GPUs in general) is much less tested, but should work with even less manual configuration.\n\nNote that there need to be explicit GPU hotplug support by the Wayland compositor, but most already have some level of support:\n\n- KDE's kwin: https://invent.kde.org/plasma/kwin/-/merge_requests/811\n- GNOME's Mutter: https://gitlab.gnome.org/GNOME/mutter/-/issues/17, https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1562\n- wlroots: https://gitlab.freedesktop.org/wlroots/wlroots/-/issues/1278\n\nFor open-source drivers, DRI offloading works fine:\n\n```\n$ DRI_PRIME=1 some_program\n```\n\nSome projects, such as all-ways-egpu, are trying to provide more efficient methods for GPU selection under Wayland.\n\n"
    },
    {
      "title": "Hotplugging NVIDIA eGPU",
      "level": 3,
      "content": "It is possible to hotplug eGPU when using Wayland, and use PRIME feature. NVIDIA already has great implementation of PRIME for dGPUs, and it is working same way for eGPU.\n\nFirst you need to make sure that no program uses NVIDIA modules. EGL programs tend to use 1MB dGPU memory per program, even if they run on iGPU, and it can be seen in nvidia-smi. To avoid this, add __EGL_VENDOR_LIBRARY_FILENAMES=/usr/share/glvnd/egl_vendor.d/50_mesa.json as environment variable. Best place for that is /etc/environment.d/50_mesa.conf.\n\nThen you unload NVIDIA modules:\n\n```\n# rmmod nvidia_uvm\n# rmmod nvidia_drm\n# rmmod nvidia_modeset\n# rmmod nvidia\n```\n\nWhen NVIDIA modules is no longer loaded, you can connect external GPU. When GPU is initialized, load NVIDIA modules again with modprobe nvidia-drm command or modprobe nvidia-current-drm. Naming depends on source of modules, either it is drivers from NVIDIA website or from package manager. In some cases (for example, for GIGABYTE AORUS GAMING BOX) eGPU does not work with proprietary modules, so you might need to load open-source ones: modprobe nvidia-current-open-drm.\n\nWhen modules successfully loaded, prime feature will work, but since we set __EGL_VENDOR_LIBRARY_FILENAMES variable to use MESA, we need to add __EGL_VENDOR_LIBRARY_FILENAMES=/usr/share/glvnd/egl_vendor.d/10_nvidia.json before starting program. Full string will look like:\n\n```\n__GLX_VENDOR_LIBRARY_NAME=nvidia __NV_PRIME_RENDER_OFFLOAD=1 __VK_LAYER_NV_optimus=NVIDIA_only __EGL_VENDOR_LIBRARY_FILENAMES=/usr/share/glvnd/egl_vendor.d/10_nvidia.json %command%\n```\n\nFor GNOME users, you might need to patch switcheroo-control to include __EGL_VENDOR_LIBRARY_FILENAMES into list of environment variables. This will allow programs to run on eGPU naturally with right click and \"Launch using Dedicated Graphics Card\". But this is beyond scope of this article.\n\n"
    },
    {
      "title": "Hotplugging NVIDIA eGPU and temporarily disabling NVIDIA dGPU",
      "level": 3,
      "content": "In case you have iGPU, NVIDIA dGPU and want to connect NVIDIA eGPU, you will encounter a conflict, where graphics renders only on dGPU, no matter what you do. To solve this, you need to temporarily disable dGPU, so NVIDIA driver will not notice it. Best way to do that is to override its driver.\n\nFirst, you need to unload NVIDIA driver:\n\n```\n# rmmod nvidia_uvm\n# rmmod nvidia_drm\n# rmmod nvidia_modeset\n# rmmod nvidia\n```\n\nThen, you need to override dGPU driver with driverctlAUR utility. In this example, 0000:01:00.0 is address of dGPU. It can be found with lspci utility.\n\n```\n# driverctl --nosave set-override 0000:01:00.0 vfio-pci\n```\n\nIt is important to use --nosave parameter, to prevent driverctl to override driver on boot. It is useful in case something goes wrong, simple reboot cleans everything.\n\nWhen dGPU is disabled, you can load kernel modules with modprobe nvidia-drm and then check if nvidia-smi shows 1 or 2 GPUs.\n\nBringing dGPU back is tricky, because it is unintuitive. First, unload NVIDIA modules, unplug eGPU and then run this series of commands:\n\n```\n# modprobe nvidia-current\n# driverctl --nosave unset-override 0000:01:00.0\n# modprobe nvidia-current\n# driverctl --nosave unset-override 0000:01:00.0\n# modprobe nvidia-current-modeset\n# modprobe nvidia-current-drm\n```\n\nIt is strange that we need to run first 2 commands twice, but otherwise it will not bring back dGPU. Command will error once, but it is not critical.\n\n"
    }
  ]
}