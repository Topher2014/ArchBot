{
  "title": "Mount encrypted volumes in parallel",
  "url": "https://wiki.archlinux.org/title/Mount_encrypted_volumes_in_parallel",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n- If in need to remotely unlock root or other early-boot filesystems (headless machine, distant servers...), follow the specific instructions from dm-crypt/Specialties#Remote unlocking of root (or other) partition.\n- To ease inputting UUIDs, PARTUUIDs, etc. in configuration files, you can install and use a text editor that supports inserting command output (e.g. nano with Ctrl+t, Vim or Neovim with :read or mcedit with Alt+u) and pass it the apropriate lsblk or blkid command. Alternatively, you can install a terminal multiplexer and use its copy and paste functionality.\n\n"
    },
    {
      "title": "Unlocking in early userspace",
      "level": 2,
      "content": "Booting an encrypted root volume requires that the initramfs contains the necessary tools for early userspace to unlock the volume. The instructions on what to unlock are typically passed via kernel parameters.\n\nThe following sections describe how to configure mkinitcpio and list which kernel parameters are required.\n\n"
    },
    {
      "title": "mkinitcpio",
      "level": 3,
      "content": "Depending on the particular scenarios, a subset of the following mkinitcpio hooks will have to be enabled:\n\nTable content:\nbusybox | systemd | Use case\nencrypt | sd-encrypt | Needed when the root partition is encrypted or when an encrypted partition needs to be mounted before the root partition. Not needed in other cases as system initialization scripts like /etc/crypttab already take care of unlocking other non-root partitions. This hook must be placed after the udev or systemd hook.\nkeyboard | Needed to make keyboards work in early userspace. Tip: For systems that are booted with different hardware configurations (e.g. laptops with external keyboard vs. internal keyboard or headless systems), it is helpful to place this hook before autodetect in order to always include all keyboard drivers. Otherwise the external keyboard only works in early userspace if it was connected when creating the image.\nkeymap | sd-vconsole | Provides support for non-US keymaps for typing encryption passwords; it must come before the encrypt hook, otherwise you will need to enter your encryption password using the default US keymap. Set your keymap in /etc/vconsole.conf, see Keyboard configuration in console#Persistent configuration.\nconsolefont | Loads an alternative console font in early userspace. Set your font in /etc/vconsole.conf, see Linux console#Persistent configuration.\n\nOther hooks needed should be clear from other manual steps followed during the installation of the system.\n\n"
    },
    {
      "title": "Examples",
      "level": 4,
      "content": "A typical /etc/mkinitcpio.conf configuration using encrypt hook:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\n...\nHOOKS=(base udev autodetect microcode modconf kms keyboard keymap consolefont block encrypt lvm2 filesystems fsck)\n...\n```\n\nA configuration with systemd-based initramfs using sd-encrypt hook:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\n...\nHOOKS=(base systemd autodetect microcode modconf kms keyboard sd-vconsole block sd-encrypt lvm2 filesystems fsck)\n...\n```\n\n"
    },
    {
      "title": "Kernel parameters",
      "level": 3,
      "content": "The kernel parameters you need to specify depend on whether the encrypt hook or the sd-encrypt hook is being used. root and resume are specified the same way for both.\n\n"
    },
    {
      "title": "root",
      "level": 4,
      "content": "The root= parameter specifies the device of the actual (decrypted) root file system:\n\n```\nroot=device\n```\n\n- If the file system is formatted directly on the decrypted device file this will be /dev/mapper/dmname.\n- If a LVM gets activated first and contains an encrypted logical rootvolume, the above form applies as well.\n- If the root file system is contained in a logical volume of a fully encrypted LVM, the device mapper for it will be in the general form of root=/dev/volumegroup/logicalvolume.\n\n- The specification of the root= parameter can be omitted when using the sd-encrypt hook and GPT partition automounting. See LUKS on a partition.\n- When using GRUB and generating grub.cfg with grub-mkconfig, the root= parameter does not need to be specified manually. grub-mkconfig will determine the correct UUID of the decrypted root filesystem and add it to grub.cfg automatically.\n\n"
    },
    {
      "title": "resume",
      "level": 4,
      "content": "```\nresume=device\n```\n\n- device is the device file of the decrypted (swap) filesystem used for suspend to disk. If swap is on a separate partition, it will be in the form of /dev/mapper/swap. See also dm-crypt/Swap encryption.\n\n"
    },
    {
      "title": "Using encrypt hook",
      "level": 4,
      "content": "Note: **one** \n\n- Unlocking multiple encrypted disks (archlinux/mkinitcpio/mkinitcpio#231). Only one device can be unlocked in the initramfs.\n- Using a detached LUKS header (archlinux/mkinitcpio/mkinitcpio#234).\n- Setting additional options that are supported by crypttab.\n\nThis specifies the device containing the encrypted root on a cold boot. It is parsed by the encrypt hook to identify which device contains the encrypted system:\n\n```\ncryptdevice=device:dmname:options\n```\n\n- device is the path to the device backing the encrypted device. Usage of persistent block device naming is strongly recommended.\n- dmname is the device-mapper name given to the device after decryption, which will be available as /dev/mapper/dmname.\n- options (optional) are comma separated options, e.g. for TRIM support. If no options are required, omit this parameter (use cryptdevice=device:dmname).\n- If a LVM contains the encrypted root, the LVM gets activated first and the volume group containing the logical volume of the encrypted root serves as device. It is then followed by the respective volume group to be mapped to root. The parameter follows the form of cryptdevice=/dev/vgname/lvname:dmname.\n\nThis parameter specifies the location of a keyfile and is required by the encrypt hook for reading such a keyfile to unlock the cryptdevice (unless a key is in the default location, see below). It can have three parameter sets, depending on whether the keyfile exists as a file in a particular device, a bitstream starting on a specific location, or a file in the initramfs.\n\nFor a file in a device the format is:\n\n```\ncryptkey=device:fstype:path\n```\n\n- device is the raw block device where the key exists. Usage of persistent block device naming is strongly recommended.\n- fstype is the filesystem type of device (or auto).\n- path is the absolute path of the keyfile within the device.\n\nExample: cryptkey=LABEL=usbstick:vfat:/secretkey\n\nFor a bitstream on a device the key's location is specified with the following:\n\n```\ncryptkey=device:offset:size\n```\n\nwhere the offset and size are in bytes. For example, cryptkey=UUID=ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ:0:512 reads a 512 byte keyfile starting at the beginning of the device.\n\nFor a file included in the initramfs the format is[1]:\n\n```\ncryptkey=rootfs:path\n```\n\nExample: cryptkey=rootfs:/secretkey\n\nAlso note that if cryptkey is not specified, it defaults to /crypto_keyfile.bin (in the initramfs).[2]\n\nSee also dm-crypt/Device encryption#Keyfiles.\n\nThis parameter is specific to pass dm-crypt plain mode options to the encrypt hook.\n\nIt takes the form\n\n```\ncrypto=hash:cipher:keysize:offset:skip\n```\n\nThe arguments relate directly to the cryptsetup options. See dm-crypt/Device encryption#Encryption options for plain mode.\n\nFor a disk encrypted with just plain default options, the crypto arguments must be specified, but each entry can be left blank:\n\n```\ncrypto=::::\n```\n\nA specific example of arguments is\n\n```\ncrypto=sha512:twofish-xts-plain64:512:0:\n```\n\n"
    },
    {
      "title": "Using systemd-cryptsetup-generator",
      "level": 4,
      "content": "systemd-cryptsetup-generator is a systemd unit generator that reads a subset of kernel parameters, and /etc/crypttab, for the purpose of unlocking encrypted devices. See the systemd-cryptsetup-generator(8) man page for more details about it and all options it supports.\n\nsystemd-cryptsetup-generator is run during the initramfs stage when using the sd-encrypt mkinitcpio hook or the systemd dracut module.\n\nIn what follows, we describe some of the kernel parameters that systemd-cryptsetup-generator interprets.\n\n- If the file /etc/crypttab.initramfs exists, it will be added to the initramfs as /etc/crypttab, there you can specify devices that need to be unlocked at the initramfs phase. See #crypttab for the syntax. If /etc/crypttab.initramfs does not exist, there will be no /etc/crypttab in the initramfs and the unlockable devices will need to be specified via kernel parameters listed below.\n- /etc/crypttab.initramfs is not limited to using only UUID like rd.luks. You can use any of the persistent block device naming methods.\n- If all the prerequisites of systemd#GPT partition automounting are met, you can avoid hardcoding the root block device identifier (e.g. UUID, PARTUUID, etc.) in /etc/crypttab.initramfs by using /dev/gpt-auto-root-luks instead.\n- Passwords entered during boot are cached in the kernel keyring by systemd-cryptsetup(8), so if multiple devices can be unlocked with the same password (this includes devices in crypttab that are unlocked after boot), then you will only need to input each password once.\n\n- All of the rd.luks parameters can be specified multiple times to unlock multiple LUKS encrypted volumes.\n- The rd.luks parameters only support unlocking LUKS devices. To unlock a plain dm-crypt device, you must specify it in /etc/crypttab.initramfs. See #crypttab for the syntax.\n\n```\nrd.luks.uuid=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n```\n\nSpecify the UUID of the device to be decrypted on boot with this flag.\n\nBy default, the mapped device will be located at /dev/mapper/luks-XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX where XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX is the UUID of the LUKS partition.\n\n```\nrd.luks.name=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=name\n```\n\nSpecify the name of the mapped device after the LUKS partition is open, where XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX is the UUID of the LUKS partition. This is equivalent to the second parameter of encrypt's cryptdevice.\n\nFor example, specifying rd.luks.name=12345678-9abc-def0-1234-56789abcdef0=root causes the unlocked LUKS device with UUID 12345678-9ABC-DEF0-1234-56789ABCDEF0 to be located at /dev/mapper/root.\n\nSpecify the location of a password file used to decrypt the device specified by its UUID. There is no default location like there is with the encrypt hook parameter cryptkey.\n\nIf the keyfile is included in the initramfs:\n\n```\nrd.luks.key=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=/path/to/keyfile\n```\n\nor\n\n```\nrd.luks.key=/path/to/keyfile\n```\n\nIf the keyfile is on another device:\n\n```\nrd.luks.key=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=/path/to/keyfile:UUID=ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ\n```\n\nReplace UUID=ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ with the identifier of the device on which the keyfile is located.\n\n- If the type of file system is different than your root file system, you must include the kernel module for it in the initramfs.\n- rd.luks.key with a keyfile on another device by default does not fallback to asking for a password if the device is not available. To fallback to a password prompt, specify the keyfile-timeout= option in rd.luks.options. E.g. for a 10 second timeout: rd.luks.options=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=keyfile-timeout=10s\n\n```\nrd.luks.options=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=keyfile-timeout=10s\n```\n\n```\nrd.luks.options=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=options\n```\n\nor\n\n```\nrd.luks.options=options\n```\n\nSet options for the device specified by it UUID or, if not specified, for all UUIDs not specified elsewhere (e.g., crypttab).\n\nThis parameter is the analogue of crypttab's options field. The format is the same—options are separated by commas, options with values are specified using option=value. This is roughly equivalent to the third parameter of encrypt's cryptdevice.\n\nFor example:\n\n```\nrd.luks.options=timeout=10s,discard,password-echo=no,tries=1\n```\n\nThere are two options that affect the timeout for entering the password during boot:\n\n- rd.luks.options=timeout=mytimeout specifies the timeout for querying for a password\n- rootflags=x-systemd.device-timeout=mytimeout specifies how long systemd should wait for the rootfs device to show up before giving up (defaults to 90 seconds)\n\nIf you want to disable the timeout altogether, then set both timeouts to zero:\n\n```\nrd.luks.options=timeout=0 rootflags=x-systemd.device-timeout=0\n```\n\nWhen the user is typing the password, systemd-cryptsetup by default outputs asterisks (*) for each typed character. This is unlike the encrypt hook, which does not output anything. To silence the output, set the password-echo=no option:\n\n```\nrd.luks.options=password-echo=no\n```\n\nIf a TPM2 chip is available in your system, or you use FIDO2-compatible security key, you can use it to automatically unlock your volume instead of using a password or a keyfile.\n\nSet\n\n- for TPM2 chip: rd.luks.options=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=tpm2-device=auto\n- for FIDO2 key: rd.luks.options=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=fido2-device=auto\n\nin addition to rd.luks.uuid or rd.luks.name\n\nAlternatively, /etc/crypttab.initramfs can be used which avoids the need to specify any kernel options.\n\n```\n/etc/crypttab.initramfs\n```\n\n```\nroot  UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX  none  tpm2-device=auto\n```\n\nHere the encrypted volume is mounted under the name root (appearing in /dev/mapper/root), mounted via the UUID of the storage device, with no password, and retrieving the key from the TPM2 device.\n\nNote that none must be provided in the password field order for the TPM2 device to be used, otherwise the value given will be used as a password or key, and if it does not work it will ask you to type in the passkey during boot without attempting to load the key from the TPM2 device.\n\nIf specifying the device via UUID as shown above, ensure it is that of the underlying (encrypted) storage device, not the UUID of the decrypted volume that is specified elsewhere as the root filesystem.\n\nWhen using a detached LUKS header, specify the block device with the encrypted data. Must be used together with rd.luks.options to specify the header file location.\n\nSee dm-crypt/Specialties#Encrypted system using a detached LUKS header for details and instructions.\n\n"
    },
    {
      "title": "crypttab",
      "level": 3,
      "content": "The /etc/crypttab (encrypted device table) file is similar to the fstab file and contains a list of encrypted devices to be unlocked during system boot up. This file can be used for automatically mounting encrypted swap devices or secondary file systems.\n\ncrypttab is read before fstab, so that dm-crypt containers can be unlocked before the file system inside is mounted. Note that crypttab is read after the system has booted up, therefore it is not a replacement for unlocking encrypted partitions by using mkinitcpio hooks and configuring them by using kernel parameters as in the case of encrypting the root partition. crypttab processing at boot time is made by the systemd-cryptsetup-generator(8) automatically.\n\nSee crypttab(5) for details, read below for some examples, and the #Mounting at boot time section for instructions on how to use UUIDs to mount an encrypted device.\n\n- If the nofail option is specified, the password entry screen may disappear while typing the password. nofail should therefore only be used together with keyfiles.\n- For dm-crypt plain mode devices, the plain option must be explicitly set to force systemd-cryptsetup(8) to recognize them. See systemd issue 442.\n\n```\n/etc/crypttab\n```\n\n```\n# Example crypttab file. Fields are: name, underlying device, passphrase, cryptsetup options.\n\n# Mount /dev/lvm/swap re-encrypting it with a fresh key each reboot\nswap\t/dev/lvm/swap\t/dev/urandom\tswap,cipher=aes-xts-plain64,size=256,sector-size=4096\n\n# Mount /dev/lvm/tmp as /dev/mapper/tmp using plain dm-crypt with a random passphrase, making its contents unrecoverable after it is dismounted.\ntmp\t/dev/lvm/tmp\t/dev/urandom\ttmp,cipher=aes-xts-plain64,size=256 \n\n# Mount /dev/lvm/home as /dev/mapper/home using LUKS, and prompt for the passphrase at boot time.\nhome   /dev/lvm/home\n\n# Mount /dev/sdb1 as /dev/mapper/backup using LUKS, with a passphrase stored in a file.\nbackup /dev/sdb1       /home/alice/backup.key\n\n# Unlock /dev/sdX using the only available TPM, naming it myvolume\nmyvolume\t/dev/sdX\tnone\ttpm2-device=auto\n```\n\nTo test your crypttab immediately after editing it, reload the systemd manager configuration with a daemon-reload and start the newly generated systemd-cryptsetup@name.service.\n\n```\n# cryptsetup status name\n```\n\n```\n/dev/mapper/name is active.\n  type:    ...\n  cipher:  ...\n  keysize: ... bits\n  key location: ...\n  device:  /dev/sdxN\n  sector size:  ...\n  offset:  ... sectors\n  size:    ... sectors\n  mode:    ...\n  flags:   ...\n```\n\nFor more on systemd-cryptsetup@name.service, see #Mounting on demand.\n\n"
    },
    {
      "title": "Mounting at boot time",
      "level": 4,
      "content": "Note: **This article or section is a candidate for merging with #crypttab.** This article or section is a candidate for merging with #crypttab.\n\nThis article or section is a candidate for merging with #crypttab.\n\nIf you want to mount an encrypted drive at boot time, enter the device's UUID in /etc/crypttab. You get the UUID (partition) by using the command lsblk -f and adding it to crypttab in the form:\n\n```\n/etc/crypttab\n```\n\n```\nexternaldrive         UUID=2f9a8428-ac69-478a-88a2-4aa458565431        none    timeout=180\n```\n\nThe first parameter is your preferred device mapper's name for the encrypted drive. The option none will trigger a prompt during boot to type the passphrase for unlocking the partition. The timeout option defines a timeout in seconds for entering the decryption password during boot.\n\nIf the keyfile for a secondary file system is itself stored inside an encrypted root, it is safe while the system is powered off and can be sourced to automatically unlock the mount during with boot via crypttab. For example, unlock a crypt specified by UUID:\n\n```\n/etc/crypttab\n```\n\n```\nhome-crypt    UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX    /etc/cryptsetup-keys.d/home-crypt.key\n```\n\n- If a keyfile is not specified, systemd-cryptsetup(8) will automatically try to load it from /etc/cryptsetup-keys.d/name.key and /run/cryptsetup-keys.d/name.key.[3]\n- If you prefer to use a --plain mode blockdevice, the encryption options necessary to unlock it are specified in /etc/crypttab. Take care to apply the systemd workaround mentioned in crypttab in this case.\n\nThen use the device mapper's name (defined in /etc/crypttab) to make an entry in /etc/fstab:\n\n```\n/etc/fstab\n```\n\n```\n/dev/mapper/home-crypt        /home   ext4        defaults        0       2\n```\n\nSince /dev/mapper/home-crypt already is the result of a unique partition mapping, there is no need to specify a UUID for it. In any case, the mapper with the filesystem will have a different UUID than the partition it is encrypted in.\n\nThe systemd generators also automatically process stacked block devices at boot.\n\nFor example, you can create a RAID setup, use cryptsetup on it and create an LVM logical volume with respective filesystem inside the encrypted block device. A resulting:\n\n```\n$ lsblk -f\n```\n\n```\n─sdXX                  linux_raid_member    \n│ └─md0                 crypto_LUKS   \n│   └─cryptedbackup     LVM2_member \n│     └─vgraid-lvraid   ext4              /mnt/backup\n└─sdYY                  linux_raid_member    \n  └─md0                 crypto_LUKS       \n    └─cryptedbackup     LVM2_member \n      └─vgraid-lvraid   ext4              /mnt/backup\n```\n\nwill ask for the passphrase and mount automatically at boot.\n\nGiven you specify the correct corresponding crypttab (e.g. UUID for the crypto_LUKS device) and fstab (/dev/vgraid/lvraid) entries, there is no need to add additional mkinitcpio hooks/configuration, because /etc/crypttab processing applies to non-root mounts only. One exception is when the mdadm_udev hook is used already (e.g. for the root device). In this case /etc/madadm.conf and the initramfs need updating to achieve the correct root raid is picked first.\n\n"
    },
    {
      "title": "Mounting on demand",
      "level": 4,
      "content": "Instead of using\n\n```\n# cryptsetup open UUID=... externaldrive\n```\n\nyou can start systemd-cryptsetup@externaldrive.service when you have an entry as follows in your /etc/crypttab:\n\n```\n/etc/crypttab\n```\n\n```\nexternaldrive UUID=... none noauto\n```\n\nThat way you do not need to remember the exact crypttab options. It will prompt you for the passphrase if needed.\n\nThe corresponding unit file is generated automatically by systemd-cryptsetup-generator(8). You can list all generated unit files using:\n\n```\n$ systemctl list-unit-files | grep systemd-cryptsetup\n```\n\n"
    },
    {
      "title": "System stuck on boot/password prompt does not show",
      "level": 3,
      "content": "If you are using Plymouth, make sure to use the correct modules (see Plymouth#mkinitcpio) or disable it. Otherwise, Plymouth will swallow the password prompt, making a system boot impossible.\n\n"
    },
    {
      "title": "Keyboard or keyfile on filesystem unavailable for unlocking",
      "level": 3,
      "content": "If you unlock the LUKS device with a keyboard or a keyfile on a filesystem that is not present when generating the initramfs, you might need to add the corresponding modules to the MODULES array of mkinitcpio. This might also be needed when the keyboard is connected through a USB hub. See mkinitcpio#MODULES for more information on this issue and Minimal initramfs#Sorting out modules as a starting point for potential keyboard and filesystem module names to be added.\n\nIn general, for keyboards that are not connected to the PC at initramfs generation time, you need to place the keyboard hook before the autodetect hook or only the parts necessary for the currently connected hardware are kept, see mkinitcpio#Common hooks.\n\n"
    }
  ]
}