{
  "title": "Daemons",
  "url": "https://wiki.archlinux.org/title/Daemons",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- systemd/User\n- systemd/Timers\n- systemd/Journal\n- systemd/Sandboxing\n- systemd/FAQ\n- init\n- udev\n- Improving performance/Boot process\n- Allow users to shutdown\n\nFrom the project web page:\n\nHistorically, what systemd calls \"service\" was named daemon: any program that runs as a \"background\" process (without a terminal or user interface), commonly waiting for events to occur and offering services. A good example is a web server that waits for a request to deliver a page, or an ssh server waiting for someone trying to log in. While these are full featured applications, there are daemons whose work is not that visible. Daemons are for tasks like writing messages into a log file (e.g. syslog, metalog) or keeping your system time accurate (e.g. ntpd). For more information see daemon(7).\n\n"
    },
    {
      "title": "Basic systemctl usage",
      "level": 2,
      "content": "The main command used to introspect and control systemd is systemctl. Some of its uses are examining the system state and managing the system and services. See systemctl(1) for more details.\n\n- You can use all of the following systemctl commands with the -H user@host switch to control a systemd instance on a remote machine. This will use SSH to connect to the remote systemd instance.\n- Plasma users can install systemdgenie as a graphical frontend for systemctl. After installing, the module will be added under System.\n\n"
    },
    {
      "title": "Using units",
      "level": 3,
      "content": "Units commonly include, but are not limited to, services (.service), mount points (.mount), devices (.device) and sockets (.socket).\n\nWhen using systemctl, you generally have to specify the complete name of the unit file, including its suffix, for example sshd.socket. There are however a few short forms when specifying the unit in the following systemctl commands:\n\n- If you do not specify the suffix, systemctl will assume .service. For example, netctl and netctl.service are equivalent.\n- Mount points will automatically be translated into the appropriate .mount unit. For example, specifying /home is equivalent to home.mount.\n- Similar to mount points, devices are automatically translated into the appropriate .device unit, therefore specifying /dev/sda2 is equivalent to dev-sda2.device.\n\nSee systemd.unit(5) for details.\n\nThe commands in the below table operate on system units since --system is the implied default for systemctl. To instead operate on user units (for the calling user), use systemctl --user without root privileges. See also systemd/User#Basic setup to enable/disable user units for all users.\n\n- Most commands also work if multiple units are specified, see systemctl(1) for more information.\n- The --now switch can be used in conjunction with enable, disable, and mask to respectively start, stop, or mask the unit immediately rather than after rebooting.\n- A package may offer units for different purposes. If you just installed a package, pacman -Qql package | grep -Fe .service -e .socket can be used to check and find them.\n- When available, enabling unit.socket instead of unit.service might be beneficial because the socket would start the service when necessary. See #Socket activation for more details.\n\nTable content:\nAction | Command | Note\nAnalyzing the system state\nShow system status | systemctl status | \nList running units | systemctl orsystemctl list-units | \nList failed units | systemctl --failed | \nList installed unit files1 | systemctl list-unit-files | \nShow process status for a PID | systemctl status pid | cgroup slice, memory and parent\nChecking the unit status\nShow a manual page associated with a unit | systemctl help unit | as supported by the unit\nStatus of a unit | systemctl status unit | including whether it is running or not\nCheck whether a unit is enabled | systemctl is-enabled unit | \nStarting, restarting, reloading a unit\nStart a unit immediately | systemctl start unit as root | \nStop a unit immediately | systemctl stop unit as root | \nRestart a unit | systemctl restart unit as root | \nReload a unit and its configuration | systemctl reload unit as root | \nReload systemd manager configuration2 | systemctl daemon-reload as root | scan for new or changed units\nEnabling a unit\nEnable a unit to start automatically at boot | systemctl enable unit as root | \nEnable a unit to start automatically at boot and start it immediately | systemctl enable --now unit as root | \nDisable a unit to no longer start at boot | systemctl disable unit as root | \nReenable a unit3 | systemctl reenable unit as root | i.e. disable and enable anew\nMasking a unit\nMask a unit to make it impossible to start4 | systemctl mask unit as root | \nUnmask a unit | systemctl unmask unit as root | \n\n1. See systemd.unit(5) § UNIT FILE LOAD PATH for the directories where available unit files can be found.\n1. This does not ask the changed units to reload their own configurations (see the Reload action).\n1. For example, in case its [Install] section has changed since last enabling it.\n1. Both manually and as a dependency, which makes masking dangerous. Check for existing masked units with: $ systemctl list-unit-files --state=masked\n\n```\n$ systemctl list-unit-files --state=masked\n```\n\n"
    },
    {
      "title": "Power management",
      "level": 3,
      "content": "polkit is necessary for power management as an unprivileged user. If you are in a local systemd-logind user session and no other session is active, the following commands will work without root privileges. If not (for example, because another user is logged into a tty), systemd will automatically ask you for the root password.\n\nTable content:\nAction | Command\nShut down and reboot the system | systemctl reboot\nShut down and power-off the system | systemctl poweroff\nSuspend the system | systemctl suspend\nPut the system into hibernation (write RAM to disk) | systemctl hibernate\nPut the system into hybrid-sleep state (also called suspend-to-both, it saves RAM to disk and then suspends) | systemctl hybrid-sleep\nFirst suspend the system, then wake up after a configured time in order to just hibernate the system | systemctl suspend-then-hibernate\nPerform a reboot of the userspace-only with a #Soft reboot. | systemctl soft-reboot\n\n"
    },
    {
      "title": "Soft reboot",
      "level": 4,
      "content": "Soft reboot is a special kind of a userspace-only reboot operation that does not involve the kernel. It is implemented by systemd-soft-reboot.service(8) and can be invoked through systemctl soft-reboot. As with kexec, it skips firmware re-initialization, but additionally the system does not go through kernel initialization and initramfs, and unlocked dm-crypt devices remain attached.\n\nWhen /run/nextroot/ contains a valid root file system hierarchy (e.g. is the root mount of another distribution or another snapshot), soft-reboot would switch the system root into it, allowing for switching to another installation without losing states managed by kernel, e.g. networking.\n\n"
    },
    {
      "title": "Writing unit files",
      "level": 2,
      "content": "The syntax of systemd's unit files (systemd.unit(5)) is inspired by XDG Desktop Entry Specification .desktop files, which are in turn inspired by Microsoft Windows .ini files. Unit files are loaded from multiple locations (to see the full list, run systemctl show --property=UnitPath), but the main ones are (listed from lowest to highest precedence):\n\n- /usr/lib/systemd/system/: units provided by installed packages\n- /etc/systemd/system/: units installed by the system administrator\n\n- The load paths are completely different when running systemd in user mode.\n- systemd unit names may only contain ASCII alphanumeric characters, underscores and periods. All other characters must be replaced by C-style \"\\x2d\" escapes, or employ their predefined semantics ('@', '-'). See systemd.unit(5) and systemd-escape(1) for more information.\n\nLook at the units installed by your packages for examples, as well as systemd.service(5) § EXAMPLES.\n\nsystemd-analyze(1) can help verifying the work. See the systemd-analyze verify FILE... section of that page.\n\n"
    },
    {
      "title": "Handling dependencies",
      "level": 3,
      "content": "With systemd, dependencies can be resolved by designing the unit files correctly. The most typical case is when unit A requires unit B to be running before A is started. In that case add Requires=B and After=B to the [Unit] section of A. If the dependency is optional, add Wants=B and After=B instead. Note that Wants= and Requires= do not imply After=, meaning that if After= is not specified, the two units will be started in parallel.\n\nDependencies are typically placed on services and not on #Targets. For example, network.target is pulled in by whatever service configures your network interfaces, therefore ordering your custom unit after it is sufficient since network.target is started anyway.\n\n"
    },
    {
      "title": "Service types",
      "level": 3,
      "content": "There are several different start-up types to consider when writing a custom service file. This is set with the Type= parameter in the [Service] section:\n\n- Type=simple (default): systemd considers the service to be started up immediately. The process must not fork. Do not use this type if other services need to be ordered on this service, unless it is socket activated.\n- Type=forking: systemd considers the service started up once the process forks and the parent has exited. For classic daemons, use this type unless you know that it is not necessary. You should specify PIDFile= as well so systemd can keep track of the main process.\n- Type=oneshot: this is useful for scripts that do a single job and then exit. You may want to set RemainAfterExit=yes as well so that systemd still considers the service as active after the process has exited. Setting RemainAfterExit=yes is appropriate for the units which change the system state (e.g., mount some partition). See also [1] for the differences of simple and oneshot.\n- Type=notify: identical to Type=simple, but with the stipulation that the daemon will send a signal to systemd when it is ready. The reference implementation for this notification is provided by libsystemd-daemon.so.\n- Type=dbus: the service is considered ready when the specified BusName appears on DBus's system bus.\n- Type=idle: systemd will delay execution of the service binary until all jobs are dispatched. Other than that behavior is very similar to Type=simple.\n\nSee the systemd.service(5) § OPTIONS man page for a more detailed explanation of the Type values.\n\n"
    },
    {
      "title": "Editing provided units",
      "level": 3,
      "content": "To avoid conflicts with pacman, unit files provided by packages should not be directly edited. There are two safe ways to modify a unit without touching the original file: create a new unit file which overrides the original unit or create drop-in snippets which are applied on top of the original unit. For both methods, you must reload the unit afterwards to apply your changes. This can be done either by editing the unit with systemctl edit (which reloads the unit automatically) or by reloading all units with:\n\n```\n# systemctl daemon-reload\n```\n\n- You can use systemd-delta to see which unit files have been overridden or extended and what exactly has been changed.\n- Use systemctl cat unit to view the content of a unit file and all associated drop-in snippets.\n\n"
    },
    {
      "title": "Replacement unit files",
      "level": 4,
      "content": "To replace the unit file /usr/lib/systemd/system/unit, create the file /etc/systemd/system/unit and reenable the unit to update the symlinks.\n\nAlternatively, run:\n\n```\n# systemctl edit --full unit\n```\n\nThis opens /etc/systemd/system/unit in your editor (copying the installed version if it does not exist yet) and automatically reloads it when you finish editing.\n\n"
    },
    {
      "title": "Drop-in files",
      "level": 4,
      "content": "To create drop-in files for the unit file /usr/lib/systemd/system/unit, create the directory /etc/systemd/system/unit.d/ and place .conf files there to override or add new options. systemd will parse and apply these files on top of the original unit.\n\nThe easiest way to do this is to run:\n\n```\n# systemctl edit unit --drop-in=drop_in_name\n```\n\nThis opens the file /etc/systemd/system/unit.d/drop_in_name.conf in your text editor (creating it if necessary) and automatically reloads the unit when you are done editing. Omitting --drop-in= option will result in systemd using the default file name override.conf .\n\n- The key must be still placed in the appropriate section in the override file.\n- Not all keys can be overridden with drop-in files. For example, for changing Conflicts= a replacement file is necessary.\n- You can use top-level drop-in files to affect all units of the same type. For example, a drop-in file in /etc/systemd/system/service.d/ affects all .service units. You can see an example in #Notifying_about_failed_services\n\n"
    },
    {
      "title": "Revert to vendor version",
      "level": 4,
      "content": "To revert any changes to a unit made using systemctl edit do:\n\n```\n# systemctl revert unit\n```\n\n"
    },
    {
      "title": "Examples",
      "level": 4,
      "content": "For example, if you simply want to add an additional dependency to a unit, you may create the following file:\n\n```\n/etc/systemd/system/unit.d/customdependency.conf\n```\n\n```\n[Unit]\nRequires=new dependency\nAfter=new dependency\n```\n\nAs another example, in order to replace the ExecStart directive, create the following file:\n\n```\n/etc/systemd/system/unit.d/customexec.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=new command\n```\n\nNote how ExecStart must be cleared before being re-assigned [2]. The same holds for every item that can be specified multiple times, e.g. OnCalendar for timers.\n\nOne more example to automatically restart a service:\n\n```\n/etc/systemd/system/unit.d/restart.conf\n```\n\n```\n[Service]\nRestart=always\nRestartSec=30\n```\n\n"
    },
    {
      "title": "Service logging levels",
      "level": 3,
      "content": "For services that send logs directly to journald or syslog, you can control their verbosity by setting a numeric value between 0 and 6 for the LogLevelMax= parameter in the [Service] section using the methods described above. For example:\n\n```\n/etc/systemd/system/unit.d/override.conf\n```\n\n```\n[Service]\nLogLevelMax=3\n```\n\nThe standard log levels are identical to those used to filter the journal. Setting a lower number excludes all higher and less important log messages from your journal.\n\n"
    },
    {
      "title": "Suppressing a service's standard output",
      "level": 4,
      "content": "If a service is echoing stdout and/or stderr output, by default this will end up in the journal as well. This behavior can be suppressed by setting StandardOutput=null and/or StandardError=null in the [Service] section. Other values than null can be used to further tweak this behavior. See systemd.exec(5) § LOGGING_AND_STANDARD_INPUT/OUTPUT.\n\n"
    },
    {
      "title": "Targets",
      "level": 2,
      "content": "systemd uses targets to group units together via dependencies and as standardized synchronization points. They serve a similar purpose as runlevels but act a little differently. Each target is named instead of numbered and is intended to serve a specific purpose with the possibility of having multiple ones active at the same time. Some targets are implemented by inheriting all of the services of another target and adding additional services to it. There are systemd targets that mimic the common SystemVinit runlevels.\n\n"
    },
    {
      "title": "Get current targets",
      "level": 3,
      "content": "The following should be used under systemd instead of running runlevel:\n\n```\n$ systemctl list-units --type=target\n```\n\n"
    },
    {
      "title": "Create custom target",
      "level": 3,
      "content": "The runlevels that held a defined meaning under sysvinit (i.e., 0, 1, 3, 5, and 6); have a 1:1 mapping with a specific systemd target. Unfortunately, there is no good way to do the same for the user-defined runlevels like 2 and 4. If you make use of those it is suggested that you make a new named systemd target as /etc/systemd/system/your target that takes one of the existing runlevels as a base (you can look at /usr/lib/systemd/system/graphical.target as an example), make a directory /etc/systemd/system/your target.wants, and then symlink the additional services from /usr/lib/systemd/system/ that you wish to enable.\n\n"
    },
    {
      "title": "Mapping between SysV runlevels and systemd targets",
      "level": 3,
      "content": "Table content:\nSysV Runlevel | systemd Target | Notes\n0 | poweroff.target | Halt the system.\n1, s, single | rescue.target | Single user mode.\n2, 4 | multi-user.target | User-defined/Site-specific runlevels. By default, identical to 3.\n3 | multi-user.target | Multi-user, non-graphical. Users can usually login via multiple consoles or via the network.\n5 | graphical.target | Multi-user, graphical. Usually has all the services of runlevel 3 plus a graphical login.\n6 | reboot.target | Reboot\nemergency | emergency.target | Emergency shell\n\n"
    },
    {
      "title": "Change current target",
      "level": 3,
      "content": "In systemd, targets are exposed via target units. You can change them like this:\n\n```\n# systemctl isolate graphical.target\n```\n\nThis will only change the current target, and has no effect on the next boot. This is equivalent to commands such as telinit 3 or telinit 5 in Sysvinit.\n\n"
    },
    {
      "title": "Change default target to boot into",
      "level": 3,
      "content": "The standard target is default.target, which is a symlink to graphical.target. This roughly corresponds to the old runlevel 5.\n\nTo verify the current target with systemctl:\n\n```\n$ systemctl get-default\n```\n\nTo change the default target to boot into, change the default.target symlink. With systemctl:\n\n```\n# systemctl set-default multi-user.target\n```\n\n```\nRemoved /etc/systemd/system/default.target.\nCreated symlink /etc/systemd/system/default.target -> /usr/lib/systemd/system/multi-user.target.\n```\n\nAlternatively, append one of the following kernel parameters to your boot loader:\n\n- systemd.unit=multi-user.target (which roughly corresponds to the old runlevel 3),\n- systemd.unit=rescue.target (which roughly corresponds to the old runlevel 1).\n\n"
    },
    {
      "title": "Default target order",
      "level": 3,
      "content": "systemd chooses the default.target according to the following order:\n\n1. Kernel parameter shown above\n1. Symlink of /etc/systemd/system/default.target\n1. Symlink of /usr/lib/systemd/system/default.target\n\n"
    },
    {
      "title": "systemd components",
      "level": 2,
      "content": "Some (not exhaustive) components of systemd are:\n\n- kernel-install — to automatically move kernels and their respective initramfs images to the boot partition;\n- systemd-analyze(1) — may be used to determine boot-up performance, statistics and retrieve other state and tracing information, and to verify the correctness of unit files. It is also used to access special functions useful for advanced debugging.\n- systemd-boot — simple UEFI boot manager;\n- systemd-creds — to securely store and retrieve credentials used by systemd units;\n- systemd-cryptenroll — Enroll PKCS#11, FIDO2, TPM2 token/devices to LUKS2 encrypted volumes;\n- systemd-firstboot — basic system setting initialization before first boot;\n- systemd-homed — portable human-user accounts;\n- systemd-logind(8) — session management;\n- systemd-networkd — network configuration management;\n- systemd-nspawn — light-weight namespace container;\n- systemd-repart — creates partition tables, adds or grows partitions;\n- systemd-resolved — network name resolution;\n- systemd-run(1) / run0(1) — Temporarily and interactively acquire elevated or different privileges.\n- systemd-stub(7) — a UEFI boot stub used for creating unified kernel images;\n- systemd-sysusers(8) — creates system users and groups and adds users to groups at package installation or boot time;\n- systemd-timesyncd — system time synchronization across the network;\n- systemd/Journal — system logging;\n- systemd/Timers — monotonic or realtime timers for controlling .service files or events, reasonable alternative to cron.\n\n"
    },
    {
      "title": "systemd.mount - mounting",
      "level": 3,
      "content": "systemd is in charge of mounting the partitions and filesystems specified in /etc/fstab. The systemd-fstab-generator(8) translates all the entries in /etc/fstab into systemd units; this is performed at boot time and whenever the configuration of the system manager is reloaded.\n\nsystemd extends the usual fstab capabilities and offers additional mount options. These affect the dependencies of the mount unit. They can, for example, ensure that a mount is performed only once the network is up or only once another partition is mounted. The full list of specific systemd mount options, typically prefixed with x-systemd., is detailed in systemd.mount(5) § FSTAB.\n\nAn example of these mount options is automounting, which means mounting only when the resource is required rather than automatically at boot time. This is provided in fstab#Automount with systemd.\n\n"
    },
    {
      "title": "GPT partition automounting",
      "level": 4,
      "content": "On UEFI-booted systems, GPT partitions such as root, home, swap, etc. can be mounted automatically following the Discoverable Partitions Specification. These partitions can thus be omitted from fstab, and if the root partition is automounted, then root= can be omitted from the kernel command line. See systemd-gpt-auto-generator(8).\n\nThe prerequisites are:\n\n- When using mkinitcpio, the systemd hook is required.\n- All automounted partitions must reside on the same physical disk as the ESP.\n- The correct GPT partition types must be set. See Partitioning#Partition scheme.\n- The boot loader must set the LoaderDevicePartUUID EFI variable, so that the used EFI system partition can be identified. This is supported by systemd-boot, systemd-stub(7), GRUB (with grub-mkconfig generated grub.cfg; custom grub.cfg requires loading the bli module) and rEFInd (not enabled by default). This can be verified by running bootctl and checking the status of Boot loader sets ESP information or the status of Stub sets ESP information when booting via Unified kernel images.\n\nudev will create a /dev/gpt-auto-root symlink that points to the root volume block device. If the root partition is encrypted with LUKS, /dev/gpt-auto-root will point to the unlocked/mapped volume and /dev/gpt-auto-root-luks to the encrypted partition.\n\nFor /var automounting to work, the PARTUUID must match the SHA256 HMAC hash of the partition type UUID keyed by the machine ID. The required PARTUUID can be obtained using:\n\n```\n$ systemd-id128 -u var-partition-uuid\n```\n\n"
    },
    {
      "title": "systemd-sysvcompat",
      "level": 3,
      "content": "The primary role of systemd-sysvcompat (required by base) is to provide the traditional linux init binary. For systemd-controlled systems, init is just a symbolic link to its systemd executable.\n\nIn addition, it provides four convenience shortcuts that SysVinit users might be used to. The convenience shortcuts are halt(8), poweroff(8), reboot(8) and shutdown(8). Each one of those four commands is a symbolic link to systemctl, and is governed by systemd behavior. Therefore, the discussion at #Power management applies.\n\nsystemd-based systems can give up those System V compatibility methods by using the init= boot parameter (see, for example, /bin/init is in systemd-sysvcompat ?) and systemd native systemctl command arguments.\n\n"
    },
    {
      "title": "systemd-tmpfiles - temporary files",
      "level": 3,
      "content": "systemd-tmpfiles creates, deletes and cleans up volatile and temporary files and directories. It reads configuration files in /etc/tmpfiles.d/ and /usr/lib/tmpfiles.d/ to discover which actions to perform. Configuration files in the former directory take precedence over those in the latter directory.\n\nConfiguration files are usually provided together with service files, and they are named in the style of /usr/lib/tmpfiles.d/program.conf. For example, the Samba daemon expects the directory /run/samba to exist and to have the correct permissions. Therefore, the samba package ships with this configuration:\n\n```\n/usr/lib/tmpfiles.d/samba.conf\n```\n\n```\nD /run/samba 0755 root root\n```\n\nConfiguration files may also be used to write values into certain files on boot. For example, if you used /etc/rc.local to disable wakeup from USB devices with echo USBE > /proc/acpi/wakeup, you may use the following tmpfile instead:\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Path                  Mode UID  GID  Age Argument\nw    /proc/acpi/wakeup     -    -    -    -   USBE\n```\n\nIt is possible to write multiple lines to the same file, either with \\n in the argument or using the w+ type on multiple lines (including the first one) for appending:\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Path                  Mode UID  GID  Age Argument\nw+   /proc/acpi/wakeup     -    -    -    -   USBE\nw+   /proc/acpi/wakeup     -    -    -    -   LID0\n```\n\nSee the systemd-tmpfiles(8) and tmpfiles.d(5) man pages for details.\n\n"
    },
    {
      "title": "Drop-in configuration files",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nConfiguration files provided by packages should not be directly edited to avoid conflicts with pacman updates. For this, many (but not all) systemd packages provide a way to modify the configuration, but without touching the original file by creation of drop-in snippets. Check the package manual to see if drop-in configuration files are supported.\n\nTo create a drop-in configuration file for the unit file /etc/systemd/unit.conf, create the directory /etc/systemd/unit.conf.d/ and place .conf files there to override or add new options. systemd will parse and apply these files on top of the original unit.\n\nCheck the overall configuration:\n\n```\n$ systemd-analyze cat-config systemd/unit.conf\n```\n\nThe applied drop-in snippets file(s) and content will be listed at the end. Restart the service for the changes to take effect.\n\n"
    },
    {
      "title": "Socket activation",
      "level": 3,
      "content": "Some packages provide a .socket unit. For example, cups provides a cups.socket unit[3]. If cups.socket is enabled (and cups.service is left disabled), systemd will not start CUPS immediately; it will just listen to the appropriate sockets. Then, whenever a program attempts to connect to one of these CUPS sockets, systemd will start cups.service and transparently hand over control of these ports to the CUPS process.\n\n"
    },
    {
      "title": "GUI configuration tools",
      "level": 3,
      "content": "- systemadm — Graphical browser for systemd units. It can show the list of units, possibly filtered by type.\n\n- SystemdGenie — systemd management utility based on KDE technologies.\n\n"
    },
    {
      "title": "Running services after the network is up",
      "level": 3,
      "content": "To delay a service until after the network is up, include the following dependencies in the .service file:\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target\n...\n```\n\nThe network wait service of the network manager in use must also be enabled so that network-online.target properly reflects the network status.\n\n- If using NetworkManager, NetworkManager-wait-online.service should be enabled together with NetworkManager.service. Check if this is the case with systemctl is-enabled NetworkManager-wait-online.service. If it is not enabled, then reenable NetworkManager.service.\n- In the case of netctl, enable the netctl-wait-online.service (unless you are using netctl-auto; see FS#75836).\n- If using systemd-networkd, systemd-networkd-wait-online.service should be enabled together with systemd-networkd.service. Check if this is the case with systemctl is-enabled systemd-networkd-wait-online.service. If it is not enabled, then reenable systemd-networkd.service.\n\nFor more detailed explanations, see the discussion in the Network configuration synchronization points.\n\nIf a service needs to perform DNS queries, it should additionally be ordered after nss-lookup.target:\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target nss-lookup.target\n...\n```\n\nSee systemd.special(7) § Special Passive System Units.\n\nFor nss-lookup.target to have any effect it needs a service that pulls it in via Wants=nss-lookup.target and orders itself before it with Before=nss-lookup.target. Typically this is done by local DNS resolvers.\n\nCheck which active service, if any, is pulling in nss-lookup.target with:\n\n```\n$ systemctl list-dependencies --reverse nss-lookup.target\n```\n\n"
    },
    {
      "title": "Enable installed units by default",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nArch Linux ships with /usr/lib/systemd/system-preset/99-default.preset containing disable *. This causes systemctl preset to disable all units by default, such that when a new package is installed, the user must manually enable the unit.\n\nIf this behavior is not desired, simply create a symlink from /etc/systemd/system-preset/99-default.preset to /dev/null in order to override the configuration file. This will cause systemctl preset to enable all units that get installed—regardless of unit type—unless specified in another file in one systemctl preset's configuration directories. User units are not affected. See systemd.preset(5) for more information.\n\n"
    },
    {
      "title": "Sandboxing application environments",
      "level": 3,
      "content": "See systemd/Sandboxing.\n\n"
    },
    {
      "title": "Notifying about failed services",
      "level": 3,
      "content": "In order to notify about service failures, an OnFailure= directive needs to be added to the according service file, for example by using a drop-in configuration file. Adding this directive to every service unit can be achieved with a top-level drop-in configuration file. For details about top-level drop-ins, see systemd.unit(5).\n\nCreate a top-level drop-in for services:\n\n```\n/etc/systemd/system/service.d/toplevel-override.conf\n```\n\n```\n[Unit]\nOnFailure=failure-notification@%n.service\n```\n\nThis adds OnFailure=failure-notification@%n.service to every service file. If some_service_unit fails, failure-notification@some_service_unit.service will be started to handle the notification delivery (or whatever task it is configured to perform).\n\nCreate the failure-notification@.service template unit:\n\n```\n/etc/systemd/system/failure-notification@.service\n```\n\n```\n[Unit]\nDescription=Send a notification about a failed systemd unit\n\n[Service]\nType=oneshot\nExecStart=/path/to/failure-notification.sh %i\n# runs as a temporary user/group and enables several other security precautions\nDynamicUser=true\n```\n\nYou can create the failure-notification.sh script and define what to do or how to notify. Examples include sending e-mail, showing desktop notifications, using gotify, XMPP, etc. The %i will be the name of the failed service unit and will be passed as an argument to the script.\n\nIn order to prevent a recursion for starting instances of failure-notification@.service again and again if the start fails, create an empty drop-in configuration file with the same name as the top-level drop-in (the empty service-level drop-in configuration file takes precedence over the top-level drop-in and overrides the latter one):\n\n```\n# mkdir -p /etc/systemd/system/failure-notification@.service.d\n# touch /etc/systemd/system/failure-notification@.service.d/toplevel-override.conf\n```\n\n"
    },
    {
      "title": "Notifying with e-mail",
      "level": 3,
      "content": "You can set up systemd to send an e-mail when a unit fails. Cron sends mail to MAILTO if the job outputs to stdout or stderr, but many jobs are setup to only output on error. First you need two files: an executable for sending the mail and a .service for starting the executable. For this example, the executable is just a shell script using sendmail, which is in packages that provide smtp-forwarder.\n\n```\n/usr/local/bin/systemd-email\n```\n\n```\n#!/bin/sh\n\n/usr/bin/sendmail -t <<ERRMAIL\nTo: $1\nFrom: systemd <root@$HOSTNAME>\nSubject: $2\nContent-Transfer-Encoding: 8bit\nContent-Type: text/plain; charset=UTF-8\n\n$(systemctl status --full \"$2\")\nERRMAIL\n```\n\nWhatever executable you use, it should probably take at least two arguments as this shell script does: the address to send to and the unit file to get the status of. The .service we create will pass these arguments:\n\n```\n/etc/systemd/system/status_email_user@.service\n```\n\n```\n[Unit]\nDescription=status email for %i to user\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/systemd-email address %i\nUser=nobody\nGroup=systemd-journal\n```\n\nWhere user is the user being emailed and address is that user's email address. Although the recipient is hard-coded, the unit file to report on is passed as an instance parameter, so this one service can send email for many other units. At this point you can start status_email_user@dbus.service to verify that you can receive the emails.\n\nThen simply edit the service you want emails for and add OnFailure=status_email_user@%n.service to the [Unit] section. %n passes the unit's name to the template.\n\n- If you set up sSMTP security according to sSMTP#Security the user nobody will not have access to /etc/ssmtp/ssmtp.conf, and the systemctl start status_email_user@dbus.service command will fail. One solution is to use root as the User in the status_email_user@.service unit.\n- If you try to use mail -s somelogs address in your email script, mail will fork and systemd will kill the mail process when it sees your script exit. Make the mail non-forking by doing mail -Ssendwait -s somelogs address.\n\n"
    },
    {
      "title": "Automatically turn off an external HDD at shutdown",
      "level": 3,
      "content": "See udisks#Automatically turn off an external HDD at shutdown.\n\n"
    },
    {
      "title": "Investigating failed services",
      "level": 3,
      "content": "To find the systemd services which failed to start:\n\n```\n$ systemctl --state=failed\n```\n\nTo find out why they failed, examine their log output. See systemd/Journal#Filtering output for details.\n\n"
    },
    {
      "title": "Diagnosing boot problems",
      "level": 3,
      "content": "systemd has several options for diagnosing problems with the boot process. See boot debugging for more general instructions and options to capture boot messages before systemd takes over the boot process. Also see systemd debugging documentation.\n\n"
    },
    {
      "title": "Diagnosing a service",
      "level": 3,
      "content": "If some systemd service misbehaves or you want to get more information about what is happening, set the SYSTEMD_LOG_LEVEL environment variable to debug. For example, to run the systemd-networkd daemon in debug mode:\n\nAdd a drop-in file for the service adding the two lines:\n\n```\n[Service]\nEnvironment=SYSTEMD_LOG_LEVEL=debug\n```\n\nOr equivalently, set the environment variable manually:\n\n```\n# SYSTEMD_LOG_LEVEL=debug /lib/systemd/systemd-networkd\n```\n\nthen restart systemd-networkd and watch the journal for the service with the -f/--follow option.\n\n"
    },
    {
      "title": "Shutdown/reboot takes terribly long",
      "level": 3,
      "content": "If the shutdown process takes a very long time (or seems to freeze), most likely a service not exiting is to blame. systemd waits some time for each service to exit before trying to kill it. To find out whether you are affected, see Shutdown completes eventually in the systemd documentation.\n\nA common problem is a stalled shutdown or suspend process. To verify whether that is the case, you could run either of these commands and check the outputs\n\n```\n# systemctl poweroff\n```\n\n```\nFailed to power off system via logind: There's already a shutdown or sleep operation in progress\n```\n\n```\n# systemctl list-jobs\n```\n\n```\nJOB UNIT                    TYPE  STATE  \n...\n21593 systemd-suspend.service start running\n21592 suspend.target          start waiting\n..\n```\n\nThe solution to this would be to cancel these jobs by running\n\n```\n# systemctl cancel\n# systemctl stop systemd-suspend.service\n```\n\nand then trying shutdown or reboot again.\n\n"
    },
    {
      "title": "Short lived processes do not seem to log any output",
      "level": 3,
      "content": "If running journalctl -u foounit as root does not show any output for a short lived service, look at the PID instead. For example, if systemd-modules-load.service fails, and systemctl status systemd-modules-load shows that it ran as PID 123, then you might be able to see output in the journal for that PID, i.e. by running journalctl -b _PID=123 as root. Metadata fields for the journal such as _SYSTEMD_UNIT and _COMM are collected asynchronously and rely on the /proc directory for the process existing. Fixing this requires fixing the kernel to provide this data via a socket connection, similar to SCM_CREDENTIALS. In short, it is a bug. Keep in mind that immediately failed services might not print anything to the journal as per design of systemd.\n\n"
    },
    {
      "title": "Boot time increasing over time",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nAfter using systemd-analyze a number of users have noticed that their boot time has increased significantly in comparison with what it used to be. After using systemd-analyze blame NetworkManager is being reported as taking an unusually large amount of time to start.\n\nThe problem for some users has been due to /var/log/journal becoming too large. This may have other impacts on performance, such as for systemctl status or journalctl. As such the solution is to remove every file within the folder (ideally making a backup of it somewhere, at least temporarily) and then setting a journal file size limit as described in Systemd/Journal#Journal size limit.\n\n"
    },
    {
      "title": "systemd-tmpfiles-setup.service fails to start at boot",
      "level": 3,
      "content": "Starting with systemd 219, /usr/lib/tmpfiles.d/systemd.conf specifies ACL attributes for directories under /var/log/journal and, therefore, requires ACL support to be enabled for the filesystem the journal resides on.\n\nSee Access Control Lists#Enable ACL for instructions on how to enable ACL on the filesystem that houses /var/log/journal.\n\n"
    },
    {
      "title": "Disable emergency mode on remote machine",
      "level": 3,
      "content": "You may want to disable emergency mode on a remote machine, for example, a virtual machine hosted at Azure or Google Cloud. It is because if emergency mode is triggered, the machine will be blocked from connecting to network.\n\nTo disable it, mask emergency.service and emergency.target.\n\n"
    },
    {
      "title": "Error \"Unit xxx.service not found\", but service does exist",
      "level": 3,
      "content": "You may be trying to start or enable a user unit as a system unit. systemd.unit(5) indicates, which units reside where. By default systemctl operates on system services.\n\nSee Systemd/User for more details.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Wikipedia:systemd\n- Official web site systemd optimizations systemd FAQ systemd Tips and tricks\n- systemd(1)\n- Other distributions Gentoo:Systemd Fedora:Systemd Fedora:How to debug Systemd problems Fedora:SysVinit to Systemd Cheatsheet Debian:systemd\n- Lennart's blog story, update 1, update 2, update 3, summary\n- Debug Systemd Services\n- systemd for Administrators (PDF)\n- How To Use Systemctl to Manage Systemd Services and Units\n- Session management with systemd-logind\n- Emacs Syntax highlighting for Systemd files\n- Two part introductory article in The H Open magazine.\n\n- systemd optimizations\n- systemd FAQ\n- systemd Tips and tricks\n\n- Gentoo:Systemd\n- Fedora:Systemd\n- Fedora:How to debug Systemd problems\n- Fedora:SysVinit to Systemd Cheatsheet\n- Debian:systemd\n\n"
    }
  ]
}