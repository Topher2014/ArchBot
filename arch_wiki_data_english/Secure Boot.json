{
  "title": "Secure Boot",
  "url": "https://wiki.archlinux.org/title/Secure_Boot",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Arch boot process\n- Unified Extensible Firmware Interface\n- Security\n\nSecure Boot is a security feature found in the UEFI standard, designed to add a layer of protection to the pre-boot process: by maintaining a cryptographically signed list of binaries authorized or forbidden to run at boot, it helps in improving the confidence that the machine core boot components (boot manager, kernel, initramfs) have not been tampered with.\n\nAs such it can be seen as a continuation or complement to the efforts in securing one's computing environment, reducing the attack surface that other software security solutions such as system encryption cannot easily cover, while being totally distinct and not dependent on them. Secure Boot just stands on its own as a component of current security practices, with its own set of pros and cons.\n\n"
    },
    {
      "title": "Before booting the OS",
      "level": 3,
      "content": "At this point, one has to look at the firmware setup. If the machine was booted and is running, in most cases it will have to be rebooted.\n\nYou may access the firmware configuration by pressing a special key during the boot process. The key to use depends on the firmware. It is usually one of Esc, F2, Del or possibly another Fn key. Sometimes the right key is displayed for a short while at the beginning of the boot process. The motherboard manual usually records it. You might want to press the key, and keep pressing it, immediately following powering on the machine, even before the screen actually displays anything.\n\nAfter entering the firmware setup, be careful not to change any settings without prior intention. Usually there are navigation instructions, and short help for the settings, at the bottom of each setup screen. The setup itself might be composed of several pages. You will have to navigate to the correct place. The interesting setting might be simply denoted by secure boot, which can be set on or off.\n\n"
    },
    {
      "title": "After booting the OS",
      "level": 3,
      "content": "An easy way to check Secure Boot status on systems using systemd is to use systemd-boot:\n\n```\n$ bootctl\n```\n\n```\nSystem:\n      Firmware: UEFI 2.80 (American Megatrends 5.26)\n Firmware Arch: x64\n   Secure Boot: enabled (user)\n  TPM2 Support: yes\n  Measured UKI: yes\n  Boot into FW: supported\n...\n```\n\nHere we see that Secure Boot is enabled and enforced (in user mode); other values are disabled (setup) for Setup Mode, disabled (disabled) if Secure Boot is disabled and disabled (unsupported) if the firmware does not feature Secure Boot.\n\nAnother way to check whether the machine was booted with Secure Boot is to use this command:\n\n```\n$ od --address-radix=n --format=u1 /sys/firmware/efi/efivars/SecureBoot-8be4df61-93ca-11d2-aa0d-00e098032b8c\n```\n\nIf Secure Boot is enabled, this command returns 1 as the final integer in a list of five, for example:\n\n```\n6  0  0  0  1\n```\n\nNote, however, that the kernel may be unaware of Secure Boot (even if it is enabled in the firmware) if an insufficiently capable boot loader is used. This can be verified by checking the kernel messages shortly after the system starts up:\n\n```\n# dmesg | grep -i secure\n```\n\n```\n[    0.013442] Secure boot disabled\n[    0.013442] Secure boot could not be determined\n```\n\nThe kernel messages will otherwise read Secure boot enabled.\n\n"
    },
    {
      "title": "Booting an installation medium",
      "level": 2,
      "content": "The official installation image does not support Secure Boot (FS#53864). Secure Boot support was initially added in archlinux-2013.07.01-dual.iso and later removed in archlinux-2016.06.01-dual.iso. At that time prebootloader was replaced with efitools, even though the latter uses unsigned EFI binaries. There has been no support for Secure Boot in the official installation medium ever since.\n\nIn order to boot an installation medium in a Secure Boot system, you will need to either disable Secure Boot or modify the image in order to add a signed boot loader.\n\nArchboot images provide a way to use secure boot on installation media.\n\n"
    },
    {
      "title": "Disabling Secure Boot",
      "level": 3,
      "content": "The Secure Boot feature can be disabled via the UEFI firmware interface. How to access the firmware configuration is described in #Before booting the OS.\n\nIf using a hotkey did not work and you can boot Windows, you can force a reboot into the firmware configuration in the following way (for Windows 10): Settings > Update & Security > Recovery > Advanced startup (Restart now) > Troubleshoot > Advanced options > UEFI Firmware settings > restart.\n\nNote that some motherboards (this is the case in a Packard Bell laptop and recent Xiaomi laptops) only allow to disable secure boot if you have set an administrator password (that can be removed afterwards). See also Rod Smith's Disabling Secure Boot.\n\n"
    },
    {
      "title": "Repacking the installation image",
      "level": 3,
      "content": "See #ISO repacking.\n\n"
    },
    {
      "title": "Editing the installation medium",
      "level": 3,
      "content": "If you are using a USB flash installation medium, then it is possible to manually edit the EFI system partition on the medium to add support for Secure Boot.\n\nPlug in the USB drive, then mount the partition:\n\n```\n# mount /dev/disk/by-label/ARCHISO_EFI /mnt\n```\n\nThen follow the instructions in #Using a signed boot loader to install any signed boot loader. For example, to install #PreLoader:\n\n```\n# mv /mnt/EFI/BOOT/BOOTx64.EFI /mnt/EFI/BOOT/loader.efi\n# cp /usr/share/preloader-signed/PreLoader.efi /mnt/EFI/BOOT/BOOTx64.EFI\n# cp /usr/share/preloader-signed/HashTool.efi /mnt/EFI/BOOT/HashTool.efi\n```\n\n"
    },
    {
      "title": "Implementing Secure Boot",
      "level": 2,
      "content": "There are certain conditions making for an ideal setup of Secure boot:\n\n1. UEFI considered mostly trusted (despite having some well known criticisms and vulnerabilities[1]) and necessarily protected by a strong password\n1. Default manufacturer/third party keys are not in use, as they have been shown to weaken the security model of Secure Boot by a great margin[2]\n1. UEFI directly loads a user-signed EFI boot stub-compatible unified kernel image (no boot manager), including microcode (if applicable) and initramfs so as to maintain throughout the boot process the chain of trust established by Secure Boot and reduce the attack surface\n1. Use of full drive encryption, so that the tools and files involved in the kernel image creation and signing process cannot be accessed and tampered with by someone having physical access to the machine.\n1. Some further improvements may be obtained by using a TPM.\n\nA simple and fully self-reliant setup is described in #Using your own keys, while #Using a signed boot loader makes use of intermediate tools signed by a third-party.\n\nUsing the GRUB bootloader requires extra steps before enabling secure boot, see GRUB#Secure Boot support for details.\n\n"
    },
    {
      "title": "Using your own keys",
      "level": 3,
      "content": "Secure Boot implementations use these keys:\n\nSee The Meaning of all the UEFI Keys for a more detailed explanation.\n\nTo use Secure Boot you need at least PK, KEK and db keys. While you can add multiple KEK, db and dbx certificates, only one Platform Key is allowed.\n\nOnce Secure Boot is in \"User Mode\" keys can only be updated by signing the update (using sign-efi-sig-list) with a higher level key. Platform key can be signed by itself.\n\n"
    },
    {
      "title": "Backing up current variables",
      "level": 4,
      "content": "Before creating new keys and modifying EFI variables, it is advisable to backup the current variables, so that they may be restored in case of error.\n\nInstall the efitools package, then run the following commands to backup all four of the principal Secure Boot variables:\n\n```\n$ for var in PK KEK db dbx ; do efi-readvar -v $var -o old_${var}.esl ; done\n```\n\nIf you perform this command on a new computer or motherboard, the variables you extract will most likely be the ones provided by Microsoft.\n\n"
    },
    {
      "title": "Putting firmware in \"Setup Mode\"",
      "level": 4,
      "content": "Secure Boot is in Setup Mode when the Platform Key is removed. To put firmware in Setup Mode, enter firmware setup utility and find an option to delete or clear certificates. How to enter the setup utility is described in #Before booting the OS.\n\n"
    },
    {
      "title": "Assisted process with systemd",
      "level": 4,
      "content": "As of v257, you can easily set up Secure Boot with systemd and systemd-boot. Install systemd-ukify and sbsigntools.\n\nFirst generate your signing keys with e.g.:\n\n```\n# ukify genkey \\\n--secureboot-private-key /etc/kernel/secure-boot-private-key.pem \\\n--secureboot-certificate /etc/kernel/secure-boot-certificate.pem\n```\n\nNext, configure the ESP for auto-enrollment:\n\n```\n# bootctl install --secure-boot-auto-enroll yes \\\n--certificate /etc/kernel/secure-boot-certificate.pem \\\n--private-key /etc/kernel/secure-boot-private-key.pem\n```\n\nThis will create the three files PK.auth, KEK.auth and db.auth in /boot/loader/keys/auto/. Note that this command also installs (or updates) the systemd-boot bootloader to the ESP.\n\nFinally, set secure-boot-enroll=force in /boot/loader.conf. See loader.conf(5).\n\n"
    },
    {
      "title": "Assisted process with sbctl",
      "level": 4,
      "content": "sbctl is a user-friendly way of setting up secure boot and signing files.\n\nTo use it, install sbctl. See also the upstream README and sbctl(8).\n\nBefore starting, go to your firmware settings and set secure boot mode to Setup mode. This is different for each device: see sbctl(8) § USAGE.\n\nOnce you log back in, check the secure boot status:\n\n```\n$ sbctl status\n```\n\nYou should see that sbctl is not installed and secure boot is disabled.\n\nThen create your custom secure boot keys:\n\n```\n# sbctl create-keys\n```\n\nEnroll your keys, with Microsoft's keys, to the UEFI:\n\n```\n# sbctl enroll-keys -m\n```\n\nCheck the secure boot status again:\n\n```\n$ sbctl status\n```\n\nsbctl should be installed now, but secure boot will not work until the boot files have been signed with the keys you just created.\n\nCheck what files need to be signed for secure boot to work:\n\n```\n# sbctl verify\n```\n\nNow sign all the unsigned files. Usually the kernel and the boot loader need to be signed. For example:\n\n```\n# sbctl sign -s /boot/vmlinuz-linux\n# sbctl sign -s /boot/EFI/BOOT/BOOTX64.EFI\n```\n\nThe files that need to be signed will depend on your system's layout, kernel and boot loader.\n\nNote: This example assumes that the outputted file paths are relative to /boot. Alternatively, you can use:\n\n```\n# sbctl verify | sed 's/✗ /sbctl sign -s /e'\n```\n\nThis example assumes that the outputted file paths are relative to /boot. Alternatively, you can use:\n\n```\n# sbctl verify | sed -E 's|^.* (/.+) is not signed$|sbctl sign -s \"\\1\"|e'\n```\n\nThis is agnostic of the filepath, and doesn't need the '✗' character.\n\nNow you are done! Reboot your system and turn secure boot back on in the firmware settings. If the boot loader and OS load, secure boot should be working. Check with:\n\n```\n$ sbctl status\n```\n\nsbctl comes with a pacman hook that automatically signs all new files whenever the Linux kernel, systemd or the boot loader is updated.\n\n```\n# sbctl sign -s -o /usr/lib/systemd/boot/efi/systemd-bootx64.efi.signed /usr/lib/systemd/boot/efi/systemd-bootx64.efi\n```\n\n"
    },
    {
      "title": "Manual process",
      "level": 4,
      "content": "Nearly all of the following sections require you to install the efitools package.\n\nTo generate keys, perform the following steps.\n\nYou will need private keys and certificates in multiple formats:\n\nCreate a GUID for owner identification:\n\n```\n$ uuidgen --random > GUID.txt\n```\n\nPlatform key:\n\n```\n$ openssl req -newkey rsa:4096 -nodes -keyout PK.key -new -x509 -sha256 -days 3650 -subj \"/CN=my Platform Key/\" -out PK.crt\n$ openssl x509 -outform DER -in PK.crt -out PK.cer\n$ cert-to-efi-sig-list -g \"$(< GUID.txt)\" PK.crt PK.esl\n$ sign-efi-sig-list -g \"$(< GUID.txt)\" -k PK.key -c PK.crt PK PK.esl PK.auth\n```\n\nSign an empty file to allow removing Platform Key when in \"User Mode\":\n\n```\n$ sign-efi-sig-list -g \"$(< GUID.txt)\" -c PK.crt -k PK.key PK /dev/null noPK.auth\n```\n\nKey Exchange Key:\n\n```\n$ openssl req -newkey rsa:4096 -nodes -keyout KEK.key -new -x509 -sha256 -days 3650 -subj \"/CN=my Key Exchange Key/\" -out KEK.crt\n$ openssl x509 -outform DER -in KEK.crt -out KEK.cer\n$ cert-to-efi-sig-list -g \"$(< GUID.txt)\" KEK.crt KEK.esl\n$ sign-efi-sig-list -g \"$(< GUID.txt)\" -k PK.key -c PK.crt KEK KEK.esl KEK.auth\n```\n\nSignature Database key:\n\n```\n$ openssl req -newkey rsa:4096 -nodes -keyout db.key -new -x509 -sha256 -days 3650 -subj \"/CN=my Signature Database key/\" -out db.crt\n$ openssl x509 -outform DER -in db.crt -out db.cer\n$ cert-to-efi-sig-list -g \"$(< GUID.txt)\" db.crt db.esl\n$ sign-efi-sig-list -g \"$(< GUID.txt)\" -k KEK.key -c KEK.crt db db.esl db.auth\n```\n\nA helper/convenience script is offered by the author of the reference page on this topic[3] (requires python). A mildly edited version is also packaged as sbkeysAUR.\n\nIn order to use it, simply create a folder in a secure location (e.g. /etc/efi-keys/ if later use of sbupdate-gitAUR to automate unified kernel image creation and signing is planned) and run it:\n\n```\n# mkdir /etc/efi-keys\n# cd !$\n# curl -L -O https://www.rodsbooks.com/efi-bootloaders/mkkeys.sh\n# chmod +x mkkeys.sh\n# ./mkkeys.sh\nEnter a Common Name to embed in the keys, e.g. \"Secure Boot\"\n```\n\nThis will produce the required files in different formats.\n\nUse one of the following methods to enroll db, KEK and PK certificates.\n\nNote: **dbx** \n\nInstall sbsigntools. Create a directory /etc/secureboot/keys with the following directory structure -\n\n```\n/etc/secureboot/keys\n├── db\n├── dbx\n├── KEK\n└── PK\n```\n\nFor example using:\n\n```\n# mkdir -p /etc/secureboot/keys/{db,dbx,KEK,PK}\n```\n\nThen copy each of the .auth files that were generated earlier into their respective locations (for example, PK.auth into /etc/secureboot/keys/PK and so on).\n\nIf you want to verify the changes sbkeysync will make to the system's UEFI keystore, use:\n\n```\n# sbkeysync --keystore /etc/secureboot/keys --pk --dry-run --verbose\n```\n\nFinally, use sbkeysync to enroll your keys.\n\n```\n# sbkeysync --keystore /etc/secureboot/keys --verbose\n# sbkeysync --keystore /etc/secureboot/keys --verbose --pk\n```\n\nNote: On Lenovo systems:\n\n- If sbkeysync returns write errors, first run chattr -i /sys/firmware/efi/efivars/{PK,KEK,db}* prior to issuing commands with sbkeysync to temporarily change file attributes, enabling writing of the EFI keys within the efivars directory. See chattr(1).\n- If you get a permission denied error for PK.auth, you can enroll it with command efi-updatevar -f /etc/secureboot/keys/PK/PK.auth PK.\n- If this fails, it might be due to the firmware locking BIOS settings. On Dell & Lenovo systems, you may need to reset the BIOS password: Sysfs Firmware Authentication Documentation\n\nOn Lenovo systems:\n\n```\n# cat > /sys/class/firmware-attributes/thinklmi/authentication/Admin/current_password \nmy-super-secret-password\n^D\n```\n\nOn Dell systems:\n\n```\n# cat > /sys/class/firmware-attributes/dell-wmi-sysman/authentication/Admin/current_password \nmy-super-secret-password\n^D\n```\n\nOn next boot the UEFI should be back in User Mode and enforcing Secure Boot policy.\n\nCopy all *.cer, *.esl, *.auth files (except the noPK.auth file!) to a FAT formatted file system (you can use EFI system partition).\n\nNote: **Do not** The EFI system partition of your PC must not be encrypted according to the UEFI specifications and can be mounted and read on another PC (if your PC is stolen and if the hard drive is taken out and connected to another PC). Copying the noPK.auth file to the ESP of your PC and deleting it afterwards is also not advisable, because deleted files on the FAT32 EFI system partition can be recovered with tools like PhotoRec.\n\n- an external USB stick with an EFI system partition when using KeyTool. Unfortunately, KeyTool can only read files from unencrypted storage.\n- encrypted storage on your PC when using sbkeysync.\n\nThe EFI system partition of your PC must not be encrypted according to the UEFI specifications and can be mounted and read on another PC (if your PC is stolen and if the hard drive is taken out and connected to another PC). Copying the noPK.auth file to the ESP of your PC and deleting it afterwards is also not advisable, because deleted files on the FAT32 EFI system partition can be recovered with tools like PhotoRec.\n\nLaunch firmware setup utility and enroll db, KEK and PK certificates. Firmwares have various different interfaces, see Replacing Keys Using Your Firmware's Setup Utility for example how to enroll keys.\n\nIf the used tool supports it prefer using .auth and .esl over .cer.\n\nKeyTool.efi is in efitools package, copy it to ESP. To use it after enrolling keys, sign it with sbsign.\n\n```\n# sbsign --key db.key --cert db.crt --output esp/KeyTool-signed.efi /usr/share/efitools/efi/KeyTool.efi\n```\n\nLaunch KeyTool-signed.efi using firmware setup utility, boot loader or UEFI Shell and enroll keys.\n\nSee Replacing Keys Using KeyTool for explanation of KeyTool menu options.\n\nSince systemd version 252, systemd-boot can be used to enroll keys. To enroll keys, copy the db.auth, KEK.auth and PK.auth to the special folder on the ESP:\n\n```\n# cp db.auth KEK.auth PK.auth esp/loader/keys/NAME/\n```\n\nWhere NAME can be any unique name you assign, such as MYKEYS.\n\nAfter copying the keys and enabling the secure boot setup mode a new entry would appear in the boot menu that would read Enroll Secure Boot keys: MYKEYS. Activating this entry would enroll the secure boot keys.\n\nWhen Secure Boot is active (i.e. in \"User Mode\"), only signed EFI binaries (e.g. applications, drivers, unified kernel images) can be launched.\n\nInstall sbsigntools to sign EFI binaries with sbsign(1).\n\n- To check if a binary is signed and list its signatures use sbverify --list /path/to/binary.\n- The rEFInd boot manager's refind-install script can sign rEFInd EFI binaries and copy them together with the db certificates to the ESP. See rEFInd#Using your own keys for instructions.\n\nTo sign your kernel and boot manager use sbsign, e.g.:\n\n```\n# sbsign --key db.key --cert db.crt --output /boot/vmlinuz-linux /boot/vmlinuz-linux\n# sbsign --key db.key --cert db.crt --output esp/EFI/BOOT/BOOTx64.EFI esp/EFI/BOOT/BOOTx64.EFI\n```\n\nYou can also use a mkinitcpio post hook to sign the kernel when the initramfs gets generated.\n\nCreate the following file an make it executable:\n\n```\n/etc/initcpio/post/kernel-sbsign\n```\n\n```\n#!/usr/bin/env bash\n\nkernel=\"$1\"\n[[ -n \"$kernel\" ]] || exit 0\n\n# use already installed kernel if it exists\n[[ ! -f \"$KERNELDESTINATION\" ]] || kernel=\"$KERNELDESTINATION\"\n\nkeypairs=(/path/to/db.key /path/to/db.crt)\n\nfor (( i=0; i<${#keypairs[@]}; i+=2 )); do\n    key=\"${keypairs[$i]}\" cert=\"${keypairs[(( i + 1 ))]}\"\n    if ! sbverify --cert \"$cert\" \"$kernel\" &>/dev/null; then\n        sbsign --key \"$key\" --cert \"$cert\" --output \"$kernel\" \"$kernel\"\n    fi\ndone\n```\n\nReplace /path/to/db.key and /path/to/db.crt with the paths to the key pair you want to use for signing the kernel.\n\nIf you are using systemd-boot, there is a dedicated pacman hook doing this task semi-automatically.\n\nSee Unified kernel image#Signing the UKIs for Secure Boot.\n\nNote: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nsbupdate is a tool made specifically to automate unified kernel image generation and signing on Arch Linux. It handles installation, removal and updates of kernels through pacman hooks.\n\nInstall sbupdate-gitAUR and configure it following the instructions given on the project's homepage.[4]\n\nOnce configured, simply run sbupdate as root for first-time image generation.\n\n"
    },
    {
      "title": "Updating keys",
      "level": 4,
      "content": "Once Secure Boot is in \"User Mode\" any changes to KEK, db and dbx need to be signed with a higher level key.\n\nFor example, if you wanted to replace your db key with a new one:\n\n1. Create the new key,\n1. Convert it to EFI Signature List,\n1. Sign the EFI Signature List,\n1. Enroll the signed certificate update file.\n\n```\n$ cert-to-efi-sig-list -g \"$(< GUID.txt)\" new_db.crt new_db.esl\n$ sign-efi-sig-list -g \"$(< GUID.txt)\" -k KEK.key -c KEK.crt db new_db.esl new_db.auth\n```\n\nIf instead of replacing your db key, you want to add another one to the Signature Database, you need to use the option -a (see sign-efi-sig-list(1)):\n\n```\n$ sign-efi-sig-list -a -g \"$(< GUID.txt)\" -k KEK.key -c KEK.crt db new_db.esl new_db.auth\n```\n\nWhen new_db.auth is created, enroll it.\n\n"
    },
    {
      "title": "Dual booting with other operating systems",
      "level": 4,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nIt is usually not possible to boot Windows by signing its bootloader (EFI/Microsoft/Boot/bootmgfw.efi) with a custom, personal key with Secure Boot Mode enabled, without enrolling the \"Microsoft Windows Production PCA 2011\" key in the UEFI Secure Boot variables:\n\n- if bootmgfw.efi contains a signature both from the \"Microsoft Windows Production PCA 2011\" and from your own Secure Boot db key (so two signatures), then UEFI firmware implementations like INSYDE Corp. 4096.01 (UEFI Version 2.31, Version F.70, Release Date: 07/18/2016, BIOS Revision 15.112, Firmware Revision: 29.66) will not launch bootmgfw.efi and will throw a security violation error (Selected boot image did not authenticate. Press ENTER to continue.): UEFI firmware implementation like this can probably only read the first signature - not the second one. Only the certificate for the second signature is enrolled in the UEFI Secure Boot variables, so the Secure Boot verification fails.\n- if the \"Microsoft Windows Production PCA 2011\" signature from the bootmgfw.efi file is stripped/removed, and only a signature from your own Secure Boot db key is added to the file, then UEFI will launch the file - but Windows will launch a recovery/repair environment: Windows complains that the Windows installation is broken (because the \"Microsoft Windows Production PCA 2011\" signature on bootmgfw.efi file is missing).\n\nSo to dual boot with Windows,\n\n- you either have to add the hash of bootmgfw.efi to the list of allowed hashes in the db variable; and you have to update the db variable every time a Windows Update changes bootmgfw.efi. This is very tedious, error-prone and not supported by Microsoft; and for example BitLocker will not work properly anymore with this setup (BitLocker will ask for your recovery password every time to decrypt your Windows partition).\n- or you have to add Microsoft's certificates to the UEFI Secure Boot variables Microsoft has four db certificates and two KEK certificates: The Microsoft Windows Production PCA 2011 certificate and Windows UEFI CA 2023 must be included in the db variable in order to allow the Windows Operating System to load. The Microsoft Corporation UEFI CA 2011 certificate and Microsoft UEFI CA 2023 aka the Microsoft 3rd Party UEFI CA certificates should be included in the db variable in order to use third-party binaries like UEFI drivers, option ROMs, shim, etc. The Microsoft Corporation KEK CA 2011 certificate and Microsoft Corporation KEK 2K CA 2023 should be included in the KEK variable, in order to \"enable revocation of bad images by updating the dbx and potentially for updating db to prepare for newer Windows signed images\". However, Windows will also boot without them.\n\n- The Microsoft Windows Production PCA 2011 certificate and Windows UEFI CA 2023 must be included in the db variable in order to allow the Windows Operating System to load.\n- The Microsoft Corporation UEFI CA 2011 certificate and Microsoft UEFI CA 2023 aka the Microsoft 3rd Party UEFI CA certificates should be included in the db variable in order to use third-party binaries like UEFI drivers, option ROMs, shim, etc.\n- The Microsoft Corporation KEK CA 2011 certificate and Microsoft Corporation KEK 2K CA 2023 should be included in the KEK variable, in order to \"enable revocation of bad images by updating the dbx and potentially for updating db to prepare for newer Windows signed images\". However, Windows will also boot without them.\n\nCreate EFI Signature Lists from Microsoft's DER format db certificates using Microsoft's GUID (77fa9abd-0359-4d32-bd60-28f4e78f784b) and combine them in one file for simplicity:\n\n```\n$ sbsiglist --owner 77fa9abd-0359-4d32-bd60-28f4e78f784b --type x509 --output MS_Win_db_2011.esl MicWinProPCA2011_2011-10-19.crt\n$ sbsiglist --owner 77fa9abd-0359-4d32-bd60-28f4e78f784b --type x509 --output MS_Win_db_2023.esl 'windows uefi ca 2023.crt'\n$ sbsiglist --owner 77fa9abd-0359-4d32-bd60-28f4e78f784b --type x509 --output MS_UEFI_db_2011.esl MicCorUEFCA2011_2011-06-27.crt\n$ sbsiglist --owner 77fa9abd-0359-4d32-bd60-28f4e78f784b --type x509 --output MS_UEFI_db_2023.esl 'microsoft uefi ca 2023.crt'\n$ cat MS_Win_db_2011.esl MS_Win_db_2023.esl MS_UEFI_db_2011.esl MS_UEFI_db_2023.esl > MS_db.esl\n```\n\nOptional (for strict conformity with Microsoft UEFI Secure Boot requirements): Create an EFI Signature List from Microsoft's DER format KEK certificates using Microsoft's GUID (77fa9abd-0359-4d32-bd60-28f4e78f784b):\n\n```\n$ sbsiglist --owner 77fa9abd-0359-4d32-bd60-28f4e78f784b --type x509 --output MS_Win_KEK_2011.esl MicCorKEKCA2011_2011-06-24.crt\n$ sbsiglist --owner 77fa9abd-0359-4d32-bd60-28f4e78f784b --type x509 --output MS_Win_KEK_2023.esl 'microsoft corporation kek 2k ca 2023.crt'\n$ cat MS_Win_KEK_2011.esl MS_Win_KEK_2023.esl > MS_Win_KEK.esl\n```\n\nSign a db variable update with your KEK. Use sign-efi-sig-list with option -a to add not replace a db certificate:\n\n```\n$ sign-efi-sig-list -a -g 77fa9abd-0359-4d32-bd60-28f4e78f784b -k KEK.key -c KEK.crt db MS_db.esl add_MS_db.auth\n```\n\nOptional (for strict conformity with Microsoft UEFI Secure Boot requirements): Sign a KEK variable update with your PK. Use sign-efi-sig-list with option -a to add not replace a KEK certificate:\n\n```\n$ sign-efi-sig-list -a -g 77fa9abd-0359-4d32-bd60-28f4e78f784b -k PK.key -c PK.crt KEK MS_Win_KEK.esl add_MS_Win_KEK.auth\n```\n\nFollow #Enrolling keys in firmware to enroll add_MS_db.auth and for strict conformity with Microsoft UEFI Secure Boot requirements add_MS_Win_KEK.auth into the UEFI Secure Boot Database variables.\n\n"
    },
    {
      "title": "Using a signed boot loader",
      "level": 3,
      "content": "Using a signed boot loader means using a boot loader signed with Microsoft's key. There are two known signed boot loaders: PreLoader and shim. Their purpose is to chainload other EFI binaries (usually boot loaders). Since Microsoft would never sign a boot loader that automatically launches any unsigned binary, PreLoader and shim use an allowlist called Machine Owner Key list, abbreviated MokList. If the SHA256 hash of the binary (Preloader and shim) or key the binary is signed with (shim) is in the MokList they execute it, if not they launch a key management utility which allows enrolling the hash or key.\n\nNote: The enrollment of the Microsoft 3rd Party UEFI CA certificate needs to be enabled in firmware settings to launch EFI binaries and OpROMs signed with this certificate.\n\nThe enrollment of the Microsoft 3rd Party UEFI CA certificate needs to be enabled in firmware settings to launch EFI binaries and OpROMs signed with this certificate.\n\n"
    },
    {
      "title": "PreLoader",
      "level": 4,
      "content": "When run, PreLoader tries to launch loader.efi. If the hash of loader.efi is not in MokList, PreLoader will launch HashTool.efi. In HashTool you must enroll the hash of the EFI binaries you want to launch, that means your boot loader (loader.efi) and kernel.\n\nInstall preloader-signedAUR and copy PreLoader.efi and HashTool.efi to the boot loader directory; for systemd-boot use:\n\n```\n# cp /usr/share/preloader-signed/{PreLoader,HashTool}.efi esp/EFI/systemd\n```\n\nNow copy over the boot loader binary and rename it to loader.efi; for systemd-boot use:\n\n```\n# cp esp/EFI/systemd/systemd-bootx64.efi esp/EFI/systemd/loader.efi\n```\n\nFinally, create a new NVRAM entry to boot PreLoader.efi:\n\n```\n# efibootmgr --unicode --disk /dev/sdX --part Y --create --label \"PreLoader\" --loader /EFI/systemd/PreLoader.efi\n```\n\nReplace X with the drive letter and replace Y with the partition number of the EFI system partition.\n\nThis entry should be added to the list as the first to boot; check with the efibootmgr command and adjust the boot-order if necessary.\n\nIf there are problems booting the custom NVRAM entry, copy HashTool.efi and loader.efi to the default loader location booted automatically by UEFI systems:\n\n```\n# cp /usr/share/preloader-signed/HashTool.efi esp/EFI/BOOT/\n# cp esp/EFI/systemd/systemd-bootx64.efi esp/EFI/BOOT/loader.efi\n```\n\nCopy over PreLoader.efi and rename it:\n\n```\n# cp /usr/share/preloader-signed/PreLoader.efi esp/EFI/BOOT/BOOTx64.EFI\n```\n\nFor particularly intransigent UEFI implementations, copy PreLoader.efi to the default loader location used by Windows systems:\n\n```\n# mkdir -p esp/EFI/Microsoft/Boot\n# cp /usr/share/preloader-signed/PreLoader.efi esp/EFI/Microsoft/Boot/bootmgfw.efi\n```\n\nAs before, copy HashTool.efi and loader.efi to esp/EFI/Microsoft/Boot/.\n\nWhen the system starts with Secure Boot enabled, follow the steps above to enroll loader.efi and /vmlinuz-linux (or whichever kernel image is being used).\n\nA message will show up that says Failed to Start loader... I will now execute HashTool. To use HashTool for enrolling the hash of loader.efi and vmlinuz.efi, follow these steps. These steps assume titles for a remastered archiso installation media. The exact titles you will get depends on your boot loader setup.\n\n- Select OK\n- In the HashTool main menu, select Enroll Hash, choose \\loader.efi and confirm with Yes. Again, select Enroll Hash and archiso to enter the archiso directory, then select vmlinuz.efi and confirm with Yes. Then choose Exit to return to the boot device selection menu.\n- In the boot device selection menu choose Arch Linux archiso x86_64 UEFI CD\n\nEvery entry of hashes enrolled in the MOK database eats up a little piece of space of NVRAM. You may want to delete useless hashes to free the space and to prevent outdated programs from booting.\n\nInstall efitools and copy KeyTool.efi:\n\n```\n# cp /usr/share/efitools/efi/KeyTool.efi esp/EFI/systemd/KeyTool.efi\n```\n\nManage to boot to Preloader and you will see the KeyTool entry. You can then edit hashes in the MOK database.\n\nUninstall preloader-signedAUR and simply remove the copied files and revert configuration; for systemd-boot use:\n\n```\n# rm esp/EFI/systemd/{PreLoader,HashTool}.efi\n# rm esp/EFI/systemd/loader.efi\n# efibootmgr --unicode --bootnum N --delete-bootnum\n# bootctl update\n```\n\nWhere N is the NVRAM boot entry created for booting PreLoader.efi. Check with the efibootmgr command and adjust the boot-order if necessary.\n\n"
    },
    {
      "title": "shim",
      "level": 4,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nWhen run, shim tries to launch grubx64.efi. If MokList does not contain the hash of grubx64.efi or the key it is signed with, shim will launch MokManager (mmx64.efi). In MokManager you must enroll the hash of the EFI binaries you want to launch (your boot loader (grubx64.efi) and kernel) or enroll the key they are signed with.\n\n- If you use #shim with hash, each time you update any of the binaries (e.g. boot loader or kernel) you will need to enroll their new hash.\n- Since version 15.3, shim will not launch EFI binaries without a valid .sbat section. Run objdump -j .sbat -s /path/to/binary.efi to verify if an EFI binary has it. See the SBAT documentation for details.\n- If you are not actually interested in the security brought by Secure Boot and are only enabling it to meet the requirements posed by Windows 11, you may want to consider disabling the validation process in shim with mokutil --disable-validation. In that case you will not need to sign grub (sbat probably still needed) or the kernel images and at the same time be able to boot Windows with chainloader in grub.\n\nInstall shim-signedAUR.\n\nRename your current boot loader to grubx64.efi, because, by default, Shim will try load and run a file named grubx64.efi. While this default can be overridden by passing a file path to a different EFI binary as a command line argument to shim, since some firmware have issues with UEFI boot entries that have command line arguments, it is more foolproof to rely on the default.\n\n```\n# mv esp/EFI/BOOT/BOOTx64.EFI esp/EFI/BOOT/grubx64.efi\n```\n\nCopy shim and MokManager to your boot loader directory on ESP; use previous filename of your boot loader as as the filename for shimx64.efi:\n\nNote: **not** \n\n```\n# cp /usr/share/shim-signed/shimx64.efi esp/EFI/BOOT/BOOTx64.EFI\n# cp /usr/share/shim-signed/mmx64.efi esp/EFI/BOOT/\n```\n\nFinally, create a new NVRAM entry to boot BOOTx64.EFI:\n\n```\n# efibootmgr --unicode --disk /dev/sdX --part Y --create --label \"Shim\" --loader /EFI/BOOT/BOOTx64.EFI\n```\n\nshim can authenticate binaries by Machine Owner Key or hash stored in MokList.\n\nUsing hash is simpler, but each time you update your boot loader or kernel you will need to add their hashes in MokManager. With MOK you only need to add the key once, but you will have to sign the boot loader and kernel each time it updates.\n\nIf shim does not find the SHA256 hash of grubx64.efi in MokList it will launch MokManager (mmx64.efi).\n\nIn MokManager select Enroll hash from disk, find grubx64.efi and add it to MokList. Repeat the steps and add your kernel vmlinuz-linux. When done select Continue boot and your boot loader will launch and it will be capable launching the kernel.\n\nInstall sbsigntools.\n\nYou will need:\n\nCreate a Machine Owner Key:\n\n```\n$ openssl req -newkey rsa:2048 -nodes -keyout MOK.key -new -x509 -sha256 -days 3650 -subj \"/CN=my Machine Owner Key/\" -out MOK.crt\n$ openssl x509 -outform DER -in MOK.crt -out MOK.cer\n```\n\nSign your boot loader (named grubx64.efi) and kernel:\n\n```\n# sbsign --key MOK.key --cert MOK.crt --output /boot/vmlinuz-linux /boot/vmlinuz-linux\n# sbsign --key MOK.key --cert MOK.crt --output esp/EFI/BOOT/grubx64.efi esp/EFI/BOOT/grubx64.efi\n```\n\nYou will need to do this each time they are updated. You can automate the kernel signing with a mkinitcpio post hook. Create the following file and make it executable:\n\n```\n/etc/initcpio/post/kernel-sbsign\n```\n\n```\n#!/usr/bin/env bash\n\nkernel=\"$1\"\n[[ -n \"$kernel\" ]] || exit 0\n\n# use already installed kernel if it exists\n[[ ! -f \"$KERNELDESTINATION\" ]] || kernel=\"$KERNELDESTINATION\"\n\nkeypairs=(/path/to/MOK.key /path/to/MOK.crt)\n\nfor (( i=0; i<${#keypairs[@]}; i+=2 )); do\n    key=\"${keypairs[$i]}\" cert=\"${keypairs[(( i + 1 ))]}\"\n    if ! sbverify --cert \"$cert\" \"$kernel\" &>/dev/null; then\n        sbsign --key \"$key\" --cert \"$cert\" --output \"$kernel\" \"$kernel\"\n    fi\ndone\n```\n\nCopy MOK.cer to a FAT formatted file system (you can use EFI system partition).\n\nReboot and enable Secure Boot. If shim does not find the certificate grubx64.efi is signed with in MokList it will launch MokManager (mmx64.efi).\n\nIn MokManager select Enroll key from disk, find MOK.cer and add it to MokList. When done select Continue boot and your boot loader will launch and it will be capable launching any binary signed with your Machine Owner Key.\n\nSee GRUB#Shim-lock for instructions.\n\nEvery entry of hash/key enrolled in the MOK database eats up a little piece of space of NVRAM. You may want to delete useless hash/key to free the space and to prevent outdated programs from booting.\n\nMOK database can be managed with mokutil\n\nList enrolled keys & hashes\n\n```\n# mokutil --list-enrolled\n```\n\nRemove hash from database. The password entered here will be asked for confirmation to delete in MOK manager.\n\n```\n# mokutil --delete-hash <hash to remove from above command>\nInput password:\n```\n\nRemove key from database\n\n```\n# mokutil --delete MOK.cer\n```\n\nList hashes/keys to be deleted on next reboot\n\n```\n# mokutil --list-delete\n```\n\nOn next reboot, MOK manager will be initiated with option to Enroll/Delete hashes/keys. More details mokutil(1)\n\nUninstall shim-signedAUR, remove the copied shim and MokManager files and rename back your boot loader.\n\n"
    },
    {
      "title": "Protecting Secure Boot",
      "level": 2,
      "content": "The only way to prevent anyone with physical access from disabling Secure Boot is to protect the firmware settings with a password. Most UEFI firmwares provide such a feature, usually listed under the \"Security\" section in the firmware settings.\n\nConsider enabling kernel lockdown mode. See [7].\n\n"
    },
    {
      "title": "ISO repacking",
      "level": 3,
      "content": "It is possible to unpack and repack the official installation image using libisoburn and mtools. This way, you can create an image that supports Secure Boot, either with custom keys or with a signed boot loader.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n"
    },
    {
      "title": "Sign the official ISO with custom keys",
      "level": 4,
      "content": "Support for Secure Boot using custom keys can be added to the official ISO by simply extracting the boot loader (BOOTx64.EFI and BOOTIA32.EFI), kernel, UEFI shell, signing them and then repacking the ISO with the signed files.\n\nFirst extract the relevant files and El Torito boot images:\n\n```\n$ osirrox -indev archlinux-YYYY.MM.DD-x86_64.iso \\\n\t-extract_boot_images ./ \\\n\t-cpx /arch/boot/x86_64/vmlinuz-linux \\\n\t/EFI/BOOT/BOOTx64.EFI \\\n\t/EFI/BOOT/BOOTIA32.EFI \\\n\t/shellx64.efi \\\n\t/shellia32.efi ./\n```\n\nxorrisofs(1) option -rational-rock as used by mkarchiso makes the files on ISO 9660 read-only which persists after extracting them. Make the files writable so that they can be modified:\n\n```\n$ chmod +w BOOTx64.EFI BOOTIA32.EFI shellx64.efi shellia32.efi vmlinuz-linux\n```\n\nSign the files. To do so with sbsigntools, for example:\n\n```\n$ sbsign --key db.key --cert db.crt --output BOOTx64.EFI BOOTx64.EFI\n$ sbsign --key db.key --cert db.crt --output BOOTIA32.EFI BOOTIA32.EFI\n$ sbsign --key db.key --cert db.crt --output shellx64.efi shellx64.efi\n$ sbsign --key db.key --cert db.crt --output shellia32.efi shellia32.efi\n$ sbsign --key db.key --cert db.crt --output vmlinuz-linux vmlinuz-linux\n```\n\nCopy the signed EFI binaries to eltorito_img2_uefi.img. It will be used as the EFI system partition and will be listed as an El Torito UEFI boot image. The size of eltorito_img2_uefi.img is fixed, but there are 8 MiB free space added by mkarchiso (for the purposes of rounding/alignment, to account for reserved sectors, etc.), so the size increase from the signatures should not be an issue.\n\n```\n$ mcopy -D oO -i eltorito_img2_uefi.img vmlinuz-linux ::/arch/boot/x86_64/vmlinuz-linux\n$ mcopy -D oO -i eltorito_img2_uefi.img BOOTx64.EFI BOOTIA32.EFI ::/EFI/BOOT/\n$ mcopy -D oO -i eltorito_img2_uefi.img shellx64.efi shellia32.efi ::/\n```\n\nRepack the ISO using the modified El Torito UEFI boot image and add the signed EFI binaries to ISO 9660:\n\n```\n$ xorriso -indev archlinux-YYYY.MM.DD-x86_64.iso \\\n\t-outdev archlinux-YYYY.MM.DD-x86_64-Secure_Boot.iso \\\n\t-map vmlinuz-linux /arch/boot/x86_64/vmlinuz-linux \\\n\t-map_l ./ /EFI/BOOT/ BOOTx64.EFI BOOTIA32.EFI -- \\\n\t-map_l ./ / shellx64.efi shellia32.efi -- \\\n\t-boot_image any replay \\\n\t-append_partition 2 0xef eltorito_img2_uefi.img\n```\n\nBoot the resulting archlinux-YYYY.MM.DD-x86_64-Secure_Boot.iso.\n\n"
    },
    {
      "title": "Replacing the boot loader with PreLoader",
      "level": 4,
      "content": "Another way to add Secure Boot support to the official ISO is by extracting the boot loader and replacing it with #PreLoader.\n\nFirst, extract the boot loader and the El Torito boot image:\n\n```\n$ osirrox -indev archlinux-YYYY.MM.DD-x86_64.iso \\\n\t-extract_boot_images ./ \\\n\t-extract /EFI/BOOT/BOOTx64.EFI loader.efi\n```\n\nReplace the BOOTx64.efi file with PreLoader:\n\n```\n$ cp /usr/share/preloader-signed/PreLoader.efi BOOTx64.EFI\n$ cp /usr/share/preloader-signed/HashTool.efi HashTool.efi\n```\n\nAdd the new files to the boot image:\n\n```\n$ mcopy -D oO -i eltorito_img2_uefi.img BOOTx64.EFI loader.efi HashTool.efi ::/EFI/BOOT/\n```\n\nFinally, repack the ISO using the modified boot image and the new boot loader files:\n\n```\n$ xorriso -indev archlinux-YYYY.MM.DD-x86_64.iso \\\n\t-outdev archlinux-YYYY.MM.DD-x86_64-Secure_Boot.iso \\\n\t-map_l ./ /EFI/BOOT/ BOOTx64.EFI loader.efi HashTool.efi -- \\\n\t-boot_image any replay \\\n\t-append_partition 2 0xef eltorito_img2_uefi.img\n```\n\n"
    },
    {
      "title": "Sign the official ISO with a Machine Owner Key for shim",
      "level": 4,
      "content": "Support for Secure Boot using shim with a Machine Owner Key (MOK) can be added to the official ISO by extracting the boot loader, kernel and UEFI shell, signing them and then repacking the ISO with the signed files and shim.\n\nFirst extract the relevant files and El Torito boot images. The boot loader file name will need to be grubx64.efi so that shim can find it.\n\n```\n$ osirrox -indev archlinux-YYYY.MM.DD-x86_64.iso \\\n\t-extract_boot_images ./ \\\n\t-extract /EFI/BOOT/BOOTx64.EFI grubx64.efi \\\n\t-extract /shellx64.efi shellx64.efi \\\n\t-extract /arch/boot/x86_64/vmlinuz-linux vmlinuz-linux\n```\n\nxorrisofs(1) option -rational-rock as used by mkarchiso makes the files on ISO 9660 read-only which persists after extracting them. Make the files writable so that they can be modified:\n\n```\n$ chmod +w grubx64.efi shellx64.efi vmlinuz-linux\n```\n\nSign the files with your MOK:\n\n```\n$ sbsign --key MOK.key --cert MOK.crt --output grubx64.efi grubx64.efi\n$ sbsign --key MOK.key --cert MOK.crt --output shellx64.efi shellx64.efi\n$ sbsign --key MOK.key --cert MOK.crt --output vmlinuz-linux vmlinuz-linux\n```\n\nAcquire pre-signed shim EFI binaries, e.g. by installing shim-signedAUR. Place shim and MokManager in the current directory and change the shim EFI binary's file name to BOOTx64.EFI:\n\n```\n$ cp /usr/share/shim-signed/shimx64.efi BOOTx64.EFI\n$ cp /usr/share/shim-signed/mmx64.efi ./\n```\n\nCopy shim, MokManager, the signed EFI binaries and the DER format MOK to eltorito_img2_uefi.img. It will be used as the EFI system partition and will be listed as an El Torito UEFI boot image. The size of eltorito_img2_uefi.img is fixed, but there are 8 MiB free space added by mkarchiso (for the purposes of rounding/alignment, to account for reserved sectors, etc.), so the size increase from the added files should not be an issue.\n\n```\n$ mcopy -D oO -i eltorito_img2_uefi.img vmlinuz-linux ::/arch/boot/x86_64/vmlinuz-linux\n$ mcopy -D oO -i eltorito_img2_uefi.img MOK.cer shellx64.efi ::/\n$ mcopy -D oO -i eltorito_img2_uefi.img BOOTx64.EFI grubx64.efi mmx64.efi ::/EFI/BOOT/\n```\n\nRepack the ISO using the modified El Torito UEFI boot image and add shim, MokManager, the signed EFI binaries and the DER format MOK to ISO 9660:\n\n```\n$ xorriso -indev archlinux-YYYY.MM.DD-x86_64.iso \\\n\t-outdev archlinux-YYYY.MM.DD-x86_64-Secure_Boot.iso \\\n\t-map vmlinuz-linux /arch/boot/x86_64/vmlinuz-linux \\\n\t-map_l ./ / shellx64.efi MOK.cer -- \\\n\t-map_l ./ /EFI/BOOT/ BOOTx64.EFI grubx64.efi mmx64.efi -- \\\n\t-boot_image any replay \\\n\t-append_partition 2 0xef eltorito_img2_uefi.img\n```\n\nBoot the resulting archlinux-YYYY.MM.DD-x86_64-Secure_Boot.iso. When MokManager launches, select Enroll key from disk > ARCHISO_EFI > MOK.cer. After enrolling the key, reboot and at the next boot, the live environment will successfully boot.\n\n"
    },
    {
      "title": "Enrolling Option ROM digests",
      "level": 3,
      "content": "Option ROMs (OpROMs), i.e. device firmware that is executed during boot, must be signed for Secure Boot otherwise the devices will not be initialized. Typically OpROMs are signed with the Microsoft 3rd Party UEFI CA certificate which may prevent implementing Secure Boot with only your own keys. To solve this, the SHA256 digests of OpROMs can be enrolled instead.\n\nOn systems with a TPM, it is possible to acquire Option ROM SHA256 digests from the TPM event log.\n\nInstall tpm2-tools and digest-to-efi-sig-listAUR.\n\nUse tpm2_eventlog(1) to read /sys/kernel/security/tpm0/binary_bios_measurements and look for the digests of BOOT_SERVICES_DRIVER.[8]\n\nFor example:\n\n```\n# tpm2_eventlog /sys/kernel/security/tpm0/binary_bios_measurements\n```\n\n```\n...\n- EventNum: 9\n  PCRIndex: 2\n  EventType: EV_EFI_BOOT_SERVICES_DRIVER\n  DigestCount: 1\n  Digests:\n  - AlgorithmId: sha256\n    Digest: \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\"\n...\n- EventNum: 10\n  PCRIndex: 2\n  EventType: EV_EFI_BOOT_SERVICES_DRIVER\n  DigestCount: 1\n  Digests:\n  - AlgorithmId: sha256\n    Digest: \"fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210\"\n...\n```\n\nThis will print an easy to parse list of digests:\n\n```\n# tpm2_eventlog /sys/kernel/security/tpm0/binary_bios_measurements | grep -o 'Digest: \"[a-f0-9]\\{64\\}\"' | sed 's/Digest: \"//;s/\"$//'\n```\n\nUse digest-to-efi-sig-listAUR to create an EFI signature list for each OpROM digest you find:\n\n```\n$ digest-to-efi-sig-list 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef OpROM1.esl\n$ digest-to-efi-sig-list fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210 OpROM2.esl\n```\n\nIn case you have multiple OpROMs, combine their EFI signature lists into one so that it could be signed as a single file:\n\n```\n$ cat OpROM1.esl OpROM2.esl > OpROM.esl\n```\n\nYou could use a bash script like this if you have a lot of digests.\n\nSign the EFI signature list for appending to the Signature Database:\n\n```\n$ sign-efi-sig-list -a -g \"$(< GUID.txt)\" -k KEK.key -c KEK.crt db OpROM.esl OpROM.auth\n```\n\nEnroll it.\n\nThe final and most dangerous step is to remove Microsoft 3rd Party UEFI CA certificate from the Signature Database and see if the system still boots and all devices still work.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Understanding the UEFI Secure Boot Chain by tianocore\n- Wikipedia:Unified Extensible Firmware Interface#Secure Boot\n- Dealing with Secure Boot by Rod Smith\n- Controlling Secure Boot by Rod Smith\n- UEFI secure booting (part 2) by Matthew Garrett\n- UEFI Secure Boot by James Bottomley\n- efitools README\n- Will your computer's \"Secure Boot\" turn out to be \"Restricted Boot\"? — Free Software Foundation\n- Free Software Foundation recommendations for free operating system distributions considering Secure Boot\n- Intel's UEFI Secure Boot Tutorial\n- Secure Boot, Signed Modules and Signed ELF Binaries\n- National Security Agency docs: UEFI Defensive Practices Guidance and unclassified UEFI Secure Boot customization\n- sbkeysync & maintaining uefi key databases by Jeremy Kerr\n- Secure your boot process: UEFI + Secureboot + EFISTUB + Luks2 + lvm + ArchLinux (2020-07)\n- How is hibernation supported, on machines with UEFI Secure Boot? (Security StackExchange)\n- Authenticated Boot and Disk Encryption on Linux by Lennart Poettering (2021-09-23)\n- The tool cryptbootAUR simplifies the whole process and is easy to use\n\n"
    }
  ]
}