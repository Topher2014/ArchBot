{
  "title": "Ping",
  "url": "https://wiki.archlinux.org/title/Ping",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Domain name resolution\n- Firewalls\n- Internet sharing\n- Network Debugging\n- Router\n\nThis article describes how to configure network connections on OSI layer 3 and above. Medium-specifics are handled in the /Ethernet and /Wireless subpages.\n\n"
    },
    {
      "title": "Check the connection",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nTo troubleshoot a network connection, go through the following conditions and ensure that you meet them:\n\n1. Your network interface is listed and enabled. Otherwise, check the device driver â€“ see /Ethernet#Device driver or /Wireless#Device driver.\n1. You are connected to the network. The cable is plugged in or you are connected to the wireless LAN.\n1. Your network interface has an IP address.\n1. Your routing table is correctly set up.\n1. You can ping a local IP address (e.g. your default gateway).\n1. You can ping a public IP address (e.g. 9.9.9.9, which is a DNS server operated by the Quad9 Foundation and is a convenient address to test with).\n1. Check if you can resolve domain names (e.g. archlinux.org).\n\n"
    },
    {
      "title": "Ping",
      "level": 3,
      "content": "ping is used to test if you can reach a host.\n\n```\n$ ping www.example.com\n```\n\n```\nPING www.example.com (93.184.216.34) 56(84) bytes of data.\n64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=1 ttl=56 time=11.632 ms\n64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=2 ttl=56 time=11.726 ms\n64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=3 ttl=56 time=10.683 ms\n...\n```\n\nFor every reply received, the ping utility will print a line like the above until you interrupt (Ctrl+c) it interactively. For more information see the ping(8) manual. Note that computers can be configured not to respond to ICMP echo requests. [1]\n\nIf you receive an error message (see ping error indications) or no reply, this may be related to incomplete configuration, but also your default gateway or your Internet Service Provider (ISP). You can run a traceroute to further diagnose the route to the host.\n\n"
    },
    {
      "title": "Network management",
      "level": 2,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nTo set up a network connection, go through the following steps:\n\n1. Ensure your network interface is listed and enabled.\n1. Connect to the network. Plug in the Ethernet cable or connect to the wireless LAN.\n1. Configure your network connection: Most networks use the Dynamic Host Configuration Protocol for network configuration. Clients can automatically obtain a dynamic or static IP address from the DHCP server via a standalone DHCP client or using a network manager. If the network does not have a DHCP server, you can configure a static IP address, routing table and DNS servers manually for each client. See #Static IP address for details.\n\n- Most networks use the Dynamic Host Configuration Protocol for network configuration. Clients can automatically obtain a dynamic or static IP address from the DHCP server via a standalone DHCP client or using a network manager.\n- If the network does not have a DHCP server, you can configure a static IP address, routing table and DNS servers manually for each client. See #Static IP address for details.\n\n- systemd-networkd, which is configured as a DHCP client for Ethernet, WLAN and WWAN network interfaces, and\n- systemd-resolved configured for system-wide DNS, see systemd-resolved#DNS.\n\n"
    },
    {
      "title": "iproute2",
      "level": 4,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\niproute2 is a dependency of the base meta package and provides the ip(8) command-line interface, used to manage network interfaces, IP addresses and the routing table. Be aware that configuration made using ip will be lost after a reboot. For persistent configuration, you can automate ip commands using scripts and systemd units. Also note that ip commands can generally be abbreviated, for clarity they are however spelled out in this article.\n\n"
    },
    {
      "title": "Static IP address",
      "level": 4,
      "content": "A static IP address can be configured with most standard network managers and also dhcpcd.\n\nTo manually configure a static IP address, add an IP address as described in #IP addresses, set up your routing table and configure your DNS servers.\n\n"
    },
    {
      "title": "IP addresses",
      "level": 4,
      "content": "IP addresses are managed using ip-address(8).\n\nList IP addresses:\n\n```\n$ ip address show\n```\n\nAdd an IP address to an interface:\n\n```\n# ip address add address/prefix_len broadcast + dev interface\n```\n\n- the address is given in CIDR notation to also supply a subnet mask\n- + is a special symbol that makes ip derive the broadcast address from the IP address and the subnet mask\n\nDelete an IP address from an interface:\n\n```\n# ip address del address/prefix_len dev interface\n```\n\nDelete all addresses matching a criteria, e.g. of a specific interface:\n\n```\n# ip address flush dev interface\n```\n\n"
    },
    {
      "title": "Routing table",
      "level": 4,
      "content": "The routing table is used to determine if you can reach an IP address directly or what gateway (router) you should use. If no other route matches the IP address, the default gateway is used.\n\nThe routing table is managed using ip-route(8).\n\nPREFIX is either a CIDR notation or default for the default gateway.\n\nList IPv4 routes:\n\n```\n$ ip route show\n```\n\nList IPv6 routes:\n\n```\n$ ip -6 route show\n```\n\nAdd a route:\n\n```\n# ip route add PREFIX via address dev interface\n```\n\nDelete a route:\n\n```\n# ip route del PREFIX via address dev interface\n```\n\n"
    },
    {
      "title": "Automatic",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nAutomatic network configuration is accomplished using Dynamic Host Configuration Protocol (DHCP). The network's DHCP server provides IP address(es), the default gateway IP address(es) and optionally also DNS name servers upon request from the DHCP client.\n\nSee Router#DNS and DHCP for a DHCP server comparison table.\n\n"
    },
    {
      "title": "Network managers",
      "level": 4,
      "content": "A network manager lets you manage network connection settings in so called network profiles to facilitate switching networks.\n\nTable content:\nSoftware | Connection type | Wireless authentication | IP address, route and DNS management | Interface\nEthernet | PPPoE | Mobile broadband | WPA/WPA2 | WPA3 | Static IP | DHCP client | Domain name resolution | CLI | TUI | GUI\ndhclient1 | Yes | No | No | No2 | Yes | internal | Yes (writes /etc/resolv.conf) | No | No | No\ndhcpcd | Yes | No | No | Launches wpa_supplicant3 | Yes | internal | Yes (uses resolvconf or writes /etc/resolv.conf) | No | No | dhcpcd-uiAUR\nConnMan | Yes | No | Yes (via ofonoAUR) | Yes (via wpa_supplicant or iwd) | Yes | internal | Yes (runs a builtin resolver and writes /etc/resolv.conf) | connmanctl(1) | Yes | Yes\nnetctl | Yes | Yes (via ppp) | Yes (via ppp) | Yes (via wpa_supplicant) | No | Yes | dhcpcd or dhclient | Yes (uses resolvconf) | netctl(1) | wifi-menu(1)4 | No\nNetworkManager | Yes | Yes (via ppp) | Yes (via modemmanager) | Yes (via wpa_supplicant or iwd) | Yes | internal, dhclient or dhcpcd5 | Yes (uses systemd-resolved, resolvconf or writes /etc/resolv.conf) | nmcli(1) | nmtui(1) | Yes\nsystemd-networkd | Yes | No | No | No2 | Yes | internal | Yes (uses systemd-resolved) | networkctl(1) | No | No\nwpa_supplicant | IEEE 802.1X | No | No | Yes | Yes | No | wpa_cli(8) | No | wpa_supplicant_guiAUR\niwd | IEEE 802.1X | No | No | Yes | Yes | Yes | internal | Yes (uses systemd-resolved or resolvconf) | iwctl(1) | impala | iwgtkAUR\n\n1. No longer maintained as of early 2022. ISC advises no longer using it in production.\n1. Wireless authentication can be configured separately with wpa_supplicant or iwd.\n1. Wireless authentication must be configured separately with wpa_supplicant.\n1. Only Wi-Fi connections can be managed.\n1. NetworkManager does not use dhcpcd for DHCPv6, see NetworkManager#DHCP client.\n\n"
    },
    {
      "title": "Network interfaces",
      "level": 2,
      "content": "Network interfaces are managed by udev and configured by systemd.link(5) files. The default configuration assigns names to your network interface controllers using Predictable Network Interface Names, which prefixes interfaces names with en (wired/Ethernet), wl (wireless/WLAN), or ww (mobile broadband/WWAN). See systemd.net-naming-scheme(7).\n\n- The system /usr/lib/systemd/network/99-default.link is generally sufficient for most cases.\n- To change interface names, see #Change interface name and #Revert to traditional interface names.\n- You can run udevadm test-builtin net_setup_link /sys/path/to/network/device as the root user to diagnose problems with .link files.\n\n"
    },
    {
      "title": "Listing network interfaces",
      "level": 3,
      "content": "Both wired and wireless interface names can be found via ls /sys/class/net or ip link. Note that lo is the virtual loopback interface and not used in making network connections.\n\nWireless device names can also be retrieved using iw dev. See also /Wireless#Get the name of the interface.\n\nIf your network interface is not listed, make sure your device driver was loaded successfully. See /Ethernet#Device driver or /Wireless#Device driver.\n\n"
    },
    {
      "title": "Enabling and disabling network interfaces",
      "level": 3,
      "content": "Network interfaces can be enabled or disabled using ip link set interface up|down, see ip-link(8).\n\nTo check the status of the interface enp2s0:\n\n```\n$ ip link show dev enp2s0\n```\n\n```\n2: enp2s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master br0 state DOWN mode DEFAULT qlen 1000\n...\n```\n\nThe UP in <BROADCAST,MULTICAST,UP,LOWER_UP> is what indicates the interface is up, not the later state DOWN.\n\n"
    },
    {
      "title": "Change interface name",
      "level": 3,
      "content": "You can change the device name by defining the name manually with an systemd.link(5) file. For example:\n\n```\n/etc/systemd/network/10-net0.link\n```\n\n```\n[Match]\nPermanentMACAddress=aa:bb:cc:dd:ee:ff\n\n[Link]\nName=net0\n```\n\nAlternatively, a udev rule can be used:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTR{address}==\"aa:bb:cc:dd:ee:ff\", NAME=\"net0\"\n```\n\nThese rules will be applied automatically at boot. To apply the change immediately, do a manual trigger of the udev rule on the net subsystem:\n\n```\n# udevadm trigger --verbose --subsystem-match=net --action=add\n```\n\nIf you want to run a test on the changes made, udevadm --debug test /sys/class/net/* can be of help.\n\n- The priority of Name is lower than NamePolicy, so make sure the latter is unset/empty or the name will not be changed. 99-default.link sets NamePolicy, requiring the custom config to be ordered before it, i.e. to have a numerical prefix.\n- The network interface must be down before changing its name. [3]\n- To get the MAC address of each card, run ip link.\n- Make sure to use the lower-case hex values in your udev rules. It does not like upper-case.\n\nIf the network card has a dynamic MAC, you can use Path (which can be checked using networkctl status interface_name):\n\n```\n/etc/systemd/network/10-net1.link\n```\n\n```\n[Match]\nPath=pci-0000:01:00.0\n\n[Link]\nName=net1\n```\n\nOr, use a udev rule with DEVPATH:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", DEVPATH==\"/devices/pci*/*1c.0/*/net/*\", NAME=\"net1\"\n```\n\nTo get the DEVPATH of all currently-connected devices, see where the symlinks in /sys/class/net/ lead. For example:\n\n```\n$ file /sys/class/net/*\n```\n\n```\n/sys/class/net/enp0s20f0u4u1: symbolic link to ../../devices/pci0000:00/0000:00:14.0/usb2/2-4/2-4.1/2-4.1:1.0/net/enp0s20f0u4u1\n/sys/class/net/enp0s31f6:     symbolic link to ../../devices/pci0000:00/0000:00:1f.6/net/enp0s31f6\n/sys/class/net/lo:            symbolic link to ../../devices/virtual/net/lo\n/sys/class/net/wlp4s0:        symbolic link to ../../devices/pci0000:00/0000:00:1c.6/0000:04:00.0/net/wlp4s0\n```\n\nThe device path should match both the new and old device name, since the rule may be executed more than once on bootup. For example, in the given rule, \"/devices/pci*/*1c.0/*/net/en*\" would be wrong since it will stop matching once the name is changed to net1. Only the system-default rule will fire the second time around, causing the name to be changed back.\n\nIf you are using a USB network device (e.g. Android phone tethering) that has a dynamic MAC address and you want to be able to use different USB ports, you could use a rule that matched depending on vendor and model ID instead:\n\n```\n/etc/systemd/network/20-net2.link\n```\n\n```\n[Match]\nProperty=ID_VENDOR_ID=12ab ID_MODEL_ID=3cd4\n\n[Link]\nName=net2\n```\n\nor\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTRS{idVendor}==\"12ab\", ATTRS{idProduct}==\"3cd4\", NAME=\"net2\"\n```\n\nNote: **it should be avoided to use names in the format of \"ethX\" and \"wlanX\"** \n\n"
    },
    {
      "title": "Revert to traditional interface names",
      "level": 3,
      "content": "If you would prefer to retain traditional interface names such as eth0, Predictable Network Interface Names can be disabled by changing the default NamePolicy for udev's net_setup_link built-in:\n\n```\n/etc/systemd/network/99-default.link.d/traditional-naming.conf\n```\n\n```\n[Link]\nNamePolicy=keep kernel\n```\n\nAlternatively, net_setup_link can be completely disabled by masking the corresponding udev rule:\n\n```\n# ln -s /dev/null /etc/udev/rules.d/80-net-setup-link.rules\n```\n\nor by adding net.ifnames=0 to the kernel parameters.\n\n"
    },
    {
      "title": "Set device MTU and queue length",
      "level": 3,
      "content": "You can change the device MTU and queue length by defining manually with a systemd.link(5) config. For example:\n\n```\n/etc/systemd/network/30-mtu.link\n```\n\n```\n[Match]\nType=wlan\n\n[Link]\nMTUBytes=1500\nTransmitQueueLength=2000\n```\n\nOr through a udev rule:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"net\", KERNEL==\"wl*\", ATTR{mtu}=\"1500\", ATTR{tx_queue_len}=\"2000\"\n```\n\nMTUBytes: Using a value larger than 1500 (so called jumbo frames) can significantly speed up your network transfers. Note that all network interfaces, including switches in the local network, must support the same MTU in order to use jumbo frames. For PPPoE, the MTU should not be larger than 1492. You can also set MTU via systemd.netdev(5).\n\nTransmitQueueLength: Small value for slower devices with a high latency like modem links and ISDN. High value is recommended for server connected over the high-speed internet connections that perform large data transfers.\n\n"
    },
    {
      "title": "Set the hostname",
      "level": 2,
      "content": "A hostname is a unique name created to identify a machine on a network, configured in /etc/hostnameâ€”see hostname(5) and hostname(7) for details. The file can contain the system's domain name, if any. To set the hostname, edit /etc/hostname to include a single line with yourhostname:\n\n```\n/etc/hostname\n```\n\n```\nyourhostname\n```\n\nAlternatively, using hostnamectl(1):\n\n```\n# hostnamectl hostname yourhostname\n```\n\nTo temporarily set the hostname (until reboot), use hostname(1) from inetutils:\n\n```\n# hostname yourhostname\n```\n\nTo set the \"pretty\" hostname and other machine metadata, see machine-info(5).\n\n"
    },
    {
      "title": "Local network hostname resolution",
      "level": 3,
      "content": "To make your machine accessible in your LAN via its hostname you can:\n\n- edit the /etc/hosts file for every device in your LAN, see hosts(5)\n- set up a DNS server to resolve your hostname and make the LAN devices use it (e.g. via DHCP)\n- or the easy way: use a Zero-configuration networking service: Hostname resolution via Microsoft's NetBIOS. Provided by Samba on Linux. It only requires the nmb.service. Computers running Windows, macOS, or Linux with nmb running, will be able to find your machine. Hostname resolution via mDNS. Provided by either nss_mdns with Avahi (see Avahi#Hostname resolution for setup details) or systemd-resolved. Computers running macOS, or Linux with Avahi or systemd-resolved running, will be able to find your machine. The older Win32 API does not support mDNS, which may prevent some older Windows applications from accessing your device.\n\n- Hostname resolution via Microsoft's NetBIOS. Provided by Samba on Linux. It only requires the nmb.service. Computers running Windows, macOS, or Linux with nmb running, will be able to find your machine.\n- Hostname resolution via mDNS. Provided by either nss_mdns with Avahi (see Avahi#Hostname resolution for setup details) or systemd-resolved. Computers running macOS, or Linux with Avahi or systemd-resolved running, will be able to find your machine. The older Win32 API does not support mDNS, which may prevent some older Windows applications from accessing your device.\n\n"
    },
    {
      "title": "Bonding or LAG",
      "level": 3,
      "content": "See netctl or systemd-networkd, or Wireless bonding.\n\n"
    },
    {
      "title": "IP address aliasing",
      "level": 3,
      "content": "IP aliasing is the process of adding more than one IP address to a network interface. With this, one node on a network can have multiple connections to a network, each serving a different purpose. Typical uses are virtual hosting of Web and FTP servers, or reorganizing servers without having to update any other machines (this is especially useful for nameservers).\n\n"
    },
    {
      "title": "Example",
      "level": 4,
      "content": "To manually set an alias, for some NIC, use iproute2 to execute\n\n```\n# ip addr add 192.168.2.101/24 dev enp2s0 label enp2s0:1\n```\n\nTo remove a given alias execute\n\n```\n# ip addr del 192.168.2.101/24 dev enp2s0:1\n```\n\nPackets destined for a subnet will use the primary alias by default. If the destination IP is within a subnet of a secondary alias, then the source IP is set respectively. Consider the case where there is more than one NIC, the default routes can be listed with ip route.\n\n"
    },
    {
      "title": "Promiscuous mode",
      "level": 3,
      "content": "Toggling promiscuous mode will make a (wireless) NIC forward all traffic it receives to the OS for further processing. This is opposite to \"normal mode\" where a NIC will drop frames it is not intended to receive. It is most often used for advanced network troubleshooting and packet sniffing.\n\n```\n/etc/systemd/system/promiscuous@.service\n```\n\n```\n[Unit]\nDescription=Set %i interface in promiscuous mode\nAfter=network.target\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/ip link set dev %i promisc on\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n\nIf you want to enable promiscuous mode on interface enp2s0, enable promiscuous@enp2s0.service.\n\n"
    },
    {
      "title": "Investigate sockets",
      "level": 3,
      "content": "ss is a utility to investigate network ports and is part of the iproute2 package. It has a similar functionality to the deprecated netstat utility.\n\nCommon usage includes:\n\nDisplay all TCP Sockets with service names:\n\n```\n$ ss -at\n```\n\nDisplay all TCP Sockets with port numbers:\n\n```\n$ ss -atn\n```\n\nDisplay all UDP Sockets:\n\n```\n$ ss -au\n```\n\nFor more information see ss(8).\n\n"
    },
    {
      "title": "The TCP window scaling problem",
      "level": 3,
      "content": "TCP packets contain a \"window\" value in their headers indicating how much data the other host may send in return. This value is represented with only 16 bits, hence the window size is at most 64KiB. TCP packets are cached for a while (they have to be reordered), and as memory is (or used to be) limited, one host could easily run out of it.\n\nBack in 1992, as more and more memory became available, RFC:1323 was written to improve the situation: Window Scaling. The \"window\" value, provided in all packets, will be modified by a Scale Factor defined once, at the very beginning of the connection. That 8-bit Scale Factor allows the Window to be up to 32 times higher than the initial 64KiB.\n\nIt appears that some broken routers and firewalls on the Internet are rewriting the Scale Factor to 0 which causes misunderstandings between hosts. The Linux kernel 2.6.17 introduced a new calculation scheme generating higher Scale Factors, virtually making the aftermaths of the broken routers and firewalls more visible.\n\nThe resulting connection is at best very slow or broken.\n\n"
    },
    {
      "title": "How to diagnose the problem",
      "level": 4,
      "content": "First of all, let us make it clear: this problem is odd. In some cases, you will not be able to use TCP connections (HTTP, FTP, ...) at all and in others, you will be able to communicate with some hosts (very few).\n\nWhen you have this problem, the output from dmesg is okay, logs are clean and ip addr will report normal status... and actually everything appears normal.\n\nIf you cannot browse any website, but you can ping some random hosts, chances are great that you are experiencing this problem: ping uses ICMP and is not affected by TCP problems.\n\nYou can try to use Wireshark. You might see successful UDP and ICMP communications but unsuccessful TCP communications (only to foreign hosts).\n\n"
    },
    {
      "title": "Ways of fixing it",
      "level": 4,
      "content": "To fix it the bad way, you can change the tcp_rmem value, on which Scale Factor calculation is based. Although it should work for most hosts, it is not guaranteed, especially for very distant ones.\n\n```\n# sysctl -w net.ipv4.tcp_rmem=\"4096 87380 174760\"\n```\n\nSimply disable Window Scaling. Since Window Scaling is a nice TCP feature, it may be uncomfortable to disable it, especially if you cannot fix the broken router. There are several ways to disable Window Scaling, and it seems that the most bulletproof way (which will work with most kernels) is to add the following line to /etc/sysctl.d/99-disable_window_scaling.conf (see also sysctl):\n\n```\nnet.ipv4.tcp_window_scaling = 0\n```\n\nThis problem is caused by broken routers/firewalls, so let us change them. Some users have reported that the broken router was their very own DSL router.\n\n"
    },
    {
      "title": "More about it",
      "level": 4,
      "content": "This section is based on the LWN article TCP window scaling and broken routers and an archived Kernel Trap article: Window Scaling on the Internet.\n\nThere are also several relevant threads on the LKML.\n\n"
    },
    {
      "title": "localhost is resolved over the network",
      "level": 3,
      "content": "nss-myhostname(8) (an NSS module provided by systemd and enabled by default in /etc/nsswitch.conf) provides localhost and the local hostname resolution to an IP address. Some software may, however, still instead read /etc/hosts directly; see [4] [5] for examples.\n\nTo prevent such software from unsafely resolving localhost over the network, add entries for localhost to the hosts(5) file:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n```\n\nTo allow resolving the local hostname, additionally add it to the hosts(5) file:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n127.0.1.1        yourhostname\n```\n\nFor a system with a permanent IP address, replace 127.0.1.1 with that permanent IP address. For a system with a fully qualified domain name, insert the fully qualified domain name before the hostname (see the following link for the reasoning). For example:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n203.0.113.45     host1.fqdomain.example host1\n```\n\nAs a result the system resolves to both entries:\n\n```\n$ getent hosts\n```\n\n```\n127.0.0.1       localhost\n127.0.0.1       localhost\n127.0.1.1       yourhostname\n```\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Linux Network Administrators Guide\n- Debian Reference: Network setup\n- RHEL7: Networking Guide\n- Monitoring and tuning the Linux Networking Stack: Receiving data\n- Monitoring and tuning the Linux Networking Stack: Sending data\n- Tracing a packet journey using tracepoints, perf and eBPF\n\n"
    }
  ]
}