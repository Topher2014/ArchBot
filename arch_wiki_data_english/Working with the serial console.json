{
  "title": "Working with the serial console",
  "url": "https://wiki.archlinux.org/title/Working_with_the_serial_console",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "An Arch Linux machine can be configured for connections via the serial console port, which enables administration of a machine even if it has no keyboard, mouse, monitor, or network attached to it.\n\nInstallation of Arch Linux is possible via the serial console as well.\n\nA basic environment for this scenario is two machines connected using a serial cable (9-pin connector cable). The administering machine can be any Unix/Linux or Windows machine with a terminal emulator program (PuTTY or Minicom, for example).\n\nThe configuration instructions below will enable boot loader menu selection, boot messages, and terminal forwarding to the serial console.\n\n"
    },
    {
      "title": "GRUB",
      "level": 4,
      "content": "When using GRUB with a generated grub.cfg, edit /etc/default/grub and enable serial input and output support:\n\n```\n/etc/default/grub\n```\n\n```\n...\nGRUB_TERMINAL_INPUT=\"console serial\"\n...\nGRUB_TERMINAL_OUTPUT=\"gfxterm serial\"\n...\n```\n\nNext add the GRUB_SERIAL_COMMAND variable and set the options for the serial connection. For COM1 (/dev/ttyS0) with baud rate of 115200 bit/s:\n\n```\n/etc/default/grub\n```\n\n```\n...\nGRUB_SERIAL_COMMAND=\"serial --unit=0 --speed=115200\"\n```\n\nRead GRUB's manual on Using GRUB via a serial line and the serial command for detailed explanation of the available options.\n\nWhen GRUB is installed to an encrypted /boot/ partition - GRUB first stage (core.img) will show Enter passphrase for hdX,gptY: password prompt only on platform console and will not show anything in serial console even if all serial console configuration steps were done properly.\n\nThis happens because the grub-install has special behavior for GRUB_ENABLE_CRYPTODISK=y and will create early config placed in /boot/grub/PLATFORM/load.cfg but grub-install ignores serial console configuration from /etc/default/grub for GRUB first stage.\n\nThe /boot/grub/PLATFORM/load.cfg file gets overwritten each time grub-install is launched.\n\nTo get the GRUB cryptodisk password prompt on the serial console a few extra configuration steps are required:\n\n1. Run the following command to generate /boot/grub/PLATFORM/load.cfg and see the correct grub-mkimage parameters for your system:\n\nEFI platforms:\n\n```\n# grub-install --verbose 2>&1 | grep grub-mkimage\n```\n\nBIOS platorms:\n\n```\n# grub-install --verbose /dev/YOUR_BOOT_DISK 2>&1 | grep grub-mkimage\n```\n\nYou can reboot the system to check if it boots properly, but you should save the output of the commahd above - it will be hecessary at step 4.\n\n2. Copy /boot/grub/PLATFORM/load.cfg to /boot/grub/PLATFORM/early-grub.cfg\n\n3. Add the following lines at the beginning of /boot/grub/PLATFORM/early-grub.cfg (change those lines according to desired configuration as described above):\n\n```\nserial --unit=0 --speed=115200\nterminal_input serial console\nterminal_output serial console\n```\n\n4. Edit grub-mkimage parameters from step 1 (the grub-install output):\n\nReplace --config '/boot/grub/PLATFORM/load.cfg' to --config '/boot/grub/PLATFORM/early-grub.cfg' Remove paramters with empty arguments (like --dtb and --sbat ) and add serial and terminal modules to the end of the grub-mkimage parameters list.\n\n5. Run grub-mkimage with these parameters.\n\n6. On BIOS platforms like i386-pc (for EFI platforms just skip this step) run the following command to install new core.img to your system:\n\n```\n# grub-bios-setup -d /boot/grub/i386-pc/ /dev/YOUR_BOOT_DISK\n```\n\nIn order to revert those changes - just reinstall GRUB using grub-install command.\n\n"
    },
    {
      "title": "GRUB Legacy",
      "level": 4,
      "content": "Edit the GRUB Legacy configuration file /boot/grub/menu.lst and add these lines to the general area of the configuration:\n\n```\nserial --unit=0 --speed=9600\nterminal --timeout=5 serial console\n```\n\n"
    },
    {
      "title": "rEFInd",
      "level": 4,
      "content": "rEFInd supports serial console only in text mode. Edit refind.conf and uncomment textonly.\n\n"
    },
    {
      "title": "Syslinux",
      "level": 4,
      "content": "To enable serial console in Syslinux, edit syslinux.cfg and add SERIAL as the first directive in the configuration file.\n\nFor COM1 (/dev/ttyS0) with baud rate of 115200 bit/s:\n\n```\nSERIAL 0 115200\n```\n\nThe serial parameters are hardcoded to 8 bits, no parity and 1 stop bit.[1]. Read Syslinux Wiki:Config#SERIAL for the directive's options.\n\n"
    },
    {
      "title": "Kernel",
      "level": 3,
      "content": "Kernel's output can be sent to serial console by setting the console= kernel parameter. The last specified console= will be set as /dev/console.\n\n```\nconsole=tty0 console=ttyS0,115200\n```\n\nSee https://docs.kernel.org/admin-guide/serial-console.html.\n\n"
    },
    {
      "title": "getty",
      "level": 3,
      "content": "At boot, systemd-getty-generator(8) will start a getty instance for each console specified in the kernel command line.\n\nIf you have not configured console= in kernel command line start serial-getty@device.service. For /dev/ttyS0 (COM1) that would be serial-getty@ttyS0.service. Enable the service to start it at boot.\n\nUnless specified otherwise in the kernel command line, getty will be expecting 38400 bit/s baud rate, 8 data bits, no parity and one stop bit-times.\n\n"
    },
    {
      "title": "Connect using a terminal emulator program",
      "level": 3,
      "content": "Perform these steps on the machine used to connect the remote console.\n\n"
    },
    {
      "title": "cu",
      "level": 3,
      "content": "uucp tool cu can be used to \"Call Up\" another system and act as a serial console:\n\n```\n$ cu --line /dev/ttyS0\n```\n\n"
    },
    {
      "title": "dterm",
      "level": 4,
      "content": "dterm-gitAUR is a tiny serial communication program. If you invoke it without parameters, it will connect to /dev/ttyS0 at 9600 baud by default. The following example connect to /dev/ttyS0 at 115200 baud, with 8 data bits, no parity bit and 1 stop bit-times:\n\n```\n$ dterm 115200 8 n 1\n```\n\nSee its README for more examples.\n\n"
    },
    {
      "title": "Minicom",
      "level": 4,
      "content": "minicom can be obtained from the official repositories. Start Minicom in setup mode:\n\n```\n$ minicom -s\n```\n\nUsing the textual navigation menu, change the serial port settings to the following:\n\n```\nSerial Device: /dev/ttyS0\nBps/Par/Bits: 9600 8N1\n```\n\nPress Enter to exit the menus (pressing Esc will not save changes). Remove the modem Init and Reset strings, as we are not connecting to a modem. To do this, under the Modem and Dialing menu, delete the Init and Reset strings. Optionally save the configuration by choosing save setup as dfl from the main menu. Restart minicom with the serial cable connected to the target machine. The special keys for navigating Minicom can be found in the help menu which is opened by pressing Ctrl+A Z (i.e., exit session is Ctrl+A X).\n\n"
    },
    {
      "title": "picocom",
      "level": 4,
      "content": "picocom is a tiny dumb-terminal emulation program that is very like minicom, but instead of mini, it is pico. The following example connect to ttyS0 at 9600 bps:\n\n```\n$ picocom -b 9600 /dev/ttyS0\n```\n\nSee its manual for detailed usage.\n\n"
    },
    {
      "title": "Screen",
      "level": 4,
      "content": "GNU Screen is able to connect to a serial port. It will connect at 9600 baud by default:\n\n```\n$ screen /dev/ttyS0\n```\n\nA different baud rate (e.g. 115200) may be specified on the command line.\n\n```\n$ screen /dev/ttyS0 115200\n```\n\nTo end the session, press Ctrl+a followed by K. Alternatively, press Ctrl+a, type :quit and confirm it by pressing Enter.\n\n"
    },
    {
      "title": "Serialclient",
      "level": 4,
      "content": "Serialclient[2] is a CLI client for serial connection written in ruby. Install ruby package, then install it with the following:\n\n```\n# gem install serialclient\n```\n\nThen, you can use like this:\n\n```\n$ serialclient -p /dev/ttyS0\n```\n\n"
    },
    {
      "title": "tinyserial",
      "level": 4,
      "content": "tinyserialAUR is a minicom replacement for accessing serial ports on Linux inspired by FreeBSD 'tip'.\n\n```\n$ com /dev/ttyS0 9600\n```\n\n"
    },
    {
      "title": "tio",
      "level": 4,
      "content": "tioAUR is a simple serial device tool which features a straightforward command-line and configuration file interface to easily connect to serial TTY devices for basic I/O operations. It has less focus on classic terminal/modem features and more focus on the needs of embedded developers and hackers. tio was originally created to replace screen for connecting to serial devices when used in combination with tmux.\n\n```\n$ tio /dev/ttyUSB0\n```\n\n"
    },
    {
      "title": "socat",
      "level": 4,
      "content": "socat is a command line based utility that establishes two bidirectional byte streams and transfers data between them.\n\n```\n$ socat - /dev/ttyACM0,raw,echo=0,b115200\n```\n\n"
    },
    {
      "title": "microcom",
      "level": 4,
      "content": "microcom Copy bytes from stdin to TTY and from TTY to stdout, its part of busybox\n\n```\n$ busybox microcom -s 115200 /dev/ttyACM0\n```\n\n"
    },
    {
      "title": "Graphical front-ends",
      "level": 3,
      "content": "- cutecom — A GUI enabled serial monitor.\n\n- PuTTY — A terminal integrated SSH/Telnet client.\n\n- moserial — A GTK-based serial terminal, primarily intended for technical users and hardware hackers who need to communicate with embedded systems, test equipment, and serial consoles.\n\n- gtkterm — GTKTerm is a simple, graphical serial port terminal emulator for Linux and possibly other POSIX-compliant operating systems. It can be used to communicate with all kinds of devices with a serial interface, such as embedded computers, microcontrollers, modems, GPS receivers, CNC machines and more.\n\n"
    },
    {
      "title": "Windows clients",
      "level": 3,
      "content": "On Windows machines, connect to the serial port using programs like PuTTY or Terminalbpp.\n\n"
    },
    {
      "title": "Installing Arch Linux using the serial console",
      "level": 2,
      "content": "1. Connect to the target machine using the method described above.\n1. Boot the target machine using the Arch Linux installation medium.\n1. When the bootloader appears, select Boot Arch Linux (<arch>) and press Tab to edit\n1. Append console=ttyS0,115200 and press Enter.\n1. Now systemd should detect ttyS0 and spawn a serial getty on it. Login as root and start the installation as usual.\n\n- After setup is complete, the console settings will not be saved on the target machine; in order to avoid having to connect a keyboard and monitor, configure console access on the target machine before rebooting.\n- While a port speed of 9600 is used in most of the examples in this document, working with higher values is recommended (List of available speeds is displayed in Minicom by pressing Ctrl+a and then p)\n\n"
    },
    {
      "title": "Debugging an unresponsive machine using a serial console",
      "level": 2,
      "content": "Even though [4] has only raw and terse instructions, it presents the full scene. It is important to note that here, the machine under test got unresponsive in a reproducible manner. And that it happened during normal operation. So it could be accessed normally before it needed debugging. However, in general, the serial console is also useful for debugging boot issues. Perhaps by configuring the boot loader by hand at machine startup time. Also note the mentioned netconsole within the P.S paragraph of the external link from this section.\n\n"
    },
    {
      "title": "Ctrl+c and Minicom",
      "level": 3,
      "content": "If you are having trouble sending a Ctrl+c command through minicom you need to switch off hardware flow control in the device settings (minicom -s), which then enables the break.\n\n"
    },
    {
      "title": "Resizing a terminal",
      "level": 3,
      "content": "Unlike ssh, serial connections do not have a mechanism to transfer something like SIGWINCH when a terminal is resized. This can cause weird problems with some full-screen programs (e.g. less) when you resize your terminal emulator's window.\n\nResizing the terminal via stty is a workaround:\n\n```\n$ stty rows lines cols columns\n```\n\nHowever, this requires you to manually input the proper geometry. The following methods should be simpler.\n\n1. There is a lesser-known utility called resize, shipped with xterm, that can solve this problem. Invoke it without parameters after you resize the terminal emulator's window:\n\n```\n$ resize\n```\n\n2. If you do not want to install xterm, it is possible to do the same work via a shell function. Put the following function into your bash/zshrc and invoke it without parameters after resizing the terminal emulator's window:\n\n```\nrsz() {\n\tif [[ -t 0 && $# -eq 0 ]];then\n\t\tlocal IFS='[;' escape geometry x y\n\t\techo -ne '\\e7\\e[r\\e[999;999H\\e[6n\\e8'\n\t\tread -t 5 -sd R escape geometry || {\n\t\t\techo unsupported terminal emulator. >&2\n\t\t\treturn 1\n\t\t}\n\t\tx=\"${geometry##*;}\" y=\"${geometry%%;*}\"\n\t\tif [[ ${COLUMNS} -eq \"${x}\" && ${LINES} -eq \"${y}\" ]];then\n\t\t\techo \"${TERM} ${x}x${y}\"\n\t\telif [[ \"$x\" -gt 0 && \"$y\" -gt 0 ]];then\n\t\t\techo \"${COLUMNS}x${LINES} -> ${x}x${y}\"\n\t\t\tstty cols ${x} rows ${y}\n\t\telse\n\t\t\techo unsupported terminal emulator. >&2\n\t\t\treturn 1\n\t\tfi\n\telse\n\t\techo 'Usage: rsz'\n\tfi\n}\n```\n\n"
    },
    {
      "title": "Extra hardware serial ports",
      "level": 3,
      "content": "The generic 8250 serial driver exposes 32 hardware serial ports, as set in the Arch kernel configuration. This means by default serial ports are created numbered from /dev/ttyS0 to /dev/ttyS31. On most systems many of these ports will be non-functional.\n\nThe number can be reduced by setting the kernel parameter 8250.nr_uarts. E.g.:\n\n```\n8250.nr_uarts=5\n```\n\nThis value must be set as a kernel boot parameter not a module option, as the serial8250 driver is compiled into the kernel image.\n\n"
    }
  ]
}