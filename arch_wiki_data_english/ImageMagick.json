{
  "title": "ImageMagick",
  "url": "https://wiki.archlinux.org/title/ImageMagick",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "According to Wikipedia:\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the imagemagick package. Alternatively install graphicsmagick for GraphicsMagick, a fork of ImageMagick, emphasizing stability of the API and command-line interface.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "See ImageMagick(1), or gm(1) for GraphicsMagick.\n\n- ImageMagick at /usr/share/doc/ImageMagick-7/www/index.html\n- GraphicsMagick at /usr/share/doc/GraphicsMagick/www/index.html\n\n"
    },
    {
      "title": "Convert between image formats",
      "level": 4,
      "content": "The basic usage of this facility is to specify the existing, and desired, image formats as the filename extension. For example, to get the .jpg representation of a given .png image, use:\n\n```\n$ magick image.png image.jpg\n```\n\n"
    },
    {
      "title": "Append",
      "level": 4,
      "content": "Combining multiple pictures into one:\n\n```\n$ magick -append input.pngs output.png\n```\n\n"
    },
    {
      "title": "Crop, chop",
      "level": 4,
      "content": "To crop part of multiple images and convert them to another format:\n\n```\n$ mogrify -crop WIDTHxHEIGHT+X+Y -format jpg *.png\n```\n\nWhere WIDTH and HEIGHT is the cropped output image size, and X and Y is the offset from the input image size.\n\nOne can also -chop to cut of a single edge from an image, using gravity to select that edge. Which is easier as less numbers, or trial and error, is involved.\n\n```\n$ magick frame_red.gif -gravity South -chop 0x10 chop_bottom.gif\n```\n\n"
    },
    {
      "title": "Limit the storage size",
      "level": 4,
      "content": "To achieve reasonable quality for a given storage size:\n\n```\n$ magick image.jpg -define jpeg:extent=3000KB image_small.jpg\n```\n\nHopefully, this will shorten the transmission time. Note that -quality, as in\n\n```\n$ magick image.jpg -quality 85% image_small.jpg\n```\n\nis harder to use when the correlation between quality and storage size is not clear.\n\n"
    },
    {
      "title": "Screenshot taking",
      "level": 3,
      "content": "An easy way to take a screenshot of your current system is using the import(1) command:\n\n```\n$ import -window root screenshot.jpg\n```\n\nRunning import without the -window option allows selecting a window or an arbitrary region interactively. With -pause you can specify a delay in which you can, for example, lower some windows.\n\nNote: **graphicsmagick** \n\n"
    },
    {
      "title": "Screenshot of multiple X screens",
      "level": 4,
      "content": "If you run twinview or dualhead, simply take the screenshot twice and use imagemagick to paste them together:\n\n```\n$ import -window root -display :0.0 -screen /tmp/0.png\n$ import -window root -display :0.1 -screen /tmp/1.png\n$ convert +append /tmp/0.png /tmp/1.png screenshot.png\n$ rm /tmp/{0,1}.png\n```\n\n"
    },
    {
      "title": "Screenshot of individual Xinerama heads",
      "level": 4,
      "content": "Xinerama-based multi-head setups have only one virtual screen. If the physical screens are different in height, you will find dead space in the screenshot. In this case, you may want to take screenshot of each physical screen individually. As long as Xinerama information is available from the X server, the following will work:\n\n```\n#!/bin/sh\nxdpyinfo -ext XINERAMA | sed '/^  head #/!d;s///' |\nwhile IFS=' :x@,' read i w h x y; do\n        import -window root -crop ${w}x$h+$x+$y head_$i.png\ndone\n```\n\n"
    },
    {
      "title": "Screenshot of the active/focused window",
      "level": 4,
      "content": "The following script takes a screenshot of the currently focused window. It works with EWMH/NetWM compatible X Window Managers. To avoid overwriting previous screenshots, the current date is used as the filename.\n\n```\n#!/bin/sh\nactiveWinLine=$(xprop -root | grep \"_NET_ACTIVE_WINDOW(WINDOW)\")\nactiveWinId=${activeWinLine:40}\nimport -window \"$activeWinId\" /tmp/$(date +%F_%H%M%S_%N).png\n```\n\nAlternatively, the following should work regardless of EWMH support:\n\n```\n$ import -window \"$(xdotool getwindowfocus -f)\" /tmp/$(date +%F_%H%M%S_%N).png\n```\n\n"
    },
    {
      "title": "Encryption of image data",
      "level": 3,
      "content": "To encrypt:\n\n```\n$ echo pass_phrase | magick image.jpg -encipher - -depth 8 png24:image.png\n```\n\nThis can be decrypted by:\n\n```\n$ echo pass_phrase | magick image.png -decipher - image.jpg\n```\n\nIt is highly advised to read the discussion at Encrypting Images for all sorts of issues, and suggestions, for such commands.\n\nMetadata of image formats that have the cipher tag can be used to test for encryption. However, it could be removed or spoofed by an EXIF editing program.\n\n```\n$ identify -verbose image.png\n```\n\nIn general, testing if a raster image was encrypted can be done by checking the distribution of the pixel components. If it exceeds a certain threshold, the data could be considered random and a possible candidate for encryption. However, an example for false positives are images created with the Diamond-square algorithm.\n\n"
    },
    {
      "title": "Create a PDF from images",
      "level": 2,
      "content": "See PDF, PS and DjVu#Create a PDF from images. For some background, a stackexchange thread.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- ImageMagick website for an extensive list of options, examples and showcase.\n- List of applications/Multimedia#Image processing\n- Fred's ImageMagick Scripts for large collection of ImageMagic scripts\n\n"
    }
  ]
}