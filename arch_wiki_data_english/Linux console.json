{
  "title": "Linux console",
  "url": "https://wiki.archlinux.org/title/Linux_console",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- /Keyboard configuration\n- Screen capture#Virtual console\n- Color output in console\n- getty\n\nAccording to Wikipedia:\n\nThis article describes the basics of the Linux console and how to configure the font display. Keyboard configuration is described in the /Keyboard configuration subpage. For alternative console solutions offering more features (full Unicode fonts, modern graphics adapters etc.), see KMSCON or similar projects.\n\n"
    },
    {
      "title": "Implementation",
      "level": 2,
      "content": "The console, unlike most services that interact directly with users, is implemented in the kernel. This contrasts with terminal emulation software, such as Xterm, which is implemented in user space as a normal application. The console has always been part of released Linux kernels, but has undergone changes in its history, most notably the transition to using the framebuffer and support for Unicode.\n\nDespite many improvements in the console, its full backward compatibility with legacy hardware means it is limited compared to a graphical terminal emulator. The main difference between the Linux console and graphical terminal emulators is the shells in the Linux console are attached directly to TTY devices (/dev/tty*), whereas the shells in a graphical terminal emulator are attached to pseudo-TTYs (/dev/pty*).\n\nAlso, graphical terminal emulators can have many more features than the Linux console, including a richer set of available fonts, multiple tabs/windows, split views, scrollback buffers/sliders, background colors/images (optionally with transparency), etc. Some of these features can be used in the Linux console with terminal multiplexers, such as Tmux or GNU Screen, or in certain text user interface programs (TUI) typically relying on libraries such as ncurses and the like, e.g. Vim, nano, or Emacs. These can also be used in graphical terminal emulators, if desired.\n\n"
    },
    {
      "title": "Virtual consoles",
      "level": 3,
      "content": "The console is presented to the user as a series of virtual consoles. These give the impression that several independent terminals are running concurrently; each virtual console can be logged in with different users, run its own shell and have its own font settings. The virtual consoles each use a device /dev/ttyX, and you can switch between them by pressing Alt+Fx (where x is equal to the virtual console number, beginning with 1). The device /dev/console is automatically mapped to the active virtual console.\n\nSee also chvt(1), openvt(1) and deallocvt(1).\n\n"
    },
    {
      "title": "Text mode",
      "level": 3,
      "content": "Since Linux originally began as a kernel for PC hardware, the console was developed using standard IBM CGA/EGA/VGA graphics, which all PCs supported at the time. The graphics operated in VGA text mode, which provides a simple 80x25 character display with 16 colours. This legacy mode is similar to the capabilities of dedicated text terminals, such as the DEC VT100 series. It is still possible to boot in text mode (with vga=0 nomodeset) if the system hardware supports it, but almost all modern distributions (including Arch Linux) use the framebuffer console instead.\n\n"
    },
    {
      "title": "Framebuffer console",
      "level": 3,
      "content": "As Linux was ported to other non-PC architectures, a better solution was required, since other architectures do not use VGA-compatible graphics adapters, and may not support text modes at all. The framebuffer console was implemented to provide a standard console across all platforms, and so presents the same VGA-style interface regardless of the underlying graphics hardware. As such, the Linux console is not a terminal emulator, but a terminal in its own right. It uses the terminal type linux, and is largely compatible with VT100.\n\n"
    },
    {
      "title": "Keyboard shortcuts",
      "level": 2,
      "content": "Table content:\nKeyboard Shortcut | Description\nCtrl+Alt+Del | Reboots the system (specified by the symlink /usr/lib/systemd/system/ctrl-alt-del.target)\nAlt+F1, F2, F3, ... | Switch to n-th virtual console (not to be confused with Ctrl+Alt+Fn used in Xorg and Wayland)\nAlt+Left | Switch to previous virtual console\nAlt+Right | Switch to next virtual console\nScroll Lock | When Scroll Lock is activated, input/output is locked\nCtrl+c | Kills current task\nCtrl+d | Inserts an EOF\nCtrl+z | Pauses current Task\n\nSee also console_codes(4).\n\n"
    },
    {
      "title": "Fonts",
      "level": 2,
      "content": "The Linux console uses UTF-8 encoding by default, but because the standard VGA-compatible framebuffer is used, a console font is limited to either a standard 256, or 512 glyphs. If the font has more than 256 glyphs, the number of colours is reduced from 16 to 8. In order to assign correct symbol to be displayed to the given Unicode value, a special translation map, often called unimap, is needed. Nowadays, most of the console fonts have the unimap built-in; historically, it had to be loaded separately.\n\nBy default, the virtual console uses the kernel built-in font with a CP437 character set[1], but this can be easily changed. The kernel offers about 15 built in fonts to choose from, from which the officially supported kernels provide two: VGA 8x16 font (CONFIG_FONT_8x16) and Terminus 16x32 font (CONFIG_FONT_TER16x32). The kernel chooses the one to use based on its evaluation of the screen resolution. Another builtin font can be forced upon by kernel parameters boot parameter setting such as fbcon=font:TER16x32.\n\nThe kbd package provides tools to override the kernel decision for virtual console font and font mapping. Available fonts are provided in the /usr/share/kbd/consolefonts/ directory; those ending with .psfu or .psfu.gz have a Unicode translation map built-in.\n\nKeymaps, the connection between the key pressed and the character used by the computer, are found in the subdirectories of /usr/share/kbd/keymaps/; see /Keyboard configuration for details.\n\n"
    },
    {
      "title": "Preview and temporary changes",
      "level": 3,
      "content": "```\n$ showconsolefont\n```\n\nshows a table of glyphs or letters of a font.\n\nsetfont temporarily changes the font if passed a font name (in /usr/share/kbd/consolefonts/) such as\n\n```\n$ setfont lat2-16 -m 8859-2\n```\n\nFont names are case-sensitive. With no parameter, setfont returns the console to the default font.\n\nSo to have a small 8x8 font, with that font installed like seen below, use e.g.:\n\n```\n$ setfont -h8 /usr/share/kbd/consolefonts/drdos8x8.psfu.gz\n```\n\nTo have a bigger font, the Terminus font (terminus-font) is available in many sizes, such as ter-132b which is large.\n\nYou can also append -d for double size. This would be using a 64*64 font:\n\n```\n$ setfont -d ter-132n\n```\n\n- All font changing commands can be typed in \"blind\".\n- The Terminus font names (ter-*) are explained in /usr/share/terminus-font/README.\n\n"
    },
    {
      "title": "Persistent configuration",
      "level": 3,
      "content": "The FONT variable in /etc/vconsole.conf is used to set the font at boot, persistently for all consoles. See vconsole.conf(5) for details.\n\nFor displaying characters such as Č, ž, đ, š or Ł, ę, ą, ś using the font lat2-16.psfu.gz:\n\n```\n/etc/vconsole.conf\n```\n\n```\n...\nFONT=lat2-16\nFONT_MAP=8859-2\n```\n\nIt means that second part of ISO/IEC 8859 characters are used with size 16. You can change font size using other values (e.g. lat2-08). For the regions determined by 8859 specification, look at the Wikipedia:ISO/IEC 8859#The parts of ISO/IEC 8859.\n\nSince mkinitcpio v33, the font specified in /etc/vconsole.conf gets automatically loaded during early userspace by default via the consolefont hook, which adds the font to the initramfs. See Mkinitcpio#HOOKS for more information.\n\nYou may also need to restart systemd-vconsole-setup.service after changing /etc/vconsole.conf.\n\nIf the fonts appear to not change on boot, or change only temporarily, it is most likely that they got reset when graphics driver was initialized and console was switched to framebuffer. By default, all in-tree kernel drivers are loaded early, NVIDIA users should see NVIDIA#Early loading to load their graphics driver before /etc/vconsole.conf is applied.\n\n"
    },
    {
      "title": "Cursor appearance",
      "level": 2,
      "content": "This subject is poorly documented. You should read the following articles:\n\n- Software cursor for VGA\n- Cursor Appearance in the Linux Console\n- Disable Cursor Blinking on Linux Console\n\nTable content:\n | Hardware | Software\nShape | (0) default applies (2) underscore (1) invisible (2) underscore (3) lower third (4) lower half (5) two thirds (6) full block | (16) full block the shape can't be changed, but the cursor can effectively be invisible in case of background and foreground colors are equal\nBlinking | blinks | driver-dependent the highest bit of background color can be interpreted as \"bright\" or as \"blinking\"\nColor | the same as console text color (usually white/gray) can't be set independently | can be set by a user\n\nThe console cursor can be adjusted with Device Attributes (DA) control function. The sequence of parameters must be preceded by a single question mark (despite console_codes(4) says the opposite).\n\nHere is an example for full block non-blinking green cursor with black symbols under it:\n\n```\n$ printf \"\\x1b\\x5b?16;$((8+4+2+1));$((32+0+8+4+2+1))\\x63\"\n```\n\nThe same can be expressed with the octal and characters instead of hex codes:\n\n```\n$ printf '\\033[?16;15;47c'\n```\n\nThe same can be applied as permanent configuration with kernel parameter:\n\n```\nvt.cur_default=0x2f0f10\n```\n\nNote: **16, 15, 47** \n\n"
    },
    {
      "title": "Cursor size",
      "level": 3,
      "content": "The first parameter, despite it's name cursor size, with number 16 (the rightmost two hex digits of the kernel parameter are 10) means \"use software cursor.\"\n\nNote: **48** \n\nIf you want to change hardware cursor shape - use corresponding number (from 0 to 6, see the table above).\n\n"
    },
    {
      "title": "Toggle mask",
      "level": 3,
      "content": "The second parameter, called toggle mask, flips corresponding bits of the color.\n\nTable content:\n | Background (cursor block) | Foreground (symbol under the cursor)\n | Bright (highlight) or blinking | Red | Green | Blue | Bright (highlight) or blinking | Red | Green | Blue\nDecimals | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1\nHex | 80 | 40 | 20 | 10 | 8 | 4 | 2 | 1\n\n(cursor block)\n\n(symbol under the cursor)\n\nor blinking\n\nor blinking\n\nIn our case the second parameter is 15 (the middle hex digits of the kernel parameter are 0f), so all four foreground (symbol) bits will be flipped. The most important rule is: toggling (the second parameter) is applied after the setting (the third parameter).\n\nNote: **and** \n\n"
    },
    {
      "title": "Set mask",
      "level": 3,
      "content": "The third parameter is called set mask. It sets corresponding character attribute bits. We use 47 (the leftmost hex digits of the kernel parameter are 2f) in our example, which means two things:\n\n- (32) use pure green color for cursor block\n- (8+4+2+1) set all four foreground (symbol color) bits. These bits will be toggled by the second parameter, so the color of the symbol under the cursor will be black (0000).\n\n"
    },
    {
      "title": "HiDPI",
      "level": 2,
      "content": "See HiDPI#Linux console (tty).\n\n"
    },
    {
      "title": "Audible tones",
      "level": 2,
      "content": "See PC speaker#Beep.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- The TTY demystified – Linus Åkesson\n\n"
    }
  ]
}