{
  "title": "Nginx",
  "url": "https://wiki.archlinux.org/title/Nginx",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "nginx (pronounced \"engine X\"), is a free, open-source, high-performance HTTP web server and reverse proxy, as well as an IMAP/POP3 proxy server, written by Igor Sysoev in 2005. nginx is well known for its stability, rich feature set, simple configuration, and low resource consumption.\n\nThis article describes how to set up nginx and how to optionally integrate it with PHP via #FastCGI.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install one of the following packages:\n\n- nginx-mainline - mainline branch: new features, updates, bugfixes.\n- nginx - stable branch: major bugfixes only.\n- angieAUR - fork and drop-in replacement for nginx with more features.\n- freenginx-mainlineAUR - drop-in replacement that preserves the free and open development of nginx (mainline branch).\n- freenginx-libresslAUR - drop-in replacement that preserves the free and open development of nginx (mainline branch with LibreSSL support).\n- freenginxAUR - drop-in replacement that preserves the free and open development of nginx (stable branch).\n\nUsing the mainline branch is recommended. The main reason to use the stable branch is that you are concerned about possible impacts of new features, such as incompatibility with third-party modules or the inadvertent introduction of bugs in new features.\n\nFor a chroot-based installation for additional security, see #Installation in a chroot.\n\n"
    },
    {
      "title": "Running",
      "level": 2,
      "content": "Start/enable nginx.service or angie.service if you use Angie.\n\nThe default page served at http://127.0.0.1 is /usr/share/nginx/html/index.html.\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "First steps with nginx are described in the Beginner’s Guide. You can modify the configuration by editing the files in /etc/nginx/ The main configuration file is located at /etc/nginx/nginx.conf.\n\nMore details and examples can be found in the official documentation.\n\nThe examples below cover the most common use cases. It is assumed that you use the default location for documents (/usr/share/nginx/html). If that is not the case, substitute your path instead.\n\n"
    },
    {
      "title": "Configuration example",
      "level": 3,
      "content": "```\n/etc/nginx/nginx.conf\n```\n\n```\nuser http;\nworker_processes auto;\nworker_cpu_affinity auto;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    charset utf-8;\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    server_tokens off;\n    log_not_found off;\n    types_hash_max_size 4096;\n    client_max_body_size 16M;\n\n    # MIME\n    include mime.types;\n    default_type application/octet-stream;\n\n    # logging\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log warn;\n\n    # load configs\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n}\n```\n\n"
    },
    {
      "title": "Processes and connections",
      "level": 4,
      "content": "You should choose a fitting value for worker_processes. This setting ultimately defines how many connections nginx will accept and how many processors it will be able to make use of. Generally, making it the number of hardware threads in your system is a good start. Alternatively, worker_processes accepts the auto value since versions 1.3.8 and 1.2.5, which will try to autodetect the optimal value (source).\n\nThe maximum connections nginx will accept is given by max_clients = worker_processes * worker_connections.\n\n"
    },
    {
      "title": "Running under different user",
      "level": 4,
      "content": "By default, nginx runs the master process as root and worker processes as user http. To run worker processes as another user, change the user directive in nginx.conf:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nuser user [group];\n```\n\nIf the group is omitted, a group whose name equals that of user is used.\n\n"
    },
    {
      "title": "Server blocks",
      "level": 4,
      "content": "It is possible to serve multiple domains using server blocks. These are comparable to \"VirtualHosts\" in Apache HTTP Server. Also see the upstream examples.\n\nIn the example below the server listens for incoming connections on IPv4 and IPv6 ports 80 for two domains, domainname1.tld and domainname2.tld:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\n...\nserver {\n    listen 80;\n    listen [::]:80;\n    server_name domainname1.tld;\n    root /usr/share/nginx/domainname1.tld/html;\n    location / {\n        index index.php index.html index.htm;\n    }\n}\n\nserver {\n    listen 80;\n    listen [::]:80;\n    server_name domainname2.tld;\n    root /usr/share/nginx/domainname2.tld/html;\n    ...\n}\n```\n\nRestart nginx.service to apply any changes.\n\nIt is possible to put different server blocks in different files. This allows you to easily enable or disable certain sites.\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nInstead, one can just create files inside etc/nginx/conf.d/ which adheres to the standard of drop in configuration files. Then, include include /etc/nginx/conf.d/*.conf in the main config file, similar to including other file patterns in other directories as shown below. This way, sites can be disabled just be renaming them to e.g. original_name.conf.disabled, since only files ending in .conf are included.\n\nFor using the sites-enabled and sites-available approach, create the following directories:\n\n```\n# mkdir /etc/nginx/sites-available\n# mkdir /etc/nginx/sites-enabled\n```\n\nCreate a file inside the sites-available directory that contains one or more server blocks:\n\n```\n/etc/nginx/sites-available/example.conf\n```\n\n```\nserver {\n    listen 443 ssl;\n    listen [::]:443 ssl;\n    http2 on;\n\n    ...\n}\n```\n\nAppend include sites-enabled/*; to the end of the http block:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nhttp {\n    ...\n    include sites-enabled/*;\n}\n```\n\nTo enable a site, simply create a symlink:\n\n```\n# ln -s /etc/nginx/sites-available/example.conf /etc/nginx/sites-enabled/example.conf\n```\n\nTo disable a site, unlink the active symlink:\n\n```\n# unlink /etc/nginx/sites-enabled/example.conf\n```\n\nReload/restart nginx.service to enable changes to the site's configuration.\n\n"
    },
    {
      "title": "TLS",
      "level": 4,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nOpenSSL provides TLS support and is installed by default on Arch installations.\n\n- You may want to read the ngx_http_ssl_module documentation first before configuring SSL.\n- Let’s Encrypt is a free, automated, and open certificate authority. A plugin is available to request valid SSL certificates straight from the command line and automatic configuration.\n- Mozilla has a useful TLS article as well as an automated tool to help create a more secure configuration.\n\nCreate a private key and self-signed certificate. This is adequate for most installations that do not require a CSR:\n\n```\n# mkdir /etc/nginx/ssl\n# cd /etc/nginx/ssl\n# openssl req -new -x509 -nodes -newkey rsa:4096 -keyout server.key -out server.crt -days 1095\n# chmod 400 server.key\n# chmod 444 server.crt\n```\n\nIf you need to create a CSR, follow these instructions instead of the above:\n\n```\n# mkdir /etc/nginx/ssl\n# cd /etc/nginx/ssl\n# openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -out server.key\n# chmod 400 server.key\n# openssl req -new -sha256 -key server.key -out server.csr\n# openssl x509 -req -days 1095 -in server.csr -signkey server.key -out server.crt\n```\n\nA starting point for a /etc/nginx/nginx.conf with TLS is Mozilla's SSL Configuration Generator.\n\nRestart nginx.service to apply any changes.\n\n"
    },
    {
      "title": "Per-user directories",
      "level": 4,
      "content": "To replicate Apache-style ~user URLs to users' ~/public_html directories, try the following. (Note: if both rules are used, below, the more-specific PHP rule must come first.)\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\n...\nserver {\n    ...\n    # PHP in user directories, e.g. http://example.com/~user/test.php\n    location ~ ^/~(.+?)(/.+\\.php)$ {\n        alias          /home/$1/public_html$2;\n        fastcgi_pass   unix:/run/php-fpm/php-fpm.sock;\n        fastcgi_index  index.php;\n        include        fastcgi.conf;\n    }\n\n    # User directories, e.g. http://example.com/~user/\n    location ~ ^/~(.+?)(/.*)?$ {\n        alias     /home/$1/public_html$2;\n        index     index.html index.htm;\n        autoindex on;\n    }\n    ...\n}\n...\n```\n\nSee #PHP implementation for more information on PHP configuration with nginx.\n\nRestart nginx.service to enable the new configuration.\n\n"
    },
    {
      "title": "FastCGI",
      "level": 3,
      "content": "FastCGI, also FCGI, is a protocol for interfacing interactive programs with a web server. FastCGI is a variation on the earlier Common Gateway Interface (CGI); FastCGI's main aim is to reduce the overhead associated with interfacing the web server and CGI programs, allowing servers to handle more web page requests at once.\n\nFastCGI technology is introduced into nginx to work with many external tools, e.g. Perl, PHP and Python.\n\n"
    },
    {
      "title": "PHP implementation",
      "level": 4,
      "content": "PHP-FPM is the recommended solution to run as FastCGI server for PHP.\n\nInstall php-fpm and make sure PHP has been installed and configured correctly. The main configuration file of PHP-FPM is /etc/php/php-fpm.conf. For basic usage the default configuration should be sufficient.\n\nFinally, start/enable php-fpm.service.\n\nYou can also use php-legacy-fpm instead, see #Using php-legacy.\n\n- If you run nginx under a different user, make sure that the PHP-FPM socket file is accessible by this user, or use a TCP socket.\n- If you run nginx in chrooted environment (chroot is /srv/nginx-jail, web pages are served at /srv/nginx-jail/www), you must modify the file /etc/php/php-fpm.conf to include the chroot = /srv/nginx-jail and listen = /srv/nginx-jail/run/php-fpm/php-fpm.sock directives within the pool section (a default one is [www]). Create the directory for the socket file, if missing. Moreover, for modules that are dynamically linked to dependencies, you will need to copy those dependencies to the chroot (e.g. for php-imagick, you will need to copy the ImageMagick libraries to the chroot, but not imagick.so itself).\n\nWhen serving a PHP web-application, a location for PHP-FPM should to be included in each server block [2], e.g.:\n\n```\n/etc/nginx/sites-available/example.conf\n```\n\n```\nserver {\n    root /usr/share/nginx/html;\n\n    location / {\n        index index.html index.htm index.php;\n    }\n\n    location ~ \\.php$ {\n        # 404\n        try_files $fastcgi_script_name =404;\n\n        # default fastcgi_params\n        include fastcgi_params;\n\n        # fastcgi settings\n        fastcgi_pass\t\t\tunix:/run/php-fpm/php-fpm.sock;\n        fastcgi_index\t\t\tindex.php;\n        fastcgi_buffers\t\t\t8 16k;\n        fastcgi_buffer_size\t\t32k;\n\n        # fastcgi params\n        fastcgi_param DOCUMENT_ROOT\t$realpath_root;\n        fastcgi_param SCRIPT_FILENAME\t$realpath_root$fastcgi_script_name;\n        #fastcgi_param PHP_ADMIN_VALUE\t\"open_basedir=$base/:/usr/lib/php/:/tmp/\";\n    }\n}\n```\n\nIf it is needed to process other extensions with PHP (e.g. .html and .htm):\n\n```\nlocation ~ [^/]\\.(php|html|htm)(/|$) {\n    ...\n}\n```\n\nNon .php extension processing in PHP-FPM should also be explicitly added in /etc/php/php-fpm.d/www.conf:\n\n```\nsecurity.limit_extensions = .php .html .htm\n```\n\nNote: **default** You might use the common TCP socket, not default,\n\n```\nfastcgi_pass unix:/run/php-fpm/php-fpm.sock;\n```\n\nYou might use the common TCP socket, not default,\n\n```\nfastcgi_pass 127.0.0.1:9000;\n```\n\nNote: To enable PHP support for a particular server, simply include the php_fastcgi.conf configuration file:\n\n```\n/etc/nginx/php_fastcgi.conf\n```\n\n```\nlocation ~ \\.php$ {\n    # 404\n    try_files $fastcgi_script_name =404;\n\n    # default fastcgi_params\n    include fastcgi_params;\n\n    # fastcgi settings\n    ...\n}\n```\n\nTo enable PHP support for a particular server, simply include the php_fastcgi.conf configuration file:\n\n```\n/etc/nginx/sites-available/example.conf\n```\n\n```\nserver {\n    server_name example.com;\n    ...\n\n    include /etc/nginx/php_fastcgi.conf;\n}\n```\n\nYou need to restart the php-fpm.service and nginx.service units if the configuration has been changed in order to apply changes.\n\nTo test the FastCGI implementation, create a new PHP file inside the root folder containing:\n\n```\n<?php phpinfo(); ?>\n```\n\nNavigate this file inside a browser and you should see the informational page with the current PHP configuration.\n\n"
    },
    {
      "title": "CGI implementation",
      "level": 4,
      "content": "This implementation is needed for CGI applications.\n\nInstall fcgiwrap. The configuration is done by editing fcgiwrap.socket. Enable and start fcgiwrap.socket.\n\nIf you want to spawn multiple worker threads, it is recommended that you use multiwatchAUR, which will take care of restarting crashed children. You will need to use spawn-fcgi to create the Unix socket, as multiwatch seems unable to handle the systemd-created socket, even though fcgiwrap itself does not have any trouble if invoked directly in the unit file.\n\nOverride the unit fcgiwrap.service (and the fcgiwrap.socket unit, if present), and modify the ExecStart line to suit your needs. Here is a unit file that uses multiwatchAUR. Make sure fcgiwrap.socket is not started or enabled, because it will conflict with this unit:\n\n```\n/etc/systemd/system/fcgiwrap.service\n```\n\n```\n[Unit]\nDescription=Simple CGI Server\nAfter=nss-user-lookup.target\n\n[Service]\nExecStartPre=/bin/rm -f /run/fcgiwrap.socket\nExecStart=/usr/bin/spawn-fcgi -u http -g http -s /run/fcgiwrap.sock -n -- /usr/bin/multiwatch -f 10 -- /usr/sbin/fcgiwrap\nExecStartPost=/usr/bin/chmod 660 /run/fcgiwrap.sock\nPrivateTmp=true\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target\n```\n\nTweak -f 10 to change the number of children that are spawned.\n\nIn /etc/nginx, copy the file fastcgi_params to fcgiwrap_params. In fcgiwrap_params, comment or delete the lines which set SCRIPT_NAME and DOCUMENT_ROOT.\n\nInside each server block serving a CGI web application should appear a location block similar to:\n\n```\nlocation ~ \\.cgi$ {\n     include       fcgiwrap_params;\n     fastcgi_param DOCUMENT_ROOT /srv/www/cgi-bin/;\n     fastcgi_param SCRIPT_NAME   myscript.cgi;\n     fastcgi_pass  unix:/run/fcgiwrap.sock;\n}\n```\n\nThe default socket file for fcgiwrap is /run/fcgiwrap.sock.\n\nUsing fastcgi_param SCRIPT_FILENAME /srv/www/cgi-bin/myscript.cgi is a shortcut alternative to setting DOCUMENT_ROOT and SCRIPT_NAME. If you use SCRIPT_FILENAME, you also will not need to copy fastcgi_params to fcgiwrap_params and comment out the DOCUMENT_ROOT and SCRIPT_NAME lines.\n\nIf you keep getting a 502 - bad Gateway error, you should check if your CGI-application first announces the mime-type of the following content. For HTML this needs to be Content-type: text/html.\n\nIf you get 403 errors, make sure that the CGI executable is readable and executable by the http user and that every parent folder is readable by the http user.\n\n"
    },
    {
      "title": "Installation in a chroot",
      "level": 2,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nInstalling nginx in a chroot adds an additional layer of security. For maximum security the chroot should include only the files needed to run the nginx server and all files should have the most restrictive permissions possible, e.g., as much as possible should be owned by root, directories such as /usr/bin should be unreadable and unwritable, etc.\n\nArch comes with an http user and group by default which will run the server. The chroot will be in /srv/http.\n\nA Perl script to create this jail is available at jail.pl gist. You can either use that or follow the instructions in this article. It expects to be run as root. You will need to uncomment a line before it makes any changes.\n\n"
    },
    {
      "title": "Create necessary devices",
      "level": 3,
      "content": "nginx needs /dev/null, /dev/random, and /dev/urandom. To install these in the chroot create the /dev/ directory and add the devices with mknod. Avoid mounting all of /dev/ to ensure that, even if the chroot is compromised, an attacker must break out of the chroot to access important devices like /dev/sda1.\n\n- Be sure that /srv/http is mounted without the nodev option\n- See mknod(1) and ls -l /dev/{null,random,urandom} to better understand the mknod options.\n\n```\n# export JAIL=/srv/http\n# mkdir $JAIL/dev\n# mknod -m 0666 $JAIL/dev/null c 1 3\n# mknod -m 0666 $JAIL/dev/random c 1 8\n# mknod -m 0444 $JAIL/dev/urandom c 1 9\n```\n\n"
    },
    {
      "title": "Create necessary directories",
      "level": 3,
      "content": "nginx requires a bunch of files to run properly. Before copying them over, create the folders to store them. This assumes your nginx document root will be /srv/http/www.\n\n```\n# mkdir -p $JAIL/etc/nginx/logs\n# mkdir -p $JAIL/usr/{lib,bin}\n# mkdir -p $JAIL/usr/share/nginx\n# mkdir -p $JAIL/var/{log,lib}/nginx\n# mkdir -p $JAIL/www/cgi-bin\n# mkdir -p $JAIL/{run,tmp}\n# cd $JAIL; ln -s usr/lib lib\n# cd $JAIL; ln -s usr/lib lib64\n# cd $JAIL/usr; ln -s lib lib64\n```\n\nThen mount $JAIL/tmp and $JAIL/run as tmpfs's. The size should be limited to ensure an attacker cannot eat all the RAM.\n\n```\n# mount -t tmpfs none $JAIL/run -o 'noexec,size=1M'\n# mount -t tmpfs none $JAIL/tmp -o 'noexec,size=100M'\n```\n\nIn order to preserve the mounts across reboots, the following entries should be added to /etc/fstab:\n\n```\n/etc/fstab\n```\n\n```\ntmpfs   /srv/http/run   tmpfs   rw,noexec,relatime,size=1024k   0       0\ntmpfs   /srv/http/tmp   tmpfs   rw,noexec,relatime,size=102400k 0       0\n```\n\n"
    },
    {
      "title": "Populate the chroot",
      "level": 3,
      "content": "First copy over the easy files.\n\n```\n# cp -r /usr/share/nginx/* $JAIL/usr/share/nginx\n# cp -r /usr/share/nginx/html/* $JAIL/www\n# cp /usr/bin/nginx $JAIL/usr/bin/\n# cp -r /var/lib/nginx $JAIL/var/lib/nginx\n```\n\nNow copy over required libraries. Use ldd to list them and then copy them all to the correct location. Copying is preferred over hardlinks to ensure that even if an attacker gains write access to the files they cannot destroy or alter the true system files.\n\n```\n$ ldd /usr/bin/nginx\n```\n\n```\nlinux-vdso.so.1 (0x00007fffc41fe000)\nlibpthread.so.0 => /usr/lib/libpthread.so.0 (0x00007f57ec3e8000)\nlibcrypt.so.1 => /usr/lib/libcrypt.so.1 (0x00007f57ec1b1000)\nlibstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x00007f57ebead000)\nlibm.so.6 => /usr/lib/libm.so.6 (0x00007f57ebbaf000)\nlibpcre.so.1 => /usr/lib/libpcre.so.1 (0x00007f57eb94c000)\nlibssl.so.1.0.0 => /usr/lib/libssl.so.1.0.0 (0x00007f57eb6e0000)\nlibcrypto.so.1.0.0 => /usr/lib/libcrypto.so.1.0.0 (0x00007f57eb2d6000)\nlibdl.so.2 => /usr/lib/libdl.so.2 (0x00007f57eb0d2000)\nlibz.so.1 => /usr/lib/libz.so.1 (0x00007f57eaebc000)\nlibGeoIP.so.1 => /usr/lib/libGeoIP.so.1 (0x00007f57eac8d000)\nlibgcc_s.so.1 => /usr/lib/libgcc_s.so.1 (0x00007f57eaa77000)\nlibc.so.6 => /usr/lib/libc.so.6 (0x00007f57ea6ca000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f57ec604000)\n```\n\nFor files residing in /usr/lib you may try the following one-liner:\n\n```\n# cp $(ldd /usr/bin/nginx | grep /usr/lib/ | sed -sre 's/(.+)(\\/usr\\/lib\\/\\S+).+/\\2/g') $JAIL/usr/lib\n```\n\nAnd the following for ld-linux-x86-64.so:\n\n```\n# cp /lib64/ld-linux-x86-64.so.2 $JAIL/lib\n```\n\nCopy over some miscellaneous but necessary libraries and system files.\n\n```\n# cp /usr/lib/libnss_* $JAIL/usr/lib\n# cp -rfvL /etc/{services,localtime,nsswitch.conf,nscd.conf,protocols,hosts,ld.so.cache,ld.so.conf,resolv.conf,host.conf,nginx} $JAIL/etc\n```\n\nCreate restricted user/group files for the chroot. This way only the users needed for the chroot to function exist as far as the chroot knows, and none of the system users/groups are leaked to attackers should they gain access to the chroot.\n\n```\n$JAIL/etc/group\n```\n\n```\nhttp:x:33:\nnobody:x:99:\n```\n\n```\n$JAIL/etc/passwd\n```\n\n```\nhttp:x:33:33:http:/:/bin/false\nnobody:x:99:99:nobody:/:/bin/false\n```\n\n```\n$JAIL/etc/shadow\n```\n\n```\nhttp:x:14871::::::\nnobody:x:14871::::::\n```\n\n```\n$JAIL/etc/gshadow\n```\n\n```\nhttp:::\nnobody:::\n```\n\n```\n# touch $JAIL/etc/shells\n# touch $JAIL/run/nginx.pid\n```\n\nFinally, make set very restrictive permissions. As much as possible should be owned by root and set unwritable.\n\n```\n# chown -R root:root $JAIL/\n\n# chown -R http:http $JAIL/www\n# chown -R http:http $JAIL/etc/nginx\n# chown -R http:http $JAIL/var/{log,lib}/nginx\n# chown http:http $JAIL/run/nginx.pid\n\n# find $JAIL/ -gid 0 -uid 0 -type d -print | xargs chmod -rw\n# find $JAIL/ -gid 0 -uid 0 -type d -print | xargs chmod +x\n# find $JAIL/etc -gid 0 -uid 0 -type f -print | xargs chmod -x\n# find $JAIL/usr/bin -type f -print | xargs chmod ug+rx\n# find $JAIL/ -group http -user http -print | xargs chmod o-rwx\n# chmod +rw $JAIL/tmp\n# chmod +rw $JAIL/run\n```\n\nIf your server will bind port 80 (or any other port in range [1-1023]), give the chrooted executable permission to bind these ports without root.\n\n```\n# setcap 'cap_net_bind_service=+ep' $JAIL/usr/bin/nginx\n```\n\n"
    },
    {
      "title": "Modify nginx.service to start chroot",
      "level": 3,
      "content": "Override the unit nginx.service. Upgrading nginx will not modify your custom .service file.\n\nThe systemd unit must be changed to start up nginx in the chroot, as the http user, and store the PID file in the chroot.\n\n```\n/etc/systemd/system/nginx.service\n```\n\n```\n[Unit]\nDescription=A high performance web server and a reverse proxy server\nAfter=network.target\n\n[Service]\nType=forking\nPIDFile=/srv/http/run/nginx.pid\nExecStartPre=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -t -q -g 'pid /run/nginx.pid; daemon on; master_process on;'\nExecStart=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -g 'pid /run/nginx.pid; daemon on; master_process on;'\nExecReload=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -g 'pid /run/nginx.pid; daemon on; master_process on;' -s reload\nExecStop=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -g 'pid /run/nginx.pid;' -s quit\n\n[Install]\nWantedBy=multi-user.target\n```\n\nYou can now safely get rid of the non-chrooted nginx installation.\n\n```\n# pacman -Rsc nginx\n```\n\nIf you do not remove the non-chrooted nginx installation, you may want to make sure that the running nginx process is in fact the chrooted one. You can do so by checking where /proc/PID/root symlinks to. It should link to /srv/http instead of /.\n\n```\n# ps -C nginx | awk '{print $1}' | sed 1d | while read -r PID; do ls -l /proc/$PID/root; done\n```\n\n"
    },
    {
      "title": "Running unprivileged using systemd",
      "level": 3,
      "content": "Use a drop-in unit file for nginx.service and set the User and optionally Group options under [Service]:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\nUser=user\nGroup=group\n```\n\nWe can harden the service against ever elevating privileges:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nNoNewPrivileges=yes\n```\n\nThen we need to ensure that user has access to everything it needs. Follow the subsections below and then start nginx.\n\n"
    },
    {
      "title": "Port",
      "level": 4,
      "content": "Linux does not permit non-root processes to bind to ports below 1024 by default. A port above 1024 can be used:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nserver {\n        listen 8080;\n}\n```\n\nOr you may grant the nginx process the CAP_NET_BIND_SERVICE capability which allows it to bind to ports below 1024:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nCapabilityBoundingSet=\nCapabilityBoundingSet=CAP_NET_BIND_SERVICE\nAmbientCapabilities=\nAmbientCapabilities=CAP_NET_BIND_SERVICE\n```\n\nAlternatively, you can use systemd socket activation. In this case, systemd will listen on the ports and, when a connection is made, spawn nginx passing the socket as a file descriptor. This means nginx requires no special capabilities as the socket already exists when it is started. This relies on an internal environment variable that nginx uses for passing sockets [3] and is therefore not officially supported. Instead of setting CapabilityBoundingSet and AmbientCapabilities, edit the service override to set the NGINX environment variable to tell nginx which file descriptors the sockets will be passed as:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nEnvironment=NGINX=3:4;\n```\n\nThere will be one socket per listening port starting at file descriptor 3, so in this example we are telling nginx to expect two sockets. Now create an nginx.socket unit specifying what ports to listen on:\n\n```\n/etc/systemd/system/nginx.socket\n```\n\n```\n[Socket]\nListenStream=0.0.0.0:80\nListenStream=0.0.0.0:443\nAfter=network.target\nRequires=network.target\n\n[Install]\nWantedBy=sockets.target\n```\n\nThe sockets will be passed in the order defined in this unit, so port 80 will be file descriptor 3 and port 443 will be file descriptor 4. If you previously enabled or started the service, you should now stop it, and enable nginx.socket instead. When your system starts, nginx will not be running, but will be started when you access the website in a browser. With this you can harden the service further; for example, in many cases you can now set PrivateNetwork=True in the service file, blocking nginx from the external network, since the socket created by systemd is sufficient to serve the website over. Note that this will print a warning in the logs of the nginx service: 2020/08/29 19:33:20 [notice] 254#254: using inherited sockets from \"3:4;\"\n\n"
    },
    {
      "title": "PID file",
      "level": 4,
      "content": "nginx is compiled to use /run/nginx.pid by default, which user cannot write to. We can create a directory that user can write to and place the PID file there. This can for example be done with RuntimeDirectory (systemd.exec(5)).\n\nEdit nginx.service to configure the PID file:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nRuntimeDirectory=nginx\nPIDFile=/run/nginx/nginx.pid\nExecStart=\nExecStart=/usr/bin/nginx -g 'pid /run/nginx/nginx.pid; error_log stderr;' \nExecReload=\nExecReload=/usr/bin/nginx -s reload -g 'pid /run/nginx/nginx.pid; error_log stderr;'\n```\n\n"
    },
    {
      "title": "/var/lib/nginx",
      "level": 4,
      "content": "nginx is compiled to store temp files in /var/lib/nginx by default.\n\nYou can give user write access to this directory by for example using StateDirectory (systemd.exec(5)):\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nStateDirectory=nginx\n```\n\n"
    },
    {
      "title": "/var/log/nginx",
      "level": 4,
      "content": "nginx is compiled to store access logs in /var/log/nginx by default.\n\nYou can give user write access to this directory by for example using LogsDirectory (systemd.exec(5)):\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nLogsDirectory=nginx\n```\n\n"
    },
    {
      "title": "Running user service using systemd",
      "level": 3,
      "content": "If you want to run a server instance fully controlled and configurable by unprivileged user, consider using nginx-user-serviceAUR.\n\n"
    },
    {
      "title": "Alternative script for systemd",
      "level": 3,
      "content": "On pure systemd you can get advantages of chroot + systemd. [4] Based on set user group and pid with:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nuser http;\npid /run/nginx.pid;\n```\n\nthe absolute path of the file is /srv/http/etc/nginx/nginx.conf.\n\n```\n/etc/systemd/system/nginx.service\n```\n\n```\n[Unit]\nDescription=nginx (Chroot)\nAfter=network.target\n\n[Service]\nType=forking\nPIDFile=/srv/http/run/nginx.pid\nRootDirectory=/srv/http\nExecStartPre=/usr/bin/nginx -t -c /etc/nginx/nginx.conf\nExecStart=/usr/bin/nginx -c /etc/nginx/nginx.conf\nExecReload=/usr/bin/nginx -c /etc/nginx/nginx.conf -s reload\nExecStop=/usr/bin/nginx -c /etc/nginx/nginx.conf -s stop\n\n[Install]\nWantedBy=multi-user.target\n```\n\nIt is not necessary to set the default location, nginx loads at default -c /etc/nginx/nginx.conf, but it is a good idea.\n\nAlternatively you can run only ExecStart as chroot with parameter RootDirectoryStartOnly set as yes (see systemd.service(5)) or start it before mount point as effective or a systemd path (see systemd.path(5)) is available.\n\n```\n/etc/systemd/system/nginx.path\n```\n\n```\n[Unit]\nDescription=nginx (Chroot) path\n[Path]\nPathExists=/srv/http/site/Public_html\n[Install]\nWantedBy=default.target\n```\n\nEnable the created nginx.path and change the WantedBy=default.target to WantedBy=nginx.path in /etc/systemd/system/nginx.service.\n\nThe PIDFile in unit file allows systemd to monitor process (absolute path required). If it is undesired, you can change to default one-shot type, and delete the reference from the unit file.\n\n"
    },
    {
      "title": "Nginx beautifier",
      "level": 3,
      "content": "nginxbeautifierAUR is a commandline tool used to beautify and format nginx configuration files.\n\n"
    },
    {
      "title": "Better headers management",
      "level": 3,
      "content": "Nginx has a rather unintuitive header management system where headers can only be defined in one context, any other headers are ignored. To remedy this we can install the headers-more-nginx module.\n\nInstall the package nginx-mod-headers-more package. This will install the module to /usr/lib/nginx/modules directory.\n\nTo load the module add the following to the top of your main nginx configuration file.\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nload_module \"/usr/lib/nginx/modules/ngx_http_headers_more_filter_module.so\";\n...\n```\n\n"
    },
    {
      "title": "Basic Authentication",
      "level": 3,
      "content": "Basic authentication requires creation of a password file. The password file can be managed using htpasswd program provided by the apache package or using nginx_passwdAUR which provides nginx-passwd - details available on GitHub source\n\n"
    },
    {
      "title": "Using php-legacy",
      "level": 3,
      "content": "Install php-legacy-fpm instead of php-fpm and make sure PHP has been installed and configured correctly.\n\nThe main configuration file of PHP-LEGACY-FPM is /etc/php-legacy/php-fpm.conf. For basic usage the default configuration should be sufficient.\n\nThe Unix socket for the fastcgi_pass argument also needs to be adjusted, usually it is:\n\n```\nfastcgi_pass unix:/run/php-fpm-legacy/php-fpm.sock;\n```\n\nThen start/enable php-legacy-fpm.service.\n\n"
    },
    {
      "title": "Configuration validation",
      "level": 3,
      "content": "```\n# nginx -t\n```\n\n```\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n```\n\n"
    },
    {
      "title": "Error: The page you are looking for is temporarily unavailable. Please try again later. (502 Bad Gateway)",
      "level": 3,
      "content": "This is because the FastCGI server has not been started, or the socket used has wrong permissions.\n\nTry out this answer to fix the 502 error.\n\nIn Arch Linux, the configuration file mentioned in above link is /etc/php/php-fpm.conf.\n\n"
    },
    {
      "title": "Error: No input file specified",
      "level": 3,
      "content": "1. Verify that variable open_basedir in /etc/php/php.ini contains the correct path specified as root argument in nginx.conf (usually /usr/share/nginx/). When using PHP-FPM as FastCGI server for PHP, you may add fastcgi_param PHP_ADMIN_VALUE \"open_basedir=$document_root/:/tmp/:/proc/\"; in the location block which aims for processing PHP file in nginx.conf.\n\n2. Another occasion is that, wrong root argument in the location ~ \\.php$ section in nginx.conf. Make sure the root points to the same directory as it in location / in the same server. Or you may just set root as global, do not define it in any location section.\n\n3. Check permissions: e.g. http for user/group, 755 for directories and 644 for files. Remember the entire path to the html directory should have the correct permissions. See File permissions and attributes#Bulk chmod to bulk modify a directory tree.\n\n4. You do not have the SCRIPT_FILENAME containing the full path to your scripts. If the configuration of nginx (fastcgi_param SCRIPT_FILENAME) is correct, this kind of error means PHP failed to load the requested script. Usually it is simply a permissions issue, you can just run php-cgi as root:\n\n```\n# spawn-fcgi -a 127.0.0.1 -p 9000 -f /usr/bin/php-cgi\n```\n\nor you should create a group and user to start the php-cgi:\n\n```\n# groupadd www\n# useradd -g www www\n# chmod +w /srv/www/nginx/html\n# chown -R www:www /srv/www/nginx/html\n# spawn-fcgi -a 127.0.0.1 -p 9000 -u www -g www -f /usr/bin/php-cgi\n```\n\n5. If you are running php-fpm with chrooted nginx ensure chroot is set correctly within /etc/php-fpm/php-fpm.d/www.conf (or /etc/php-fpm/php-fpm.conf if working on older version)\n\n"
    },
    {
      "title": "Warning: Could not build optimal types_hash",
      "level": 3,
      "content": "When starting the nginx.service, the process might log the message:\n\n```\n[warn] 18872#18872: could not build optimal types_hash, you should increase either types_hash_max_size: 1024 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size\n```\n\nTo fix this warning, increase the values for these keys inside the http block [5] [6]:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nhttp {\n    types_hash_max_size 4096;\n    server_names_hash_bucket_size 128;\n    ...\n}\n```\n\n"
    },
    {
      "title": "Cannot assign requested address",
      "level": 3,
      "content": "The full error from nginx.service unit status is\n\n```\n[emerg] 460#460: bind() to A.B.C.D:443 failed (99: Cannot assign requested address)\n```\n\nEven if your nginx unit-file is configured to run after network.target with systemd, nginx may attempt to listen at an address that is configured but not added to any interface yet. Verify that this the case by manually running start for nginx (thereby showing the IP address is configured properly). Configuring nginx to listen to any address will resolve this issue. Now if your use case requires listening to a specific address, one possible solution is to reconfigure systemd.\n\nTo start nginx after all configured network devices are up and assigned an IP address, append network-online.target to After= within nginx.service and start/enable systemd-networkd-wait-online.service.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- WebDAV with nginx\n- nginx configuration pitfalls\n- Very good in-depth 2014 look at nginx security and Reverse Proxying\n- Installing LEMP (nginx, PHP, MySQL with MariaDB engine and PhpMyAdmin) in Arch Linux\n- Using SSL certificates generated with Let's Encrypt\n\n"
    }
  ]
}