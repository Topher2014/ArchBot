{
  "title": "Yardım:Okuma",
  "url": "https://wiki.archlinux.org/title/Yard%C4%B1m:Okuma",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "İlgili makaleler\n\n- Help:Browsing\n- Help:Style\n\nArchWiki makalelerinin büyük bir çoğunluğu, Arch Linux'a (veya genel olarak GNU/Linux'a) yeni olan kullanıcılar için açıklığa kavuşturulması gerekecek türden emareler barındırdığından dolayı; karışıklıkları, makalelerin asimile olmasını ve içerikte tekrarı önlemek amacıyla bu kısa bilgiler bütünü oluşturulmuştur.\n\n"
    },
    {
      "title": "Organizasyon",
      "level": 2,
      "content": "ArchWiki'deki çoğu makale tek bir konu hakkında bütüncül yönergeler sunmaz. Bunun yerine kullanıcının o an için anlamadığı şeyi kavramasına yardımcı olacak dokümanları bulup okuyacağı varsayılaraktan, \"Kendini Tekrar Etme\" prensibine uygun biçimde yazılır.\n\nBu düzen sonucunda, bir ArchWiki makalesini tam olarak anlayabilmek için birden fazla ilgili kaynağı gözden geçirmek gerekli olabilmektedir. Özellikle Arch'a (veya GNU/Linux'a) yeni olan kullanıcıların kendilerini, küçük bir sorun için bile çokça makale okumuş hâlde bulabileceğini bilmesi gerekir. Ayrıca diğer kullanıcılardan yardım istemeden önce yardımcı dokümanların incelenmiş olması büyük önem arz eder.\n\n"
    },
    {
      "title": "Biçim",
      "level": 2,
      "content": "- içinde bulunulan makaledeki başka bir bölüme yönlendirme: #Organizasyon\n- başka bir ArchWiki makalesine yönlendirme\n- site dışı bir bağlantıya yönlendirme\n- bir kılavuz sayfasına yönlendirme: intro(1)\n- sadece çevrim dışı ulaşılabilir olan bir kılavuz sayfası: foo(1)\n- resmî depolardaki bir pakete yönlendirme: foobar\n- AUR'da bulunan bir pakete yönlendirme: foobarAUR\n\n"
    },
    {
      "title": "Sıradan kullanıcı, kök kullanıcısı ve diğer tür kullanıcıların ayrımı",
      "level": 2,
      "content": "Bazı satırlar bu şekilde yazılmıştır::\n\n```\n# mkinitcpio -p linux\n```\n\nBazıları ise bu şekilde:\n\n```\n$ makepkg -s\n```\n\nKare işareti (#) verilen komutun kök kullanıcısı olarak çalıştırılması gerektiğini ifade ederken, dolar işareti ($) verilen komutun sıradan kullanıcı olarak çalıştırılması gerektiğini ifade eder.\n\nVerilen komutların belli bir kullanıcı olarak çalıştırılması gerektiğinde, köşeli parantez içinde kullanıcı adı ön ek şeklinde gösterilecektir, örneğin:\n\n```\n[postgres]$ initdb -D /var/lib/postgres/data\n```\n\nBu, o komutu bir ayrıcalık yükseltici araç ile çalıştırmanız gerektiği anlamına gelir (örneğin sudo):\n\n```\n$ sudo -u postgres initdb -D /var/lib/postgres/data\n```\n\nKaçınılması gereken dikkate değer bir istisna:\n\n```\n# Bu arma (alias), ls komutunun renkli bir şekilde listelemesini sağlar\nalias ls='ls --color=auto'\n```\n\nBu örnekte, kare işaretinden sonra gelen içeriğin komut olarak çalıştırılması gerektiği anlaşılmamalıdır. Bir dosyada bir bölümü belirtir. Yukarıdaki bu durumda kare sembolü bir yorum satırına işarettir. Bir yorum, ilgili programla karıştırılmaması gereken açıklayıcı yazıdır. Yani Bash betiklerinin yorum belirteçleri ve kök kullanıcı PS1'ı çakışmaktadır.\n\nDaha fazla inceleme sonrasında, yorum satırlarında # karakterinden sonraki cümlenin büyük harf ile başlayabileceği görülecektir. Unix komutları genellikle tam bir İngilizce kelime şeklinde değil de, bu İngilizce kelimenin kısaltması şeklinde olurlar. (ör. Copy işlemi, yani kopyalama işlemi, cp komutu ile yapılır)\n\nNe olursa olsun çoğu makale, bu kare işaretinin ne anlama geldiğinin anlaşılmasına yardımcı olur:\n\n~/dosyanin/bulunduğu/dizin dosyasına bunları girin:\n\n```\n# Bu arma (alias), ls komutunun renkli bir şekilde listelemesini sağlar\nalias ls='ls --color=auto'\n```\n\n"
    },
    {
      "title": "Eklemek, oluşturmak, düzenlemek, dosyasına ekleme yapmak",
      "level": 2,
      "content": "ekle, oluştur, düzenle, dosyasına ekleme yap gibi anahtar kelimeler bir veya birden fazla dosya için kullanıldığında, bu yollardan birini o dosya(lar) ile kullanmanız gerektiğini kasteder.\n\nBirden çok satırı bulunan dosyaların metin editörü ile düzenlenmesi/oluşturulması tavsiye edilir. Örneğin nano'yu kullanarak /etc/bash.bashrc dosyasını düzenlemek için şu komut kullanılabilir:\n\n```\n# nano /etc/bash.bashrc\n```\n\nGörece kısa bir metinden dosya oluşturmak veya var olan dosyanın üzerine yazmak için çıktı yönlendirmesi yolunu kullanmak daha kolay olabilir. Aşağıda verilen örnekte /etc/hostname dosyasının üstüne bilgisayar_adi metni yazılır.\n\n```\n# echo bilgisayar_adi > /etc/hostname\n```\n\nÇıktı yönlendirmeleri bir dosyaya metin eklemesi yapmak için de kullanılabilir. Aşağıdaki örnekte /etc/pacman.conf dosyasına [ozel-depo] metni eklenir.\n\n```\n# echo \"[ozel-depo]\" >> /etc/pacman.conf\n```\n\nBir dizin oluşturulması istendiğinde, mkdir komutunu kullanın:\n\n```\n# mkdir /mnt/boot\n```\n\n"
    },
    {
      "title": "Yürütülebilir yapma",
      "level": 3,
      "content": "Bir dosya oluşturduktan sonra, eğer bu dosya betik (script) olarak (elle veya bir program tarafından) çalıştırılacaksa yürütülebilir yapılması gerekir. Örneğin şu örnekte olduğu gibi:\n\n```\n$ chmod +x script\n```\n\nAyrıntılar için chmod'a göz atın. Bazı programlar, bilhassa dosya yöneticileri, dosyaları çizgesel (graphical) arayüzden yürütülebilir yapabilmeyi sağlarlar.\n\n"
    },
    {
      "title": "Kaynak dosya belirtme",
      "level": 2,
      "content": "Bazı uygulamalar, özellikle komut satırı kabukları, yapılandırma ayarları için betikleri kullanırlar: bu yapılandırma betikleri değiştirildikten sonra uygulanabilmeleri için kaynak olarak verilmesi gerekir. Aşağıdaki örnekteki gibi bash kabuğu söz konusuyken kaynak belirtme şu şekilde yapılabilir (Bu örnekte ~/.bashrc betiği kaynak gösterilir. Ayrıca source komutu . ile değiştirilebilir):\n\n```\n$ source ~/.bashrc\n```\n\nWikide bir yapılandırma betiğinin düzenlenmesine dair yönergeler verildiğinde, özellikle dosyanın kaynak olarak belirtilmesi gerektiği hatırlatılmayacaktır, ve sadece bazı durumlarda bu bölüme yönlendiren bir bağlantı gösterilecektir.\n\n"
    },
    {
      "title": "Paketlerin kurulması",
      "level": 2,
      "content": "Bir makalede sizden bazı paketleri bilinen yolla kurmanız istendiğinde, nasıl yapılacağına dair detaylı bir yönergeden verilmeyecektir ve paketlerin ismi verilip indirilmesi gerektiğini söylenecektir.\n\nAşağıdaki alt bölümler, paket türüne göre genel kurulum süreçleri hakkında genel bir açıklama sağlamaktadır:\n\n"
    },
    {
      "title": "Resmî paketler",
      "level": 3,
      "content": "Resmî depolardan indirilen paketler için şöyle bir yönerge görebilirsiniz:\n\nBu şu komutu çalıştırmanız gerektiği anlamına gelir:\n\n```\n# pacman -S foobar\n```\n\npacman makalesi, Arch Linux'ta paket yönetimiyle nasıl ustalıkla ilgilenebileceğiniz hakkında detaylı açıklamalar barındırır.\n\n"
    },
    {
      "title": "Arch Kullanıcı Deposu (AUR)",
      "level": 3,
      "content": "Arch Kullanıcı Deposu (AUR) kaynağından olan paketler için şöyle bir yönerge görebilirsiniz:\n\nBu genellikle foobarAUR bağlantısını takip ederek, PKGBUILD arşivini indirip, arşivi çıkartıp, içindeki veriyi doğrulamak ve son olarak aynı klasörde aşağıdaki komutu çalıştırmak anlamına gelir:\n\n```\n$ makepkg -si\n```\n\nArch User Repository makalesi, AUR paketleri ile ilgilenmenin en iyi yolları hakkında tüm detaylı açıklamaları barındırır.\n\n"
    },
    {
      "title": "systemd birimlerinin kontrolü",
      "level": 2,
      "content": "Bir makale, herhangi bir systemd birimi (ör. bir servis) hakkında başlat, etkinleştir gibi isteklerde bulunuyorsa, nasıl yapılacağı hakkında detaylı bir yönerge barındırmayabilir, bunun yerine aşağıdaki gibi bir cümle göreceksinizdir:\n\nBu şu komutu çalıştırmanız gerektiği anlamına gelir:\n\n```\n# systemctl start ornek.service\n```\n\nBu parametre örüntüsüne sahip olmayan bir komut ise systemctl daemon-reload komutudur. Bu komut herhangi bir argüman olmadan çağrılır.\n\nsystemd#Using units makale bölümü, karşılık düşen systemctl komutları ile birlikte mevcut eylemlerin (başlat, etkinleştir, etkinleştir ve başlat gibi) yapılandırılmış bir listesini barındırır.\n\n"
    },
    {
      "title": "Sistem boyunca veya kullanıcıya özgü yapılandırma",
      "level": 2,
      "content": "Şunu hatırlamak önemli ki bir GNU/Linux sisteminde iki çeşit yapılandırma şekli vardır. Sistem-boyu yapılandırmaları tüm kullanıcıları etkiler. Sistem-boyu ayarları genellikle /etc dizininde bulunduğundan, bu ayarları düzenlemek için kök izni gereklidir. Örneğin bir Bash ayarının tüm kullanıcılarda etkisini göstermesi isteniyorsa /etc/bash.bashrc düzenlenmelidir.\n\nKullanıcıya özgü ayarlar tek bir kullanıcıyı etkiler. Dotfilelar kullanıcıya özgü ayarlar için kullanılırlar. Örneğin ~/.bashrc dosyası kullanıcıya özgü yapılandırma dosyasıdır. Burada ana fikir kullanıcının diğer kullanıcıların ayarlarını etkilemeden kendisi için fonksiyonlar, armalar (alias) ve diğer etkileşimli özellikler belirlemesini sağlamaktır.\n\n"
    },
    {
      "title": "Yaygın kabuk dosyaları",
      "level": 3,
      "content": "Bash ve diğer Bourne-uyumlu kabuklar, Zsh gibi, gerekli yapılandırma betiklerini, açılan kabuğun giriş kabuğu mu, etkileşimli kabuk mu olduğuna göre çalıştırır. Detaylar için Bash#Configuration files ve Zsh#Startup/Shutdown files makalelerine bakın.\n\n"
    },
    {
      "title": "Kod örneklerinde sözde değişkenler",
      "level": 2,
      "content": "Bazı kod blokları sözde değişken barındırabilirler, isminden de anlaşılacağı üzere bu değişkenler kod içinde bulunan gerçek değişkenler değildirler. Bunlar daha çok genel yer tutuculardır ve kod çalıştırılmadan önce, sisteme özgü belli yapılandırma öğeleri ile değiştirilmesi gerekir. bash ve zsh gibi bilindik kabuklar, tab tuşuyla tamamlama özelliği sağlar. systemctl gibi yaygın komutlarda parametreler bu şekilde otomatik tamamlanabilir.\n\nHelp:Style/Formatting and punctuation yönergeleri uyumlu makaleler, sözde değişkenleri italik şekilde gösterirler. Örneğin:\n\n- ip link komutunun çıktısında tanımladığınız ağ arayüzü için dhcpcd@arayuz_ismi.service servisini etkinleştirin.\n\nYukarıdaki durumda arayuz_ismi, sözde değişkendir ve bir systemd şablon birimi için yer tutucudur. Tüm systemd birimleri @ işareti ile tanınabilirler ve argüman olarak sisteme özgü yapılandırma öğeleri isterler. systemd#Using units makalesine bakın.\n\n- dd if=veri_kaynağı of=/dev/sdX bs=sektör_büyüklüğü count=sektör_numarası seek=bölümün_başlangıç_sektörü komutunu kullanarak, kök izniyle, gerekli paramtereleri belirterek bir disk bölümünü silebilirsiniz.\n\nYukarıdaki örnekte sözde değişkenler yerine koyulacak parametreleri açıklamak amacıyla kullanılmıştır. Bu parametrelerin nasıl bir araya getirileceklerine dair detaylar Securely wipe disk#Calculate blocks to wipe manually bölümünde bulunmaktadır.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nDosyalarla alakalı verilen örneklerde, sözde değişkenleri direkt olarak yazarsanız, onlarla bağlantılı programların bozulmasına sebep olabilirsiniz.\n\n"
    },
    {
      "title": "Eksiltiler",
      "level": 3,
      "content": "Eksiltiler, genellikle (..) dosyanın veya kodun asıl parçası değildir, ve bahsedilen konudaki tercihi kısımları veya konuyla bağlantısı olmayan kısımları belirtmek için kullanılır.\n\nÖrneğin HOOKS=\"... encrypt ... filesystems ...\" veya:\n\n```\n/etc/X11/xorg.conf.d/50-synaptics.conf\n```\n\n```\nSection \"InputClass\"\n    ...\n    Option      \"CircularScrolling\"          \"on\"\n    Option      \"CircScrollTrigger\"          \"0\"\n    ...\nEndSection\n```\n\nYine de bilinmesinde fayda var ki bazı örneklerde eksiltiler kodun sözdiziminde önemli bir parça olabilir: dikkatli kullanıcılar bu vakaları, konunun bağlamı ile ayırt edebilmelidir.\n\n"
    }
  ]
}