{
  "title": "SSH keys",
  "url": "https://wiki.archlinux.org/title/SSH_keys",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nSSH keys can serve as a means of identifying yourself to an SSH server using public-key cryptography and challenge-response authentication. The major advantage of key-based authentication is that, in contrast to password authentication, it is not prone to brute-force attacks, and you do not expose valid credentials if the server has been compromised (see RFC 4251 9.4.4).\n\nFurthermore, SSH key authentication can be more convenient than the more traditional password authentication. When used with a program known as an SSH agent, SSH keys can allow you to connect to a server, or multiple servers, without having to remember or enter your password for each system.\n\nKey-based authentication is not without its drawbacks and may not be appropriate for all environments, but in many circumstances it can offer some strong advantages. A general understanding of how SSH keys work will help you decide how and when to use them to meet your needs.\n\nThis article assumes you already have a basic understanding of the Secure Shell protocol and have installed the openssh package.\n\n"
    },
    {
      "title": "Background",
      "level": 2,
      "content": "SSH keys are always generated in pairs with one known as the private key and the other as the public key. The private key is known only to you and it should be safely guarded. By contrast, the public key can be shared freely with any SSH server to which you wish to connect.\n\nIf an SSH server has your public key on file and sees you requesting a connection, it uses your public key to construct and send you a challenge. This challenge is an encrypted message and it must be met with the appropriate response before the server will grant you access. What makes this coded message particularly secure is that it can only be understood by the private key holder. While the public key can be used to encrypt the message, it cannot be used to decrypt that very same message. Only you, the holder of the private key, will be able to correctly understand the challenge and produce the proper response.\n\nThis challenge-response phase happens behind the scenes and is invisible to the user. As long as you hold the private key, which is typically stored in the ~/.ssh/ directory, your SSH client should be able to reply with the appropriate response to the server.\n\nA private key is a guarded secret and as such it is advisable to store it on disk in an encrypted form. When the encrypted private key is required, a passphrase must first be entered in order to decrypt it. While this might superficially appear as though you are providing a login password to the SSH server, the passphrase is only used to decrypt the private key on the local system. The passphrase is not transmitted over the network.\n\n"
    },
    {
      "title": "Generating an SSH key pair",
      "level": 2,
      "content": "An SSH key pair can be generated by running the ssh-keygen command, see the ssh-keygen(1) man page for what is \"generally considered sufficient\" and should be compatible with virtually all clients and servers:\n\n```\n$ ssh-keygen\n```\n\n```\nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/home/username/.ssh/id_ed25519):\nCreated directory '/home/username/.ssh'.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/username/.ssh/id_ed25519\nYour public key has been saved in /home/username/.ssh/id_ed25519.pub\nThe key fingerprint is:\nSHA256:RLy4JBv7jMK5qYhRKwHB3af0rpMKYwE2PBhALCBV3G8 username@hostname\nThe key's randomart image is:\n+--[ED25519 256]--+\n|%oooo. ..        |\n|== ..o.o.        |\n|==  . +o..       |\n|+ o o.ooE        |\n|...  *.oS        |\n| o..o ..         |\n|o=.. +o          |\n|+o*..+o          |\n|+.o+. .          |\n+----[SHA256]-----+\n```\n\nThe randomart image was introduced in OpenSSH 5.1 as an easier means of visually identifying the key fingerprint.\n\nYou can also add an optional comment field to the public key with the -C switch, to more easily identify it in places such as ~/.ssh/known_hosts, ~/.ssh/authorized_keys and ssh-add -L output. For example:\n\n```\n$ ssh-keygen -C \"$(whoami)@$(uname -n)-$(date -I)\"\n```\n\nwill add a comment saying which user created the key on which machine and when.\n\n"
    },
    {
      "title": "Choosing the authentication key type",
      "level": 3,
      "content": "OpenSSH supports several signing algorithms (for authentication keys) which can be divided in two groups depending on the mathematical properties they exploit:\n\n1. Ed25519 and ECDSA, which rely on the elliptic curve discrete logarithm problem (ECDLP). (example)\n1. RSA, which relies on the practical difficulty of factoring the product of two large prime numbers,\n\nElliptic curve cryptography (ECC) algorithms are a more recent addition to public key cryptosystems. One of their main advantages is their ability to provide the same level of security with smaller keys, which makes for less computationally intensive operations (i.e. faster key creation, encryption and decryption) and reduced storage and transmission requirements.\n\nDSA keys are deprecated due to their security weaknesses and most SSH implementations do not support them anymore. Dropbear 2022.83 disabled DSA key support while OpenSSH 10.0 and libssh 0.11.0 removed support for DSA keys entirely. Therefore the choice of cryptosystem lies within RSA or one of the two types of ECC.\n\nThe default Ed25519 will give you the best security and good performance. ECDSA is slower than Ed25519, but faster than RSA; concerns exist about its security (see below). RSA keys will give you the greatest compatibility with old servers, but it requires a larger key size to provide sufficient security.\n\n- Ed25519 and ECDSA keys can be stored in FIDO/U2F hardware authenticators by using the special \"security key\" key types when generating the keys. See #FIDO/U2F.\n- ECDSA and RSA are supported by Trusted Platform Modules making it possible to seal SSH keys inside the TPM. See Trusted Platform Module#SSH.\n\n"
    },
    {
      "title": "Ed25519",
      "level": 4,
      "content": "Ed25519 was introduced in OpenSSH 6.5 of January 2014: \"Ed25519 is an elliptic curve signature scheme that offers better security than ECDSA and DSA and good performance\". Its main strengths are its speed, its constant-time run time (and resistance against side-channel attacks), and its lack of nebulous hard-coded constants.[1] See also this blog post by a Mozilla developer on how it works.\n\nIt is implemented in many applications and libraries and is the default key exchange algorithm (which is different from key signature) in OpenSSH.\n\nssh-keygen(1) defaults to Ed25519 therefore there is no need to specify it with the -t ed25519 option. The key pairs can be simply generated with:\n\n```\n$ ssh-keygen\n```\n\nThere is no need to set the key size, as all Ed25519 keys are 256 bits.\n\nKeep in mind that ancient SSH clients and servers may not support these keys.\n\n"
    },
    {
      "title": "ECDSA",
      "level": 4,
      "content": "The Elliptic Curve Digital Signature Algorithm (ECDSA) was the preferred algorithm for authentication (key exchange algorithm) from OpenSSH 5.7 (2011-01-24) to OpenSSH 6.5 (2014-01-30).\n\nThere are two sorts of concerns with it:\n\n1. Political concerns, the trustworthiness of NIST-produced curves being questioned after revelations that the NSA willingly inserts backdoors into softwares, hardware components and published standards were made; well-known cryptographers have expressed doubts about how the NIST curves were designed, and voluntary tainting has already been proven in the past.\n1. Technical concerns, about the difficulty to properly implement the standard and the slowness and design flaws which reduce security in insufficiently precautious implementations.\n\nBoth of those concerns are best summarized in libssh curve25519 introduction. Although the political concerns are still subject to debate, there is a clear consensus that #Ed25519 is technically superior and should therefore be preferred.\n\nECDSA key pairs can be generated with:\n\n```\n$ ssh-keygen -t ecdsa\n```\n\nThree elliptic curve sizes are supported for ECDSA keys: 256, 384 and 521 bits. The default is 256 bits. If you wish to generate a stronger ECDSA key pair, simply specify the -b option:\n\n```\n$ ssh-keygen -t ecdsa -b 384\n```\n\n"
    },
    {
      "title": "RSA",
      "level": 4,
      "content": "RSA provides the best compatibility of all algorithms but requires the key size to be larger to provide sufficient security. Minimum key size is 1024 bits, default is 3072 (see ssh-keygen(1)) and maximum is 16384.\n\nRSA key pairs can be generated with:\n\n```\n$ ssh-keygen -t rsa\n```\n\nIf you wish to generate a stronger RSA key pair (e.g. to guard against cutting-edge or unknown attacks and more sophisticated attackers), simply specify the -b option with a higher bit value than the default:\n\n```\n$ ssh-keygen -t rsa -b 4096\n```\n\nBe aware though that there are diminishing returns in using longer keys.[2][3] The GnuPG FAQ reads: \"If you need more security than RSA-2048 offers, the way to go would be to switch to elliptical curve cryptography â€” not to continue using RSA.\"[4]\n\nOn the other hand, the latest iteration of the NSA Fact Sheet Suite B Cryptography suggests a minimum 3072-bit modulus for RSA while \"[preparing] for the upcoming quantum resistant algorithm transition\".[5]\n\n"
    },
    {
      "title": "FIDO/U2F",
      "level": 4,
      "content": "FIDO/U2F hardware authenticator support was added in OpenSSH version 8.2 for both of the elliptic curve signature schemes mentioned above. It allows for a hardware token attached via USB or other means to act a second factor alongside the private key.\n\nThe libfido2 is required for hardware token support.\n\n- Both the client and server must support the ed25519-sk and ecdsa-sk key types.\n- OpenSSH uses a middleware library to communicate with the hardware token and comes with an internal middleware which supports USB tokens. Other middleware may be specified by the sshd_config(5) Â§ SecurityKeyProvider directive or the SSH_SK_PROVIDER environment variable for ssh-keygen and ssh-add.\n\nAfter attaching a compatible FIDO key, a key pair may be generated with:\n\n```\n$ ssh-keygen -t ed25519-sk\n```\n\nYou will usually be required to enter your PIN and/or tap your token to confirm the generation. Connecting to a server will usually require tapping your token unless the -O no-touch-required command line option is used during generation and the sshd(8) Â§ no-touch-required authorized_keys option is set on the server.\n\nTo create keys that do not require touch events, generate a key pair with the no-touch-required option. For example:\n\n```\n$ ssh-keygen -O no-touch-required -t ed25519-sk\n```\n\nAdditionally, sshd rejects no-touch-required keys by default. To allow keys generated with this option, either enable it for an individual key in the authorized_keys file,\n\n```\nno-touch-required sk-ssh-ed25519@openssh.com AAAAInN... user@example.com\n```\n\nor for the whole system by editing /etc/ssh/sshd_config with\n\n```\nPubkeyAuthOptions none\n```\n\nAn ECDSA-based keypair may also be generated with the ecdsa-sk keytype, but the relevant concerns in the #ECDSA section above still apply.\n\n```\n$ ssh-keygen -t ecdsa-sk\n```\n\n"
    },
    {
      "title": "Choosing the key location and passphrase",
      "level": 3,
      "content": "Upon issuing the ssh-keygen command, you will be prompted for the desired name and location of your private key. By default, keys are stored in the ~/.ssh/ directory and named according to the type of encryption used. You are advised to accept the default name and location in order for later code examples in this article to work properly.\n\nWhen prompted for a passphrase, choose something that will be hard to guess if you have the security of your private key in mind. A longer, more random password will generally be stronger and harder to crack should it fall into the wrong hands.\n\nIt is also possible to create your private key without a passphrase. While this can be convenient, you need to be aware of the associated risks. Without a passphrase, your private key will be stored on disk in an unencrypted form. Anyone who gains access to your private key file will then be able to assume your identity on any SSH server to which you connect using key-based authentication. Furthermore, without a passphrase, you must also trust the root user, as they can bypass file permissions and will be able to access your unencrypted private key file at any time.\n\n"
    },
    {
      "title": "Changing the private key's passphrase without changing the key",
      "level": 4,
      "content": "If the originally chosen SSH key passphrase is undesirable or must be changed, one can use the ssh-keygen command to change the passphrase without changing the actual key. This can also be used to change the password encoding format to the new standard.\n\n```\n$ ssh-keygen -f ~/.ssh/id_rsa -p\n```\n\n"
    },
    {
      "title": "Managing multiple keys",
      "level": 4,
      "content": "If you have multiple SSH identities, you can set different keys to be used for different hosts or remote users by using the Host and IdentityFile directives in your configuration:\n\n```\n~/.ssh/config\n```\n\n```\nHost SERVER1\n   IdentitiesOnly yes\n   IdentityFile ~/.ssh/id_rsa_IDENTITY1\n\nHost SERVER2 SERVER3\n   IdentitiesOnly yes\n   IdentityFile ~/.ssh/id_ed25519_IDENTITY2\n```\n\nSee ssh_config(5) for full description of these options.\n\n"
    },
    {
      "title": "Storing SSH keys on hardware tokens",
      "level": 4,
      "content": "SSH keys can also be stored on a security token like a smart card or a USB token. This has the advantage that the private key is stored securely on the token instead of being stored on disk. When using a security token the sensitive private key is also never present in the RAM of the PC; the cryptographic operations are performed on the token itself. A cryptographic token has the additional advantage that it is not bound to a single computer; it can easily be removed from the computer and carried around to be used on other computers.\n\nExamples of hardware tokens are described in:\n\n- #FIDO/U2F\n- YubiKey#SSH notes Native OpenSSH support for FIDO/U2F keys\n- YubiKey#SSH keys\n- Trusted Platform Module#SSH\n\n"
    },
    {
      "title": "Copying the public key to the remote server",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nOnce you have generated a key pair, you will need to copy the public key to the remote server so that it will use SSH key authentication. The public key file shares the same name as the private key except that it is appended with a .pub extension. Note that the private key is not shared and remains on the local machine.\n\n"
    },
    {
      "title": "Simple method",
      "level": 3,
      "content": "If your key file is ~/.ssh/id_rsa.pub you can simply enter the following command.\n\n```\n$ ssh-copy-id remote-server.org\n```\n\nIf your username differs on remote machine, be sure to prepend the username followed by @ to the server name.\n\n```\n$ ssh-copy-id username@remote-server.org\n```\n\nIf your public key filename is anything other than the default of ~/.ssh/id_rsa.pub you will get an error stating /usr/bin/ssh-copy-id: ERROR: No identities found. In this case, you must explicitly provide the location of the public key.\n\n```\n$ ssh-copy-id -i ~/.ssh/id_ed25519.pub username@remote-server.org\n```\n\nIf the ssh server is listening on a port other than default of 22, be sure to include it within the host argument.\n\n```\n$ ssh-copy-id -i ~/.ssh/id_ed25519.pub -p 221 username@remote-server.org\n```\n\n"
    },
    {
      "title": "Manual method",
      "level": 3,
      "content": "By default, for OpenSSH, the public key needs to be concatenated with ~/.ssh/authorized_keys. Begin by copying the public key to the remote server.\n\n```\n$ scp ~/.ssh/id_ecdsa.pub username@remote-server.org:\n```\n\nThe above example copies the public key (id_ecdsa.pub) to your home directory on the remote server via scp. Do not forget to include the : at the end of the server address. Also note that the name of your public key may differ from the example given.\n\nOn the remote server, you will need to create the ~/.ssh directory if it does not yet exist and append your public key to the authorized_keys file.\n\n```\n$ ssh username@remote-server.org\nusername@remote-server.org's password:\n$ install -dm700 ~/.ssh\n$ cat ~/id_ecdsa.pub >> ~/.ssh/authorized_keys\n$ rm ~/id_ecdsa.pub\n$ chmod 600 ~/.ssh/authorized_keys\n```\n\nThe last two commands remove the public key file from the server and set the permissions on the authorized_keys file such that it is only readable and writable by you, the owner.\n\n"
    },
    {
      "title": "SSH agents",
      "level": 2,
      "content": "If your private key is encrypted with a passphrase, this passphrase must be entered every time you attempt to connect to an SSH server using public-key authentication. Each individual invocation of ssh or scp will need the passphrase in order to decrypt your private key before authentication can proceed.\n\nAn SSH agent is a program which caches your decrypted private keys and provides them to SSH client programs on your behalf. In this arrangement, you must only provide your passphrase once, when adding your private key to the agent's cache. This facility can be of great convenience when making frequent SSH connections.\n\nAn agent is typically configured to run automatically upon login and persist for the duration of your login session. A variety of agents, front-ends, and configurations exist to achieve this effect. This section provides an overview of a number of different solutions which can be adapted to meet your specific needs.\n\n"
    },
    {
      "title": "ssh-agent",
      "level": 3,
      "content": "ssh-agent is the default agent included with OpenSSH. It can be used directly or serve as the back-end to a few of the front-end solutions mentioned later in this section. When ssh-agent is run, it forks to background and prints necessary environment variables. E.g.\n\n```\n$ ssh-agent\n```\n\n```\nSSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;\nSSH_AGENT_PID=2148; export SSH_AGENT_PID;\necho Agent pid 2148;\n```\n\nTo make use of these variables, run the command through the eval command. Use ssh-agent -c instead if using the fish shell.\n\n```\n$ eval $(ssh-agent)\n```\n\n```\nAgent pid 2157\n```\n\nOnce ssh-agent is running, you will need to add your private key to its cache:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\n```\nEnter passphrase for /home/user/.ssh/id_ed25519:\nIdentity added: /home/user/.ssh/id_ed25519 (/home/user/.ssh/id_ed25519)\n```\n\nIf your private key is encrypted, ssh-add will prompt you to enter your passphrase. Once your private key has been successfully added to the agent you will be able to make SSH connections without having to enter your passphrase.\n\nIn order to start the agent automatically and make sure that only one ssh-agent process runs at a time, touch $XDG_RUNTIME_DIR/ssh-agent.env and add the following to your ~/.bashrc:\n\n```\nifÂ ! pgrep -u \"$USER\" ssh-agent > /dev/null; then\n    ssh-agent -t 1h > \"$XDG_RUNTIME_DIR/ssh-agent.env\"\nfi\nif [Â ! -f \"$SSH_AUTH_SOCK\" ]; then\n    source \"$XDG_RUNTIME_DIR/ssh-agent.env\" >/dev/null\nfi\n```\n\nThis will run an ssh-agent process if there is not one already, and save the output thereof. If there is one running already, we retrieve the cached ssh-agent output and evaluate it which will set the necessary environment variables. The lifetime of the unlocked keys is set to 1 hour.\n\nThere also exist a number of front-ends to ssh-agent and alternative agents described later in this section which avoid this problem.\n\n"
    },
    {
      "title": "Start ssh-agent with systemd user",
      "level": 4,
      "content": "If you would like your ssh agent to run when you are logged in, regardless of whether X is running, a handy ssh-agent.service is included in openssh since the version 9.4p1-3, which can be enabled as a user unit.\n\nThen set the environment variable SSH_AUTH_SOCK to $XDG_RUNTIME_DIR/ssh-agent.socket.\n\n"
    },
    {
      "title": "Forwarding ssh-agent",
      "level": 4,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nWhen forwarding a local ssh-agent to remote (e.g., through command-line argument ssh -A remote or through ForwardAgent yes in the configuration file), it is important for the remote machine not to overwrite the environment variable SSH_AUTH_SOCK. So if the remote machine uses a systemd unit shown previously to start the agent, SSH_AUTH_SOCK must not be set in the environment when a user is logged in through SSH. Otherwise, the forwarding may fail, and you may see errors (for example: The agent has no identities) when checking the existing keys with ssh-add -l on the remote machine.\n\nFor example, if using bash, the .bashrc could be something like:\n\n```\n~/.bashrc\n```\n\n```\n...\nif [[ -z \"${SSH_CONNECTION}\" ]]; then\n    export SSH_AUTH_SOCK=\"$XDG_RUNTIME_DIR/ssh-agent.socket\"\nfi\n...\n```\n\nIn this way, SSH_AUTH_SOCK is only set when the current session is not an SSH login. And when this is a SSH session, SSH_AUTH_SOCK on the remote machine is then set by the local machine to make the forwarding work.\n\n"
    },
    {
      "title": "ssh-agent as a wrapper program",
      "level": 4,
      "content": "An alternative way to start ssh-agent (with, say, each X session) is described in this ssh-agent tutorial by UC Berkeley Labs. A basic use case is if you normally begin X with the startx command, you can instead prefix it with ssh-agent like so:\n\n```\n$ ssh-agent startx\n```\n\nAnd so you do not even need to think about it you can put an alias in your .bash_aliases file or equivalent:\n\n```\nalias startx='ssh-agent startx'\n```\n\nDoing it this way avoids the problem of having extraneous ssh-agent instances floating around between login sessions. Exactly one instance will live and die with the entire X session.\n\nSee the notes on using x11-ssh-askpass with ssh-add for an idea on how to immediately add your key to the agent.\n\n"
    },
    {
      "title": "OpenPGP card ssh-agent",
      "level": 3,
      "content": "This ssh-agent specializes on OpenPGP card integration. It uses private keys that are stored in OpenPGP card authentication slots.\n\nInstall openpgp-card-ssh-agent and enable and start the openpgp-card-ssh-agent.socket user unit.\n\nAfterwards add the relevant environment variable for this agent:\n\n```\nexport SSH_AUTH_SOCK=\"$XDG_RUNTIME_DIR/openpgp-card/ssh-agent.sock\"\n```\n\n"
    },
    {
      "title": "User PIN handling",
      "level": 4,
      "content": "The user PIN for the OpenPGP card is persisted via an org.freedesktop.secrets provider (such as GNOME Keyring, KeePassXC or KDE Wallet) by default. The PIN storage backend is configurable and extendable.\n\nThe user PIN needs to be persisted only once for each OpenPGP card. Prior to the first SSH connection with this agent, list the available SSH public keys and add their respective card identifiers:\n\n```\n$ ssh-add -L\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJUz6VnFprMe33G88Pq8NLw3wnIKOsBg0CDrwFeUVrU6 FFFE:01234567\n$ ssh-add -s FFFE:01234567\nEnter passphrase for PKCS#11:\n```\n\n"
    },
    {
      "title": "GnuPG Agent",
      "level": 3,
      "content": "The gpg-agent has OpenSSH Agent protocol emulation. See GnuPG#SSH agent for necessary configuration.\n\n"
    },
    {
      "title": "Keychain",
      "level": 3,
      "content": "Keychain is a program designed to help you easily manage your SSH keys with minimal user interaction. It is implemented as a shell script which drives both ssh-agent and ssh-add. A notable feature of Keychain is that it can maintain a single ssh-agent process across multiple login sessions. This means that you only need to enter your passphrase once each time your local machine is booted.\n\n"
    },
    {
      "title": "Installation",
      "level": 4,
      "content": "Install the keychain package.\n\n"
    },
    {
      "title": "Configuration",
      "level": 4,
      "content": "Add a line similar to the following to your shell configuration file, e.g. if using Bash:\n\n```\n~/.bashrc\n```\n\n```\neval $(keychain --eval --quiet id_ed25519 id_rsa ~/.keys/my_custom_key)\n```\n\nIn the above example,\n\n- the --eval switch outputs lines to be evaluated by the opening eval command; this sets the necessary environment variables for an SSH client to be able to find your agent.\n- --quiet will limit output to warnings, errors, and user prompts.\n\nMultiple keys can be specified on the command line, as shown in the example. By default keychain will look for key pairs in the ~/.ssh/ directory, but absolute path can be used for keys in non-standard location. You may also use the --confhost option to inform keychain to look in ~/.ssh/config for IdentityFile settings defined for particular hosts, and use these paths to locate keys.\n\nSee keychain --help or keychain(1) for details on setting keychain for other shells.\n\nTo test Keychain, simply open a new terminal emulator or log out and back in your session. It should prompt you for the passphrase of the specified private key(s) (if applicable), either using the program set in $SSH_ASKPASS or on the terminal.\n\nBecause Keychain reuses the same ssh-agent process on successive logins, you should not have to enter your passphrase the next time you log in or open a new terminal. You will only be prompted for your passphrase once each time the machine is rebooted.\n\n"
    },
    {
      "title": "Tips",
      "level": 4,
      "content": "- keychain expects public key files to exist in the same directory as their private counterparts, with a .pub extension. If the private key is a symlink, the public key can be found alongside the symlink or in the same directory as the symlink target (this capability requires the readlink command to be available on the system).\n- To disable the graphical prompt and always enter your passphrase on the terminal, use the --nogui option. This allows to copy-paste long passphrases from a password manager for example.\n- If you do not want to be immediately prompted for unlocking the keys but rather wait until they are needed, use the --noask option.\n\n- Keychain is able to manage GPG keys in the same fashion. By default it attempts to start ssh-agent only, but you can modify this behavior using the --agents option, e.g. --agents ssh,gpg. See keychain(1).\n- If you are on Wayland, you might have to add --inherit any-once as per keychain issue 148.\n\n"
    },
    {
      "title": "x11-ssh-askpass",
      "level": 3,
      "content": "The x11-ssh-askpass package provides a graphical dialog for entering your passhrase when running an X session. x11-ssh-askpass depends only on the libx11 and libxt libraries, and the appearance of x11-ssh-askpass is customizable. While it can be invoked by the ssh-add program, which will then load your decrypted keys into ssh-agent, the following instructions will, instead, configure x11-ssh-askpass to be invoked by the aforementioned Keychain script.\n\nInstall the keychain and x11-ssh-askpass packages.\n\nEdit your ~/.xinitrc file to include the following lines, replacing the name and location of your private key if necessary. Be sure to place these commands before the line which invokes your window manager.\n\n```\n~/.xinitrc\n```\n\n```\nkeychain ~/.ssh/id_ecdsa\n[ -f ~/.keychain/$HOSTNAME-sh ] && . ~/.keychain/$HOSTNAME-sh 2>/dev/null\n[ -f ~/.keychain/$HOSTNAME-sh-gpg ] && . ~/.keychain/$HOSTNAME-sh-gpg 2>/dev/null\n...\nexec openbox-session\n```\n\nIn the above example, the first line invokes keychain and passes the name and location of your private key. If this is not the first time keychain was invoked, the following two lines load the contents of $HOSTNAME-sh and $HOSTNAME-sh-gpg, if they exist. These files store the environment variables of the previous instance of keychain.\n\n"
    },
    {
      "title": "Calling x11-ssh-askpass with ssh-add",
      "level": 4,
      "content": "The ssh-add manual page specifies that, in addition to needing the DISPLAY or WAYLAND_DISPLAY variable defined, you also need SSH_ASKPASS set to the name of your askpass program (in this case x11-ssh-askpass). It bears keeping in mind that the default Arch Linux installation places the x11-ssh-askpass binary in /usr/lib/ssh/, which will not be in most people's PATH. This is a little annoying, not only when declaring the SSH_ASKPASS variable, but also when theming. You have to specify the full path everywhere. Both inconveniences can be solved simultaneously by symlinking:\n\n```\n$ ln -sv /usr/lib/ssh/x11-ssh-askpass ~/bin/ssh-askpass\n```\n\nThis is assuming that ~/bin is in your PATH. So now in your .xinitrc, before calling your window manager, one just needs to export the SSH_ASKPASS environment variable:\n\n```\n$ export SSH_ASKPASS=ssh-askpass\n```\n\nand your X resources will contain something like:\n\n```\nssh-askpass*background: #000000\n```\n\nDoing it this way works well with the above method on using ssh-agent as a wrapper program. You start X with ssh-agent startx and then add ssh-add to your window manager's list of start-up programs.\n\n"
    },
    {
      "title": "Theming",
      "level": 4,
      "content": "The appearance of the x11-ssh-askpass dialog can be customized by setting its associated X resources. Some examples are the .ad files at https://github.com/sigmavirus24/x11-ssh-askpass. See x11-ssh-askpass(1) for full details.\n\n"
    },
    {
      "title": "Alternative passphrase dialogs",
      "level": 4,
      "content": "There are other passphrase dialog programs which can be used instead of x11-ssh-askpass. The following list provides some alternative solutions.\n\n- seahorse (provides /usr/lib/seahorse/ssh-askpass) uses the GTK library.\n- gnome-ssh-askpass3AUR uses the GTK library.\n- ksshaskpass uses the KDE Wallet.\n- openssh-askpassAUR uses the Qt5 library.\n- lxqt-openssh-askpass\n\n"
    },
    {
      "title": "pam_ssh",
      "level": 3,
      "content": "The pam_ssh project exists to provide a Pluggable Authentication Module (PAM) for SSH private keys. This module can provide single sign-on behavior for your SSH connections. On login, your SSH private key passphrase can be entered in place of, or in addition to, your traditional system password. Once you have been authenticated, the pam_ssh module spawns ssh-agent to store your decrypted private key for the duration of the session.\n\nTo enable single sign-on behavior at the tty login prompt, install the unofficial pam_sshAUR package.\n\nCreate a symlink to your private key file and place it in ~/.ssh/login-keys.d/. Replace the id_rsa in the example below with the name of your own private key file.\n\n```\n$ mkdir ~/.ssh/login-keys.d/\n$ cd ~/.ssh/login-keys.d/\n$ ln -s ../id_rsa\n```\n\nEdit the /etc/pam.d/login configuration file to include the text highlighted in bold in the example below. The order in which these lines appear is significiant and can affect login behavior.\n\n```\n/etc/pam.d/login\n```\n\n```\n#%PAM-1.0\n\nauth       required     pam_securetty.so\nauth       requisite    pam_nologin.so\nauth       include      system-local-login\nauth       optional     pam_ssh.so        try_first_pass\naccount    include      system-local-login\nsession    include      system-local-login\nsession    optional     pam_ssh.so\n```\n\nIn the above example, login authentication initially proceeds as it normally would, with the user being prompted to enter their user password. The additional auth authentication rule added to the end of the authentication stack then instructs the pam_ssh module to try to decrypt any private keys found in the ~/.ssh/login-keys.d directory. The try_first_pass option is passed to the pam_ssh module, instructing it to first try to decrypt any SSH private keys using the previously entered user password. If the user's private key passphrase and user password are the same, this should succeed and the user will not be prompted to enter the same password twice. In the case where the user's private key passphrase user password differ, the pam_ssh module will prompt the user to enter the SSH passphrase after the user password has been entered. The optional control value ensures that users without an SSH private key are still able to log in. In this way, the use of pam_ssh will be transparent to users without an SSH private key.\n\nIf you use another means of logging in, such as an X11 display manager like SLiM or XDM and you would like it to provide similar functionality, you must edit its associated PAM configuration file in a similar fashion. Packages providing support for PAM typically place a default configuration file in the /etc/pam.d/ directory.\n\nFurther details on how to use pam_ssh and a list of its options can be found in the pam_ssh(8) man page.\n\n"
    },
    {
      "title": "Using a different password to unlock the SSH key",
      "level": 4,
      "content": "If you want to unlock the SSH keys or not depending on whether you use your key's passphrase or the (different!) login password, you can modify /etc/pam.d/system-auth to\n\n```\n/etc/pam.d/system-auth\n```\n\n```\n#%PAM-1.0\n\nauth      [success=1 new_authtok_reqd=1 ignore=ignore default=ignore]  pam_unix.so     try_first_pass nullok\nauth      required  pam_ssh.so      use_first_pass\nauth      optional  pam_permit.so\nauth      required  pam_env.so\n\naccount   required  pam_unix.so\naccount   optional  pam_permit.so\naccount   required  pam_time.so\n\npassword  required  pam_unix.so     try_first_pass nullok sha512 shadow\npassword  optional  pam_permit.so\n\nsession   required  pam_limits.so\nsession   required  pam_unix.so\nsession   optional  pam_permit.so\nsession   optional  pam_ssh.so\n```\n\nFor an explanation, see [7].\n\n"
    },
    {
      "title": "Known issues with pam_ssh",
      "level": 4,
      "content": "Work on the pam_ssh project is infrequent and the documentation provided is sparse. You should be aware of some of its limitations which are not mentioned in the package itself.\n\n- Versions of pam_ssh prior to version 2.0 do not support SSH keys employing the newer option of ECDSA (elliptic curve) cryptography. If you are using earlier versions of pam_ssh you must use RSA keys.\n- The ssh-agent process spawned by pam_ssh does not persist between user logins. If you like to keep a GNU Screen session active between logins you may notice when reattaching to your screen session that it can no longer communicate with ssh-agent. This is because the GNU Screen environment and those of its children will still reference the instance of ssh-agent which existed when GNU Screen was invoked but was subsequently killed in a previous logout. The Keychain front-end avoids this problem by keeping the ssh-agent process alive between logins.\n\n"
    },
    {
      "title": "pam_exec-ssh",
      "level": 3,
      "content": "As an alternative to pam_ssh you can use pam_exec-ssh-gitAUR. It is a shell script that uses pam_exec. Help for configuration can be found upstream.\n\n"
    },
    {
      "title": "GNOME Keyring",
      "level": 3,
      "content": "The GNOME Keyring tool can act as a wrapper around ssh-agent, providing GUI and/or automatic key unlocking. See GNOME Keyring#SSH keys for further details.\n\n"
    },
    {
      "title": "Store SSH keys with Kwallet",
      "level": 3,
      "content": "For instructions on how to use kwallet to store your SSH keys, see KDE Wallet#Using the KDE Wallet to store ssh key passphrases.\n\n"
    },
    {
      "title": "KeePass2 with KeeAgent plugin",
      "level": 3,
      "content": "KeeAgent is a plugin for KeePass that allows SSH keys stored in a KeePass database to be used for SSH authentication by other programs.\n\n- Supports both PuTTY and OpenSSH private key formats.\n- Works with native SSH agent on Linux/Mac and with PuTTY on Windows.\n\nSee KeePass#Plugin installation in KeePass or install the keepass-plugin-keeagent package.\n\nThis agent can be used directly, by matching KeeAgent socket: KeePass -> Tools -> Options -> KeeAgent -> Agent mode socket file -> %XDG_RUNTIME_DIR%/keeagent.socket and environment variable: export SSH_AUTH_SOCK=\"$XDG_RUNTIME_DIR\"'/keeagent.socket'.\n\n"
    },
    {
      "title": "KeePassXC",
      "level": 3,
      "content": "The KeePassXC fork of KeePass can act as a client for an existing SSH agent. SSH keys stored in its database can be automatically (or manually) added to the agent. It is also compatible with KeeAgent's database format.\n\n"
    },
    {
      "title": "Key ignored by the server",
      "level": 3,
      "content": "- If it appears that the SSH server is ignoring your keys, ensure that you have the proper permissions set on all relevant files.\n\n```\n$ chmod 700 ~/.ssh\n$ chmod 600 ~/.ssh/key\n```\n\n```\n$ chmod 700 ~/.ssh\n$ chmod 600 ~/.ssh/authorized_keys\n```\n\n```\n$ chmod go-w ~target_user\n```\n\n- If that does not solve the problem you may try temporarily setting StrictModes to no in /etc/ssh/sshd_config. If authentication with StrictModes off is successful, it is likely an issue with file permissions persists.\n\n- Make sure keys in ~/.ssh/authorized_keys are entered correctly and only use one single line.\n- Make sure the remote machine supports the type of keys you are using: some servers do not support ECDSA keys, try using RSA keys instead, see #Generating an SSH key pair.\n- You may want to use debug mode and monitor the output while connecting:\n\n```\n# /usr/bin/sshd -d\n```\n\n- If you gave another name to your key, for example id_rsa_server, you need to connect with the -i option:\n\n```\n$ ssh -i id_rsa_server user@server\n```\n\n"
    },
    {
      "title": "agent refused operation",
      "level": 3,
      "content": "If your private key requires a password (or, for instance, you have a hardware key with a PIN) but ssh-agent is not provided with one, ssh will fail:\n\n```\nsign_and_send_pubkey: signing failed for ECDSA-SK user@host from agent: agent refused operation\n```\n\nOne potential cause for this is ssh-agent being unable to prompt for a password. Ensure that ssh-agent has access to either a display server (via the DISPLAY environment variable) or a TTY. For some graphical environments you might only need to install x11-ssh-askpass, for other setups also follow #x11-ssh-askpass instructions.\n\nAnother cause, if using a hardware authenticator, could be the key malfunctioning or being unplugged.\n\nThere is currently an open bug that triggers with the \"agent refused operation\" error when using authenticator keys like ED25519-sk and ECDSA-SK that were created with the option -O verify-required. To avoid this issue, use the -o IdentityAgent=none -o IdentitiesOnly=yes option for the ssh command or add it to your ssh_config file for the relevant hosts:\n\n```\nHost myserver.tld\n    IdentityAgent none\n    IdentitiesOnly yes\n```\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- OpenSSH key management: Part 1, Part 2, Part 3\n- Secure Secure Shell\n\n"
    }
  ]
}