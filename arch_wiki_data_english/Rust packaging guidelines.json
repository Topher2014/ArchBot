{
  "title": "Rust packaging guidelines",
  "url": "https://wiki.archlinux.org/title/Rust_packaging_guidelines",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Font – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel modules – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust - Security – Shell – VCS – Web – Wine\n\nThis document covers standards and guidelines on writing PKGBUILDs for software written in Rust.\n\n"
    },
    {
      "title": "Package naming",
      "level": 2,
      "content": "When packaging Rust projects, the package name should almost always be the same as the name of the generated binary. Note that it does not make any sense to package library crates, so only crates with bins will be packaged. For ones that generate more than one binary, the upstream crate name is usually appropriate. In any event the package name should be entirely lowercase.\n\n"
    },
    {
      "title": "Source",
      "level": 2,
      "content": "Most Rust projects may be built from tarballs, source archives (e.g. source links on GitHub releases), or any other published source.\n\nWhen other sources are not available, most Rust projects are published on crates.io which provides a stable download URL scheme for use with cargo. The downside of this source is that it usually does not include all the test files, license files, or other assets normally in the other sources. If needed, the PKGBUILD#source can use the following template:\n\n```\nsource=(\"$pkgname-$pkgver.tar.gz::https://static.crates.io/crates/$pkgname/$pkgname-$pkgver.crate\")\n```\n\n"
    },
    {
      "title": "Depends",
      "level": 2,
      "content": "While some Rust projects have external dependencies, most just use Rust ecosystem libraries that are statically embedded in the final binary. As such most projects will not need to specify many depends. The usual exceptions that most Rust binaries do link against glibc libraries, so gcc-libs and glibc are typically dependencies of most Rust packages. There may be more if the build process looks for and links against any system libraries.\n\nFor makedepends, the vast majority of Rust projects are designed to be built using the cargo dependency manager, which both orchestrates the download of libraries to satisfy build time dependencies as well as makes all the necessary calls to rustc, the actual Rust compiler. Currently both cargo and rustc are provided by the rust package, but there are also alternative ways of getting both of these together or separately including the rustup package. As such, the tool most PKGBUILDs are going to call is cargo and you should depend directly on it.\n\n```\nmakedepends=(cargo)\n```\n\nIf a project requires the use of a nightly version of the Rust tool chain, use:\n\n```\nmakedepends=(cargo-nightly)\n```\n\n"
    },
    {
      "title": "Prepare",
      "level": 2,
      "content": "The rust dependency manager cargo is able to download all the libraries required to build a project ahead of time. Running this fetch in the prepare() stage enables the later build() and other stages to be run entirely offline.\n\n```\nprepare() {\n    export RUSTUP_TOOLCHAIN=stable\n    cargo fetch --locked --target \"$(rustc -vV | sed -n 's/host: //p')\"\n}\n```\n\nwhere:\n\n- RUSTUP_TOOLCHAIN=stable makes sure the default tool chain is set to stable in the event users have changed their default. Of course this should be set to nightly in the event that's what the upstream project requires. This avoids a common side effect of user preferences when not building in a chroot. Also note this is not required if the upstream project has a rust-toolchain file or rust-toolchain.toml file in their sources that serves this purpose.\n- --locked tells cargo to strictly adhere to the versions specified in the Cargo.lock file and prevent it from updating dependencies. This is important for reproducible builds.\n- --target \"$(rustc -vV | sed -n 's/host: //p')\" tells cargo to only fetch dependencies needed for the specific target platform being built, thus reducing downloads (see PKGBUILD#arch and Rust platform support).\n\n"
    },
    {
      "title": "Build",
      "level": 2,
      "content": "Building a Rust package.\n\n```\nbuild() {\n    export RUSTUP_TOOLCHAIN=stable\n    export CARGO_TARGET_DIR=target\n    cargo build --frozen --release --all-features\n}\n```\n\nwhere:\n\n- --release tells cargo to compile a release build (the default is a debug build)\n- --frozen tells cargo to stay offline and only use the versions specified in the Cargo.lock file and as cached by the fetch run in the prepare() stage. This is functionally equivalent to --locked --offline, which may also be used. This is important for reproducible builds.\n- --all-features tells cargo to compile with all features of the package enabled. Alternatively, use --features FEATURE1,FEATURE2 if you want enable only selected features.\n- CARGO_TARGET_DIR=target tells cargo to place the output in target relative to the current directory. This avoids a common side effect of user preferences when not building in a chroot.\n\n"
    },
    {
      "title": "Check",
      "level": 2,
      "content": "Most Rust projects provide a simple way to run the test suite.\n\n```\ncheck() {\n    export RUSTUP_TOOLCHAIN=stable\n    cargo test --frozen --all-features\n}\n```\n\nYou should also check if the repository is a cargo workspace. Just open up /Cargo.toml and see if it contains a [workspace] section. If so, you should add the --workspace flag to cargo test to ensure that all tests of the workspace members are run too.\n\n"
    },
    {
      "title": "Package",
      "level": 2,
      "content": "Rust builds binaries in target/release and can simply be installed to /usr/bin.\n\n```\npackage() {\n    install -Dm0755 -t \"$pkgdir/usr/bin/\" \"target/release/$pkgname\"\n}\n```\n\nIf a package has more than one executable in /usr/bin you can use find command:\n\n```\npackage() {\n    find target/release \\\n        -maxdepth 1 \\\n        -executable \\\n        -type f \\\n        -exec install -Dm0755 -t \"$pkgdir/usr/bin/\" {} +\n}\n```\n\n"
    },
    {
      "title": "Notes about using cargo install",
      "level": 3,
      "content": "Some packages should install more files such as a man page or other assets. In the event that such a package does not have any other way to install these, one can use cargo install. In this case build() is unnecessary because cargo install forces rebuilding even if the package already has been built by using cargo build. The prepare() stage can still be used to fetch sources ahead of time:\n\n```\npackage() {\n    export RUSTUP_TOOLCHAIN=stable \n    cargo install --no-track --frozen --all-features --root \"$pkgdir/usr/\" --path .\n}\n```\n\nThe --no-track argument should always be used, otherwise cargo install will create unwanted files such as /usr/.crates.toml or /usr/.crates2.json.\n\n"
    },
    {
      "title": "Preventing the \"Package contains reference to $srcdir\" warning",
      "level": 3,
      "content": "This warning occurs because $srcdir appears in at least one file in pkg, which is undesirable for reproducible builds. Paths can be redacted as follows:\n\n```\nexport RUSTFLAGS=\"${RUSTFLAGS} --remap-path-prefix $srcdir=src\"\n```\n\n"
    },
    {
      "title": "Complete PKGBUILD template",
      "level": 2,
      "content": "```\n# Maintainer: Firstname Lastname <email@example.org>\n\npkgname=\npkgver=\npkgrel=1\npkgdesc=''\nurl=''\nlicense=()\nmakedepends=('cargo')\ndepends=()\narch=('i686' 'x86_64' 'armv6h' 'armv7h')\nsource=()\nb2sums=()\n\nprepare() {\n    export RUSTUP_TOOLCHAIN=stable\n    cargo fetch --locked --target \"$(rustc -vV | sed -n 's/host: //p')\"\n}\n\nbuild() {\n    export RUSTUP_TOOLCHAIN=stable\n    export CARGO_TARGET_DIR=target\n    cargo build --frozen --release --all-features\n}\n\ncheck() {\n    export RUSTUP_TOOLCHAIN=stable\n    cargo test --frozen --all-features\n}\n\npackage() {\n    install -Dm0755 -t \"$pkgdir/usr/bin/\" \"target/release/$pkgname\"\n    # for custom license, e.g. MIT\n    # install -Dm644 LICENSE \"${pkgdir}/usr/share/licenses/${pkgname}/LICENSE\"\n}\n```\n\n"
    },
    {
      "title": "Example packages",
      "level": 2,
      "content": "Click Package Actions > Source Files in the package page to see its example PKGBUILD.\n\n- cbindgen\n- ripgrep\n\n"
    }
  ]
}