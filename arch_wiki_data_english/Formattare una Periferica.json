{
  "title": "Formattare una Periferica",
  "url": "https://wiki.archlinux.org/title/Formattare_una_Periferica",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Articoli correlati\n\n- Partitioning\n- Device file#lsblk\n- File permissions and attributes\n- fsck\n- fstab\n- List of applications/Utilities#Mount tools\n- QEMU#Mounting a partition from a raw image\n- udev\n- udisks\n- umask\n- USB storage devices\n\nDa Wikipedia:\n\nOgni singola partizione del drive può essere configurata utilizzando uno dei tanti file system diversi disponibili. Ognuno presenta i propri vantaggi, svantaggi e le proprie idiosincrasie peculiari. Segue una breve panoramica dei file system supportati, i rispettivi link indirizzano alle pagine di Wikipedia che forniscono molte più informazioni.\n\n"
    },
    {
      "title": "Tipi di file system",
      "level": 2,
      "content": "Vedere filesystems(5) per una panoramica generale e Wikipedia:Comparison of file systems per un confronto dettagliato. I file system già caricati dal kernel o integrati sono elencati in /proc/filesystems, mentre tutti i moduli installati possono essere visualizzati eseguendo ls /lib/modules/$(uname -r)/kernel/fs.\n\nTable content:\nFile system | Comando per creazione | Utility userspace | Archiso [1] | Documentazione kernel [2] | Note\nBcachefs | bcachefs(8) | bcachefs-tools | Sì |  | Disponibile in Linux 6.7+, sperimentale\nBtrfs | mkfs.btrfs(8) | btrfs-progs | Sì | btrfs.html | Stato stabilità\nVFAT | mkfs.fat(8) | dosfstools | Sì | vfat.html | File system Windows 9x\nexFAT | mkfs.exfat(8) | exfatprogs | Sì |  | File system nativo in Linux 5.4 [3]\nmkexfatfs(8) | exfat-utils | No | N/A (basato su FUSE) | \nF2FS | mkfs.f2fs(8) | f2fs-tools | Sì | f2fs.html | Dispositivi basati su flash\next3 | mkfs.ext3(8) | e2fsprogs | Sì | ext3.html | \next4 | mkfs.ext4(8) | e2fsprogs | Sì | ext4.html | \nHFS | mkfs.hfsplus(8) | hfsprogsAUR | No | hfs.html | File system Mac OS Classic\nHFS+ | mkfs.hfsplus(8) | hfsprogsAUR | No | hfsplus.html | File system macOS (8–10.12)\nJFS | mkfs.jfs(8) | jfsutils | Sì | jfs.html | \nNILFS2 | mkfs.nilfs2(8) | nilfs-utils | Sì | nilfs2.html | Dispositivi flash raw, ad es. scheda SD\nNTFS |  |  | Sì | ntfs3.html | File system Windows NT file system. Nuovo driver disponibile dalla versione 5.15 di Linux.\n | ntfs-3g[4] | No | ntfs.html[link interrotto 2024-07-30] | Vecchio driver. Supporto in scrittura estremamente limitato. I kernel ufficialmente supportati sono compilati senza l'opzione CONFIG_NTFS_FS, pertanto questo driver non è disponibile.\nmkfs.ntfs(8) | Sì | N/A (basato su FUSE) | Driver FUSE con funzionalità estese.\nReiserFS | mkfs.reiserfs(8) | reiserfsprogsAUR | Sì |  | ReiserFS è deprecato nella versione 5.18 di Linux e ne è prevista la rimozione dal kernel nel 2025.\nUDF | mkfs.udf(8) | udftools | Sì | udf.html | \nXFS | mkfs.xfs(8) | xfsprogs | Sì | xfs.html xfs-delayed-logging-design.html[link interrotto 2024-03-03] xfs-self-describing-metadata.html[link interrotto 2024-03-03] | Impossibile ridurne le dimensioni\n\nxfs.html xfs-delayed-logging-design.html[link interrotto 2024-03-03] xfs-self-describing-metadata.html[link interrotto 2024-03-03]\n\nTable content:\nFile system | Comando per creazione | Patchset del kernel | Utility userspace | Note\nAPFS | mkapfs(8) | linux-apfs-rw-dkms-gitAUR | apfsprogs-gitAUR | File system macOS (versione 10.13 e successive). Sola lettura, sperimentale. Vedere anche la versione FUSE apfs-fuse-gitAUR.\nReiser4 | mkfs.reiser4(8) |  | reiser4progsAUR | \nZFS |  | zfs-linuxAUR, zfs-dkmsAUR | zfs-utilsAUR | Esiste un suo porting: OpenZFS\n\n"
    },
    {
      "title": "Journaling",
      "level": 3,
      "content": "Tutti i file system precedentemente citati, con le eccezioni di exFAT, FAT16/32, Reiser4 (opzionale), Bcachefs, Btrfs e ZFS, fanno ricorso al journaling. Il journal garantisce la fault resilience registrando in un log le modifiche prima che queste vengano effettivamente applicate al file system. In caso di un crash di sistema o di interruzione improvvisa dell'alimentazione elettrica, questi file system sono più veloci a tornare online e presentano una probabilità più bassa di corrompersi. Le registrazione dei log avviene in un'area appositamente dedicata del file system.\n\nNon tutte le tecniche di journaling sono uguali. Ext3 ed ext4 offrono il journaling data-mode, il quale registra nei log sia i dati che i metadati, ma può eventualmente effettuare il log dei soli metadati. Il journaling data-mode comporta una perdita di velocità e non è attivo per impostazione predefinita. Similmente, Reiser4 offre i cosiddetti \"modelli di transazione\" che modificano non solo le funzionalità fornite ma anche la modalità di journaling. Questo file system utilizza diverse tecniche di journaling: un modello speciale chiamato wandering logs che elimina la necessità di scrivere su disco due volte, write-anywhere un approccio copy-on-write puro (pressoché equivalente a quello predefinito di btrfs, ma con una differenza sostanziale nella struttura dell'\"albero\") e un approccio combinato detto ibrido, che alterna in modo euristico i due precedenti.\n\nNote: **node41** \n\nGli altri file system offrono una tipologia di journaling ordered-mode, che registra nei log solo i metadati. Benché tutti i file system con journaling sono in grado di riportare il sistema in uno stato valido in seguito a un crash, solo il journaling data-mode offre la massima protezione contro la corruzione e la perdita di dati. Tutto ciò tuttavia a prezzo di un compromesso in termini di prestazioni, in quanto il journaling data-mode effettua due operazioni di scrittura: la prima nel journal e la seconda su disco (Reiser4 evita questa limitazione grazie alla sua funzione \"wandering logs\"). Quando si sceglie il tipo di file system da utilizzare è opportuno valutare il compromesso necessario tra velocità del sistema e sicurezza dei dati. Reiser4 è l'unico file system che, in virtù del modo in cui è progettato, opera con piena atomicità e fornisce i checksum sia per i metadati che per i dati inline (un'operazione viene eseguita per intero o non viene eseguita del tutto e questo evita la corruzione o la distruzione di dati dovuta a operazioni solo parzialmente eseguite), ed è pertanto molto meno incline alla perdita di dati rispetto ad altri file system come Btrfs.\n\nI file system basati su tecnologia copy-on-write (nota anche come write-anywhere), quali Reiser4, Btrfs, Bcachefs e ZFS, non necessitano di un journal tradizionale per proteggere i metadati, in quanto il loro aggiornamento non avviene mai in-place. Sebbene Btrfs continui a possedere un albero di log simile a un journal, questo viene utilizzato esclusivamente per velocizzare le operazioni di fdatasync/fsync.\n\n"
    },
    {
      "title": "File system basati su FUSE",
      "level": 3,
      "content": "Vedere FUSE.\n\n"
    },
    {
      "title": "File system configurabili in stack",
      "level": 3,
      "content": "- eCryptfs — Il file system enterprise crittografico è un pacchetto di software per la cifratura dei dischi in Linux. È implementato come un layer di cifratura conforme allo standard POSIX a livello di file system, con l'obiettivo di offrire funzionalità simili a quelle di GnuPG ma a livello di sistema operativo.\n\n- mergerfs — uno union file system basato su FUSE.\n\n- mhddfs — File system FUSE per HDD multipli, uno union file system basato su FUSE.\n\n- overlayfs — OverlayFS è un servizio di file system per Linux che offre un'implementazione union mount per altri file system.\n\n- unionfs-fuse — Un'implementazione a livello di spazio utente di Unionfs.\n\n"
    },
    {
      "title": "File systems in sola lettura",
      "level": 3,
      "content": "- EROFS — Enhanced Read-Only File System è un file system in sola lettura leggero, che si prefigge di migliorare le prestazioni e offrire la compressione della capacità di archiviazione.\n\n- SquashFS — SquashFS è un file system compresso in sola lettura. SquashFS comprime i file, gli inode e le cartelle e supporta blocchi di dimensioni massime di 1 MiB, per una migliore compressione.\n\n"
    },
    {
      "title": "Clustered file system",
      "level": 3,
      "content": "- BeeGFS — Un file system parallelo, sviluppato e ottimizzato per computing ad alte prestazioni.\n\n- Ceph — Sistema di archiviazione unificato e distribuito, progettato per offrire prestazioni, affidabilità e scalabilità eccellenti.\n\n- Glusterfs — Cluster file system che offre una scalabilità fino a diversi petabyte.\n\n- IPFS — Un protocollo hypermedia peer-to-peer per rendere il web più veloce, più sicuro, e più aperto. IPFS mira a sostituire HTTP e a costruire un web migliore per tutti. Utilizza dei blocchi per archiviare parti di un file, ogni nodo di rete archivia solo il contenuto di proprio interesse, offre funzionalità di deduplicazione e distribuzione, oltre a un sistema scalabile, il cui unico limite è costituito dagli utenti. (Attualmente in stadio di sviluppo alpha)\n\n- MinIO — MinIO offre alte prestazioni oltre ad archiviazione degli oggetti compatibile con S3.\n\n- MooseFS — MooseFS è un file system con tolleranza agli errori, ad alta disponibilità ed elevate prestazioni, scalabile e distribuito sulla rete.\n\n- OpenAFS — Implementazione open source del file system distribuito AFS\n\n- OrangeFS — OrangeFS è un file system di rete scalabile progettato per l'accesso parallelo e trasparente a sistemi di storage multi-server. Offre supporto MPI-IO ottimizzato per applicazioni parallele e distribuite. Semplifica l'utilizzo di soluzioni di storage parallelo non solo per i client Linux, ma anche per Windows, Hadoop, e WebDAV. È compatibile con gli standard POSIX. È parte del kernel Linux a partire dalla versione 4.6.\n\n- Sheepdog — Un sistema di archiviazione di oggetti distribuito per volumi e servizi di container, gestisce dischi e nodi in modo intelligente.\n\n- Tahoe-LAFS — Tahoe Least-Authority File Store è un data store distribuito e un file system distribuito libero e aperto, sicuro, decentralizzato, con tolleranza agli errori e con distribuzione peer-to-peer.\n\n"
    },
    {
      "title": "File system con condivisione dei dischi",
      "level": 3,
      "content": "- GFS2 — GFS2 permette a tutti i membri di un cluster di avere accesso diretto e simultaneo alla medesima unità di archiviazione a blocchi condivisa\n\n- OCFS2 — Oracle Cluster File System (versione 2) è un file system con condivisione dei dischi sviluppato da Oracle Corporation e rilasciato sotto licenza GNU General Public License\n\n- VMware VMFS — VMFS (Virtual Machine File System) di VMware è utilizzato dalla suite di virtualizzazione server della società, vSphere.\n\n"
    },
    {
      "title": "Identificazione dei file system esistenti",
      "level": 2,
      "content": "Per identificare i file system esistenti è possibile utilizzare lsblk:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE LABEL     UUID                                 MOUNTPOINT\nsdb\n└─sdb1 vfat   Transcend 4A3C-A9E9\n```\n\nUn eventuale file system, se presente, verrà indicato nella colonna FSTYPE. Se è già montato, apparirà nella colonna MOUNTPOINT.\n\n"
    },
    {
      "title": "Creazione di un file system",
      "level": 2,
      "content": "Di norma i file system vengono creati su una partizione, all'interno di container logici come LVM, RAID e dm-crypt, o su un normale file (vedere Wikipedia:it:Loop device). La presente sezione descrive come creare un file system su una partizione.\n\nNote: **Creare un backup di tutti i dati che si si desidera conservare** \n\n- Dopo aver creato un nuovo file system, è improbabile che i dati precedentemente presenti sulla partizione interessata possano essere recuperati. Creare un backup di tutti i dati che si si desidera conservare.\n- L'utilizzo che si farà di una partizione può restringere il ventaglio di scelta dei file system. Ad esempio, una partizione di sistema EFI può contenere un file system FAT32, e il file system che conterrà la cartella /boot deve essere supportato dal boot loader.\n\nPrima di continuare, identificare il dispositivo su cui verrà creato il file system e controllare se è montato o meno. Ad esempio:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE   LABEL       UUID                                 MOUNTPOINT\nsda\n├─sda1                      C4DA-2C4D\n├─sda2 ext4                 5b1564b2-2e2c-452c-bcfa-d1f572ae99f2 /mnt\n└─sda3                      56adc99b-a61e-46af-aab7-a6d07e504652\n```\n\nI file system montati devono essere smontati prima di procedere. Nell'esempio precedente la partizione /dev/sda2 contiene un file system ed è montata in /mnt. Per smontarla andrebbe eseguito:\n\n```\n# umount /dev/sda2\n```\n\nPer trovare solo i file system montati, vedere #Elenco dei file system montati.\n\nPer creare un nuovo file system, utilizzare mkfs(8). Vedere #Tipi di file system per trovare il tipo esatto di file system e le utility in spazio utente da installare per un particolare file system.\n\nAd esempio, per creare un nuovo file system di tipo ext4 (comune per le partizioni dati Linux) su /dev/sda1, eseguire:\n\n```\n# mkfs.ext4 /dev/sda1\n```\n\n- Utilizzare la flag -L di mkfs.ext4 per specificare un'etichetta del file system. È possibile utilizzare e2label per cambiare l'etichetta di un file system esistente.\n- I file system possono essere ridimensionati dopo la creazione, con alcune limitazioni. Ad esempio, le dimensioni di un file system XFS possono essere aumentate, ma non diminuite. Vedere Wikipedia:Comparison of file systems#Resize capabilities e la documentazione del rispettivo file system per i dettagli.\n\nIl nuovo file system ora può essere montato nella cartella di preferenza.\n\n"
    },
    {
      "title": "Montaggio di un file system",
      "level": 2,
      "content": "Per montare manualmente un file system presente su un dispositivo (ad es., una partizione) in una cartella, utilizzare il comando mount(8). Questo esempio esegue il montaggio di /dev/sda1 in /mnt.\n\n```\n# mount /dev/sda1 /mnt\n```\n\nQuesto comando collega il file system su /dev/sda1 alla cartella /mnt, rendendo visibile il contenuto del file system stesso. Tutti i dati precedentemente esistenti nella cartella /mnt prima del comando non saranno più visibili fino a quando il file system non verrà smontato.\n\nIl file fstab contiene le informazioni su come i dispositivi dovrebbero essere montati automaticamente, ove presenti. Vedere l'articolo fstab per maggiori informazioni su come modificare questo comportamento.\n\nSe un dispositivo è specificato all'interno di /etc/fstab e si passa al comando di mount solo il dispositivo o il punto di montaggio, questa informazione verrà utilizzata per eseguire il montaggio. Ad esempio, se /etc/fstab contiene una linea che indica che /dev/sda1 deve essere montato su /mnt, il comando seguente eseguirà automaticamente il montaggio del dispositivo in quella posizione:\n\n```\n# mount /dev/sda1\n```\n\nOppure\n\n```\n# mount /mnt\n```\n\nmount contiene diverse opzioni, molte delle quali dipendono dal file system specificato. Le opzioni posso essere cambiate nei seguenti modi:\n\n- utilizzando le flag dalla linea di comando con il comando mount\n- modificando fstab\n- creando delle regole udev\n- compilando il proprio kernel\n- o utilizzando script di montaggio specifici per il file system (disponibili in /usr/bin/mount.*).\n\nConsultare questi articoli correlati e l'articolo inerente al file system di interesse per maggiori informazioni.\n\n- I file system possono essere montati anche con systemd-mount in luogo di mount. Se il punto di montaggio non è specificato, il file system verrà montato in /run/media/system/identificatore_del_dispositivo/. Ciò permette di eseguire facilmente il montaggio di un file system senza bisogno di decidere la posizione. Vedere systemd-mount(1) per il suo utilizzo e per maggior dettagli.\n- Per eseguire il montaggio dei file system come utente non privilegiato, vedere udisks#Usage. Questa soluzione permette inoltre di eseguire il montaggio senza possedere i permessi di root, in assenza di un ambiente grafico completo o di un file manager che utilizzi udisks.\n\n"
    },
    {
      "title": "Elenco dei file system montati",
      "level": 3,
      "content": "Per visualizzare l'elenco di tutti i file system montati, utilizzare findmnt(8):\n\n```\n$ findmnt\n```\n\nfindmnt accetta un'ampia serie di argomenti in grado di filtrare l'output e per mostrare informazioni aggiuntive. Ad esempio, accetta come argomento un dispositivo o un punto di montaggio per visualizzare solo le informazioni relative a quanto specificato:\n\n```\n$ findmnt /dev/sda1\n```\n\nfindmnt raccoglie le informazioni da /etc/fstab, /etc/mtab, e /proc/self/mounts.\n\n"
    },
    {
      "title": "Smontaggio di un file system",
      "level": 3,
      "content": "Per smontare un file system utilizzare umount(8). È possibile specificare sia il dispositivo che lo contiene (ad es., /dev/sda1) o il punto di montaggio (ad es., /mnt):\n\n```\n# umount /dev/sda1\n```\n\noppure\n\n```\n# umount /mnt\n```\n\n"
    },
    {
      "title": "\"linux Structure needs cleaning\"",
      "level": 3,
      "content": "Smontare il file system ed eseguire fsck sul volume che presenta questo problema.\n\n"
    },
    {
      "title": "Vedere anche",
      "level": 2,
      "content": "- filesystems(5)\n- systemd-mount(1)\n- Documentazione dei file system supportati da Linux\n- Articolo Wikipedia sui file system\n- Articolo Wikipedia sul comando mount\n\n"
    }
  ]
}