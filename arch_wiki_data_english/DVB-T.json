{
  "title": "DVB-T",
  "url": "https://wiki.archlinux.org/title/DVB-T",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- DVB-S\n- LIRC\n- RTL-SDR\n\nDVB-T is a standard for transmitting terrestrial digital video broadcast, which is used in the majority of Africa, Asia, Australia and Europe. It is possible to receive DVB-T using several different hardware setups, however this article will focus on DVB-T USB dongles based on the RTL2832U chipset (which are also very popular as cheap software defined radios using RTL-SDR).\n\n"
    },
    {
      "title": "Driver",
      "level": 2,
      "content": "The main driver in use is dvb_usb_rtl28xxu, and exists in the latest kernels. If it is not loaded, do so manually:\n\n```\n# modprobe dvb_usb_rtl28xxu\n```\n\nYou might also need to load rtl2832 or rtl2830:\n\n```\n# modprobe rtl2830\n# modprobe rtl2832\n```\n\nAfter plugging the device in, the output of dmesg should show something like this:\n\n```\n[ 4009.326338] usb 7-5: new high-speed USB device number 4 using ehci-pci\n[ 4009.466712] usb 7-5: dvb_usb_v2: found a 'Realtek RTL2832U reference design' in warm state\n[ 4009.531594] usb 7-5: dvb_usb_v2: will pass the complete MPEG2 transport stream to the software demuxer\n[ 4009.531613] DVB: registering new adapter (Realtek RTL2832U reference design)\n[ 4009.534554] usb 7-5: DVB: registering adapter 0 frontend 0 (Realtek RTL2832 (DVB-T))...\n[ 4009.534627] r820t 4-001a: creating new instance\n[ 4009.546177] r820t 4-001a: Rafael Micro r820t successfully identified\n[ 4009.552681] Registered IR keymap rc-empty\n[ 4009.552783] input: Realtek RTL2832U reference design as /devices/pci0000:00/0000:00:1d.7/usb7/7-5/rc/rc1/input20\n[ 4009.552854] rc1: Realtek RTL2832U reference design as /devices/pci0000:00/0000:00:1d.7/usb7/7-5/rc/rc1\n[ 4009.553275] input: MCE IR Keyboard/Mouse (dvb_usb_rtl28xxu) as /devices/virtual/input/input21\n[ 4009.554466] rc rc1: lirc_dev: driver ir-lirc-codec (dvb_usb_rtl28xxu) registered at minor = 0\n[ 4009.554474] usb 7-5: dvb_usb_v2: schedule remote query interval to 400 msecs\n[ 4009.565930] usb 7-5: dvb_usb_v2: 'Realtek RTL2832U reference design' successfully initialized and connected\n```\n\nAdditionally, you should now see the adapter device under /dev/dvb/adapter0. Some cards need additional firmwares that are not distributed for various reasons. Usually you will find an explicit message about that from dmesg. Look for the name of the file(s) you see with your favorite search engine, and once you have them, put the required firmware(s) in /usr/lib/firmware. Possibly a package might exist in the AUR.\n\n"
    },
    {
      "title": "Utilities",
      "level": 2,
      "content": "Various DVB utilities can be found in the linuxtv-dvb-appsAUR package.\n\n"
    },
    {
      "title": "Scanning",
      "level": 3,
      "content": "w_scan_cppAUR allows for automatic scanning of channels without configuration. Install it then issue:\n\n```\n# w_scan_cpp -ft -c [country_code] --output-mplayer > ~/channels.conf\n```\n\nIf you do not know your country code, enter the following to get a list of codes.\n\n```\n# w_scan_cpp -c \"?\"\n```\n\nThe application now provides help. Use w_scan_cpp --help for more information.\n\nMore advanced scanning options can be found under DVB-S#Scanning channels.\n\nWhen w_scan_cpp fails to find all expected channels you could try w_scan2AUR. It is a fork of the original w_scan and can be found on GitHub.\n\n"
    },
    {
      "title": "Clients",
      "level": 2,
      "content": "See also how to disable screensaver when playing video/TV by using configuration files or use xset command before and after player starts to enable/disable it. If you have installed xscreensaver then you will need to use xscreensaver-command instead of xset to activate/deactivate screensaver from command line.\n\n"
    },
    {
      "title": "Kaffeine",
      "level": 3,
      "content": "Kaffeine does not work on Wayland. On X11, DVB-T works out-of-the box in Kaffeine, including management of multpile DVB-T devices, channel tuning, channel selection, EPG and recording. No external playlist generation is needed. Multiple DVB-T devices can be used at once (e.g. for recording from a multiplex while watching another one). Many single-tuner DVB-T devices can even provide two different TV channels, as long as they share the same multiplex; this feature is also readily available in Kaffeine.\n\n"
    },
    {
      "title": "Smplayer",
      "level": 3,
      "content": "Smplayer Can play DVB-T with tvheadend\n\n"
    },
    {
      "title": "VLC",
      "level": 3,
      "content": "The simplest way to watch DVB-T channels with VLC is to first generate a playlist:\n\n```\n$ w_scan_cpp -ft -c [country_code] -L > dvb.xspf\n$ vlc dvb.xspf\n```\n\nYou can also specify the frequency and programs by hand. This can be done using:\n\n```\n$ vlc dvb://frequency=543000000\n```\n\nwhere the frequency is set in Hz, and should match the base frequency for the transmissions in your area. You can also explicitly specify which demodulation you would like to use, so instead of dvb you can use dvb-t, dvb-t2, etc.\n\nVLC also accepts various command line arguments, for example if you want to tune into a different program:\n\n```\n$ vlc dvb://frequency=543000000 :program=3\n```\n\nIf some DVB-T streams do not work, install aribb24.\n\n"
    },
    {
      "title": "MPlayer / mpv",
      "level": 3,
      "content": "For DVB streaming, MPlayer (or mpv) requires a channels configuration file at ~/.mplayer/channels.conf. Follow #Scanning for instructions on how to generate it, but make sure to use the -M flag to generate the proper format for MPlayer, if you are using w_scan_cpp:\n\n```\n$ w_scan_cpp -ft -c [country_code] -M > ~/.mplayer/channels.conf\n```\n\nFor mpv, use:\n\n```\n$ w_scan_cpp -ft -c [country_code] -M > ~/.config/mpv/channels.conf\n```\n\nTry the configuration with mplayer dvb://, which should start to play the first channel. If it does not, you might need to use -demuxer lavf or -demuxer mpegts in order to properly receive the stream.\n\nIf the configuration works, you can simply run:\n\n```\n$ mplayer dvb://\"STREAM NAME\"\n```\n\nwith a valid STREAM NAME from the channels configuration file.\n\n"
    },
    {
      "title": "Channel selector",
      "level": 4,
      "content": "Here is a lstvAUR script that will show a numbered list of channels by reading data from a ~/.mplayer/channels.conf file. You will be able to watch a channel by using a number associated to it by the script instead of having to type the whole channel name on the command line, e.g. lstv 3. The channel number associated by the script equals to the line number with tuning configuration for it. The script disables display power saving and a screen saver before starting mplayer and enables both again after you close it to disable screensaver management in this script remove xset ...; before and after MPlayer.\n\n```\n/usr/local/bin/lstv\n```\n\n```\n#!/bin/bash\nif [ \"$1\" ];then\nCC='^[0-9]+$';\n  ifÂ ! [[ \"$@\" =~ $CC ]];then echo Is not a channel number!;\n   else\n##\n    awk -F':' -v AA=\"$1\" '//{ZZ++;\n     if(AA == ZZ)system(\"xset -dpms s off;mplayer dvb://\"\"\\\"\"$1\"\\\";xset +dpms s on\")}\n     END{if(AA > ZZ)printf \"The highest channel number is: \"ZZ\"\\n\"}' \"$HOME/.mplayer/channels.conf\"\n##\n  fi;\nelse\nawk -F':' '// { ZZ++; printf  ZZ \" | \" $1 \"\\n\"}' \"$HOME/.mplayer/channels.conf\"\nfi;\n```\n\n- It is assumed that the channels.conf file has been created with: w_scan_cpp -ft -c country_code -C UTF-8 -M -E 0 -O 0 > ~/.mplayer/channels.conf\n- If the list of channels is too long then you can use something like lstv | less and search for channels name by pressing / and writing its name. When found press q for exiting of less(1) and use the channel associated number with lstvAUR.\n- If you have a problem with playing of video see Arch Linux Forum.\n\n"
    },
    {
      "title": "ffmpeg",
      "level": 3,
      "content": "FFmpeg can take DVB-T MPEG streams as input, but requires tzap (in linuxtv-dvb-appsAUR) to do so.\n\nFirst, generate a tzap-compatible channels.conf file, using w_scan_cpp:\n\n```\n$ w_scan_cpp -ft -A1 -X > ~/.tzap/channels.conf\n```\n\nThen, you can run:\n\n```\n$ tzap -r \"CHANNEL NAME\"\n```\n\nwhich, if setup correctly should yield an output similar to:\n\n```\nusing '/dev/dvb/adapter0/frontend0' and '/dev/dvb/adapter0/demux0'\nreading channels from file '/home/user/.tzap/channels.conf'\nVersion: 5.10  \t FE_CAN { DVB-T }\ntuning to 506000000 Hz\nvideo pid 0x0a21, audio pid 0x0a22\nstatus 00 | signal 0000 | snr 0000 | ber 0000ffff | unc 00007fbd | \nstatus 1f | signal 0000 | snr 0126 | ber 00000000 | unc 00007fbd | FE_HAS_LOCK\nstatus 1f | signal 0000 | snr 0129 | ber 0000000f | unc 00007fbd | FE_HAS_LOCK\nstatus 1f | signal 0000 | snr 0120 | ber 00000003 | unc 00007fbd | FE_HAS_LOCK\nstatus 1f | signal 0000 | snr 0125 | ber 00000011 | unc 00007fbd | FE_HAS_LOCK\n# ....\n```\n\nMore information on tzap is available on the zap wiki page.\n\nOnce tzap is encoding the stream, /dev/dvb/adapter0/dvr0 should be available to ffmpeg (or any other program).\n\nA simple command to stream a program, without additional encoding might look like so:\n\n```\n$ ffmpeg -f mpegts -i /dev/dvb/adapter0/dvr0 out.mp4\n```\n\n(Note: the above command will not generate output if the card requires to setup the frontend and/or the demuxer).\n\nYou may also wish to simply record the stream with tzap, and re-encode it with ffmpeg later\n\n```\n$ tzap -t <recording duration in seconds> -o foo.ts \"<channel name>\"\n```\n\n"
    },
    {
      "title": "dvbjet",
      "level": 3,
      "content": "DVB cards receive several simultaneous programs multiplexed. The command-line dvbjet standalone tool (has no dependencies) tunes the TV card by selecting the frequency, as with a radio, and saves the full MPEG-TS stream. To play or extract a separate program from it (with all its audio, video and subtitle tracks) its companion python script lists the programs and invokes ffmpeg.\n\n"
    },
    {
      "title": "Multiple frontends",
      "level": 3,
      "content": "Many DVB dongles may register more than 1 frontend. This can be spotted in dmesg:\n\n```\n[ 9080.196561] usb 1-6: DVB: registering adapter 0 frontend 0 (Realtek RTL2832 (DVB-T))...\n[ 9080.196567] dvbdev: dvb_create_media_entity: media entity 'Realtek RTL2832 (DVB-T)' registered.\n[ 9080.196626] usb 1-6: DVB: registering adapter 0 frontend 1 (Sony CXD2837ER DVB-T/T2/C demodulator)...\n[ 9080.196630] dvbdev: dvb_create_media_entity: media entity 'Sony CXD2837ER DVB-T/T2/C demodulator' registered.\n```\n\nThey can be listed by doing:\n\n```\n$ ls /dev/dvb/adapter0/frontend*\n```\n\nEach frontend may have a specific purpose and may only support decoding specific DVB standards. Some software may not have an ability or proper documentation on selecting which frontend to use and will default to frontend0, which will cause problems if the broadcast is in a standard that frontend0 does not support (in above example, if the broadcast is in DVB-T2, but the frontend can only do DVB-T, it will not work)\n\n"
    },
    {
      "title": "Other",
      "level": 3,
      "content": "If you run into problems, these tools can help debug problems:\n\n- dvbsnoopAUR is an advanced tool that can show all the necessary data regarding the bandwidth, signal, frontend, etc.\n- femon -H shows signal statistics\n\n"
    }
  ]
}