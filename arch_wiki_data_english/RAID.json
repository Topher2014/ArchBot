{
  "title": "RAID",
  "url": "https://wiki.archlinux.org/title/RAID",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- LVM on software RAID\n- LVM#RAID\n- Install Arch Linux with Fake RAID\n- Convert a single drive system to RAID\n- ZFS\n- ZFS/Virtual disks\n- Swap#Striping\n- Btrfs#RAID\n\nRedundant Array of Independent Disks (RAID) is a storage technology that combines multiple disk drive components (typically disk drives or partitions thereof) into a logical unit. Depending on the RAID implementation, this logical unit can be a file system or an additional transparent layer that can hold several partitions. Data is distributed across the drives in one of several ways called #RAID levels, depending on the level of redundancy and performance required. The RAID level chosen can thus prevent data loss in the event of a hard disk failure, increase performance or be a combination of both.\n\nThis article explains how to create/manage a software RAID array using mdadm.\n\n"
    },
    {
      "title": "RAID levels",
      "level": 2,
      "content": "Despite redundancy implied by most RAID levels, RAID does not guarantee that data is safe. A RAID will not protect data if there is a fire, the computer is stolen or multiple hard drives fail at once. Furthermore, installing a system with RAID is a complex process that may destroy data.\n\n"
    },
    {
      "title": "Standard RAID levels",
      "level": 3,
      "content": "There are many different levels of RAID; listed below are the most common.\n\nNote: **expected** \n\n"
    },
    {
      "title": "RAID level comparison",
      "level": 3,
      "content": "Table content:\nRAID level | Data redundancy | Physical drive utilization | Read performance | Write performance | Min drives\n0 | No | 100% | nX Best | nX Best | 2\n1 | Yes | 50% | Up to nX if multiple processes are reading, otherwise 1X | 1X | 2\n5 | Yes | 67% - 94% | (n−1)X Superior | (n−1)X Superior | 3\n6 | Yes | 50% - 88% | (n−2)X | (n−2)X | 4\n10,far2 | Yes | 50% | nX Best; on par with RAID0 but redundant | (n/2)X | 2\n10,near2 | Yes | 50% | Up to nX if multiple processes are reading, otherwise 1X | (n/2)X | 2\n\nBest\n\nBest\n\nSuperior\n\nSuperior\n\nBest; on par with RAID0 but redundant\n\n* Where n is standing for the number of dedicated disks.\n\n"
    },
    {
      "title": "LINEAR",
      "level": 3,
      "content": "LINEAR allows to map two or more devices into a single device, without parallel accesses like RAID0 but allowing to fully use disks from different sizes. To create a pseudo RAID using this mode without mdadm, one can either use the low-level dmsetup(8) utility, the high-level LVM framework or the Btrfs filesystem.\n\n"
    },
    {
      "title": "Implementation",
      "level": 2,
      "content": "The RAID devices can be managed in different ways:\n\n- an abstraction layer (e.g. mdadm); Note: This is the method we will use later in this guide.\n- a logical volume manager (e.g. LVM);\n- a component of a file system (e.g. ZFS, Btrfs).\n\n"
    },
    {
      "title": "Which type of RAID do I have?",
      "level": 3,
      "content": "Since software RAID is implemented by the user, the type of RAID is easily known to the user.\n\nHowever, discerning between FakeRAID and true hardware RAID can be more difficult. As stated, manufacturers often incorrectly distinguish these two types of RAID and false advertising is always possible. The best solution in this instance is to run the lspci command and looking through the output to find the RAID controller. Then do a search to see what information can be located about the RAID controller. Hardware RAID controllers appear in this list, but FakeRAID implementations do not. Also, true hardware RAID controllers are often rather expensive, so if someone customized the system, then it is very likely that choosing a hardware RAID setup made a very noticeable change in the computer's price.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install mdadm. mdadm is used for administering pure software RAID using plain block devices: the underlying hardware does not provide any RAID logic, just a supply of disks. mdadm will work with any collection of block devices. Even if unusual. For example, one can thus make a RAID array from a collection of thumb drives.\n\n"
    },
    {
      "title": "Prepare the devices",
      "level": 3,
      "content": "If the device is being reused or re-purposed from an existing array, erase any old RAID configuration information:\n\n```\n# mdadm --misc --zero-superblock /dev/drive\n```\n\nor if a particular partition on a drive is to be deleted:\n\n```\n# mdadm --misc --zero-superblock /dev/partition\n```\n\n- Zapping a partition's superblock should not affect the other partitions on the disk.\n- Due to the nature of RAID functionality it is very difficult to securely wipe disks fully on a running array. Consider whether it is useful to do so before creating it.\n- You can do the whole disk preparation procedure from a GUI with blivet-guiAUR.\n\n"
    },
    {
      "title": "Partition the devices",
      "level": 3,
      "content": "It is highly recommended to partition the disks to be used in the array. Since most RAID users are selecting disk drives larger than 2 TiB, GPT is required and recommended. See Partitioning for more information on partitioning and the available partitioning tools.\n\n"
    },
    {
      "title": "GUID Partition Table",
      "level": 4,
      "content": "- After creating the partitions, their partition type GUIDs should be A19D880F-05FC-4D3B-A006-743F0F84911E (it can be assigned by selecting partition type Linux RAID in fdisk or FD00 in gdisk).\n- If a larger disk array is employed, consider assigning filesystem labels or partition labels to make it easier to identify an individual disk later.\n- Creating partitions that are of the same size on each of the devices is recommended.\n\n"
    },
    {
      "title": "Master Boot Record",
      "level": 4,
      "content": "For those creating partitions on HDDs with a MBR partition table, the partition types IDs available for use are:\n\n- 0xDA for non-FS data (Non-FS data in fdisk). This is the recommended mdadm partition type for RAID arrays on Arch Linux.\n- 0xFD for RAID autodetect arrays (Linux RAID autodetect in fdisk). This partition type should only be used if RAID autodetection is desireable (non-initramfs system, old mdadm metadata format).\n\nSee Linux Raid Wiki:Partition Types for more information.\n\n"
    },
    {
      "title": "Build the array",
      "level": 3,
      "content": "Use mdadm to build the array. See mdadm(8) for supported options. Several examples are given below.\n\n- If this is a RAID1 array which is intended to boot from Syslinux a limitation in syslinux v4.07 requires the metadata value to be 1.0 rather than the default of 1.2.\n- When creating an array from Arch installation medium use the option --homehost=yourhostname (or --homehost=any to always have the same name regardless of the host) to set the hostname, otherwise the hostname archiso will be written in the array metadata.\n\nThe following example shows building a 2-device RAID1 array:\n\n```\n# mdadm --create --verbose --level=1 --metadata=1.2 --raid-devices=2 /dev/md/MyRAID1Array /dev/sdb1 /dev/sdc1\n```\n\nThe following example shows building a RAID5 array with 4 active devices and 1 spare device:\n\n```\n# mdadm --create --verbose --level=5 --metadata=1.2 --chunk=256 --raid-devices=4 /dev/md/MyRAID5Array /dev/sdb1 /dev/sdc1 /dev/sdd1 /dev/sde1 --spare-devices=1 /dev/sdf1\n```\n\nThe following example shows building a RAID10,far2 array with 2 devices:\n\n```\n# mdadm --create --verbose --level=10 --metadata=1.2 --chunk=512 --raid-devices=2 --layout=f2 /dev/md/MyRAID10Array /dev/sdb1 /dev/sdc1\n```\n\nThe array is created under the virtual device /dev/mdX, assembled and ready to use (in degraded mode). One can directly start using it while mdadm resyncs the array in the background. It can take a long time to restore parity. Check the progress with:\n\n```\n$ cat /proc/mdstat\n```\n\n"
    },
    {
      "title": "Update configuration file",
      "level": 3,
      "content": "By default, most of mdadm.conf is commented out, and it contains just the following:\n\n```\n/etc/mdadm.conf\n```\n\n```\n...\nDEVICE partitions\n...\n```\n\nThis directive tells mdadm to examine the devices referenced by /proc/partitions and assemble as many arrays as possible. This is fine if you really do want to start all available arrays and are confident that no unexpected superblocks will be found (such as after installing a new storage device). A more precise approach is to explicitly add the arrays to /etc/mdadm.conf:\n\n```\n# mdadm --detail --scan >> /etc/mdadm.conf\n```\n\nThis results in something like the following:\n\n```\n/etc/mdadm.conf\n```\n\n```\n...\nDEVICE partitions\n...\nARRAY /dev/md/MyRAID1Array metadata=1.2 name=pine:MyRAID1Array UUID=27664f0d:111e493d:4d810213:9f291abe\n```\n\nThis also causes mdadm to examine the devices referenced by /proc/partitions. However, only devices that have superblocks with a UUID of 27664… are assembled in to active arrays.\n\nSee mdadm.conf(5) for more information.\n\n"
    },
    {
      "title": "Assemble the array",
      "level": 3,
      "content": "Once the configuration file has been updated the array can be assembled using mdadm:\n\n```\n# mdadm --assemble --scan\n```\n\n"
    },
    {
      "title": "Format the RAID filesystem",
      "level": 3,
      "content": "The array can now be formatted with a file system like any other partition, just keep in mind that:\n\n- Due to the large volume size not all filesystems are suited (see: Wikipedia:Comparison of file systems#Limits).\n- The filesystem should support growing and shrinking while online (see: Wikipedia:Comparison of file systems#Features).\n- One should calculate the correct stride and stripe-width for optimal performance.\n\n"
    },
    {
      "title": "Calculating the stride and stripe width",
      "level": 4,
      "content": "Two parameters are required to optimise the filesystem structure to fit optimally within the underlying RAID structure: the stride and stripe width. These are derived from the RAID chunk size, the filesystem block size, and the number of \"data disks\".\n\nThe chunk size is a property of the RAID array, decided at the time of its creation. mdadm's current default is 512 KiB. It can be found with mdadm:\n\n```\n# mdadm --detail /dev/mdX | grep 'Chunk Size'\n```\n\nThe block size is a property of the filesystem, decided at its creation. The default for many filesystems, including ext4, is 4 KiB. See /etc/mke2fs.conf for details on ext4.\n\nThe number of \"data disks\" is the minimum number of devices in the array required to completely rebuild it without data loss. For example, this is N for a raid0 array of N devices and N-1 for raid5.\n\nOnce you have these three quantities, the stride and the stripe width can be calculated using the following formulas:\n\n```\nstride = chunk size / block size\nstripe width = number of data disks * stride\n```\n\nExample formatting to ext4 with the correct stripe width and stride:\n\n- Hypothetical RAID0 array is composed of 2 physical disks.\n- Chunk size is 512 KiB.\n- Block size is 4 KiB.\n\nstride = chunk size / block size. In this example, the math is 512/4 so the stride = 128.\n\nstripe width = # of physical data disks * stride. In this example, the math is 2*128 so the stripe width = 256.\n\n```\n# mkfs.ext4 -v -L myarray -b 4096 -E stride=128,stripe-width=256 /dev/md0\n```\n\nExample formatting to ext4 with the correct stripe width and stride:\n\n- Hypothetical RAID5 array is composed of 4 physical disks; 3 data discs and 1 parity disc.\n- Chunk size is 512 KiB.\n- Block size is 4 KiB.\n\nstride = chunk size / block size. In this example, the math is 512/4 so the stride = 128.\n\nstripe width = # of physical data disks * stride. In this example, the math is 3*128 so the stripe width = 384.\n\n```\n# mkfs.ext4 -v -L myarray -b 4096 -E stride=128,stripe-width=384 /dev/md0\n```\n\nFor more on stride and stripe width, see: RAID Math.\n\nExample formatting to ext4 with the correct stripe width and stride:\n\n- Hypothetical RAID10 array is composed of 2 physical disks. Because of the properties of RAID10 in far2 layout, both count as data disks.\n- Chunk size is 512 KiB.\n- Block size is 4 KiB.\n\nstride = chunk size / block size. In this example, the math is 512/4 so the stride = 128.\n\nstripe width = # of physical data disks * stride. In this example, the math is 2*128 so the stripe width = 256.\n\n```\n# mkfs.ext4 -v -L myarray -b 4096 -E stride=128,stripe-width=256 /dev/md0\n```\n\n"
    },
    {
      "title": "Mounting from a Live CD",
      "level": 2,
      "content": "Users wanting to mount the RAID partition from a Live CD, use:\n\n```\n# mdadm --assemble /dev/mdnumber /dev/disk1 /dev/disk2 /dev/disk3 /dev/disk4\n```\n\nIf your RAID 1 that is missing a disk array was wrongly auto-detected as RAID 1 (as per mdadm --detail /dev/mdnumber) and reported as inactive (as per cat /proc/mdstat), stop the array first:\n\n```\n# mdadm --stop /dev/mdnumber\n```\n\n"
    },
    {
      "title": "Installing Arch Linux on RAID",
      "level": 2,
      "content": "You should create the RAID array between the Partitioning and formatting steps of the Installation Procedure. Instead of directly formatting a partition to be your root file system, it will be created on a RAID array. Follow the section #Installation to create the RAID array. Then continue with the installation procedure until the pacstrap step is completed. When using UEFI boot, also read EFI system partition#ESP on software RAID1.\n\n"
    },
    {
      "title": "Update configuration file",
      "level": 3,
      "content": "After the base system is installed the default configuration file, mdadm.conf, must be updated like so:\n\n```\n# mdadm --detail --scan >> /mnt/etc/mdadm.conf\n```\n\nAlways check the mdadm.conf configuration file using a text editor after running this command to ensure that its contents look reasonable.\n\nContinue with the installation procedure until you reach the step Installation guide#Initramfs, then follow the next section.\n\n"
    },
    {
      "title": "Configure mkinitcpio",
      "level": 3,
      "content": "Install mdadm and add mdadm_udev to the HOOKS array of the mkinitcpio.conf to add support for mdadm into the initramfs image:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\n...\nHOOKS=(base udev autodetect microcode modconf kms keyboard keymap consolefont block mdadm_udev filesystems fsck)\n...\n```\n\nThen regenerate the initramfs.\n\n"
    },
    {
      "title": "Root device",
      "level": 4,
      "content": "Point the root parameter to the mapped device. E.g.:\n\n```\nroot=/dev/md/MyRAIDArray\n```\n\nIf booting from a software raid partition fails using the kernel device node method above, an alternative way is to use one of the methods from Persistent block device naming, for example:\n\n```\nroot=LABEL=Root_Label\n```\n\nSee also GRUB#RAID.\n\n"
    },
    {
      "title": "RAID0 layout",
      "level": 4,
      "content": "Since version 5.3.4 of the Linux kernel, you need to explicitly tell the kernel which RAID0 layout should be used: RAID0_ORIG_LAYOUT (1) or RAID0_ALT_MULTIZONE_LAYOUT (2).[1] You can do this by providing the kernel parameter as follows:\n\n```\nraid0.default_layout=2\n```\n\nThe correct value depends upon the kernel version that was used to create the raid array: use 1 if created using kernel 3.14 or earlier, use 2 if using a more recent version of the kernel. One way to check this is to look at the creation time of the raid array:\n\n```\nmdadm --detail /dev/md1\n```\n\n```\n/dev/md1:\n           Version : 1.2\n     Creation Time : Thu Sep 24 10:17:41 2015\n        Raid Level : raid0\n        Array Size : 975859712 (930.65 GiB 999.28 GB)\n      Raid Devices : 3\n     Total Devices : 3\n       Persistence : Superblock is persistent\n\n       Update Time : Thu Sep 24 10:17:41 2015\n             State : clean\n    Active Devices : 3\n   Working Devices : 3\n    Failed Devices : 0\n     Spare Devices : 0\n\n        Chunk Size : 512K\n\nConsistency Policy : none\n\n              Name : archiso:root\n              UUID : 028de718:20a81234:4db79a2c:e94fd560\n            Events : 0\n\n    Number   Major   Minor   RaidDevice State\n       0     259        2        0      active sync   /dev/nvme0n1p1\n       1     259        6        1      active sync   /dev/nvme2n1p1\n       2     259        5        2      active sync   /dev/nvme1n1p2\n```\n\nHere we can see that this raid array was created on September 24, 2015. The release date of Linux Kernel 3.14 was March 30, 2014, and as such this raid array is most likely created using a multizone layout (2).\n\n"
    },
    {
      "title": "Scrubbing",
      "level": 3,
      "content": "It is good practice to regularly run data scrubbing to check for and fix errors. Depending on the size/configuration of the array, a scrub may take multiple hours to complete.\n\nTo initiate a data scrub:\n\n```\n# echo check > /sys/block/mdX/md/sync_action\n```\n\nThe check operation scans the drives for bad sectors and automatically repairs them. If it finds good sectors that contain bad data (i.e. a mismatch, the data in a sector does not agree with what the data from another disk indicates that it should be, for example the parity block + the other data blocks would cause us to think that this data block is incorrect), then no action is taken, but the event is logged (see below). This \"do nothing\" allows admins to inspect the data in the sector and the data that would be produced by rebuilding the sectors from redundant information and pick the correct data to keep.\n\nAs with many tasks/items relating to mdadm, the status of the scrub can be queried by reading /proc/mdstat.\n\nExample:\n\n```\n$ cat /proc/mdstat\n```\n\n```\nPersonalities : [raid6] [raid5] [raid4] [raid1]\nmd0 : active raid1 sdb1[0] sdc1[1]\n      3906778112 blocks super 1.2 [2/2] [UU]\n      [>....................]  check =  4.0% (158288320/3906778112) finish=386.5min speed=161604K/sec\n      bitmap: 0/30 pages [0KB], 65536KB chunk\n```\n\nTo stop a currently running data scrub safely:\n\n```\n# echo idle > /sys/block/md0/md/sync_action\n```\n\nWhen the scrub is complete, admins may check how many blocks (if any) have been flagged as bad:\n\n```\n# cat /sys/block/md0/md/mismatch_cnt\n```\n\n"
    },
    {
      "title": "General notes on scrubbing",
      "level": 4,
      "content": "Note: **repair** \n\nIt is a good idea to set up a cron job as root to schedule a periodic scrub. See raid-checkAUR which can assist with this. To perform a periodic scrub using systemd timers instead of cron, See raid-check-systemdAUR which contains the same script along with associated systemd timer unit files.\n\nNote: **six seconds per gigabyte** \n\n"
    },
    {
      "title": "RAID1 and RAID10 notes on scrubbing",
      "level": 4,
      "content": "Due to the fact that RAID1 and RAID10 writes in the kernel are unbuffered, an array can have non-0 mismatch counts even when the array is healthy. These non-0 counts will only exist in transient data areas where they do not pose a problem. However, we cannot tell the difference between a non-0 count that is just in transient data or a non-0 count that signifies a real problem. This fact is a source of false positives for RAID1 and RAID10 arrays. It is however still recommended to scrub regularly in order to catch and correct any bad sectors that might be present in the devices.\n\n"
    },
    {
      "title": "Removing devices from an array",
      "level": 3,
      "content": "One can remove a block device from the array after marking it as faulty:\n\n```\n# mdadm --fail /dev/md0 /dev/failing_array_member\n```\n\nNow remove it from the array:\n\n```\n# mdadm --remove /dev/md0 /dev/failing_array_member\n```\n\nIf the device has not failed entirely, but you would like to replace it, e.g. because it looks like it is dying, you can actually handle replacement more gracefully by first adding a new drive and then telling mdadm to replace it.\n\nFor example, with /dev/sdc1 as the new one and /dev/sdb1 as the failing one:\n\n```\n# mdadm /dev/md0 --add /dev/sdc1\n# mdadm /dev/md0 --replace /dev/sdb1 --with /dev/sdc1\n```\n\nThe --with /dev/sdc1 part is optional, but more explicit. See [2] for more details.\n\nTo remove a device permanently (for example, to use it individually from now on), follow the steps above (fail/remove or add/replace) and then run:\n\n```\n# mdadm --zero-superblock /dev/failing_array_member\n```\n\n- Do not issue this command on linear or RAID0 arrays or data loss will occur!\n- Reusing the removed disk without zeroing the superblock will cause loss of all data on the next boot. (After mdadm will try to use it as the part of the raid array).\n\nStop using an array:\n\n1. Umount target array\n1. Stop the array with: mdadm --stop /dev/md0\n1. Repeat the three command described in the beginning of this section on each device.\n1. Remove the corresponding line from /etc/mdadm.conf.\n\n"
    },
    {
      "title": "Adding a new device to an array",
      "level": 3,
      "content": "Adding new devices with mdadm can be done on a running system with the devices mounted. Partition the new device using the same layout as one of those already in the arrays as discussed above.\n\nAssemble the RAID array if it is not already assembled:\n\n```\n# mdadm --assemble /dev/md0 /dev/sda1 /dev/sdb1\n```\n\nAdd the new device to the array:\n\n```\n# mdadm --add /dev/md0 /dev/sdc1\n```\n\nThis should not take long for mdadm to do.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nDepending on the type of RAID (for example, with RAID1), mdadm may add the device as a spare without syncing data to it. You can increase the number of disks the RAID uses by using --grow with the --raid-devices option. For example, to increase an array to four disks:\n\n```\n# mdadm --grow /dev/md0 --raid-devices=4\n```\n\nYou can check the progress with:\n\n```\n# cat /proc/mdstat\n```\n\nCheck that the device has been added with the command:\n\n```\n# mdadm --misc --detail /dev/md0\n```\n\nNote: This is because the above commands will add the new disk as a \"spare\" but RAID0 does not have spares. If you want to add a device to a RAID0 array, you need to \"grow\" and \"add\" in the same command, as demonstrated below:\n\n```\nmdadm: add new device failed for /dev/sdc1 as 2: Invalid argument\n```\n\nThis is because the above commands will add the new disk as a \"spare\" but RAID0 does not have spares. If you want to add a device to a RAID0 array, you need to \"grow\" and \"add\" in the same command, as demonstrated below:\n\n```\n# mdadm --grow /dev/md0 --raid-devices=3 --add /dev/sdc1\n```\n\n"
    },
    {
      "title": "Increasing size of a RAID volume",
      "level": 3,
      "content": "If larger disks are installed in a RAID array or partition size has been increased, it may be desirable to increase the size of the RAID volume to fill the larger available space. This process may be begun by first following the above sections pertaining to replacing disks. Once the RAID volume has been rebuilt onto the larger disks it must be \"grown\" to fill the space.\n\n```\n# mdadm --grow /dev/md0 --size=max\n```\n\nNext, partitions present on the RAID volume /dev/md0 may need to be resized. See Partitioning for details. Finally, the filesystem on the above mentioned partition will need to be resized. If partitioning was performed with gparted this will be done automatically. If other tools were used, unmount and then resize the filesystem manually.\n\n```\n# umount /storage\n# fsck.ext4 -f /dev/md0p1\n# resize2fs /dev/md0p1\n```\n\n"
    },
    {
      "title": "Change sync speed limits",
      "level": 3,
      "content": "Syncing can take a while. If the machine is not needed for other tasks the speed limit can be increased.\n\n```\n# cat /proc/mdstat\n```\n\n```\nPersonalities : [raid10]\n md127 : active raid10 sdd1[3] sdc1[2] sdb1[1] sda1[0]\n     31251490816 blocks super 1.2 512K chunks 2 far-copies [4/4] [UUUU]\n     [=>...................]  resync =  5.2% (1629533760/31251490816) finish=2071.7min speed=238293K/sec\n     bitmap: 221/233 pages [884KB], 65536KB chunk\n```\n\nIn the above example, it would seem the max speed is limited to approximately 238 M/sec.\n\nCheck the current speed limit (in kibibytes per second, KiB/s):\n\n```\n# sysctl dev.raid.speed_limit_min\n```\n\n```\ndev.raid.speed_limit_min = 1000\n```\n\n```\n# sysctl dev.raid.speed_limit_max\n```\n\n```\ndev.raid.speed_limit_max = 200000\n```\n\nSet a new maximum speed of raid resyncing operations using sysctl:\n\n```\n# sysctl -w dev.raid.speed_limit_min=600000\n# sysctl -w dev.raid.speed_limit_max=600000\n```\n\nThen check out the syncing speed and estimated finish time.\n\n```\n# cat /proc/mdstat\n```\n\n```\nPersonalities : [raid10]\n md127 : active raid10 sdd1[3] sdc1[2] sdb1[1] sda1[0]\n     31251490816 blocks super 1.2 512K chunks 2 far-copies [4/4] [UUUU]\n     [=>...................]  resync =  5.3% (1657016448/31251490816) finish=1234.9min speed=399407K/sec\n     bitmap: 221/233 pages [884KB], 65536KB chunk\n```\n\n"
    },
    {
      "title": "RAID5 performance",
      "level": 3,
      "content": "To improve RAID5 performance for fast storage (e.g. NVMe), increase /sys/block/mdx/md/group_thread_cnt to more threads. For example, to use 8 threads to operate on a RAID5 device:\n\n```\n# echo 8 > /sys/block/md0/md/group_thread_cnt\n```\n\nSee git kernel commit 851c30c9badf.\n\n"
    },
    {
      "title": "Update RAID superblock",
      "level": 3,
      "content": "To update the RAID superblock, you need to first unmount the array and then stop the array with the following command:\n\n```\n# mdadm --stop /dev/md0\n```\n\nThen you can update certain parameters by reassembling the array. For example, to update the homehost:\n\n```\n# mdadm --assemble --update=homehost --homehost=NAS /dev/md0 /dev/sda1 /dev/sdb1\n```\n\nSee the arguments of --update for details.\n\n"
    },
    {
      "title": "Monitoring",
      "level": 2,
      "content": "A simple one-liner that prints out the status of the RAID devices:\n\n```\n# awk '/^md/ {printf \"%s: \", $1}; /blocks/ {print $NF}' </proc/mdstat\n```\n\n```\nmd1: [UU]\nmd0: [UU]\n```\n\n"
    },
    {
      "title": "Watch mdstat",
      "level": 3,
      "content": "```\n# watch -t 'cat /proc/mdstat'\n```\n\nOr preferably using tmux:\n\n```\n# tmux split-window -l 12 \"watch -t 'cat /proc/mdstat'\"\n```\n\n"
    },
    {
      "title": "Track IO with iotop",
      "level": 3,
      "content": "The iotop package displays the input/output stats for processes. Use this command to view the IO for raid threads.\n\n```\n# iotop -a $(sed 's/^/-p /g' <<<`pgrep \"_raid|_resync|jbd2\"`)\n```\n\n"
    },
    {
      "title": "Track IO with iostat",
      "level": 3,
      "content": "The iostat utility from sysstat package displays the input/output statistics for devices and partitions.\n\n```\n# iostat -dmy 1 /dev/md0\n# iostat -dmy 1 # all\n```\n\n"
    },
    {
      "title": "mdadm via systemd",
      "level": 3,
      "content": "mdadm provides the systemd service mdmonitor.service which can be useful for monitoring the health of your raid arrays and notifying you if anything goes wrong.\n\nThis service is special in that it cannot be manually activated like a regular service; mdadm will take care of activating it via udev upon assembling your arrays on system startup, but it will only do so if an email address and/or program has been configured for its notifications (see below).\n\n"
    },
    {
      "title": "Email notifications",
      "level": 4,
      "content": "To enable this functionality, edit /etc/mdadm.conf and define the email address:\n\n```\nMAILADDR user@domain\n```\n\nThen, to verify that everything is working as it should, run the following command:\n\n```\n# mdadm --monitor --scan --oneshot --test\n```\n\nIf the test is successful and the email is delivered, then you are done; the next time your arrays are reassembled, mdmonitor.service will begin monitoring them for errors.\n\n"
    },
    {
      "title": "Program notifications",
      "level": 4,
      "content": "Like Email notification above, edit /etc/mdadm.conf and edit the line:\n\n```\nPROGRAM /usr/sbin/handle-mdadm-events\n```\n\nThe argument for PROGRAM is the script you want to run for any event. Which then interact with proper network monitoring agents. Or even IM clients or push notification services like ntfy.sh for home users.\n\nTest in the same way as for email notification above.\n\n"
    },
    {
      "title": "Troubleshooting",
      "level": 2,
      "content": "If you are getting error when you reboot about \"invalid raid superblock magic\" and you have additional hard drives other than the ones you installed to, check that your hard drive order is correct. During installation, your RAID devices may be hdd, hde and hdf, but during boot they may be hda, hdb and hdc. Adjust your kernel line accordingly. This is what happened to me anyway.\n\n"
    },
    {
      "title": "Error: \"kernel: ataX.00: revalidation failed\"",
      "level": 3,
      "content": "If you suddenly (after reboot, changed BIOS settings) experience Error messages like:\n\n```\nFeb  9 08:15:46 hostserver kernel: ata8.00: revalidation failed (errno=-5)\n```\n\nIt does not necessarily mean that a drive is broken. You often find panic links on the web which go for the worst. In a word, No Panic. Maybe you just changed APIC or ACPI settings within your BIOS or Kernel parameters somehow. Change them back and you should be fine. Ordinarily, turning ACPI and/or ACPI off should help.\n\n"
    },
    {
      "title": "Start arrays read-only",
      "level": 3,
      "content": "When an md array is started, the superblock will be written, and resync may begin. To start read-only set the kernel module md_mod parameter start_ro. When this is set, new arrays get an 'auto-ro' mode, which disables all internal io (superblock updates, resync, recovery) and is automatically switched to 'rw' when the first write request arrives.\n\nTo set the parameter at boot, add md_mod.start_ro=1 to your kernel line.\n\nOr set it at module load time by Kernel module#Using modprobe.d or from directly from /sys/:\n\n```\n# echo 1 > /sys/module/md_mod/parameters/start_ro\n```\n\n"
    },
    {
      "title": "Recovering from a broken or missing drive in the raid",
      "level": 3,
      "content": "You might get the above mentioned error also when one of the drives breaks for whatever reason. In that case you will have to force the raid to still turn on even with one disk short. Type this (change where needed):\n\n```\n# mdadm --manage /dev/md0 --run\n```\n\nNow you should be able to mount it again with something like this (if you had it in fstab):\n\n```\n# mount /dev/md0\n```\n\nNow the raid should be working again and available to use, however with one disk short. So, to add that one disc partition it the way like described above in #Prepare the devices. Once that is done you can add the new disk to the raid by doing:\n\n```\n# mdadm --manage --add /dev/md0 /dev/sdd1\n```\n\nIf you type:\n\n```\n# cat /proc/mdstat\n```\n\nyou probably see that the raid is now active and rebuilding.\n\nYou also might want to update your configuration (see: #Update configuration file).\n\n"
    },
    {
      "title": "Benchmarking",
      "level": 2,
      "content": "There are several tools for benchmarking a RAID. The most notable improvement is the speed increase when multiple threads are reading from the same RAID volume.\n\nbonnie++ tests database type access to one or more files, and creation, reading, and deleting of small files which can simulate the usage of programs such as Squid, INN, or Maildir format e-mail. The enclosed ZCAV program tests the performance of different zones of a hard drive without writing any data to the disk.\n\nhdparm should not be used to benchmark a RAID, because it provides very inconsistent results.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Linux kernel RAID documentation\n- Linux Software RAID (thomas-krenn.com)\n- Linux RAID wiki entry in The Linux kernel archives\n- How Bitmaps Work\n- Chapter 19. Managing RAID of Red Hat Enterprise Linux 9 documentation\n- Linux-RAID FAQ on the Linux documentation project\n- BAARF(Archive.org) including Why should I not use RAID 5?(Archive.org) by Art S. Kagel\n- Introduction to RAID, Nested-RAID: RAID-5 and RAID-6 Based Configurations, Intro to Nested-RAID: RAID-01 and RAID-10, and Nested-RAID: The Triple Lindy in Linux Magazine\n- HowTo: Speed Up Linux Software Raid Building And Re-syncing\n- Wikipedia:Non-RAID drive architectures\n\nmailing list\n\n- Kernel Linux-Raid mailing list\n\nmdadm\n\n- mdadm source code\n- Software RAID on Linux with mdadm in Linux Magazine\n- Wikipedia - mdadm\n\nForum threads\n\n- Raid Performance Improvements with bitmaps\n- GRUB and GRUB2\n- Can't install grub2 on software RAID\n- Use RAID metadata 1.2 in boot and root partition\n\n"
    }
  ]
}