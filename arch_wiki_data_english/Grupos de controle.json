{
  "title": "Grupos de controle",
  "url": "https://wiki.archlinux.org/title/Grupos_de_controle",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- Linux Containers\n- systemd-nspawn\n- Docker\n- limits.conf\n\nGrupos de Controle, ou em inglês Control groups (ou também conhecido por cgroups) é um recurso para gerenciamento, restrição e auditoria de grupos de processos fornecido pelo kernel Linux. Comparado com outros gerenciamentos como pelo comando nice(1) ou por configurações em /etc/security/limits.conf, cgroups é mais flexível por conseguir operar em (sub)conjuntos de processos (usável com diferentes usuários de sistema).\n\nO controle de grupos pode ser acessado por diversas ferramentas:\n\n- Usando diretivas nos arquivos unit do systemd para especificar limites de serviços e slices;\n- Acessando o sistema de arquivos cgroup diretamente;\n- Por via de cgcreate, cgexec e cgclassify (parte dos pacotes libcgroup-gitAUR e libcgroup-gitAUR) ou similares;\n- Usando o serviço de controle de grupos (rules engine daemon) para automaticamente mover certos usuários/grupos/comandos para grupos (/etc/cgrules.conf) e cgconfig.service (parte dos pacotes libcgroup-gitAUR e libcgroup-gitAUR);\n- E através de outros softwares de virtualização como Linux Containers (LXC).\n\nEm Arch Linux systemd é o método preferível e mais fácil para chamar e configurar cgroups, pois faz parte da instalação padrão.\n\n"
    },
    {
      "title": "Instalação",
      "level": 2,
      "content": "Tenha certeza que você possui um desses pacotes instalados para automatizar o controle de grupos:\n\n- systemd - para controle de recursos de um serviço systemd.\n- libcgroupAUR, libcgroup-gitAUR - conjunto de ferramentas standalone (cgcreate, cgclassify, persistência via cgconfig.conf).\n\n"
    },
    {
      "title": "Hierarquia",
      "level": 3,
      "content": "A atual hierarquia de cgroup pode ser vista com systemctl status ou pelo comando systemd-cgls.\n\n```\n$ systemctl status\n```\n\n```\n● myarchlinux\n    State: running\n     Jobs: 0 queued\n   Failed: 0 units\n    Since: Wed 2019-12-04 22:16:28 UTC; 1 day 4h ago\n   CGroup: /\n           ├─user.slice \n           │ └─user-1000.slice \n           │   ├─user@1000.service \n           │   │ ├─gnome-shell-wayland.service \n           │   │ │ ├─ 1129 /usr/bin/gnome-shell\n           │   │ ├─gnome-terminal-server.service \n           │   │ │ ├─33519 /usr/lib/gnome-terminal-server\n           │   │ │ ├─37298 fish\n           │   │ │ └─39239 systemctl status\n           │   │ ├─init.scope \n           │   │ │ ├─1066 /usr/lib/systemd/systemd --user\n           │   │ │ └─1067 (sd-pam)\n           │   └─session-2.scope \n           │     ├─1053 gdm-session-worker [pam/gdm-password]\n           │     ├─1078 /usr/bin/gnome-keyring-daemon --daemonize --login\n           │     ├─1082 /usr/lib/gdm-wayland-session /usr/bin/gnome-session\n           │     ├─1086 /usr/lib/gnome-session-binary\n           │     └─3514 /usr/bin/ssh-agent -D -a /run/user/1000/keyring/.ssh\n           ├─init.scope \n           │ └─1 /sbin/init\n           └─system.slice \n             ├─systemd-udevd.service \n             │ └─285 /usr/lib/systemd/systemd-udevd\n             ├─systemd-journald.service \n             │ └─272 /usr/lib/systemd/systemd-journald\n             ├─NetworkManager.service \n             │ └─656 /usr/bin/NetworkManager --no-daemon\n             ├─gdm.service \n             │ └─668 /usr/bin/gdm\n             └─systemd-logind.service \n               └─654 /usr/lib/systemd/systemd-logind\n```\n\n"
    },
    {
      "title": "Encontre o cgroup de um processo",
      "level": 3,
      "content": "O nome de um processo do cgroup pode ser encontrado em /proc/PID/cgroup.\n\nPor exemplo, o cgroup do shell:\n\n```\n$ cat /proc/self/cgroup\n```\n\n```\n0::/user.slice/user-1000.slice/session-3.scope\n```\n\n"
    },
    {
      "title": "Uso de recursos do cgroup",
      "level": 3,
      "content": "O comando systemd-cgtop pode ser usado para visualizar o uso de recursos:\n\n```\n$ systemd-cgtop\n```\n\n```\nControl Group                            Tasks   %CPU   Memory  Input/s Output/s\nuser.slice                                 540  152,8     3.3G        -        -\nuser.slice/user-1000.slice                 540  152,8     3.3G        -        -\nuser.slice/u…000.slice/session-1.scope     425  149,5     3.1G        -        -\nsystem.slice                                37      -   215.6M        -        -\n```\n\n"
    },
    {
      "title": "Customização de cgroups",
      "level": 3,
      "content": "Um arquivo unit systemd.slice(5) pode ser usado para definir uma configuração de cgroup personalizada, do qual deve ser colocado em um diretório do systemd como /etc/systemd/system/. As opções de controle de recursos que podem ser atribuídas estão documentadas em systemd.resource-control(5).\n\nEste é um exemplo de um slice unit que pode somente permitir 30% da CPU em uso:\n\n```\n/etc/systemd/system/meu.slice\n```\n\n```\n[Slice]\nCPUQuota=30%\n```\n\nLembre-se de fazer systemd daemon-reload para selecionar qualquer arquivo novo ou modificado em .slice.\n\n"
    },
    {
      "title": "Arquivo unit de serviço",
      "level": 4,
      "content": "Recursos podem ser especificamente direcionados em uma definição de serviço ou como arquivo drop-in:\n\n```\n[Service]\nMemoryMax=1G\n```\n\nNeste exemplo os limites do serviço foram definidos para 1 gigabyte.\n\n"
    },
    {
      "title": "Agrupando unit em um slice",
      "level": 4,
      "content": "Um serviço pode ser direcionado para uma execução de slice específica em:\n\n```\n[Service]\nSlice=meu.slice\n```\n\n"
    },
    {
      "title": "Como root",
      "level": 3,
      "content": "systemd-run pode ser usado para executar um comando em um slice específico.\n\n```\n# systemd-run --slice=meu.slice comando\n```\n\n--uid=nomedousuario é uma opção usada para gerar o comando como um usuário específico.\n\n```\n# systemd-run --uid=nomedousuario --slice=meu.slice comando\n```\n\nA opção --shell é usada para gerar um comando em shell de dentro do slice.\n\n"
    },
    {
      "title": "Como usuário sem privilégios",
      "level": 3,
      "content": "Usuários sem privilégios podem dividir os recursos disponibilizados em novos cgroups, se claro algumas condições forem atendidas.\n\nÉ importante que cgroups v2 seja utilizado para que um usuário sem privilégios consiga as permissões de gerenciamento de recursos cgroup.\n\n"
    },
    {
      "title": "Tipos de controladores",
      "level": 4,
      "content": "Nem todos os recursos podem ser controlados pelo usuário.\n\nTable content:\nControlador | Controlado pelo usuário | Opções\ncpu | Precisa de delegação | CPUAccounting, CPUWeight, CPUQuota, AllowedCPUs, AllowedMemoryNodes\nio | Precisa de delegação | IOWeight, IOReadBandwidthMax, IOWriteBandwidthMax, IODeviceLatencyTargetSec\nmemory | Sim | MemoryLow, MemoryHigh, MemoryMax, MemorySwapMax\npids | Sim | TasksMax\nrdma | Não | Não definido ou desconhecido.\neBPF | Não | IPAddressDeny, DeviceAllow, DevicePolicy\n\n"
    },
    {
      "title": "Delegações de usuário",
      "level": 4,
      "content": "Para o usuário controlar CPU e recursos de I/O os mesmos precisam ser delegados ao usuário em questão. Isso pode ser feito com um arquivo drop-in.\n\nPor exemplo, se o seu id de usuário for 1000:\n\n```\n/etc/systemd/system/user@1000.service.d/delegate.conf\n```\n\n```\n[Service]\nDelegate=cpu cpuset io\n```\n\nReinicie o sistema e verifique a utilização dos controladores cpu e io na sessão de usuário:\n\n```\n$ cat /sys/fs/cgroup/user.slice/user-1000.slice/cgroup.controllers\n```\n\n```\ncpuset cpu io memory pids\n```\n\n"
    },
    {
      "title": "Slices definidos pelo usuário",
      "level": 4,
      "content": "Os arquivos slice de usuário podem ser colocados em ~/.config/systemd/user/.\n\nPara executar comandos em um certo slice:\n\n```\n$ systemd-run --user --slice=meu.slice comando\n```\n\nVocê pode também executar seu login shell de dentro do slice:\n\n```\n$ systemd-run --user --slice=meu.slice --shell\n```\n\n"
    },
    {
      "title": "Ajuste durante runtime - Tempo de execução",
      "level": 3,
      "content": "Recursos definidos pelo cgroups podem ser ajustados durante o tempo de execução usando o comando systemctl set-property. A sintaxe é idêntica às opções de systemd.resource-control(5).\n\nPor exemplo, para cortar o acesso à internet de todas as sessões de usuário:\n\n```\n$ systemctl set-property user.slice IPAddressDeny=any\n```\n\nNote: **permanentes** \n\n"
    },
    {
      "title": "Com libcgroup",
      "level": 2,
      "content": "É possível habilitar o serviço chconfig com systemd. Isto permite facilmente o rastreio de quaisquer erros gerados pelo cgconfig.conf.\n\n"
    },
    {
      "title": "Grupos ad-hoc",
      "level": 3,
      "content": "Um dos poderes de cgroups é a criação de grupos \"ad-hoc\" em tempo real. Uma das vantagens é adicionar privilégios ao usuário regular ativo para criação de grupos customizados. No exemplo abaixo nomedogrupo é o nome do cgroup:\n\n```\n# cgcreate -a usuario -t usuario -g memory,cpu:nomedogrupo\n```\n\nAgora todos os comportamentos ajustados no grupo nomedogrupo podem ser escritos pelo usuário ativo.\n\n```\n$ ls -l /sys/fs/cgroup/memory/nomedogrupo\n```\n\n```\ntotal 0\n-rwxrwxr-x 1 user root 0 Sep 25 00:39 cgroup.event_control\n-rwxrwxr-x 1 user root 0 Sep 25 00:39 cgroup.procs\n-rwxrwxr-x 1 user root 0 Sep 25 00:39 cpu.rt_period_us\n-rwxrwxr-x 1 user root 0 Sep 25 00:39 cpu.rt_runtime_us\n-rwxrwxr-x 1 user root 0 Sep 25 00:39 cpu.shares\n-rwxrwxr-x 1 user root 0 Sep 25 00:39 notify_on_release\n-rwxrwxr-x 1 user root 0 Sep 25 00:39 tasks\n```\n\nCgroups são hierárquicos, ou seja, um usuário pode criar quantos subgrupos forem desejados. Se por exemplo um usuário regular quiser executar o shell bash de dentro de um novo subgrupo chamado foo:\n\n```\n$ cgcreate -g memory,cpu:nomedogrupo/foo\n$ cgexec    -g memory,cpu:nomedogrupo/foo bash\n```\n\nPor garantia verifique (somente necessário ao usar cgroups legacy (v1)):\n\n```\n$ cat /proc/self/cgroup\n```\n\n```\n11:memory:/nomedogrupo/foo\n6:cpu:/nomedogrupo/foo\n```\n\nDesta forma um novo subdiretório foi criado para este grupo. Para limitar o uso da memória de todos os processos envolvidos no grupo em 10MB, execute o comando abaixo:\n\n```\n$ echo 10000000 > /sys/fs/cgroup/memory/groupname/foo/memory.limit_in_bytes\n```\n\nNote que o limite de memória se aplica apenas ao uso de RAM. A partir do momento que as tarefas alcançarem o máximo estabelecido, a memória é convertida em swap. Entretanto a troca não afetará a performance de forma significativa.\n\nDe maneira similar, você pode mudar a prioridade (\"shares\", ou compartilhamentos) de CPU em grupo. Por padrão todos os grupos tem 1024 shares. Um grupo com 100 shares deterá aproximadamente 10% do tempo de CPU.\n\n```\n$ echo 100 > /sys/fs/cgroup/cpu/groupname/foo/cpu.shares\n```\n\nMais ajustes de comportamento ou estatísticas podem ser encontrados ao listar o diretório do cgroup.\n\nSe for preferível um processo já em execução pode ter seu cgroup alterado. Como mostrado no exemplo abaixo, para mover todos os comandos dos processos em shell 'bash' com destino ao nomedogrupo/foo:\n\n```\n$ pidof bash\n13244 13266\n$ cgclassify -g memory,cpu:nomedogrupo/foo `pidof bash`\n$ cat /proc/13244/cgroup\n11:memory:/nomedogrupo/foo\n6:cpu:/nomedogrupo/foo\n```\n\n"
    },
    {
      "title": "Configuração persistente de grupo",
      "level": 3,
      "content": "Se você quiser que cgroups sejam criados durante o boot, defina no arquivo de configuração em /etc/cgconfig.conf. Por exemplo, o \"nomedogrupo\" garante permissão para o $USER e usuários do grupo $GROUP para gerenciar limites e adicionar tarefas. Portanto as definições de grupo do subgrupo \"nomedogrupo/foo\" seriam semelhantes a configuração abaixo:\n\n```\n/etc/cgconfig.conf\n```\n\n```\ngroup nomedogrupo {\n  perm {\n# who can manage limits\n    admin {\n      uid = $USER;\n      gid = $GROUP;\n    }\n# who can add tasks to this group\n    task {\n      uid = $USER;\n      gid = $GROUP;\n    }\n  }\n# create this group in cpu and memory controllers\n  cpu { }\n  memory { }\n}\n\ngroup nomedogrupo/foo {\n  cpu {\n    cpu.shares = 100;\n  }\n  memory {\n    memory.limit_in_bytes = 10000000;\n  }\n}\n```\n\nNote: **#** Isto é equivalente a esses comandos em shell:\n\n- Comentários devem começar na primeira linha! Ou seja, o carácter # usado em comentários deve aparecer como o primeiro carácter da linha. Caso não seja, o cgconfigparser irá ter problemas de parsing e será reportado o erro: cgroup change of grupo failed, ou de forma traduzida: mudança de grupo falhou para cgroup. O erro também é evitável se cgconfig for executado por uma unit do systemd.\n- A seção de permissões é opcional.\n- A hierarquia do diretório /sys/fs/cgroup/ que contém todos os controladores já possui os subdiretórios criados e montados durante o boot como um sistema de arquivos virtual. Isto fornece a habilidade de criar uma nova entrada de grupo com o comando $CONTROLLER-NAME { }. Se por alguma razão você quiser criar e montar hierarquias em outro lugar, será necessário escrever uma segunda entrada em /etc/cgconfig.conf da seguinte forma:\n\n```\nmount {    \n   cpuset = /local/do/nomedogrupo;\n }\n```\n\nIsto é equivalente a esses comandos em shell:\n\n```\n# mkdir /local/do/nomedogrupo\n # mount -t /local/do -o cpuset nomedogrupo /local/do/nomedogrupo\n```\n\n"
    },
    {
      "title": "Com o sistema de arquivos virtual cgroup",
      "level": 2,
      "content": "A partir do systemd versão 232, ao invés do método cgm descrito na próxima seção abaixo, esta seção aborda uma alternativa manual para configurar a limitação de memória em uso.\n\nCrie um novo nome de cgroup chamado nomedogrupo:\n\n```\n# mkdir /sys/fs/cgroup/memory/nomedogrupo\n```\n\nExemplo: defina o valor limite de memória para 100MB:\n\n```\n# echo 100000000 > /sys/fs/cgroup/memory/nomedogrupo/memory.limit_in_bytes\n```\n\nMova um único processo para o cgroup por vez:\n\n```\n# echo pid > /sys/fs/cgroup/memory/groupname/cgroup.procs\n```\n\n"
    },
    {
      "title": "Restrição de uso da memória ou CPU de um comando",
      "level": 3,
      "content": "O exemplo a seguir demonstra um cgroup que restringe um determinado comando para 2GB de memória.\n\n```\n$ systemd-run --scope -p MemoryMax=2G --user comando\n```\n\nE o exemplo a seguir demonstra um comando restringido para 20% do uso de um core de CPU.\n\n```\n$ systemd-run --scope -p CPUQuota=\"20%\" --user comando\n```\n\n"
    },
    {
      "title": "Matlab",
      "level": 3,
      "content": "Fazer cálculos extensos com MATLAB pode resultar em crash do seu sistema. Devido ao fato que Matlab não possui nenhuma proteção contra o consumo de memória ou CPU da máquina. O exemplo a seguir mostra um cgroup que restringe o uso do Matlab para o limite dos primeiros 6 cores de CPU e 5GB de memória.\n\n"
    },
    {
      "title": "Com systemd",
      "level": 4,
      "content": "```\n~/.config/systemd/user/matlab.slice\n```\n\n```\n[Slice]\nAllowedCPUs=0-5\nMemoryHigh=6G\n```\n\nInicie Matlab desta maneira (tenha certeza que o caminho está correto):\n\n```\n$ systemd-run --user --slice=matlab.slice /opt/MATLAB/2012b/bin/matlab -desktop\n```\n\n"
    },
    {
      "title": "Com libcgroup",
      "level": 4,
      "content": "```\n/etc/cgconfig.conf\n```\n\n```\ngroup matlab {\n    perm {\n        admin {\n            uid = nomedousuario;\n        }\n        task {\n            uid = nomedousuario;\n        }\n    }\n\n    cpuset {\n        cpuset.mems=\"0\";\n        cpuset.cpus=\"0-5\";\n    }\n    memory {\n        memory.limit_in_bytes = 5000000000;\n    }\n}\n```\n\nMude nomedousuario para o nome de usuário que estiver executando Matlab.\n\nVocê também pode restringir o compartilhamento de CPU (share) ao delimitar com cpu.\n\nInicie Matlab desta maneira (tenha certeza que o caminho está correto):\n\n```\n$ cgexec -g memory,cpuset:matlab /opt/MATLAB/2012b/bin/matlab -desktop\n```\n\n"
    },
    {
      "title": "Documentação",
      "level": 2,
      "content": "- Para informações de controladores e o que certos switches ou ajustes de comportamento (tunables) significam, consulte a documentação do kernel: v1 ou v2 (ou instale linux-docs e veja /usr/src/linux/Documentation/cgroup)\n- Página do manual do Linux: cgroups(7).\n- Um detalhado e completo guia sobre gerenciamento de recursos pode ser encontrado na documentação do Red Hat Enterprise Linux.\n\nPara comandos e configurações de arquivos, veja as páginas man relevantes, por exemplo: cgcreate(1) ou cgrules.conf(5)\n\n"
    },
    {
      "title": "Habilitar cgroup v1",
      "level": 3,
      "content": "Cgroup v2 é agora habilitado por padrão. Se você quiser trocar para cgroup v1, defina o seguinte parâmetro de kernel:\n\n```\nsystemd.unified_cgroup_hierarchy=0\n```\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- systemd cgroups hacker guide\n- cgroupv2: Linux's new unified control group system\n\n"
    }
  ]
}