{
  "title": "Kdump",
  "url": "https://wiki.archlinux.org/title/Kdump",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Kexec\n\nKdump is a standard Linux mechanism to dump machine memory content on kernel crash. Kdump is based on Kexec. Kdump utilizes two kernels: the regular system kernel and kdump capture kernel (called from now on, the kdump kernel). System kernel is the normal kernel, booted with the crashkernel parameter - we need to tell the system kernel to reserve some amount of physical memory where the kdump kernel will be loaded/executed. Then it's necessary to load the kdump kernel in advance, because when the system kernel crashes, there is no reliable way to read data from disk, for example, given that such kernel is broken.\n\nOnce a kernel crash happens, the system kernel crash handler uses the Kexec mechanism to boot the kdump kernel in its pre-reserved memory. The memory from system kernel is preserved in such kexec boot, and it's accessible from the kdump kernel at the moment of crash. Once the kdump kernel is booted, the user can collect the file /proc/vmcore to get access to memory of the crashed system kernel. Such crash dump can be saved to disk or copied over network to some other machine for further post-mortem investigation.\n\nIn server production environments, the system and kdump kernels could be different - system kernel needs a lot of features and is compiled with a many kernel flags/drivers, while the kdump kernel goal is to be minimalistic and take as small amount of memory as possible, e.g. it could be compiled without network support if we store the crash dump to disk only. But for desktops and in general, for non-specific setups, the same kernel is used both as system and kdump kernels. It means we will load the same kernel code twice - one time as normal system kernel, another one to the reserved memory area, but with different kernel parameters.\n\n"
    },
    {
      "title": "The automatic way: kdumpst",
      "level": 3,
      "content": "The kdumpstAUR tool is an automatic way for loading kdump. It's highly customizable - it defaults to another method of log collecting (called pstore), but can be easily set to use kdump (a matter of setting USE_PSTORE_RAM=0 on /usr/share/kdumpst.d/00-default. The tool also fallbacks to kdump in case pstore RAM region isn't available.\n\nAfter installing kdumpst, one can check the journal and the following message means kdump is loaded: kdumpst: panic kexec loaded successfully. If a kernel crash happens, the kdump will be collected and in the subsequent boot, a message indicates the success of the operation: kdumpst: logs saved in \"/var/crash/kdumpst/logs\". In that folder, the user will find a lightweight zip blob, that included a dmesg plus some extra data. The vmcore itself is saved on /var/crash/kdumpst/crash. For questions/issues, the #kdump IRC channel at OFTC could be used, or open issues in the kdumpst repository.\n\n"
    },
    {
      "title": "The automatic way: simple-kdump",
      "level": 3,
      "content": "The simple-kdumpAUR tool provides a simple and easy-to-config way to setup and collect kdump. Unlike kdumpstAUR, it is boot loader independent, has one and only one objective, save the vmcore file to /var/crash/.\n\nIt's mostly all the manual setups mentioned in later sections with slightly better organization using systemd, but re-use the Archlinux kernels (or whatever kernel the end user choose), so it's super flex and simple.\n\nAfter installing simple-kdumpAUR, fill /etc/conf.d/simple-kdump.conf using any booting kernel/initramfs combination, which has the CONFIG_PROC_VMCORE=y enabled. It's recommended to use the Archlinux linux or linux-lts kernel, which already have all the needed features enabled.\n\nThen add crashkernel=[size] kernel parameter and reboot. Recommended to use value no smaller than 512M\n\nFinally enable and start simple-kdump-setup.service, then refer to #Testing kdump by crashing the kernel to verify the kdump behavior.\n\nThe kexec kernel should reach target Emergency Mode to collect vmcore, with a prompt asking login for the emergency shell. You can ignore that login as the vmcore collection will happen at the background and reboot automatically.\n\nAfter the reboot, there should be a new crash dump at /var/crash/crashdump-*.\n\n"
    },
    {
      "title": "Manual steps",
      "level": 3,
      "content": "In case the preference is for doing that manually, the below guide will help with that.\n\n"
    },
    {
      "title": "Compiling kernel",
      "level": 4,
      "content": "Both System/kdump kernels requires some configuration flags that may not be set by default. Please consult Kernel Compilation article for more information about compiling a custom kernel in Arch. Here we will emphasize on Kdump specific configurations. Current default Arch kernel builds have these flags already set. You can verify if your running kernel has these set by looking in /proc/config.gz.\n\nPlease note that, the default linux and linux-lts kernels all have the needed options enabled. But unfortunately the default kernels have debug info striped, thus one still needs to recompile the kernel to have all the debug info so that the vmcore can be properly analyzed.\n\nTo create a kernel you need to edit the kernel .config file and enable following configuration options:\n\n```\n.config\n```\n\n```\nCONFIG_DEBUG_INFO=y\nCONFIG_CRASH_DUMP=y\nCONFIG_PROC_VMCORE=y\nCONFIG_DEBUG_INFO=y\nCOFNIG_DEBUG_INFO_BTF=y\n```\n\nThe last two are for the extra debuginfo so that tools like crash or drgn can analyze the vmcore. (Or is there a way to use debuginfod to download the kernel debuginfo?)\n\nAlso change package base name to something like linux-kdump to distinguish the kernel from the default Arch one. Compile kernel package and install it. Save ./src/linux-X.Y/vmlinux uncompressed system kernel binary - it contains debug symbols and you will need them later when analyzing the crash.\n\nFor reference, some details about building a kdump kernel or configuring the kernel parameters for kdump could be found in the kernel Kdump documentation.\n\n"
    },
    {
      "title": "Reuse existing kernel and initramfs",
      "level": 4,
      "content": "The simplest way to setup kdump is to use the existing kernel and initramfs. The example here will use linux kernel as an example, which generates its initramfs at /boot/initramfs-linux.img.\n\nThe core idea is to boot the kexec environment just as a regular Archlinux boot sequence. But with extra systemd options to slightly change the boot sequence (to skip re-setup kexec environment, collect vmcore, and reboot).\n\nThus we do not need to generate a special initramfs, unlike other distros (and our default initramfs generated by mkinitcpio is already way smaller than our competitors).\n\n"
    },
    {
      "title": "Setup the kdump kernel",
      "level": 4,
      "content": "First, you need to reserve memory in the system kernel, for the kdump kernel loading. Edit your boot loader configuration and add crashkernel=[size] kernel parameter.\n\nDepending on the machine and how the kdump kernel was built, something from 256M to 512M is usually enough - it worth trying after setting everything to check if it succeeds. Note that the reserved memory is unavailable to the system kernel.\n\nReboot into your system kernel. To make sure that the kernel is booted with correct options please check the files /proc/cmdline and /sys/kernel/kexec_crash_size to see if the memory was indeed pre-reserved (sometimes it's possible , though rare, that such memory reservation fails - if it happens, check the dmesg to get more information).\n\nNext you need to tell Kexec that you want to use your kdump kernel. Specify your kernel, initramfs file, root device and other parameters if needed: (here we use default linux kernel)\n\n```\n# kexec -p /boot/vmlinuz-linux --initrd=/boot/initramfs-linux.img] --append=\"root=[root-device] irqpoll nr_cpus=1 reset_devices\"\n```\n\nIt loads the kdump kernel into the reserved area. Without the -p flag kexec would boot the kernel right away, but in presence of such flag, the kdump kernel will be loaded into the reserved memory but its boot is postponed until a crash happens.\n\nInstead of running kexec manually you might want to setup Systemd service that will run kexec on boot:\n\n```\n/etc/systemd/system/kdump.service\n```\n\n```\n[Unit]\nDescription=Load the kdump kernel\nAfter=local-fs.target\n\n[Service]\nType=oneshot\nRemainAfterExit=true\nExecStart=/usr/bin/kexec -p /boot/vmlinuz-linux --initrd=/boot/initramfs-linux.img --append=\"root=[root-device] irqpoll nr_cpus=1 reset_devices systemd.mask=kdump.service\"\nExecStop=/usr/bin/kexec -p -u\n\n[Install]\nWantedBy=multi-user.target\n```\n\nThen enable kdump.service.\n\nNote, since the service is enabled, and our kexec environment boots exactly like a regular boot, it will try to start kdump.service but fail since there is not enough memory. Thus in the --append= option, systemd.mask=kdump.service is specified to avoid the kdump service itself.\n\nTo check whether the crash kernel is already loaded please run following command:\n\n```\n$ cat /sys/kernel/kexec_crash_loaded\n```\n\n"
    },
    {
      "title": "Testing kdump by crashing the kernel",
      "level": 4,
      "content": "If you want to test crash then you can use sysrq for this.\n\n```\n# sync; echo 1 > /proc/sys/kernel/sysrq; echo c > /proc/sysrq-trigger\n```\n\nOnce crash happens kexec will load your kdump kernel, which should look exactly like a regular boot, but with much smaller memory (the reserved size) and only one CPU core.\n\n"
    },
    {
      "title": "Saving the crashed kernel memory",
      "level": 4,
      "content": "Once booted into the kdump kernel, the idea is to save the relevant contents from /proc/vmcore to analyze it later. Though this is exposed as a file (hence it's possible to copy it, like in cp /proc/vmcore /root/vmcore.crashdump, this is not the recommended way. The vmcore is a full copy of system memory, so this file will have 64G if your machine has 64G, for example. It includes all data from all the userpace loaded, as well as free memory. So, the best way for saving it is use the makedumpfile utility. Such application is able to remove free memory and userspace irrelevant data, as well as compress the vmcore! Example of the usage:\n\n```\n# makedumpfile -z -d 31 /proc/vmcore /root/vmcore.crashdump_compressed\n```\n\nYou can also save out the dmesg log from the crashed kernel using this command:\n\n```\n# makedumpfile --dump-dmesg /proc/vmcore /root/vmcore.dmesg\n```\n\nThe following systemd service can be used to automatically save the crash dumps and reboot into the system kernel again:\n\n```\n/etc/systemd/system/kdump-save.service\n```\n\n```\n[Unit]\nDescription=Save the kernel crash dump after a crash\nAfter=multi-user.target\n\n[Service]\nType=idle\nExecStart=/bin/sh -c 'mkdir -p /var/crash/ && /usr/bin/makedumpfile -z -d 31 /proc/vmcore \"/var/crash/crashdump-$$(date +%%F-%%T)\"'\nExecStopPost=/usr/bin/systemctl reboot\nUMask=0077\n```\n\nThis can be invoked from the kdump kernel command line - for that, we should edit the kdump load service as below:\n\n```\n/etc/systemd/system/kdump.service\n```\n\n```\n[Unit]\nDescription=Load the kdump kernel\nAfter=local-fs.target\n\n[Service]\nType=oneshot\nRemainAfterExit=true\nExecStart=/usr/bin/kexec -p /boot/vmlinuz-linux --initrd=/boot/initramfs-linux.img --append=\"root=[root-device] irqpoll nr_cpus=1 reset_devices systemd.mask=kdump.service systemd.unit=kdump-save.service\"\nExecStop=/usr/bin/kexec -p -u\n\n[Install]\nWantedBy=multi-user.target\n```\n\n"
    },
    {
      "title": "Early kdump using mkinitcpio",
      "level": 4,
      "content": "You might encounter a situation where the kernel crashes before the systemd service can be started. In this case, it might be helpful to run kexec as a mkinitcpio hook rather than a service.\n\nFirst make a copy of your initramfs. This will be used to run the crash kernel.\n\n```\n# cp /boot/initramfs-linux.img /boot/initramfs-linux-crash.img\n```\n\nNext, create the mkinitcpio install file. This builds allows us to build the main initramfs with a copy of the crash initramfs for the crash kernel and the\n\n```\n/etc/initcpio/install/kdump\n```\n\n```\nbuild() {\n        add_binary kexec\n        add_file /boot/initramfs-linux-crash.img /crash/initramfs.img\n        add_file /boot/vmlinuz-linux /crash/vmlinuz\n        add_runscript\n}\n\nhelp() {\n        cat <<HELPEOF\nInstalls the crash kernel on boot\nHELPEOF\n}\n```\n\nNext, make the mkinitcpio hook file. This runs kexec as an earlyhook, hopefully before anything in the kernel can crash. An important note here is that we run the kernel in emergency mode, because running the kernel in rescue or normal might might just lead to another the same crash happening in the crash kernel.\n\n```\n/etc/initcpio/hook/kdump\n```\n\n```\nrun_earlyhook() {\n\tmsg 'Loading crash kernel..'\n\tif [ -e /crash/vmlinuz ]; then\n\t\tif [ -e /crash/initramfs.img ]; then\n\t\t\tkexec -p /crash/vmlinuz --initrd=/crash/initramfs.img --append=\"root=[root-device] irqpoll nr_cpus=1 reset_devices emergency\"\n\t\telse\n\t\t\tmsg 'No initramfs found'\n\t\tfi\n\telse\n\t\tmsg 'No vmlinuz found'\n\tfi\n}\n```\n\nNow run mkinitcpio with the new hook\n\n```\n# mkinitcpio -A kdump\n```\n\nWhen the crash happens, you will be loaded into emergency kernel mode. After entering your password, you will be at a terminal. The first thing you will need to do is make your root filesystem writable.\n\n```\n$ mount -o remount, rw /\n```\n\nNow you can save the dump using makedumpfile (see #Saving the crashed kernel memory)\n\n"
    },
    {
      "title": "Analyzing the kernel core dump",
      "level": 2,
      "content": "The best way for studying the saved kernel core dump involves tools aimed specifically at that. The most common alternative is the gdb-based crash. Run crash as in\n\n```\n$ crash vmlinux path/crash.dump\n```\n\nWhere the vmlinux should contain debug symbols included in order to extract more information from the saved crash dump.\n\nFollow man crash or [1] for more information about debugging practices.\n\nAnother recent alternative is drgn, a python-based and fully scriptable tool to extract information from the vmcore.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- https://docs.kernel.org/admin-guide/kdump/kdump.html - Official kdump documentation\n- https://www.dedoimedo.com/computers/www.dedoimedo.com-crash-book.pdf - The crash book\n- https://gitlab.freedesktop.org/gpiccoli/kdumpst/ - kdumpst repository\n- https://crash-utility.github.io - The crash website\n- https://drgn.readthedocs.io/ - The drgn documentation website\n\n"
    }
  ]
}