{
  "title": "Systemctl --user",
  "url": "https://wiki.archlinux.org/title/Systemctl_--user",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- systemd\n- Automatic login to virtual console\n- Start X at login\n\nsystemd offers the ability to manage services under the user's control with a per-user systemd instance, enabling them to start, stop, enable, and disable their own user units. This is convenient for daemons and other services that are commonly run for a single user, such as mpd, or to perform automated tasks like fetching mail.\n\n"
    },
    {
      "title": "How it works",
      "level": 2,
      "content": "As per default configuration in /etc/pam.d/system-login, the pam_systemd module automatically launches a systemd --user instance when the user logs in for the first time. This process will survive as long as there is some session for that user, and will be killed as soon as the last session for the user is closed. When #Automatic start-up of systemd user instances is enabled, the instance is started on boot and will not be killed. The systemd user instance is responsible for managing user services, which can be used to run daemons or automated tasks with all the benefits of systemd, such as socket activation, timers, dependency system, and strict process control via cgroups.\n\nSimilar to system units, user units are located in the following directories (ordered by ascending precedence):\n\n- /usr/lib/systemd/user/ where units provided by installed packages belong.\n- ~/.local/share/systemd/user/ where units of packages that have been installed in the home directory belong.\n- /etc/systemd/user/ where system-wide user units are placed by the system administrator.\n- ~/.config/systemd/user/ where the user puts their own units.\n\nWhen a systemd user instance starts, it brings up the per user target default.target. Other units can be controlled manually with systemctl --user. See systemd.special(7) § UNITS MANAGED BY THE USER SERVICE MANAGER.\n\n- Be aware that the systemd --user instance is a per-user process, and not per-session. The rationale is that most resources handled by user services, like sockets or state files will be per-user (live on the user's home directory) and not per session. This means that all user services run outside of a session. As a consequence, programs that need to be run inside a session will probably break in user services. The way systemd handles user sessions is pretty much in flux. See [1] and [2] for some hints on where things are going.\n- systemd --user runs as a separate process from the systemd --system process. User units can not reference or depend on system units or units of other users.\n\n"
    },
    {
      "title": "Basic setup",
      "level": 2,
      "content": "All the user units will be placed in ~/.config/systemd/user/. If you want to start units on first login, execute systemctl --user enable unit for any unit you want to be autostarted.\n\n"
    },
    {
      "title": "Environment variables",
      "level": 3,
      "content": "Units started by user instance of systemd do not inherit any of the environment variables set in places like .bashrc etc. There are several ways to set environment variables for them:\n\n- For users with a $HOME directory, create a .conf file in the ~/.config/environment.d/ directory with lines of the form NAME=VAL. Affects only that user's user unit. See environment.d(5) for more information.\n- Use the DefaultEnvironment option in /etc/systemd/user.conf file. Affects all user units.\n- Add a drop-in configuration file in /etc/systemd/system/user@UID.service.d/, see #Service example\n- Add a drop-in configuration file in /etc/systemd/system/user@.service.d/ (affects all users), see #Service example\n- At any time, use systemctl --user set-environment or systemctl --user import-environment. Affects all user units started after setting the environment variables, but not the units that were already running.\n- Using the dbus-update-activation-environment --systemd --all command provided by dbus. Has the same effect as systemctl --user import-environment, but also affects the D-Bus session. You can add this to the end of your shell initialization file.\n- For \"global\" environment variables for the user environment you can use the environment.d directories which are parsed by some generators. See environment.d(5) and systemd.generator(7) for more information.\n- You can also write a systemd.environment-generator(7) script which can produce environment variables that vary from user to user, this is probably the best way if you need per-user environments (this is the case for XDG_RUNTIME_DIR, DBUS_SESSION_BUS_ADDRESS, etc).\n\nOne variable you may want to set is PATH.\n\nAfter configuration, the command systemctl --user show-environment can be used to verify that the values are correct. You may need to run systemctl --user daemon-reload for changes to take effect immediately.\n\n"
    },
    {
      "title": "Systemd user instance",
      "level": 4,
      "content": "The above only addresses default environment variables for user units. However, the systemd user instance itself is also affected by some environment variables. In particular, certain specifiers (see systemd.unit(5) § SPECIFIERS) are affected by XDG variables.\n\nHowever, the systemd user instance will only use environment variables that are set when it is started. In particular, it will not try parsing files, see upstream bug #29414 (closed WONTFIX). Therefore, if such environment variables are needed, they should be set in a drop-in configuration file, see #Service example.\n\nSystemd does not provide introspection tools to check these values, however, something like the following service can be used to help checking that the specifiers expand as expected:\n\n```\n$XDG_CONFIG_HOME/systemd/user/test-specifiers.service\n```\n\n```\n[Service]\nType=oneshot\nExecStart=printf '(systemd)=(envvar)\\n'\nExecStart=printf '%%s=%%s\\n' %C \"${XDG_CACHE_HOME}\"\nExecStart=printf '%%s=%%s\\n' %E \"${XDG_CONFIG_HOME}\"\nExecStart=printf '%%s=%%s\\n' %L \"${XDG_STATE_HOME}\"/log\nExecStart=printf '%%s=%%s\\n' %S \"${XDG_STATE_HOME}\"\nExecStart=printf '%%s=%%s\\n' %t \"${XDG_RUNTIME_DIR}\"\n```\n\n"
    },
    {
      "title": "Service example",
      "level": 4,
      "content": "Create the drop-in directory /etc/systemd/system/user@.service.d/ and inside create a file that has the extension .conf (e.g. local.conf):\n\n```\n/etc/systemd/system/user@.service.d/local.conf\n```\n\n```\n[Service]\nEnvironment=\"PATH=/usr/lib/ccache/bin:/usr/local/sbin:/usr/local/bin:/usr/bin\"\nEnvironment=\"EDITOR=nano -c\"\nEnvironment=\"BROWSER=firefox\"\nEnvironment=\"NO_AT_BRIDGE=1\"\nEnvironment=\"XDG_STATE_HOME=%h/.local/var/state\"\n```\n\n"
    },
    {
      "title": "DISPLAY and XAUTHORITY",
      "level": 4,
      "content": "DISPLAY is used by any X application to know which display to use and XAUTHORITY to provide a path to the user's .Xauthority file and thus the cookie needed to access the X server. If you plan on launching X applications from systemd units, these variables need to be set. Systemd provides a script in /etc/X11/xinit/xinitrc.d/50-systemd-user.sh to import those variables into the systemd user session on X launch. [3] So unless you start X in a nonstandard way, user services should be aware of the DISPLAY and XAUTHORITY.\n\n"
    },
    {
      "title": "PATH",
      "level": 4,
      "content": "If you customize your PATH and plan on launching applications that make use of it from systemd units, you should make sure the modified PATH is set on the systemd environment. Assuming you set your PATH in .bash_profile, the best way to make systemd aware of your modified PATH is by adding the following to .bash_profile after the PATH variable is set:\n\n```\n~/.bash_profile\n```\n\n```\nsystemctl --user import-environment PATH\n```\n\n- This will not affect systemd services started before PATH is imported.\n- systemd does not look at the set PATH when resolving non-absolute binaries itself.\n\n"
    },
    {
      "title": "pam_env",
      "level": 4,
      "content": "Environment variables can be made available through use of the pam_env.so module. See Environment variables#Using pam_env for configuration details.\n\n"
    },
    {
      "title": "Automatic start-up of systemd user instances",
      "level": 3,
      "content": "The systemd user instance is started after the first login of a user and killed after the last session of the user is closed. Sometimes it may be useful to start it right after boot, and keep the systemd user instance running after the last session closes, for instance to have some user process running without any open session. Lingering is used to that effect. Use the following command to enable lingering for your own user, if polkit is installed:\n\n```\n$ loginctl enable-linger\n```\n\nWithout polkit or to enable lingering for a different user:\n\n```\n# loginctl enable-linger username\n```\n\nNote: **not** \n\nTo list all users which have the permit for lingering see column \"LINGER\" with yes:\n\n```\n$ loginctl list-users\n```\n\nor inspect /var/lib/systemd/linger. To revoke lingering:\n\n```\n# loginctl disable-linger username\n```\n\n"
    },
    {
      "title": "Writing user units",
      "level": 2,
      "content": "See systemd#Writing unit files for general information about writing systemd unit files.\n\n"
    },
    {
      "title": "Example",
      "level": 3,
      "content": "The following is an example of a user version of the mpd service:\n\n```\n~/.config/systemd/user/mpd.service\n```\n\n```\n[Unit]\nDescription=Music Player Daemon\n\n[Service]\nExecStart=/usr/bin/mpd --no-daemon\n\n[Install]\nWantedBy=default.target\n```\n\n"
    },
    {
      "title": "Example with variables",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nThe following is a user service used by foldingathomeAUR, which takes into account variable home directories where Folding@home can find certain files:\n\n```\n~/.config/systemd/user/foldingathome-user.service\n```\n\n```\n[Unit]\nDescription=Folding@home distributed computing client\nAfter=network.target\n\n[Service]\nType=simple\nWorkingDirectory=%h/.config/fah\nExecStart=/usr/bin/FAHClient\nCPUSchedulingPolicy=idle\nIOSchedulingClass=3\n\n[Install]\nWantedBy=default.target\n```\n\nAs detailed in systemd.unit(5) § SPECIFIERS, the %h variable is replaced by the home directory of the user running the service. There are other variables that can be taken into account in the systemd manpages.\n\n"
    },
    {
      "title": "Reading the journal",
      "level": 3,
      "content": "The journal for the user can be read using the analogous command:\n\n```\n$ journalctl --user\n```\n\nTo specify a unit, one can use\n\n```\n$ journalctl --user-unit myunit.service\n```\n\nOr, equivalently:\n\n```\n$ journalctl --user -u myunit.service\n```\n\n"
    },
    {
      "title": "Temporary files",
      "level": 2,
      "content": "systemd-tmpfiles allows users to manage custom volatile and temporary files and directories just like in the system-wide way (see systemd#systemd-tmpfiles - temporary files). User-specific configuration files are read from ~/.config/user-tmpfiles.d/ and ~/.local/share/user-tmpfiles.d/, in that order. For this functionality to be used, it is needed to enable the necessary systemd user units for your user:\n\n```\n$ systemctl --user enable systemd-tmpfiles-setup.service systemd-tmpfiles-clean.timer\n```\n\nThe syntax of the configuration files is the same than those used system-wide. See the systemd-tmpfiles(8) and tmpfiles.d(5) man pages for details.\n\n"
    },
    {
      "title": "Xorg and systemd",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nThere are several ways to run xorg within systemd units. Below there are 3 options, either by starting a new user session with an xorg process, launching xorg from a systemd user service, or launching xinit and application as a service.\n\n"
    },
    {
      "title": "Automatic login into Xorg without display manager",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nThis option will launch a system unit that will start a user session with an xorg server and then run the usual ~/.xinitrc to launch the window manager, etc. You need to have xlogin-gitAUR installed. Set up your xinitrc as specified in the Xinit#xinitrc section.\n\nThe session will use its own dbus daemon, but various systemd utilities will automatically connect to the dbus.service instance. Finally, enable the xlogin@username service for automatic login at boot. The user session lives entirely inside a systemd scope and everything in the user session should work just fine.\n\n"
    },
    {
      "title": "Xorg as a systemd user service",
      "level": 3,
      "content": "Alternatively, xorg can be run from within a systemd user service. This is nice since other X-related units can be made to depend on xorg, etc, but on the other hand, it has some drawbacks explained below.\n\nxorg-server provides integration with systemd in two ways:\n\n- Can be run unprivileged, delegating device management to logind (see Hans de Goede commits around this commit).\n- Can be made into a socket activated service (see this commit).\n\nUnfortunately, to be able to run xorg in unprivileged mode, it needs to run inside a session. So, right now the handicap of running xorg as user service is that it must be run with root privileges (like before 1.16), and cannot take advantage of the unprivileged mode introduced in 1.16.\n\nThis is how to launch xorg from a user service:\n\n1. Make xorg run with root privileges for any user, by editing /etc/X11/Xwrapper.config. This builds on Xorg#Xorg as Root by adding the stipulation that this need not be done from a physical console. That is, allowed_user's default of console is being overwritten with anybody; see Xorg.wrap(1).\n\n```\n/etc/X11/Xwrapper.config\n```\n\n```\nallowed_users=anybody\nneeds_root_rights=yes\n```\n\n2. Add the following units to ~/.config/systemd/user\n\n```\n~/.config/systemd/user/xorg@.socket\n```\n\n```\n[Unit]\nDescription=Socket for xorg at display %i\n\n[Socket]\nListenStream=/tmp/.X11-unix/X%i\n```\n\n```\n~/.config/systemd/user/xorg@.service\n```\n\n```\n[Unit]\nDescription=Xorg server at display %i\n\nRequires=xorg@%i.socket\nAfter=xorg@%i.socket\n\n[Service]\nType=simple\nSuccessExitStatus=0 1\n\nExecStart=/usr/bin/Xorg :%i -nolisten tcp -noreset -verbose 2 \"vt${XDG_VTNR}\"\n```\n\nwhere ${XDG_VTNR} is the virtual terminal where xorg will be launched, either hard-coded in the service unit, or set in the systemd environment with\n\n```\n$ systemctl --user set-environment XDG_VTNR=1\n```\n\n3. Make sure to configure the DISPLAY environment variable as explained above.\n\n4. Then, to enable socket activation for xorg on display 0 and tty 2 one would do:\n\n```\n$ systemctl --user set-environment XDG_VTNR=2     # So that xorg@.service knows which vt use\n$ systemctl --user start xorg@0.socket            # Start listening on the socket for display 0\n```\n\nNow running any X application will launch xorg on virtual terminal 2 automatically.\n\nThe environment variable XDG_VTNR can be set in the systemd environment from .bash_profile, and then one could start any X application, including a window manager, as a systemd unit that depends on xorg@0.socket.\n\n"
    },
    {
      "title": "xinit and application as a systemd service",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nThe service below is an example to run xinit and mate-session with user privilege.\n\n```\n/etc/systemd/system/xinit.service\n```\n\n```\n[Unit]\nAfter=graphical.target systemd-user-sessions.service modprobe@drm.service\nConflicts=getty@tty1.service mdoprobe@drm.service\n\n[Service]\nType=simple\nUser=username\nWorkingDirectory=~\n\nPAMName=login\nEnvironment=XDG_SESSION_TYPE=x11\nTTYPath=/dev/tty1\nStandardInput=tty\nUnsetEnvironment=TERM\n\nStandardOutput=journal\nExecStart=/bin/xinit /bin/mate-session -- -quiet -logfile /dev/null -nolisten tcp vt01\n[Install]\nWantedBy=graphical.target\n```\n\nSee also [8] .\n\n"
    },
    {
      "title": "Window manager",
      "level": 3,
      "content": "To run a window manager as a systemd service, you first need to run #Xorg as a systemd user service. In the following we will use awesome as an example:\n\n```\n~/.config/systemd/user/awesome.service\n```\n\n```\n[Unit]\nDescription=Awesome window manager\nAfter=xorg.target\nRequires=xorg.target\n\n[Service]\nExecStart=/usr/bin/awesome\nRestart=always\nRestartSec=10\n \n[Install]\nWantedBy=wm.target\n```\n\n"
    },
    {
      "title": "Persistent terminal multiplexer",
      "level": 3,
      "content": "Rather than logging you into a window manager session for your user session by default, you may want to automatically run a terminal multiplexer (such as screen or tmux) in the background.\n\nCreate the following:\n\n```\n~/.config/systemd/user/multiplexer.target\n```\n\n```\n[Unit]\nDescription=Terminal multiplexer\nDocumentation=info:screen man:screen(1) man:tmux(1)\nAfter=cruft.target\nWants=cruft.target\n\n[Install]\nAlias=default.target\n```\n\nSeparating login from X login is most likely only useful for those who boot to a TTY instead of to a display manager (in which case you can simply bundle everything you start in mystuff.target).\n\nThe dependency cruft.target, like the mystuff.target above, allows starting anything which should run before the multiplexer starts (or which you want started at boot regardless of timing), such as a GnuPG daemon session.\n\nYou then need to create a service for your multiplexer session. Here is a sample service, using tmux as an example and sourcing a gpg-agent session which wrote its information to /tmp/gpg-agent-info. This sample session, when you start X, will also be able to run X programs, since $DISPLAY is set:\n\n```\n~/.config/systemd/user/tmux.service\n```\n\n```\n[Unit]\nDescription=tmux: A terminal multiplexer \nDocumentation=man:tmux(1)\nAfter=gpg-agent.service\nWants=gpg-agent.service\n\n[Service]\nType=forking\nExecStart=/usr/bin/tmux start\nExecStop=/usr/bin/tmux kill-server\nEnvironment=DISPLAY=:0\nEnvironmentFile=/tmp/gpg-agent-info\n\n[Install]\nWantedBy=multiplexer.target\n```\n\nEnable tmux.service, multiplexer.target and any services you created to be run by cruft.target, start user@.service as usual and you should be done.\n\n"
    },
    {
      "title": "Kill user processes on logout",
      "level": 2,
      "content": "Arch Linux builds the systemd package with --without-kill-user-processes, setting KillUserProcesses to no by default. This setting causes user processes not to be killed when the user logs out. To change this behavior in order to have all user processes killed on the user's logout, set KillUserProcesses=yes in /etc/systemd/logind.conf.\n\nNote that changing this setting breaks terminal multiplexers such as tmux and GNU Screen. If you change this setting, you can still use a terminal multiplexer by using systemd-run as follows:\n\n```\n$ systemd-run --scope --user command args\n```\n\nFor example, to run screen you would do:\n\n```\n$ systemd-run --scope --user screen -S foo\n```\n\nUsing systemd-run will keep the process running after logout only while the user is logged in at least once somewhere else in the system and user@.service is still running.\n\nAfter the user logs out of all sessions, user@.service will be terminated too, by default, unless the user has \"lingering\" enabled [9]. To effectively allow users to run long-term tasks even if they are completely logged out, lingering must be enabled for them. See #Automatic start-up of systemd user instances and loginctl(1) for details.\n\n"
    },
    {
      "title": "Runtime directory '/run/user/1000' is not owned by UID 1000, as it should",
      "level": 3,
      "content": "```\nsystemd[1867]: pam_systemd(systemd-user:session): Runtime directory '/run/user/1000' is not owned by UID 1000, as it should.\nsystemd[1867]: Trying to run as user instance, but $XDG_RUNTIME_DIR is not set\n```\n\nIf you see errors such as this and your login session is broken, it is possible that another system (non-user) service on your system is creating this directory. This can happen for example if you use a docker container that has a bind mount to /run/user/1000. To fix this, you can either fix the container by removing the mount, or disable/delay the docker service.\n\n"
    },
    {
      "title": "\"A stop job is running for User Manager for UID 1000\"",
      "level": 3,
      "content": "If you see this message during shutdown, usually with a 2 minute timeout, it means that one of the user services did not stop in a timely manner. This can be caused by a misbehaving application which spawned a transient service earlier. You can simply wait for the timeout to expire, but if this bothers you, you can either create an override for the misbehaving service or reduce the global timeout for all user services.\n\n"
    },
    {
      "title": "Finding and overriding the misbehaving service",
      "level": 4,
      "content": "To troubleshoot this problem, start the systemd debug shell:\n\n```\n# systemctl start debug-shell\n```\n\nThen, reboot or shut down the system. When the problem occurs, switch to the debug shell using Ctrl+Alt+F9. To find out which service is preventing the shutdown, run:\n\n```\n# systemctl --user list-jobs\n```\n\nFor most open source applications, this problem should be reported to the respective maintainers such that an override isn't necessary. For closed source applications, however, an override can be created like so:\n\n```\n$ systemctl --user edit --force name@.service\n```\n\n```\n[Service]\nTimeoutStopSec=1s\n```\n\nThis will shorten the timeout of that particular service to 1 second. The --force parameter is only required for transient services which do not create a .service file on disk. The override will work regardless. Instead of the timeout, KillSignal=SIGKILL can be used. This will cause the service to be killed immediately when the user manager is stopped. Only use this if you know the service can handle it.\n\n"
    },
    {
      "title": "Changing the timeout value",
      "level": 4,
      "content": "If you don't care which service is preventing the shutdown, you can change the global timeout for all user services in a similar manner:\n\n```\n# systemctl edit user@.service\n```\n\n```\n[Service]\nTimeoutStopSec=10s\n```\n\nAfter this timeout, any user services which haven't gracefully stopped will be killed, which is equivalent to a sudden power loss. Adjust this value for your particular use case. Setting the timeout too low may cause data corruption depending on the application.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- KaiSforza's Bitbucket wiki\n- Zoqaeski's units on GitHub\n- Arch forum thread about changes in systemd 206 user instances\n\n"
    }
  ]
}