{
  "title": "Modalias",
  "url": "https://wiki.archlinux.org/title/Modalias",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis document is an intro to how the Linux kernel and modules see and understand hardware, and how this translates into a sysfs 'modalias'\n\n"
    },
    {
      "title": "What is a modalias",
      "level": 2,
      "content": "Modalias is a little sysfs trick that exports hardware information to a file named 'modalias'. This file simply contains a formatted form of the information normal hardware exposes.\n\n```\n$ cat /sys/devices/pci0000:00/0000:00:1f.1/modalias\n```\n\n```\npci:v00008086d000024DBsv0000103Csd0000006Abc01sc01i8A\n```\n\n"
    },
    {
      "title": "What is a modalias file?",
      "level": 2,
      "content": "As described above, a modalias file simply exposes the information that a given piece of hardware already tells the kernel. This file simply specifies a structure for exposing this information. Let us return to the example above:\n\n```\n$ cat /sys/devices/pci0000:00/0000:00:1f.1/modalias\n```\n\n```\npci:v00008086d000024DBsv0000103Csd0000006Abc01sc01i8A\n```\n\nLet us take it apart piece-by-piece. First, the file name, /sys/devices/pci0000:00/0000:00:1f.1/modalias:\n\n- pci0000:00 is the id for the first PCI bus. For most machines this will be the only PCI bus you have, but it is possible this can extend to pci0000:01 or pci0000:02 - the exacts are unimportant, as it is a good guess that you only have one PCI bus (HINT: try ls /sys/devices/pci* to check)\n- 0000:00:1f.1 is the index of the given device on the PCI bus. Specifically, this is on bus 0000:00 and has index 1f.1\n- All this is rather unimportant, unless you want to know where all these numbers come from. For completeness, if you check the output of lspci you will see the same information:\n\n```\n$ lspci\n```\n\n```\n00:1f.1 IDE interface: Intel Corp.: Unknown device 24db (rev 02)\n```\n\nNow, let us take a peek at the contents of this modalias file for device 00:1f.1:\n\n```\npci:v00008086d000024DBsv0000103Csd0000006Abc01sc01i8A\n```\n\nWell, hey, I can see pci! I recognize that, but what's all this gibberish at the end? This gibberish is actually structured data. You will notice a repeating letter/number scheme. Let us split this apart to make it easier to read:\n\n```\nv  00008086\nd  000024DB\nsv 0000103C\nsd 0000006A\nbc 01\nsc 01\ni  8A\n```\n\nEach of these identifiers, and corresponding hex numbers represent some of the info that a given device exposes. For starters, v is the vendor id and d is the device id - these are very standard numbers. In fact, tools like hwdetect uses these, and other sysfs files, to give information for a device. You can even find websites to look up specific hardware identification based on the vendor and device ids, for instance, https://devicehunt.com/\n\nWe can also see these numbers here:\n\n```\n$ lspci -n\n```\n\n```\n00:1f.1 Class 0101: 8086:24db (rev 02)\n```\n\nSee how the 8086:24db matches to the v and d tokens listed above?\n\nFor the record, sv and sd are \"subsystem\" versions of both vendor and device. A majority of the time these are ignored. They are mainly used by the hardware developers to distinguish slight differences in the inner workings which do not change the device as a whole.\n\nbc (base class) and sc (sub class) are used to create the \"Class\" listed by lspci, in order \"bcsc\". This is the device class, which is fairly generic. In this case, the \"class\" is looked up in the normal lspci output. We can see that \"Class 0101\" maps to \"IDE Interface\" (lspci also looks up the vendor and device id's - 8086 maps to \"Intel Corp.\" and 24DB maps to 'Unknown Device', hehe)\n\ni is the \"Programming interface\", which is only meaningful for a few devices classes.\n\n"
    },
    {
      "title": "How is this information used?",
      "level": 2,
      "content": "Ok, now we all know what this information is. A bunch of obscure numbers that each device exposes. Big deal. How does this matter when talking about modules?\n\nOne thing which people tend to ignore, is all the work depmod does. When you run depmod, it builds a series of \"map\" files in /lib/modules/`uname -r` which tell modprobe how to handle certain things it needs to do. In this case we can ignore most of them. The important one is modules.alias. This file contains aliases, or secondary names for modules. Just for a demonstration, let us look at aliases for, say, snd_intel8x0m:\n\n```\n$ grep snd_intel8x0m /lib/modules/$(uname -r)/modules.alias\n```\n\n```\nalias pci:v00008086d00002416sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00008086d00002426sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00008086d00002446sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00008086d00002486sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00008086d000024C6sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00008086d000024D6sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00008086d0000266Dsv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00008086d000027DDsv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00008086d00007196sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00001022d00007446sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v00001039d00007013sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v000010DEd000001C1sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v000010DEd00000069sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v000010DEd00000089sv*sd*bc*sc*i* snd_intel8x0m\nalias pci:v000010DEd000000D9sv*sd*bc*sc*i* snd_intel8x0m\n```\n\nHey, wait! I recognize that! That's the vendor/device id information from before!\n\nYes, it is. It is a rather simple format of \"alias <something> <actual module>\". In fact, you can alias just about anything you want. I can add \"alias boogabooga snd_intel8x0m\" and then safely \"modprobe boogabooga\".\n\nThe \"*\" indicates it will match anything, much like filesystem globbing (ls somedir/*). As stated before, most aliases ignore sv, sd, bc, sc, and i by way of the \"*\" matching.\n\n"
    },
    {
      "title": "Where does this modules.alias file come from?",
      "level": 2,
      "content": "Ok, now you may be thinking \"Well, hardware probe used to look things up based on a device table, what makes this any different?\"\n\nThe difference is that this lookup table is not static. It is not maintained by hand. In fact, it is built dynamically whenever you run depmod. \"Where does this information come from?\", you ask? Why, from the kernel modules themselves. When you think about it, each specific module should know what hardware it supports, as it is coded specifically for that hardware. I mean, the nvidia module developers know that their module only work with Nvidia (vendor) Graphics Cards (class). In fact, the module actually exports this information. It says \"Hey, I can support this:\".\n\n```\n$ modinfo nvidia\n  filename:       /lib/modules/2.6.14-ARCH/kernel/drivers/video/nvidia.ko\n  license:        NVIDIA\n  alias:          char-major-195-*\n  vermagic:       2.6.14-ARCH SMP preempt 686 gcc-4.1\n  depends:        agpgart\n  alias:          pci:v000010DEd*sv*sd*bc03sc00i00*\n```\n\nAs you can see by the alias listed, it looks specifically for vendor \"10DE\" (Nvidia) and bc/sc 0300 (which is most likely 'graphics cards'). In fact, if you look at the modinfo for snd_intel8x0m:\n\n```\n$ modinfo snd_intel8x0m\n  filename:       /lib/modules/2.6.14-ARCH/kernel/sound/pci/snd-intel8x0m.ko\n  author:         Jaroslav Kysela <perex@suse.cz>\n  description:    Intel 82801AA,82901AB,i810,i820,i830,i840,i845,MX440; SiS 7013; NVidia MCP/2/2S/3 modems\n  license:        GPL\n  vermagic:       2.6.14-ARCH SMP preempt 686 gcc-4.1\n  depends:        snd-ac97-codec,snd-pcm,snd-page-alloc,snd\n  alias:          pci:v00008086d00002416sv*sd*bc*sc*i*\n  alias:          pci:v00008086d00002426sv*sd*bc*sc*i*\n  alias:          pci:v00008086d00002446sv*sd*bc*sc*i*\n  alias:          pci:v00008086d00002486sv*sd*bc*sc*i*\n  alias:          pci:v00008086d000024C6sv*sd*bc*sc*i*\n  alias:          pci:v00008086d000024D6sv*sd*bc*sc*i*\n  alias:          pci:v00008086d0000266Dsv*sd*bc*sc*i*\n  alias:          pci:v00008086d000027DDsv*sd*bc*sc*i*\n  alias:          pci:v00008086d00007196sv*sd*bc*sc*i*\n  alias:          pci:v00001022d00007446sv*sd*bc*sc*i*\n  alias:          pci:v00001039d00007013sv*sd*bc*sc*i*\n  alias:          pci:v000010DEd000001C1sv*sd*bc*sc*i*\n  alias:          pci:v000010DEd00000069sv*sd*bc*sc*i*\n  alias:          pci:v000010DEd00000089sv*sd*bc*sc*i*\n  alias:          pci:v000010DEd000000D9sv*sd*bc*sc*i*\n```\n\nIt matches the aliases found by 'grep'ing the alias file. These aliases exported by each module, are gathered by depmod and merged into the modules.alias file dynamically. There is no hand-changing of a lookup table, as it is built on-the-fly. Each module knows exactly what it supports, and therefore depmod can use that information to help load modules.\n\n"
    },
    {
      "title": "How does udev work?",
      "level": 2,
      "content": "udev is closely tied with sysfs (the filesystem which exposes the modalias in the firstplace). In fact, to load modules based on the modalias when a new device is added (or when udev is first started on boot), it is insanely simple:\n\n```\nDRIVER!=\"?*\", ENV{MODALIAS}==\"?*\", RUN{builtin}=\"kmod load $env{MODALIAS}\"\n```\n\nYep, that's it. It is a one-liner. This simple line, which is part of the default udev rules replace hotplug. Amazing, is it not?\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "This article shows others modalias templates, i.e. for usb, dmi and acpi subtypes\n\n- Modalias strings - a practical way to map \"stuff\" to hardware by Petter Reinholdtsen\n\n"
    }
  ]
}