{
  "title": "DNS resolver",
  "url": "https://wiki.archlinux.org/title/DNS_resolver",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Network configuration\n- DNS over HTTPS servers\n\nIn general, a domain name represents an IP address and is associated to it in the Domain Name System (DNS). This article explains how to configure domain name resolution and resolve domain names.\n\n"
    },
    {
      "title": "Name Service Switch",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nThe Name Service Switch (NSS) facility is part of the GNU C Library (glibc) and backs the getaddrinfo(3) API, used to resolve domain names. NSS allows system databases to be provided by separate services, whose search order can be configured by the administrator in nsswitch.conf(5). The database responsible for domain name resolution is the hosts database, for which glibc offers the following services:\n\n- files: reads the /etc/hosts file, see hosts(5)\n- dns: the glibc resolver which reads /etc/resolv.conf, see resolv.conf(5)\n\nsystemd provides three NSS services for hostname resolution:\n\n- nss-resolve(8) — a caching DNS stub resolver, described in systemd-resolved\n- nss-myhostname(8) — provides local hostname resolution without having to edit /etc/hosts\n- nss-mymachines(8) — provides hostname resolution for the names of local systemd-machined(8) containers\n\n"
    },
    {
      "title": "Resolve a domain name using NSS",
      "level": 3,
      "content": "NSS databases can be queried with getent(1). A domain name can be resolved through NSS using:\n\n```\n$ getent ahosts domain_name\n```\n\n"
    },
    {
      "title": "Glibc resolver",
      "level": 2,
      "content": "The glibc resolver reads /etc/resolv.conf for every resolution to determine the nameservers and options to use.\n\nresolv.conf(5) lists nameservers together with some configuration options. Nameservers listed first are tried first, up to three nameservers may be listed. Lines starting with a number sign (#) are ignored.\n\n"
    },
    {
      "title": "Overwriting of /etc/resolv.conf",
      "level": 3,
      "content": "Network managers tend to overwrite /etc/resolv.conf, for specifics see the corresponding section:\n\n- dhcpcd#/etc/resolv.conf\n- Netctl#/etc/resolv.conf\n- NetworkManager#/etc/resolv.conf\n- ConnMan#/etc/resolv.conf\n\nTo prevent programs from overwriting /etc/resolv.conf, it is also possible to write-protect it by setting the immutable file attribute:\n\n```\n# chattr +i /etc/resolv.conf\n```\n\n"
    },
    {
      "title": "Alternative using nmcli",
      "level": 4,
      "content": "Note: **This article or section is a candidate for merging with NetworkManager#/etc/resolv.conf.** This article or section is a candidate for merging with NetworkManager#/etc/resolv.conf.\n\nThis article or section is a candidate for merging with NetworkManager#/etc/resolv.conf.\n\nIf you use NetworkManager, nmcli(1) can be used to set persistent options for /etc/resolv.conf. Change \"Wired\" to the name of your connection. Example:\n\n```\n# nmcli con mod Wired +ipv4.dns-options 'rotate,single-request,timeout:1'\n```\n\nFor more options have a look at the man pages of nmcli(1), nm-settings-nmcli(5) and resolv.conf(5).\n\n"
    },
    {
      "title": "Limit lookup time",
      "level": 3,
      "content": "If you are confronted with a very long hostname lookup (may it be in pacman or while browsing), it often helps to define a small timeout after which an alternative nameserver is used. To do so, put the following in /etc/resolv.conf.\n\n```\n/etc/resolv.conf\n```\n\n```\noptions timeout:1\n```\n\n"
    },
    {
      "title": "Hostname lookup delayed with IPv6",
      "level": 3,
      "content": "If you experience a 5 second delay when resolving hostnames it might be due to a DNS-server/Firewall misbehaving and only giving one reply to a parallel A and AAAA request.[1] You can fix that by setting the following option in /etc/resolv.conf:\n\n```\n/etc/resolv.conf\n```\n\n```\noptions single-request\n```\n\n"
    },
    {
      "title": "Local domain names",
      "level": 3,
      "content": "To be able to use the hostname of local machine names without the fully qualified domain name, add a line to /etc/resolv.conf with the local domain such as:\n\n```\n/etc/resolv.conf\n```\n\n```\nsearch example.org\n```\n\nThat way you can refer to local hosts such as mainmachine1.example.org as simply mainmachine1 when using the ssh command, but the drill command still requires the fully qualified domain names in order to perform lookups.\n\n"
    },
    {
      "title": "Lookup utilities",
      "level": 2,
      "content": "To query specific DNS servers and DNS/DNSSEC records you can use dedicated DNS lookup utilities. These tools implement DNS themselves and do not use NSS.\n\nldns provides drill(1), which is a tool designed to retrieve information out of the DNS.\n\nFor example, to query a specific nameserver with drill for the TXT records of a domain:\n\n```\n$ drill @nameserver TXT domain\n```\n\nUnless a DNS server is specified, drill will use the nameservers defined in /etc/resolv.conf.\n\n- knot provides khost(1) and kdig(1).\n- Unbound has unbound-host(1).\n- BIND has dig(1), host(1), nslookup(1) and a bunch of dnssec- tools.\n- systemd-resolved has resolvectl(1), which provides a query sub-command for DNS lookup.\n\n"
    },
    {
      "title": "Resolver performance",
      "level": 2,
      "content": "The Glibc resolver does not cache queries. To implement local caching, use systemd-resolved or set up a local caching DNS server and use it as the name server by setting 127.0.0.1 and ::1 as the name servers in /etc/resolv.conf or in /etc/resolvconf.conf if using openresolv.\n\n- The drill or dig lookup utilities report the query time.\n- A router usually sets its own caching resolver as the network's DNS server thus providing DNS cache for the whole network.\n- If it takes too long to switch to the next DNS server you can try decreasing the timeout.\n\n"
    },
    {
      "title": "Privacy and security",
      "level": 2,
      "content": "The DNS protocol (Do53) is unencrypted and does not account for confidentiality, integrity or authentication, so if you use an untrusted network or a malicious ISP, your DNS queries can be eavesdropped and the responses manipulated. Furthermore, DNS servers can conduct DNS hijacking.\n\nYou need to trust your DNS server to treat your queries confidentially. DNS servers are provided by ISPs and third-parties. Alternatively you can run your own recursive name server (a.k.a recursive resolver, a.k.a DNS recursor), which however takes more effort. Mind that the communication between recursive resolvers and authoritative servers is not encrypted. If you use a DHCP client in untrusted networks, be sure to set static name servers to avoid using and being subject to arbitrary DNS servers, or alternatively, use a VPN to connect to a secure network and use its DNS servers. To secure your communication with a remote DNS server you can use an encrypted protocol, provided that both the upstream server and your local resolver support the protocol. Common encrypted DNS protocols are:\n\n- DNS over TLS (DoT)—RFC 7858,\n- DNS over HTTPS (DoH)—RFC 8484,\n- DNS over QUIC (DoQ)—RFC 9250,\n- DNSCrypt.\n\nTo verify that responses are actually from authoritative name servers, you can validate DNSSEC, provided that both the upstream server(s) and your local resolver support it.\n\n"
    },
    {
      "title": "TLS Server Name Indication",
      "level": 3,
      "content": "Although one may use an encrypted DNS resolver, a TLS connection still leaks the domain names in the Server Name Indication (SNI) when requesting the domain certificate. This leak can be checked using the Wireshark filter tls.handshake.extensions_server_name_len > 0, or using the following tshark command:\n\n```\n# tshark -p -Tfields -e tls.handshake.extensions_server_name -Y 'tls.handshake.extensions_server_name_len>0'\n```\n\nA proposed solution is to use the Encrypted Client Hello (ECH), a TLS 1.3 protocol extension.\n\n"
    },
    {
      "title": "Application-level DNS",
      "level": 3,
      "content": "Be aware that some client software, such as major web browsers[2][3], are starting to implement DNS over HTTPS. While the encryption of queries may often be seen as a bonus, it also means the software sidetracks queries around the system resolver configuration.[4]\n\nFirefox provides configuration options to enable or disable DNS over HTTPS and select a DNS server. Mozilla has setup a Trusted Recursive Resolver (TRR) programme with transparency information on their default providers. It is notable that Firefox supports and automatically enables the Encrypted Client Hello (ECH) for TRR providers, see Firefox/Privacy#Encrypted Client Hello.\n\nChromium will examine the user's system resolver and enable DNS over HTTPS if the system resolver addresses are known to also provide DNS over HTTPS. See this blog post for more information and how DNS over HTTPS can be disabled.\n\nMozilla has proposed universally disabling application-level DNS if the system resolver cannot resolve the domain use-application-dns.net. Currently, this is only implemented in Firefox.\n\n"
    },
    {
      "title": "Oblivious DNS over HTTPS",
      "level": 3,
      "content": "Oblivious DNS over HTTPS (RFC:9230) is a system which addresses a number of DNS privacy concerns. See Cloudflare's article for more information. It added DNS over HTTPS (DoH) to the academic Oblivious DNS design. See the Improving the privacy of DNS and DoH with oblivion article for a discussion of the differences.\n\n"
    },
    {
      "title": "Third-party DNS services",
      "level": 2,
      "content": "- Before using a third-party DNS service, check its privacy policy for information on how user data is handled. User data has value and can be sold to other parties.\n- It is highly advised to use an encrypted protocol when connecting to third-party DNS services.\n\nThere are various third-party DNS services. Wikipedia has a list of \"notable\" public DNS service operators while the curl project's wiki has a more extensive list of publicly available DNS over HTTPS servers (a lot of which also support DNS over TLS). The systemd package configures fallback DNS for systemd-resolved when no DNS servers are configured (manually or via DHCP/RA).\n\nYou can use dnsperftest to test the performance of the most popular DNS resolvers from your location. dnsperf.com provides global benchmarks between providers.\n\n"
    },
    {
      "title": "Third-party DNS client software",
      "level": 3,
      "content": "Some DNS services also provide dedicated software:\n\n- cloudflared — A DNS client for Cloudflare DNS over HTTPS\n\n- opennic-up — Automates the renewal of the DNS servers with the most responsive OpenNIC servers\n\n- nextdns — A DNS-over-HTTPS CLI client for NextDNS\n\n"
    },
    {
      "title": "DNS servers",
      "level": 2,
      "content": "DNS servers can be authoritative and recursive. If they are neither, they are called stub resolvers and simply forward all queries to another recursive name server. Stub resolvers are typically used to introduce DNS caching on the local host or network. Note that the same can also be achieved with a fully-fledged name server. This section compares the available DNS servers, for a more detailed comparison, refer to Wikipedia:Comparison of DNS server software.\n\nTable content:\nName | Package | Capabilities | resolvconf | Supported protocols\nAuthoritative | Recursive | Cache | ValidatesDNSSEC | DNS | DNSCrypt | DNSover TLS | DNSover HTTPS | DNSover QUIC\nBIND | bind | Yes | Yes | Yes | Yes | Yes | Yes | No | Yes | Server | No\nCoreDNS | corednsAUR | Yes | No | Yes | No | No | Yes | No | Yes | Server | No\nDNS-over-HTTPS | dns-over-https | No | No | No | No | No | Server | No | No | Yes | No\nDeadwood (MaraDNS recursor) | maradnsAUR | No | Yes | Yes | No | No | Yes | No | No | No | No\ndnscrypt-proxy | dnscrypt-proxy | No | No | Yes | No | No | Server | Resolver | No | Yes | No\ndnsmasq | dnsmasq | Partial1 | No | Yes | Yes | Yes | Yes | No | No | No | No\ndnsproxy | dnsproxyAUR | No | No | Yes | No | No | Yes | Yes | Yes | Yes | Yes\nKnot Resolver | knot-resolver | No | Yes | Yes | Yes | No | Yes | No | Yes | Server | No\npdnsd | pdnsd | Partial1 | Yes | Permanent | No | Yes | Yes | No | No | No | No\nPowerDNS Recursor | powerdns-recursor | No | Yes | Yes | Yes | Yes | Yes | No | Partial | No | No\nRescached | rescached-gitAUR | No | No | Yes | No | Yes | Yes | No | Yes | Yes | No\nRouteDNS | routedns-gitAUR | No | No | Yes2 | No | No | Yes | No | Yes | Yes | Yes\nSmartDNS | smartdns | No | No | Yes | No | No | Yes | No | Resolver | Resolver | No\nStubby | stubby | No | No | No | Yes | No | Server | No | Resolver | No | No\nsystemd-resolved | systemd | No | No | Yes | Experimental | Yes | Resolver and limited server | No | Resolver | No | No\nUnbound | unbound | Partial | Yes | Yes2 | Yes | Yes | Yes | Server | Yes | Server | No3\n\n1. From Wikipedia: limited authoritative support, intended for internal network use rather than public Internet use.\n1. Supports persistent cache using the Redis backend.\n1. Unbound's DNS over QUIC server feature requires for unbound to be built with libngtcp2 which in turn needs to be built with a patched OpenSSL.[5]\n\n"
    },
    {
      "title": "Authoritative-only servers",
      "level": 3,
      "content": "Table content:\nName | Package | DNSSEC | Geographicbalancing\ngdnsd | gdnsd | No | Yes\nKnot DNS | knot | Yes | Yes\nMaraDNS | maradnsAUR | No | No\nNSD | nsd | Yes | No\nPowerDNS | powerdns | Yes | Yes\n\n"
    },
    {
      "title": "Conditional forwarding",
      "level": 3,
      "content": "It is possible to use specific DNS resolvers when querying specific domain names. This is particularly useful when connecting to a VPN, so that queries to the VPN network are resolved by the VPN's DNS, while queries to the internet will still be resolved by your standard DNS resolver. It can also be used on local networks.\n\nTo implement it, you need to use a local resolver because glibc does not support it.\n\nIn a dynamic environment (laptops and to some extents desktops), you need to configure your resolver based on the network(s) you are connected to. The best way to do that is to use openresolv because it supports multiple subscribers. Some network managers support it, either through openresolv, or by configuring the resolver directly. NetworkManager supports conditional forwarding without openresolv.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Linux Network Administrators Guide\n- Debian Handbook\n- RFC:7706 - Decreasing Access Time to Root Servers by Running One on Loopback\n- Domain name system overview - Diagram about DNS\n- What does DNS stand for\n\n"
    }
  ]
}