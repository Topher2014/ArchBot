{
  "title": "Tailscale",
  "url": "https://wiki.archlinux.org/title/Tailscale",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- WireGuard\n\nTailscale builds on top of WireGuard and provides OAuth2 (SSO), OpenID, and SAML authentication for peers to build a mesh network. It is crossplatform, has ACL settings and internal DNS.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install tailscale. Alternatively, one can use unstable builds by installing the tailscale-gitAUR or tailscale-unstable-binAUR package.\n\nIt is also possible to run tailscale as a Docker container. This way, one can run multiple exit nodes on a single machine, each with its own tailnet.\n\n"
    },
    {
      "title": "Third-party clients",
      "level": 3,
      "content": "- KTailctl — GUI to monitor and manage Tailscale.\n\n- trayscale — An unofficial GUI wrapper for the Tailscale CLI client.\n\n- tailscaledesktop — Unnofficial Tailscale desktop application.\n\n- tailscale-systray-git — Linux port of tailscale system tray menu.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "To use tailscale, enable/start tailscaled.service and run the server as follows:\n\n```\n# tailscale up\n```\n\nYou can authenticate a headless machine by specifying the auth key:\n\n```\n# tailscale up --authkey=tskey-KEY\n```\n\n- Edit /etc/default/tailscaled to include TS_NO_LOGS_NO_SUPPORT=true\n- Edit /etc/default/tailscaled and add --no-logs-no-support to FLAGS\n\n"
    },
    {
      "title": "Using a custom Control Server",
      "level": 3,
      "content": "Using a custom control server like headscale is possible.\n\nTo login run\n\n```\n# tailscale up --login-server https://example.com\n```\n\nOn headless systems a non-interactive login using a token is possible.\n\n```\n# tailscale up --login-server https://example.com --authkey your_auth_key\n```\n\n"
    },
    {
      "title": "Running as a Docker container",
      "level": 3,
      "content": "Follow this guide for a general idea of how to run tailscale as a docker container.\n\n"
    },
    {
      "title": "As an exit node",
      "level": 4,
      "content": "In order to be able to use a tailscale instance running as a docker container as an exit node, we need to use a smaller MTU for the container's network. This is due to an MTU-related issue.\n\nIf you don't have one already, create a custom network:\n\n```\n# docker network create --opt com.docket.network.driver.mtu=1280 my_custom_network\n```\n\nThen, use that network for the container instance:\n\n```\n# docker run --detach --name=my_tailscale_container --network=my_custom_network --volume /var/lib/tailscale-exitnode-1:/var/lib/tailscale --env TS_STATE_DIR=/var/lib/tailscale --env TS_USERSPACE=1 --env TS_AUTHKEY=tskey-auth-XXX --env TS_EXTRA_ARGS='--advertise-exit-node' tailscale/tailscale\n```\n\nNote that:\n\n- By default, docker will create a network of type bridge, so no need to specify it here.\n- Use an auth key to authenticate the node. Authenticating with the regular SSO method usually takes too long, and the process may time out before initial authentication is successful.\n- Define TS_USERSPACE=1 so that the container doesn't need elevated permissions (CAP_NET_ADMIN and CAP_NET_RAW).\n- Bind mount an unused directory on the host (/var/lib/tailscale-exitnode-1) to /var/lib/tailscale inside the container, and also define TS_STATE_DIR=/var/lib/tailscale, so that tailscale will use a persistent state file. Without these, the exit node will use volatile memory to keep state, and thus get a new ID and tailnet IP address every time the container is restarted.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- https://tailscale.com/\n- https://github.com/juanfont/headscale\n\n"
    }
  ]
}