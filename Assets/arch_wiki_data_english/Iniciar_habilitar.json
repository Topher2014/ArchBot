{
  "title": "Iniciar/habilitar",
  "url": "https://wiki.archlinux.org/title/Iniciar/habilitar",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- systemd/User\n- systemd/Timers\n- systemd/Journal\n- systemd FAQ\n- init\n- udev\n- Melhorando o desempenho/Processo de inicialização\n- Permitir desligamento por usuários\n\nDa página web do projeto:\n\nHistoricamente o que systemd chama por \"serviço\", ou do inglês \"service\", era conhecido por se chamar daemon, tal qual o significado é: qualquer programa que esteja ativo no \"plano de fundo\" (background) como um processo (sem um terminal ou interface de usuário), normalmente aguardando a ocorrência de eventos e oferecendo serviços. Um bom exemplo é um servidor web que espera por um requerimento para entregar uma página, ou um servidor ssh a espera de alguém que tente logar. Enquanto que estas aplicações citadas são cheias de funcionalidades, existem daemons que o trabalho não é tão aparente. Daemons são para tarefas como escrever mensagens em um arquivo de log (por exemplo syslog, metalog) ou para manter o horário do sistema pontual (por exemplo ntpd). Para mais informações, veja daemon(7).\n\n"
    },
    {
      "title": "Uso básico do systemctl",
      "level": 2,
      "content": "O principal comando usado para introspecção e controle systemd é systemctl. Alguns de seus usos são examinando o estado do sistema e gerenciando o sistema e serviços. Consulte systemctl(1) para mais detalhes.\n\n- Você pode usar todos os comandos de systemctl abaixo com a opção -H usuário@host para controlar uma instância de systemd em uma máquina remota. Isso usará SSH para se conectar uma instância remota systemd.\n- Usuários de Plasma podem instalar systemdgenie como um frontend gráfico para systemctl. Após a instalação, o módulo será adicionado sob \"Sistema\".\n\n"
    },
    {
      "title": "Usando units",
      "level": 3,
      "content": "As units geralmente incluem, mas não estão limitadas a, serviços (.service), pontos de montagem (.mount), dispositivos (.device) ou soquetes (.socket).\n\nAo utilizar systemctl, geralmente é necessário especificar o nome completo do arquivo unit, incluindo seu sufixo, por exemplo sshd.socket}. No entanto, existem algumas formas curtas de especificar a unit nos seguintes comandos systemctl:\n\n- Se você não especificar o sufixo, systemctl presumirá .service. Por exemplo, netctl e netctl.service são equivalentes.\n- Os pontos de montagem serão automaticamente convertidos para a unit .mount adequada. Por exemplo, especificar /home equivale a home.mount.\n- Similar aos pontos de montagem, dispositivos são automaticamente convertidos para a unit .device adequada, portanto, especificar /dev/sda2 equivale a dev-sda2.device.\n\nVeja systemd.unit(5) para detalhes.\n\nOs comandos da tabela abaixo operam sobre units do sistema, pois --system é o padrão implícito para systemctl. Em vez disso, para operar em units de usuário (para o usuário chamador), use systemctl --user sem privilégios de root. Veja também systemd/User#Basic setup para habilitar/desabilitar units de usuário para todos os usuários.\n\n- A maioria dos comandos também funcionam se várias units forem especificadas, veja systemctl(1) para obter mais informações.\n- A opção --now pode ser usada em conjunto com enable, disable e mask para iniciar, parar ou mascarar, respectivamente, imediatamente a unit em vez de após reinicializar.\n- Um pacote pode oferecer units para diferentes finalidades. Se você acabou de instalar um pacote, pacman -Qql pacote | grep -Fe .service -e .socket pode ser usado para verificar e localizá-las.\n\nTable content:\nAção | Comando | Nota\nAnalisando o status do sistema\nMostrar status do sistema | systemctl status | \nLista units em execução | systemctl orsystemctl list-units | \nLista units com falhas | systemctl --failed | \nListar arquivos de unit1 instalados | systemctl list-unit-files | \nMostra status do processo para um PID | systemctl status pid | parte dos grupos de controle (\"cgroups\"), memória e pais\nVerificando o status unit\nMostra uma página do manual associada a uma unit | systemctl help unit | como suportado pela unit\nStatus de uma unit | systemctl status unit | incluindo se está em execução ou não\nCheca se uma unit está habilitada | systemctl is-enabled unit | \nIniciando, reiniciando e recarregando um unit\nIniciar imediatamente uma unit | systemctl start unit como root | \nParar imediatamente uma unit | systemctl stop unit como root | \nReiniciar uma unit | systemctl restart unit como root | \nRecarregar uma unit e sua configuração | systemctl reload unit como root | \nRecarregar a configuração2 do gerenciador do systemd | systemctl daemon-reload como root | procura por units novas ou alteradas\nHabilitando um unit\nHabilitar uma unit para iniciá-la automaticamente no boot | systemctl enable unit como root | \nHabilitar uma unit para iniciá-la automaticamente no boot e iniciá-la imediatamente | systemctl enable --now unit como root | \nDesabilitar uma unit para não iniciar mais no boot | systemctl disable unit como root | \nReabilitar uma unit3 | systemctl reenable unit como root | ou seja, desabilita e habilita novamente\nMascarando um unit\nMascarar uma unit para tonar impossível o seu início4 | systemctl mask unit como root | \nDesmascarar uma unit | systemctl unmask} unit como root | \n\n1. Veja systemd.unit(5) § UNIT FILE LOAD PATH para os diretórios onde os arquivos das units disponíveis podem ser encontrados.\n1. Isso não solicita às units alteradas que recarreguem suas próprias configurações (veja Recarregar).\n1. Por exemplo, no caso de sua seção [Install] tenha mudado desde a última vez que foi habilitada.\n1. Tanto manualmente quanto como dependência, o que torna o mascaramento perigoso. Verifique a existência de units mascarados com: $ systemctl list-unit-files --state=masked\n\n```\n$ systemctl list-unit-files --state=masked\n```\n\n"
    },
    {
      "title": "Gerenciamento de energia",
      "level": 3,
      "content": "polkit é necessário para o gerenciamento de energia como um usuário sem privilégios. Se você está em uma sessão de usuário local systemd-logind e nenhuma outra sessão está ativa, os seguintes comandos funcionarão sem privilégios de root. Se não (por exemplo, porque outro usuário está conectado em um tty), systemd vai automaticamente pedir a senha de root.\n\nTable content:\nAção | Comando\nDesliga e reinicia o sistema | systemctl reboot\nDesliga e encerra o sistema | systemctl poweroff\nSuspende o sistema | systemctl suspend\nColoca o sistema em hibernação (escreve RAM para o disco) | systemctl hibernate\nColoca o sistema em um estado de suspensão híbrida (também chamado de \"suspender para ambos\", salva RAM para o disco e então suspende) | systemctl hybrid-sleep\nPrimeiro suspende o sistema, o acorda após um tempo determinado somente para hibernar o sistema | systemctl suspend-then-hibernate\nReinicia apenas o espaço de usuário com #Reinício suave | systemctl soft-reboot\n\nsystemctl hybrid-sleep\n\nsystemctl suspend-then-hibernate\n\nsystemctl soft-reboot\n\n"
    },
    {
      "title": "Reinício suave",
      "level": 4,
      "content": "O reinício suave é uma forma especial de reiniciar somente o espaço de usuário, do qual não envolve o kernel. A função é implementada pelo systemd-soft-reboot.service(8) e pode ser invocada através de systemctl soft-reboot. Assim como kexec, ele pula a reinicialização do firmware, com a diferença adicional do sistema não passar pela reinicialização do kernel e pelo initramfs. Além disso, dispositivos criptografados que estejam destravados permanecem conectados.\n\nQuando /run/nextroot/ possui uma hierarquia de sistema de arquivos root válida (por exemplo se o root está montado em outra distribuição ou outro snapshot), soft-reboot pode trocar o sistema root para dentro de outros dispositivos, permitindo então a troca em outras instalações sem perder estados gerenciados pelo kernel, por exemplo a rede de internet.\n\n"
    },
    {
      "title": "Escrevendo arquivos unit",
      "level": 2,
      "content": "A sintaxe de arquivos unit do systemd (systemd.unit(5)) é inspirada nos arquivos .desktop da XDG Desktop Entry Specification , que por sua vez são inspirados nos arquivos .ini do Microsoft Windows. Os arquivos unit são carregados de vários localizações (para ver a lista completa, execute systemctl show --property=UnitPath), mas os principais são (listados da menor para a mais alta precedência):\n\n- /usr/lib/systemd/system/: units fornecidas por pacotes instalados\n- /etc/systemd/system/: units instaladas pelo administrador do sistema\n\n- Os caminhos de carregamento são completamente diferentes quando se está executando systemd em modo usuário.\n- Nomes de unit do systemd só podem conter caracteres alfanuméricos, sublinhados e pontos. Todos outros caracteres devem ser substituídos por escapes no estilo C \"\\x2d\" ou deve-se empregar suas semânticas predefinidas ('@', '-'). Veja systemd.unit(5) e systemd-escape(1) para mais informações.\n\nVeja as units instaladas por seus pacotes para exemplos, bem como em systemd.service(5) § EXAMPLES.\n\nsystemd-analyze(1) pode ajudar a verificar o trabalho. Veja a página do manual e busque a seção systemd-analyze verify FILE....\n\n"
    },
    {
      "title": "Manuseando dependências",
      "level": 3,
      "content": "Com o systemd, dependências podem ser resolvidas através da concepção de arquivos unit corretamente. O caso mais típico é quando a unit A requer a unit B para ser executada antes da A ser iniciada. Nesse caso, adicione Requires=B e After=B para a seção [Unit] de A. Se a dependência for opcional, então adicione Wants=B e After=B. Nota que Wants= e Requires= não implicam After=, significando que se After= não for especificado, as duas units serão iniciada em paralelo.\n\nDependências são normalmente colocadas em serviços e não em #Targets. Por exemplo, o network.target é obtido por qualquer serviço que configure suas interfaces de rede, portanto, ordenando a sua unit personalizada depois disso é o bastante desde que network.target é iniciado de qualquer maneira.\n\n"
    },
    {
      "title": "Tipos de serviços",
      "level": 3,
      "content": "Há vários tipos de execução diferentes a considerar quando se escreve um arquivo de serviço personalizado. Isso é definido com o parâmetro Type= na seção [Service]:\n\n- Type=simple (padrão): systemd considera que o serviço seja iniciado imediatamente. O processo não deve fazer fork. Não use este tipo se outros serviços precisarem ser ordenados neste serviço, a menos que seja socket ativado.\n- Type=forking: systemd considera que o serviço iniciou uma vez que o processo fez fork e o pai encerrou. Para daemons clássicos, use este tipo a menos que você saiba que ele não é necessário. Você deve especificar PIDFile= também, de forma que o systemd possa acompanhar o processo principal.\n- Type=oneshot: este é útil para os scripts que fazem um trabalho único e, em seguida, saem. Você pode querer definir RemainAfterExit=yes também para que systemd ainda considere o serviço como ativo depois que o processo foi encerrado. Definindo RemainAfterExit=yes é apropriado para as units que mudam o estado do sistema (por exemplo, montar alguma partição). Veja também [1] para conhecer as diferenças entre simple e oneshot.\n- Type=notify: idêntico ao Type=simple, mas com a condição de que o servidor enviará um sinal para systemd quando estiver pronto. A implementação de referência para essa notificação é fornecida por libsystemd-daemon.so.\n- Type=dbus: o serviço é considerado pronto quando o BusName especificado aparece no barramento do sistema do DBus.\n- Type=idle: systemdvai atrasar a execução do binário do serviço até todos os trabalhos serem despachados. Além desse comportamento, é muito similar a Type=simple.\n\nVeja a página man systemd.service(5) § OPTIONS para uma explicação mais detalhada dos valores de Type.\n\n"
    },
    {
      "title": "Editando units fornecidas",
      "level": 3,
      "content": "Para evitar conflitos com o pacman, arquivos unit fornecidos por pacotes não devem ser editados diretamente. Há duas formas seguras de modificar um unit sem tocar no arquivo original: crie um novo arquivo unit que se sobreponha ao unit original ou crie trechos drop-in que são aplicados sobre o unit original. Para ambos métodos, você deve recarregar o unit em seguida para aplicar suas alterações. Isso pode ser feito editando o unit com systemctl edit (que recarrega o unit automaticamente) ou recarregando todos os units com:\n\n```\n# systemctl daemon-reload\n```\n\n- Você pode usar systemd-delta para ver quais arquivos units foram sobrepostos ou estendidos e o que exatamente foi alterado.\n- Use systemctl cat unit para ver o conteúdo de um arquivo unit e todos os trechos drop-in associados.\n\n"
    },
    {
      "title": "Arquivos unit de substituição",
      "level": 4,
      "content": "Para substituir o arquivo unit /usr/lib/systemd/system/unit, crie o arquivo /etc/systemd/system/unit e reabilite o unit para atualizar os links simbólicos.\n\nAlternativamente, execute:\n\n```\n# systemctl edit --full unit\n```\n\nIsso abre /etc/systemd/system/unit em seu editor (copiando a versão instalada se ela não existir ainda) e automaticamente a recarrega quando você finaliza a edição.\n\n"
    },
    {
      "title": "Arquivos drop-in",
      "level": 4,
      "content": "Para criar arquivos drop-in para o arquivo de unidade /usr/lib/systemd/system/unit, crie o diretório /etc/systemd/system/unit.d/ e coloque arquivos .conf para substituir ou adicionar novas opções. systemd analisará e aplicará esses arquivos sobre a unit original.\n\nA forma mais fácil de fazer isso é executar:\n\n```\n# systemctl edit unit --drop-in=nome_drop_in\n```\n\nIsso abre o arquivo /etc/systemd/system/unit.d/nome_drop_in.conf em seu editor de texto (criando-o, se necessário) e recarrega automaticamente a unit quando você finalizar a edição. Omitir a opção --drop-in= resultará na escolha do uso de nome de arquivo padrão override.conf pelo systemd.\n\n- A chave ainda deve ser colocada na seção apropriada no arquivo de substituição.\n- Nem todas as chaves podem ser substituídas por arquivos drop-in. Por exemplo, para alterar Conflicts= um arquivo de substituição é necessário.\n\n"
    },
    {
      "title": "Reverter para versão do vendor",
      "level": 4,
      "content": "Para reverter quaisquer alterações a uma unit feita usando systemctl edit faça:\n\n```\n# systemctl revert unit\n```\n\n"
    },
    {
      "title": "Exemplos",
      "level": 4,
      "content": "Por exemplo, se você só quiser adicionar uma dependência adicional a uma unit, basta criar o seguinte arquivo:\n\n```\n/etc/systemd/system/unit.d/dependenciapesonalizada.conf\n```\n\n```\n[Unit]\nRequires=nova dependência\nAfter=nova dependência\n```\n\nComo outro exemplo, para substituir a diretiva ExecStart, crie o seguinte arquivo:\n\n```\n/etc/systemd/system/unit.d/execpersonalizado\n```\n\n```\n[Service]\nExecStart=\nExecStart=novo comando\n```\n\nNote como ExecStart deve ser limpado antes de reatribuir [2]. O mesmo ocorre para todo item que pode ser especificado várias vezes, como OnCalendar para timers.\n\nMais um exemplo para reiniciar automaticamente um serviço:\n\n```\n/etc/systemd/system/unit.d/reiniciar.conf\n```\n\n```\n[Service]\nRestart=always\nRestartSec=30\n```\n\n"
    },
    {
      "title": "Targets",
      "level": 2,
      "content": "O systemd usa targets para agrupar units por meio de dependências e como pontos de sincronização padronizada. Eles servem a um propósito semelhante, como níveis de execução, mas agem um pouco diferente. Cada target é nomeado em vez de numerado e destina-se a servir uma finalidade específica com a possibilidade de ter múltiplos ativos ao mesmo tempo. Alguns targets são implementados herdando todos os serviços de outro target e adicionando serviços adicionais a ele. Há targets do systemd que imitam os níveis de execução comuns do SystemVinit.\n\n"
    },
    {
      "title": "Obter targets atuais",
      "level": 3,
      "content": "O comando deve ser no systemd em vez de executar runlevel:\n\n```\n$ systemctl list-units --type=target\n```\n\n"
    },
    {
      "title": "Criar target personalizado",
      "level": 3,
      "content": "Os níveis de execução que tinham um significado definido no sysvinit (ex.: 0, 1, 3, 5 e 6) têm um mapeamento 1:1 com um target de systemd específico. Infelizmente, não há nenhuma boa forma de fazer o mesmo com os níveis de execução definidos pelo usuário, como 2 e 4. Se você fizer uso deles é sugerido que você faça um target de systemd com um novo nome como /etc/systemd/system/seu target que leva um dos níveis de execução existentes como base (você pode examinar /usr/lib/systemd/system/graphical.target como um exemplo), crie um diretório /etc/systemd/system/seu target.wants, e então faça um link simbólico dos serviços adicionais de /usr/lib/systemd/system/ que você deseja ativar.\n\n"
    },
    {
      "title": "Mapeamento entre níveis do SysV e targets do systemd",
      "level": 3,
      "content": "Table content:\nNível de execução do SysV | Target do systemd | Notas\n0 | poweroff.target | Interrrompe o sistema.\n1, s, único | rescue.target | Modo de usuário único.\n2, 4 | multi-user.target | Níveis de execução User-defined/Site-specific. Por padrão, idêntico ao 3.\n3 | multi-user.target | Multi-usuário, não-gráfico. Os usuários geralmente podem acessar através de múltiplos consoles ou via rede.\n5 | graphical.target | Multi-usuário, gráfico. Normalmente tem todos os serviços do nível de execução 3, mais um login gráfico.\n6 | reboot.target | Reiniciar\nemergência | emergency.target | Shell de emergência\n\n"
    },
    {
      "title": "Alterar target atual",
      "level": 3,
      "content": "No systemd, targets são expostos via units de targets. Você pode alterá-los assim:\n\n```\n# systemctl isolate graphical.target\n```\n\nIsso só vai mudar o target atual, e não tem nenhum efeito na próxima inicialização. É equivalente aos comandos como telinit 3 ou telinit 5 no Sysvinit.\n\n"
    },
    {
      "title": "Alterar target padrão para inicializar",
      "level": 3,
      "content": "O target padrão é default.target, que é um link simbólico para graphical.target. Basicamente, ele corresponde ao antigo nível de execução 5.\n\nPara verificar o target atual com systemctl:\n\n```\n$ systemctl get-default\n```\n\nPara alterar o target padrão a ser inicializado, altere o link simbólico default.target. Com systemctl:\n\n```\n# systemctl set-default multi-user.target\n```\n\n```\nRemoved /etc/systemd/system/default.target.\nCreated symlink /etc/systemd/system/default.target -> /usr/lib/systemd/system/multi-user.target.\n```\n\nAlternativamente, acrescente um dos seguintes parâmetros do kernel a seu gerenciador de boot:\n\n- systemd.unit=multi-user.target (que basicamente corresponde ao antigo nível de execução 3),\n- systemd.unit=rescue.target (que basicamente corresponde ao antigo nível de execução 1).\n\n"
    },
    {
      "title": "Ordem de target padrão",
      "level": 3,
      "content": "O systemd escolhe o default.target conforme a ordem a seguir:\n\n1. Parâmetro de kernel mostrado acima\n1. Link simbólico de /etc/systemd/system/default.target\n1. Link simbólico de /usr/lib/systemd/system/default.target\n\n"
    },
    {
      "title": "Componentes do systemd",
      "level": 2,
      "content": "Alguns componentes (sendo uma lista não exaustiva, ou seja, um resumo do todo) do systemd são:\n\n- kernel-install — Para automaticamente mover kernels e as respectivos imagens initramfs para a partição de boot;\n- systemd-analyze(1) Pode ser usado para determinar o desempenho da inicialização, formar estatísticas, recuperar outro estado de boot, realizar buscas de informações e verificar a exatidão de arquivos unit. É também usado para acessar funções especiais, sendo útil para depurações avançadas;\n- systemd-boot — simples gerenciador de boot UEFI;\n- systemd-creds — Para armazenar com segurança e recuperar credenciais usadas por units do systemd;\n- systemd-cryptenroll — Inscreve PKCS#11, FIDO2, token/dispositivos TPM2 para volumes criptografados com LUKS2;\n- systemd-firstboot — inicialização da configuração básica do sistema antes da primeira inicialização;\n- systemd-homed — contas portáteis de usuário humano;\n- systemd-logind — gerenciamento de sessão;\n- systemd-networkd — gerenciamento de configuração de rede;\n- systemd-nspawn — contêiner de namespace leve;\n- systemd-resolved — resolução de nome de rede;\n- systemd-run(1) / run0(1) — Temporariamente e interativamente adquire privilégios elevados ou diferenciados;\n- systemd-stub(7) — um stub de boot UEFI usado para criar imagens de kernel unificadas.\n- systemd-sysusers(8) — cria usuários e grupos do sistema e adiciona usuários a grupos na instalação do pacote ou na inicialização;\n- systemd-timesyncd — sincronização da hora do sistema na rede;\n- systemd/Journal — registro do sistema;\n- systemd/Timers — cronômetros monotônicos ou em tempo real para controlar arquivos ou eventos .service, alternativa razoável ao cron.\n\n"
    },
    {
      "title": "systemd.mount - montagem",
      "level": 3,
      "content": "O systemd é responsável pela montagem das partições e sistemas de arquivos especificados em /etc/fstab. O systemd-fstab-generator(8) converte todas as entradas em /etc/fstab em unidades do systemd, isso é executado no momento da inicialização e sempre que a configuração do gerenciador de sistema é recarregada.\n\nO systemd estende as capacidades usuais do fstab e oferece opções adicionais de montagem. Eles afetam as dependências da unidade de montagem, eles podem, por exemplo, garantir que uma montagem seja realizada apenas quando a rede estiver ativa ou apenas quando outra partição for montada. A lista completa de opções de montagem específicas do systemd, normalmente prefixadas com x-systemd., é detalhada em systemd.mount(5) § FSTAB.\n\nUm exemplo dessas opções de montagem no contexto de montagem automática, que significa montagem apenas quando o recurso é necessário, em vez de automaticamente no momento da inicialização, é fornecido em fstab (Português)#Automontagem com systemd.\n\n"
    },
    {
      "title": "Montagem automática de partição GPT",
      "level": 4,
      "content": "Em sistemas inicializados por UEFI, se condições específicas forem atendidas, systemd-gpt-auto-generator(8) montará automaticamente as partições GPT seguindo a Especificação de Partições Detectáveis. Elas podem, portanto, ser omitidas do fstab, e se a partição root é auto-montavél, então root= pode ser omitido da linha de comando do kernel.\n\nOs pré-requisitos são:\n\n- O gerenciador/carregador de boot deve definir a variável EFI LoaderDevicePartUUID para que a partição do sistema EFI usada possa ser identificada. Isso é suportado pelo systemd-boot, systemd-stub(7), GRUB (com o grub.cfg gerado por grub-mkconfig, se for um grub.cfg customizado o mesmo requer que seja carregado o módulo bli e do gerenciador de boot rEFInd (não habilitado por padrão). Isso pode ser verificado executando bootctl e checando o status de Boot loader sets ESP information ou o status de Stub sets ESP information ao inicializar via imagens de kernel unificadas.\n- A partição do root deve estar no mesmo disco físico que a partição do sistema EFI utilizado. Outras partições que serão montadas automaticamente devem estar no mesmo disco físico que a partição raiz. Isto significa basicamente que todas as partições montadas automaticamente devem compartilhar o mesmo disco físico com o ESP.\n- O ponto de montagem /efi deve ser criado manualmente (se desejado), caso contrário systemd-gpt-auto-generator usará /boot.\n\nPara a montagem automática do /var funcionar, a PARTUUID deve corresponder ao hash SHA256 HMAC do tipo de partição UUID (4d21b016-b534-45c2-a9fb-5c16e091fd2d) codificado pelo ID da máquina. O PARTUUID necessário pode ser obtido usando:\n\n```\n$ systemd-id128 -u --app-specific=4d21b016-b534-45c2-a9fb-5c16e091fd2d machine-id\n```\n\n"
    },
    {
      "title": "systemd-sysvcompat",
      "level": 3,
      "content": "A função principal do systemd-sysvcompat (requerido por base) é fornecer o binário tradicional do linux init. Para sistemas controlados pelo systemd, init é apenas um link simbólico para seu executável systemd.\n\nAlém disso, ele também fornece 4 atalhos de conveniência aos quais os usuários do SysVinit podem estar acostumados. Os atalhos de conveniência são halt(8), poweroff(8), reboot(8) e shutdown(8). Cada um desses 4 comandos é um link simbólico para systemctl, e governado pelo comportamento do systemd. Portanto, a discussão em #Gerenciamento de energia se aplica.\n\nOs sistemas baseados em Systemd podem desistir dos métodos de compatibilidade do System V usando o parâmetro de boot init= (consulte, por exemplo, [solved] /bin/init is in systemd-sysvcompat ?) e argumentos de comando do systemctl, nativo do systemd.\n\n"
    },
    {
      "title": "systemd-tmpfiles - arquivos temporários",
      "level": 3,
      "content": "O \"systemd-tmpfiles cria, apaga e limpa arquivos e diretórios temporários e voláteis.\" Ele lê os arquivos de configuração em /etc/tmpfiles.d/ e /usr/lib/tmpfiles.d/ para descobrir quais ações executar. Os arquivos de configuração do diretório anterior têm precedência sobre os do diretório anterior.\n\nOs arquivos de configuração geralmente são fornecidos junto com os arquivos de serviço e são nomeados no estilo de /usr/lib/tmpfiles.d/programa.conf. Por exemplo, o daemon Samba espera que o diretório /run/samba exista e tenha as permissões corretas. Portanto, o pacote samba vem com esta configuração:\n\n```\n/usr/lib/tmpfiles.d/samba.conf\n```\n\n```\nD /run/samba 0755 root root\n```\n\nOs arquivos de configuração também podem ser usados para gravar valores em certos arquivos na inicialização. Por exemplo, se você usou /etc/rc.local para desativar a ativação de dispositivos USB com echo USBE > /proc/acpi/wakeup, você pode usar o seguinte arquivo tmp:\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Caminho               Modo UID  GID  Age Argumento\nw    /proc/acpi/wakeup     -    -    -    -   USBE\n```\n\nÉ possível escrever múltiplas linhas no mesmo arquivo, com \\n no argumento ou usando o tipo w+ em múltiplas linhas (incluindo a primeira) para acrescentar.\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Path                  Mode UID  GID  Age Argument\n\t\nw+   /proc/acpi/wakeup     -    -    -    -   USBE\n\t\nw+   /proc/acpi/wakeup     -    -    -    -   LID0\n```\n\nVeja as páginas do manual systemd-tmpfiles(8) e tmpfiles.d(5) para detalhes.\n\n"
    },
    {
      "title": "Arquivos de configuração drop-in",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nArquivos de configuração fornecidos por pacotes não devem ser diretamente editados para evitar conflitos com atualizações do pacman. Por conta disso, vários pacotes do systemd (mas não todos) dão uma forma de modificar a configuração sem tocar no arquivo original: pela criação de arquivos drop-in que fazem uma espécie de \"recorte\" (snippet) dessas definições. Verifique no manual do pacote se a configuração de arquivos drop-in é suportada.\n\nPara criar um arquivo de configuração drop-in para o arquivo da unit etc/systemd/unit.conf, crie o diretório /etc/systemd/unit.conf.d e coloque arquivos .conf neste local para sobescrever ou adicionar novas opções. systemd irá validar e aplicar as definições desses arquivos e priorizá-los em relação à unit original.\n\nVerifique a configuração geral:\n\n```\n$ systemd-analyze cat-config systemd/unit.conf\n```\n\nO(s) arquivo(s) fragmentados (drop-in snippets) aplicados e o conteúdo dos mesmos serão listados no final. Reinicie o serviço para que as mudanças tenham efeito.\n\n"
    },
    {
      "title": "Ativação de sockets",
      "level": 3,
      "content": "Alguns pacotes fornecem uma unit .socket. Por exemplo, cups fornece a unit cups.socket [3]. Se cups.socket está habilitado (e cups.service permanece inativo), systemd não inicializará CUPS de forma imediata; apenas ficará escutando os sockets apropriados, e então, seja lá quando um programa tentar se conectar a um desses sockets do CUPS, o systemd irá iniciar cups.service e transferir, de forma vísivel e transparente, o controle dessas portas para o processo do CUPS.\n\n"
    },
    {
      "title": "Ferramentas de configuração GUI",
      "level": 3,
      "content": "- systemadm — Navegador gráfico para as units do systemd. Ele pode mostrar a lista de units, possivelmente filtradas por tipo.\n\n- SystemdGenie — Utilitário de gerenciamento systemd baseado em tecnologias KDE.\n\n"
    },
    {
      "title": "Executando serviços após a rede estar ativa",
      "level": 3,
      "content": "Para atrasar um serviço até depois que a rede está ativa, inclua as seguintes dependências no arquivo .service:\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target\n...\n```\n\nO serviço de espera de rede do gerenciador de rede em uso também deve ser ativado para que network-online.target reflita adequadamente o status da rede.\n\n- Se estiver usando o NetworkManager, o NetworkManager-wait-online.service deve ser habilitado junto com o NetworkManager.service. Verifque se neste caso com systemctl is-enabled NetworkManager-wait-online.service. Se ele não estiver habilitado, então reabilite NetworkManager.service.\n- No caso do netctl, habilite o netctl-wait-online.service (a menos que esteja usando netctl-auto; veja FS#75836).\n- Se estiver usando systemd-networkd, o systemd-networkd-wait-online.service deve ser habilitado junto com o systemd-networkd.service. Verifique se este é o caso com systemctl is-enabled systemd-networkd-wait-online.service. Se ele não estiver habilitado, então reabilite systemd-networkd.service.\n\nPara explicações mais detalhadas, veja Network configuration synchronization points.\n\nSe um serviço precisar realizar consultas DNS, ele também deve ser solicitado após nss-lookup.target:\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target nss-lookup.target\n...\n```\n\nVeja systemd.special(7) § Special Passive System Units.\n\nPara que nss-lookup.target tenha algum efeito, ele precisa de um serviço que o extraia via Wants=nss-lookup.target e se ordena antes dele com Before=nss-lookup.target. Normalmente, isso é feito por Resolvedores de DNS locais.\n\nVerifique qual serviço ativo, se houver, está puxando nss-lookup.target com:\n\n```\n$ systemctl list-dependencies --reverse nss-lookup.target\n```\n\n"
    },
    {
      "title": "Habilitar units instaladas por padrão",
      "level": 3,
      "content": "O Arch Linux vem com /usr/lib/systemd/system-preset/99-default.preset contendo disable *. Isso faz com que o systemctl preset desabilite todas as unidades por padrão, de forma que quando um novo pacote é instalado, o usuário deve habilitar manualmente a unit.\n\nSe este comportamento não for desejado, basta criar um link simbólico de /etc/systemd/system-preset/99-default.preset para /dev/null para sobrescrever o arquivo de configuração. Isso fará com que o systemctl preset habilite todas as units que forem instaladas – independentemente do tipo de unit – a menos que especificado em outro arquivo em um dos diretórios de configuração do systemctl preset. Units de usuário não são afetadas. Veja systemd.preset(5) para mais informações.\n\n"
    },
    {
      "title": "Usando ambientes de aplicativos em sandbox",
      "level": 3,
      "content": "Um arquivo de unit pode ser criado como uma sandbox para isolar aplicativos e seus processos em um ambiente virtual reforçado. O systemd alavanca espaços de nomes, lista de permitidos/negados de capacidades e grupos de controle (\"cgroups\") para processos contêineres através de uma extensa configuração do ambiente de execução—systemd.exec(5).\n\nO aprimoramento de um arquivo existente de unit do systemd com um aplicativo de sandboxing normalmente requer testes de tentativa e erro acompanhados pelo uso generoso de strace, stderr e facilidades de saída e registro de erro do journalctl(1). Você pode querer pesquisar primeiro a documentação original para testes já feitos para basear os testes. Para obter um ponto de partida para as possível opções de segurança, execute\n\n```\n$ systemd-analyze security unit\n```\n\nAlguns exemplos de como o sandboxing com systemd pode ser implementado:\n\n- CapabilityBoundingSet define uma lista de capacidades (capabilities(7)) que são permitidas ou negadas para uma unit. Veja systemd.exec(5) § CAPABILITIES. A capacidade CAP_SYS_ADM, por exemplo, que deve ser um dos objetivos de um sandbox seguro: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n- A capacidade CAP_SYS_ADM, por exemplo, que deve ser um dos objetivos de um sandbox seguro: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n"
    },
    {
      "title": "Notificação sobre serviços com falha",
      "level": 3,
      "content": "Para notificar sobre falhas de serviço, uma diretiva OnFailure= precisa ser adicionada ao arquivo de serviço correspondente, por exemplo, usando um arquivo de configuração drop-in. A adição desta diretiva a cada unit de serviço pode ser obtido com um arquivo de configuração drop-in de nível superior. Para obter detalhes sobre drop-ins de nível superior, consulte systemd.unit(5).\n\nCria um drop-in de nível superior para serviços:\n\n```\n/etc/systemd/system/service.d/toplevel-override.conf\n```\n\n```\n[Unit]\nOnFailure=failure-notification@%n\n```\n\nIsso adiciona OnFailure=failure-notification@%n a cada arquivo de serviço. Se some_service_unit falhar, o failure-notification@some_service_unit será iniciado para lidar com a entrega da notificação (ou qualquer tarefa para a qual ela esteja configurada).\n\nCria o modelo unit failure-notification@:\n\n```\n/etc/systemd/system/failure-notification@.service\n```\n\n```\n[Unit]\nDescription=Send a notification about a failed systemd unit\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=/caminho/para/failure-notification.sh %i\n```\n\nVocê pode criar o script failure-notification.sh e definir o que fazer ou como notificar (mail, gotify, xmpp, etc.). O %i será o nome da unit de serviço com falha e será passado como um argumento para o script.\n\nPara evitar uma regressão para instâncias de failure-notification@.service, crie um arquivo de configuração drop-in vazio com o mesmo nome do drop-in de nível superior (o arquivo de configuração vazio drop-in de nível de serviço tem precedência sobre o drop-in de nível superior e substitui o último):\n\n```\n# mkdir -p /etc/systemd/system/failure-notification@.service.d\n# touch /etc/systemd/system/failure-notification@.service.d/toplevel-override.conf\n```\n\n"
    },
    {
      "title": "Desliga automaticamente um HDD externo ao desligar",
      "level": 3,
      "content": "Se um HDD externo não for desligado corretamente no desligamento do sistema, pode ser desejável corrigir o problema. A maneira mais conveniente de fazer isso é usando udisks.\n\nHabilite udisks2.service.\n\nUm serviço para invocar nosso script pode ser assim:\n\n```\n/etc/systemd/system/handle_external_hdds.service\n```\n\n```\n[Unit]\nRequires=udisks2.service\nRequires=graphical.target\nAfter=graphical.target\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStop=/usr/local/bin/handle_external_hdds.sh\n\n[Install]\nWantedBy=graphical.target\n```\n\nHabilite handle_external_hdds.service\n\nFaça um systemd daemon-reload para aplicar a nova configuração.\n\nReinicie o sistema ou reinice o graphical.target para verificar se funciona.\n\nUm script de exemplo para lidar com uma quantidade arbitrária de partições em um único disco se parece com isso:\n\n```\n/usr/local/bin/handle_external_hdds.sh\n```\n\n```\n#!/bin/bash -u\n\ndeclare -a uuids=(uuid_list)\n\t\n# Only proceed if the drive is present.\nif [[ ! -L \"/dev/disk/by-uuid/${uuids[0]}\" ]]; then\n  exit 0\nfi\n\t\nfor uuid in \"${uuids[@]}\"; do\n  if findmnt \"/dev/disk/by-uuid/$uuid\"; then\n    umount \"/dev/disk/by-uuid/$uuid\"\n  fi\ndone\n\t\n# udisksctl powers off proper drive even if its partition is supplied\nudisksctl power-off -b \"/dev/disk/by-uuid/${uuids[0]}\"\n```\n\nuuid_list é uma lista de UUIDs delimitadas por espaço correspondente às partições do dispositivo a ser verificado, por exemplo, \"uuid_1\" \"uuid_2\".\n\n"
    },
    {
      "title": "Investigar serviços que falharam",
      "level": 3,
      "content": "Para encontrar os serviços systemd que falharam em iniciar:\n\n```\n$ systemctl --state=failed\n```\n\nPara encontrar o porquê de eles terem falhado, examine a saída do log. Consulte systemd/Journal#Filtrando saída para detalhes.\n\n"
    },
    {
      "title": "Diagnosticar problemas de inicialização",
      "level": 3,
      "content": "O systemd tem várias opções para diagnosticar problemas com o processo de inicialização. Veja Depuração de inicialização para instruções mais gerais e opções para capturar mensagens de inicialização antes que o systemd assuma o processo de inicialização. Veja também a documentação de depuração do systemd.\n\n"
    },
    {
      "title": "Diagnosticar um serviço",
      "level": 3,
      "content": "Se algum serviço do systemd se comportar mal ou você quiser obter mais informações sobre o que está acontecendo, defina a variável de ambiente SYSTEMD_LOG_LEVEL com debug. Por exemplo, para executar o daemon systemd-networkd no modo de depuração:\n\nAdicione um arquivo drop-in para o serviço adicionando as duas linhas:\n\n```\n[Service]\nEnvironment=SYSTEMD_LOG_LEVEL=debug\n```\n\nOu, de forma equivalente, defina a variável de ambiente manualmente:\n\n```\n# SYSTEMD_LOG_LEVEL=debug /lib/systemd/systemd-networkd\n```\n\nentão, reinicie systemd-networkd e monitore o journal para o serviço com a opção -f/--follow.\n\n"
    },
    {
      "title": "Desligamento/reinicialização demora demais",
      "level": 3,
      "content": "Se o processo de desligamento demorar muito (ou parecer estar congelado), provavelmente um serviço que não foi encerrado é o responsável. O systemd espera um tempo para cada serviço encerrar antes de tentar matá-lo. Para descobrir se você foi afetado, veja a seção Shutdown completes eventually na documentação do systemd.\n\nUm problema comum é um desligamento interrompido ou um processo de suspensão. Para verificar qual é o seu caso, você pode executar qualquer um desses comandos e verificar as saídas\n\n```\n# systemctl poweroff\n```\n\n```\nFailed to power off system via logind: There's already a shutdown or sleep operation in progress\n```\n\n```\n# systemctl list-jobs\n```\n\n```\nJOB UNIT                    TYPE  STATE  \n...\n21593 systemd-suspend.service start running\n21592 suspend.target          start waiting\n...\n```\n\nA solução para isso seria cancelar os trabalhos em execução\n\n```\n# systemctl cancel\n# systemctl stop systemd-suspend.service\n```\n\ne, em seguida, tentar desligar ou reiniciar novamente.\n\n"
    },
    {
      "title": "Processos de curta duração não parecem registrar qualquer saída",
      "level": 3,
      "content": "Se journalctl -u foounit não mostra nenhuma saída para um serviço de curta duração, veja o PID em vez disso. Por exemplo, se systemd-modules-load.service falha, e systemctl status systemd-modules-load mostra que executou com PID 123, então você talvez possa ver uma saída no journal por esse PID, ou seja, executando journalctl -b _PID=123 como root. Campos de metadados para o journal como _SYSTEMD_UNIT e _COMM são coletados de forma assíncrona e invocam o diretório /proc para o processo existente. A solução deste problema requer fixar o kernel para fornecer esses dados através de uma conexão de socket, semelhante ao SCM_CREDENTIALS. Em resumo, é um erro. Tenha em mente que os serviços imediatamente falhos podem não imprimir nada para o journal conforme o design do systemd.\n\n"
    },
    {
      "title": "Tempo de inicialização aumentando com o tempo",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nDepois de usar o systemd-analyze, vários usuários notaram que o tempo de inicialização aumentou significativamente em comparação com o que costumava ser. Depois de usar systemd-analyse blame, o NetworkManager está sendo relatado como tendo uma quantidade anormalmente grande de tempo para iniciar.\n\nO problema para alguns usuários foi devido a /var/log/journal se tornar muito grande. Isso pode ter outros impactos no desempenho, como systemctl status ou journalctl. Como tal, a solução é remover todos os arquivos dentro da pasta (idealmente fazendo um backup em algum lugar, pelo menos temporariamente) e, em seguida, definindo um limite de tamanho de arquivo de diário conforme descrito em systemd/Journal (Português)#Limite no tamanho do journal.\n\n"
    },
    {
      "title": "systemd-tmpfiles-setup.service não inicia na inicialização do sistema",
      "level": 3,
      "content": "A partir do systemd 219, /usr/lib/tmpfiles.d/systemd.conf especifica os atributos da ACL para os diretórios sob /var/log/journal e, portanto, requer que o suporte da ACL seja ativada para o sistema de arquivos em que o journal reside.\n\nVeja Listas de Controle de Acesso#Habilitar ACL para instruções sobre como habilitar ACL no sistema de arquivos que hospeda /var/log/journal.\n\n"
    },
    {
      "title": "Desabilitar modo de emergência em máquina remota",
      "level": 3,
      "content": "Você pode querer desabilitar o modo de emergência em uma máquina remota, por exemplo, uma máquina virtual hospedada no Azure ou no Google Cloud. É porque se o modo de emergência for acionado, a máquina será bloqueada da conexão à rede.\n\nPara desativá-lo, mascare emergency.service e emergency.target.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- Wikipedia:pt:systemd\n- Site oficial do systemd Otimizações do systemd FAQ do systemd Dicas e truques do systemd\n- systemd(1)\n- Outras distribuições: Gentoo:Systemd Fedora:Systemd Fedora:How to debug Systemd problems Fedora:SysVinit to Systemd Cheatsheet Debian:systemd\n- História do blogue do Lennart, atualização 1, atualização 2, atualização 3, resumo\n- Depurar Serviços Systemd\n- systemd para administradores (PDF)\n- Como usar o systemctl para gerenciar serviços e units do systemd\n- Gerenciamento de sessão com systemd-logind\n- Realce de sintaxe do Emacs para arquivos do systemd\n- Artigo introdutório em duas partes na revista The H Open.\n\n- Otimizações do systemd\n- FAQ do systemd\n- Dicas e truques do systemd\n\n- Gentoo:Systemd\n- Fedora:Systemd\n- Fedora:How to debug Systemd problems\n- Fedora:SysVinit to Systemd Cheatsheet\n- Debian:systemd\n\n"
    }
  ]
}