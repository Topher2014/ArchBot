{
  "title": "UTF-8",
  "url": "https://wiki.archlinux.org/title/UTF-8",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Locale\n- Input method\n\nCharacter encoding is the process of interpreting bytes to readable characters. UTF-8 is the dominant encoding since 2009 and is promoted as a de-facto standard [1].\n\n"
    },
    {
      "title": "Terminal",
      "level": 3,
      "content": "Most terminals use UTF-8 by default. However, some (e.g: gnome-terminal, rxvt-unicode) need to be launched from a UTF-8 locale. To do that, set the codeset part of your locale to .UTF-8 and reload your session. See Locale#Setting the locale for instructions.\n\n- xterm - Run with the argument -u8 or configure resource xterm*utf8: 2.\n\n"
    },
    {
      "title": "Unicode character insertion",
      "level": 3,
      "content": "See List of applications/Utilities#Text input.\n\n- LibreOffice includes a built-in charmap in Insert > Special Character showing character block, hex, and decimal encodings.\n- Compose Key: XCompose can be set up to insert special characters.\n- AltGr can be set up to access additional keyboard levels providing extra characters as well as Unicode control characters such as ZWNJ and RTL mark.\n- Vim: using Ctrl+v uXXXX in insert mode, where XXXX is the hexadecimal code point.\n\n"
    },
    {
      "title": "URL encoding",
      "level": 2,
      "content": "URIs accept US-ASCII characters only and use percent-encoding to encode non-ASCII characters. This can result in very long and human-unreadable URIs.\n\nIn Firefox, it is possible to copy decoded URLs by enabling the browser.urlbar.decodeURLsOnCopy flag in about:config, or by inserting a space to the start of the URL, then selecting it (with the space) and copying it. However, this trick does not work on Chromium, and there is no equivalent flag. Alternatively, select starting at the end of the URL until right after the https:// part, then copy.\n\nFor command line usage, you can use python to translate encoded URLs from stdin.\n\n```\n$ python3 -c \"import sys; from urllib.parse import unquote; print(unquote(sys.stdin.read().strip()))\"\n```\n\n"
    },
    {
      "title": "Troubleshooting",
      "level": 2,
      "content": "Encoding problems are usually due to two programs communicating with different encodings, with one side typically not using UTF-8, resulting in mojibake.\n\n"
    },
    {
      "title": "Incorrect archive encoding",
      "level": 3,
      "content": "Zip archives sometimes use encodings other than Unicode for the filenames. This issue is most commonly seen with archives created in legacy versions of Windows (XP, Vista, and 7), where File Explorer will prioritize a character set that more closely matches the system locale even if it uses a non-Latin writing system.\n\nAs of version 6.0, the unzip executable is built with patches to enable character set conversion, however it won't do so automatically and will still default to the assumption that filenames are UTF8-encoded. To properly extract an archive with non-UTF8 filenames, use unzip -O followed by the target encoding, e.g. CP936 is a common Simplified Chinese charset in old versions of Windows:\n\n```\n$ unzip -O CP936 file.zip\n```\n\nOther common charsets include GBK, also for Simplified Chinese:\n\n```\n$ unzip -O gbk file.zip\n```\n\nAnd Shift-JIS, for Japanese:\n\n```\n$ unzip -O shift-jis file.zip\n```\n\nIf unsure about which charset you need, you can list an archive's files without extracting them by adding the -l flag, which allows you to verify that the filenames are printed correctly:\n\n```\n$ unzip -lO CP936 file.zip\n```\n\nAlternatively, you can install unzip-natspecAUR, which will auto-detect the correct encoding for filenames.\n\n"
    },
    {
      "title": "Incorrect file name encoding",
      "level": 3,
      "content": "Use convmv for encoding-conversion mv:\n\n```\n$ convmv -f SOURCE_ENCODING -t UTF-8 --nosmart file\n```\n\nBy default, convmv shows what would be done without actual moving. After figuring out the original encoding using -f (e.g: for Chinese GBK), add the --notest option to proceed with the move operation.\n\nBy default, convmv skips file name conversion if it is already UTF8-encoded. Use the --nosmart option to force the conversion.\n\nUse convmv --list to find the supported encodings.\n\n"
    },
    {
      "title": "Incorrect file encoding",
      "level": 3,
      "content": "Use the iconv command to convert the format. For example:\n\n```\n$ iconv -f SOURCE_ENCODING -t UTF-8 -o new-file origin-file\n```\n\n-f specifies the original encoding and -t specifies the output encoding. Use iconv -l to query all supported encodings and -o to specify the output file.\n\n"
    },
    {
      "title": "Vim",
      "level": 4,
      "content": "If the locale is UTF-8, opening other char-encoded files may be garbled. You can add a fallback adding to vimrc a line similar to:\n\n```\nset fileencodings=utf8,cp936,gb18030,big5\n```\n\nAlternatively, you can explicitly set it by :set fileencoding=ansi. Vim will do the conversion via iconv automatically. See :h charset-conversion.\n\n"
    },
    {
      "title": "Incorrect MP3 ID3 tag encoding",
      "level": 3,
      "content": "To modify the MP3 file tag, convert using python-mutagen or mp3unicode:\n\n```\n$ mid3iconv -e SOURCE_ENCODING file.mp3\n```\n\nIf file modification is undesired, you can tweak the behavior of media players. For players that use GStreamer as the backend, such as Rhythmbox and totem, set the environment variable:\n\n```\nGST_ID3_TAG_ENCODING=GBK:UTF-8:GB18030\n```\n\nQuod Libet player supports tag editing and setting ID3v2 encoding. Go to File > Plugins > Advanced Preferences (or File > Preferences > Advanced for quodlibet-gitAUR), click I know what I'm doing and enter a space-separated list of encodings in the ID3 encodings field. You can also edit the configuration file manually:\n\n```\n~/.config/quodlibet/config\n```\n\n```\n...\n[editing]\nid3encoding = gbk\n...\n```\n\n"
    },
    {
      "title": "Incorrect mount encoding",
      "level": 3,
      "content": "Generally, the mounted character set is different from the locales, which can be set by modifyinig fstab. If the locale is utf8, modify the line to:\n\n```\n/etc/fstab\n```\n\n```\n...\n/dev/sdxx /media/win ntfs defaults,iocharset=utf8 0 0\n```\n\nIf the locale is GBK, it should be:\n\n```\n/etc/fstab\n```\n\n```\n...\n/dev/sdxx /media/win ntfs defaults,iocharset=cp936 0 0\n...\n```\n\n"
    },
    {
      "title": "Incorrect Samba encoding",
      "level": 3,
      "content": "When using Arch as a Samba server, adding the following line to /etc/samba/smb.conf can solve the garbled problem of Windows clients:\n\n```\n/etc/samba/smb.conf\n```\n\n```\n...\nunix charset=gb2312\n...\n```\n\n"
    },
    {
      "title": "Incorrect FTP encoding",
      "level": 3,
      "content": "If you use UTF8 locale, the downloaded file name from a non-Unicode-encoded server might be garbled. For lftp, make the following settings under .lftp/rc:\n\n```\n.lftp/rc\n```\n\n```\n...\nset ftp:charset \"gbk\"\nset file:charset \"UTF-8\"\n...\n```\n\nFor gftp, you can do the following settings in .gftp/gftprc:\n\n```\n.gftp/gftprc\n```\n\n```\n...\nremote_charsets=gb2312\n...\n```\n\nHowever, the downloaded file name is still garbled and needs to be patched and compiled. The patch address is: https://www.teatime.com.tw/%7Etommy/linux/gftp_remote_charsets.patch\n\n"
    }
  ]
}