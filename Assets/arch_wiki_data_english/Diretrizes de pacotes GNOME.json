{
  "title": "Diretrizes de pacotes GNOME",
  "url": "https://wiki.archlinux.org/title/Diretrizes_de_pacotes_GNOME",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Fonte – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust – Shell – VCS – Web – Wine\n\nOs pacotes do GNOME no Arch Linux segue, um certo esquema.\n\n"
    },
    {
      "title": "URL fonte",
      "level": 2,
      "content": "Esse tópico contém as URLs fonte mais comumente usadas pelos pacotes GNOME nos repositórios oficiais e no AUR. Para exemplos, pesquise por pacotes GNOME nos repositórios oficiais[1] e no AUR[2]\n\n"
    },
    {
      "title": "Usando tarball de lançamento",
      "level": 3,
      "content": "Ao baixar um tarball de lançamento, você pode obtê-lo de https://download.gnome.org usando o seguinte vetor fonte:\n\n```\nsource=(\"https://download.gnome.org/sources/$pkgname/${pkgver%.*}/$pkgname-$pkgver.tar.xz\")\n```\n\nsendo que ${pkgver%.*} retorna a versão de pacote maior.menor, removendo o sufixo do pkgver (que é a versão de pacote micro). Por exemplo, se pkgver=3.28.0, então ${pkgver%.*} retornaria 3.28.\n\n"
    },
    {
      "title": "Usando um commit do repositório Git",
      "level": 3,
      "content": "Uma outra prática comum é usar como fonte um commit específico de um repositório git de código fonte do software GNOME. Isso não se classifica como pacote VCS porque o recurso do Pacman de definir um commit específico[3] faz o PKGBUILD não seguir os últimos commits de desenvolvimento nem atualizar o campo pkgver, em vez disso, usando o fonte do hash de commit especificado.\n\nVeja um modelo abaixo:\n\n```\nPKGBUILD\n```\n\n```\nmakedepends=(git)\ncommit=hash_de_um_commit \nsource=(\"git+https://gitlab.gnome.org/GNOME/$pkgname.git#commit=$_commit\")\nmd5sums=('SKIP')\n\npkgver() {\n  cd $pkgname\n  git describe --tags | sed 's/-/+/g'\n}\n```\n\nSubstitua hash_de_um_commit com a hash do commit Git desejado.\n\nNote que já que o fonte é baixado com git, então git deve estar no makedepends e somas de verificação devem ser definidas para SKIP, assim como ocorreria com qualquer outro pacote VCS. O uso da função pkgver() é altamente recomendado, de forma que defina o pkgver adequadamente para o hash de commit fornecido.\n\n"
    },
    {
      "title": "Compilando com meson",
      "level": 2,
      "content": "Muitos softwares do GNOME migraram o sistema de compilação para o Meson, consequentemente descartando o suporte a GNU Autotools. Isso significa que você usará ./configure e make neste caso.\n\nPara compilar usando o Meson, adicione o pacote meson para makedepends e execute seu comando meson, incluindo opcionalmente todas as opções desejadas suportadas pelo software alvo. O pacote ninja também será usado neste sistema de compilação, mas é uma dependência do meson, então você não precisa incluí-lo no vetor makedepends.\n\nAs funções build(), check() e package() devem ser parecer com:\n\n```\nPKGBUILD\n```\n\n```\nmakedepends=(meson)\n\nbuild() {\n  meson --prefix /usr --buildtype=plain fonte build\n  ninja -C build\n}\n\ncheck() {\n  ninja -C build check\n}\n\npackage() {\n  DESTDIR=\"$pkgdir\" ninja -C build install\n}\n```\n\nsendo que\n\n- fonte é o diretório contendo o código-fonte extraído como, por exemplo, $pkgname ou $pkgname-$pkgver; e\n- build é o diretório que conterá os arquivos binários a serem instalados. Normalmente o nome de diretório \"build\" é usado, então você pode querer mantê-lo para padronização, mas você pode renomeá-lo para o que mais lhe agradar.\n\n- Alguns softwares não suportam a chamada de meson de fora do diretório raiz do código-fonte. Se este for o seu caso, adapte o bloco de código acima simplesmente adicionando cd fonte ao início das três funções acima, e também alterando a linha de comando meson acima para meson . build.\n- Se o software não tiver regras de teste definidas (caso em que o bloco de código acima falharia para construir o pacote), remova/comente a toda a função check().\n\n"
    },
    {
      "title": "GConf schemas",
      "level": 2,
      "content": "Alguns pacotes do GNOME instalam schemas do GConf, apesar de muitos outros já terem migrados para GSettings. Aqueles pacotes devem depender de gconfAUR.\n\nSchemas do Gconf são instalados na base de dados GConf do sistema, que deve ser evitado. Alguns pacotes fornecem uma opção --disable-schemas-install para o ./configure, que dificilmente funciona. Porém, gconftool-2 tem uma variável chamada GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL a qual você pode definir para dizer ao gconftool-2 para não atualizar qualquer base de dados.\n\nAo criar pacotes que instalam arquivos schemas de GConf, use\n\n```\nmake GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1 DESTDIR=${pkgdir} install\n```\n\npara a etapa de instalação do pacote no PKGBUILD.\n\nNão chame gconfpkg no arquivo .install, pois schemas do GConf são automaticamente instalados/removidos (na instalação/remoção de um pacote GNOME) via hooks do pacman desde o gconfAUR=3.2.6-4\n\n"
    },
    {
      "title": "GSettings schemas",
      "level": 2,
      "content": "Os schemas de Gconf foram migrados para schemas do GSettings, então muitos aplicativos pode ser encontrados usando esse novo arquivo de schema. GSettings usa o dconf como backend, então todos os pacotes que contêm schemas de GSettings exigem dconf como dependência. Quando um novo schema de GSettings é instalado no sistema, a base de dados do GSettings tem que ser recompilada, mas não durante o empacotamento.\n\nPara evitar recompilação da base de dados do GSettings no empacotamento, use a opção --disable-schemas-compile para o ./configure.\n\nNão chame glib-compile-schemas no arquivo .install, pois as bases de dados de schemas do GSettings são recompilados automaticamente via hooks do pacman desde glib2=2.48.0-2.\n\n"
    },
    {
      "title": "Documentação do Scrollkeeper",
      "level": 2,
      "content": "A partir do GNOME 2.20, não há mais necessidade de lidar com scrollkeeper, pois rarianAUR lê seus arquivos OMF diretamente. Scrollkeeper-update é um link dos dias atuais. A única coisa que é necessário agora é acrescentar gnome-doc-utilsAUR>=0.11.2 ao vetor makedepends.\n\nEle pode ser desabilitado usando a opção --disable-scrollkeeper no ./configure.\n\n"
    },
    {
      "title": "Cache de ícones do GTK",
      "level": 2,
      "content": "Alguns ícones de instalação de pacotes no tema do ícone do hicolor.\n\nNão chame gtk-update-icon-cache no arquivo .install, pois o cache de ícone é atualizado via hooks do pacman desde gtk-update-icon-cache=3.20.3-2. Tais pacotes não devem depender de gtk-update-icon-cache, pois qualquer aplicativo que faz uso de caches de ícones gtk vai instalar o pacote com o hook e fará uma atualização de banco de dados completa e retroativa.\n\n"
    },
    {
      "title": "Arquivos .desktop",
      "level": 2,
      "content": "Muitos pacotes instalam arquivos .desktop compatíveis com Freedesktop.org e registram entradas tipo MIME neles.\n\nNão chame update-desktop-database no arquivo .install, pois a base de dados é atualizada automaticamente via hooks do pacman desde desktop-file-utils=0.22-2. Tais pacotes não devem depender de desktop-file-utils, pois qualquer desktop que faz uso de arquivos de desktop vai instalar o pacote com o hook e fará uma atualização de banco de dados completa e retroativa.\n\n"
    },
    {
      "title": "Arquivos .install",
      "level": 2,
      "content": "Anteriormente, a maioria dos pacotes GNOME tinham um arquivo .install chamando comandos como glib-compile-schemas, gtk-update-icon-cache e update-desktop-database para instalar/atualizar cache local ou base de dados. Isso está obsoleto desde o pacman 5.0, que trouxe a implementação de hooks que chamam aqueles comandos automaticamente ao instalar o pacote.\n\nPara evitar ser chamado duas vezes, os comandos supramencionados devem ser removidos do arquivo .install.\n\n"
    }
  ]
}