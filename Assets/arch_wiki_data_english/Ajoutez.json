{
  "title": "Ajoutez",
  "url": "https://wiki.archlinux.org/title/Ajoutez",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Help:Browsing\n- Help:Style\n\nLa grande majorité du ArchWiki contient des indications qui peuvent avoir besoin d'être clarifiées pour les utilisateurs novices d'Arch Linux (ou de GNU/Linux en général), ce récapitulatif des procédures de base a été écrit à la fois pour éviter la confusion dans la compréhension des articles et pour éliminer les répétitions dans le contenu lui-même.\n\n"
    },
    {
      "title": "Organisation",
      "level": 2,
      "content": "La plupart des articles sur ArchWiki n'essaient pas de fournir une introduction complète à un sujet ; ils sont plutôt écrits en adhérant au principe DRY, en supposant que l'utilisateur cherchera et lira tout matériel de référence qu'il ne comprend pas encore. Dans la mesure du possible, ces informations sont indiquées dans l'article par un formatage spécial, consultez #Mise en forme.\n\nEn raison de cette organisation, il peut être nécessaire d'examiner plusieurs sources connexes afin de comprendre pleinement un article sur ArchWiki. En particulier, les utilisateurs qui sont nouveaux sur Arch (ou GNU/Linux en général) doivent s'attendre à lire un grand nombre d'articles, même pour résoudre des problèmes simples. Il est particulièrement important d'étudier le matériel de référence avant de chercher de l'aide supplémentaire auprès d'autres utilisateurs.\n\n"
    },
    {
      "title": "Mise en forme",
      "level": 2,
      "content": "- lien vers une section de l'article en cours : #Organisation\n- lien vers un autre article de l'ArchWiki\n- lien vers une page web externe.\n- lien vers une page de manuel : intro(1)\n- une page de manuel qui n'est disponible que hors ligne : foo(1)\n- lien vers un paquet dans les dépôts officiels : foobar\n- Lien vers un paquet dans l'AUR : foobarAUR\n\n"
    },
    {
      "title": "Utilisateur ou root",
      "level": 2,
      "content": "Certaines lignes sont écrites comme ceci :\n\n```\n# mkinitcpio -p linux\n```\n\nD'autres ont un préfixe différent :\n\n```\n$ makepkg -s\n```\n\nLe signe dièse (#) indique que la commande doit être exécutée en tant que root (les termes super-utilisateur ou administrateur peuvent aussi être rencontré), tandis que le signe dollar ($) indique que la commande doit être exécutée en tant qu'utilisateur normal.\n\nUne exception notable dont il faut se méfier :\n\n```\n# Cet alias fait en sorte que ls colore la liste.\nalias ls='ls --color=auto'.\n```\n\nDans cet exemple, le contexte entourant le signe numérique indique que l'alias ne doit pas être exécuté comme une commande ; il doit plutôt être édité dans un fichier. Donc, dans ce cas, le signe numérique indique un commentaire. Un commentaire peut être un texte explicatif qui ne sera pas interprété par le programme associé. Il se trouve que la dénotation des scripts Bash pour les commentaires coïncide avec le symbole «root» d'une invite de commande (PS1).\n\nSi on regarde attentivement, les signes annonciateurs sont l'utilisation d'un caractère majuscule à la suite du signe #. Habituellement, les commandes Unix ne sont pas écrites de cette façon et la plupart du temps, il s'agit de courtes abréviations au lieu de mots anglais complets (par exemple, Copy devient cp).\n\nQuoi qu'il en soit, la plupart des articles rendent la chose facile à discerner en avertissant le lecteur :\n\nAjoutez à ~/path/to/file :\n\n```\n# Cet alias fait en sorte que ls colore la liste.\nalias ls='ls --color=auto' (en anglais)\n```\n\n"
    },
    {
      "title": "Postposer, ajouter, créer, modifier",
      "level": 2,
      "content": "Lorsqu'on vous demande d'ajouter à la fin d'un fichier (le terme anglais append désigne un ajout spécifiquement effectué à la fin), d'ajouter (le terme add en anglais indique un ajout sans que sa position dans le fichier ne soit impératif), de créer ou de modifier un ou plusieurs fichiers, il est sous-entendu que vous devez utiliser l'une des méthodes suivantes.\n\nPour créer ou modifier des fichiers multilignes, il est suggéré d'utiliser un éditeur de texte. Par exemple, l'utilisation de la commande nano pour modifier le fichier /etc/bash.bashrc est la suivante :\n\n```\n# nano /etc/bash.bashrc\n```\n\nPour créer ou écraser un fichier à partir d'une chaîne, il peut être plus simple d'utiliser les redirections. L'exemple suivant crée ou écrase le contenu du fichier /etc/hostname avec le texte myhostname.\n\n```\n# echo myhostname > /etc/hostname\n```\n\nLa redirection de sortie peut également être utilisée pour ajouter une chaîne de caractères à la fin un fichier. L'exemple suivant ajoute le texte [custom-repo] au fichier /etc/pacman.conf.\n\n```\n# echo \"[custom-repo]\" >> /etc/pacman.conf\n```\n\nLorsque vous êtes invité à créer des répertoires, utilisez la commande mkdir :\n\n```\n# mkdir /mnt/boot\n```\n\n"
    },
    {
      "title": "Rendre exécutable",
      "level": 3,
      "content": "Après avoir créé un fichier, s'il est destiné à être exécuté en tant que script (manuellement ou appelé par un autre programme), il doit être défini comme exécutable, par exemple avec :\n\n```\n$ chmod +x script.\n```\n\nConsultez chmod. Certaines applications telles que les gestionnaires de fichiers peuvent fournir des interfaces graphiques pour faire la même chose.\n\n"
    },
    {
      "title": "Sourcer",
      "level": 2,
      "content": "Certaines applications, notamment les «shells» en ligne de commandes, utilisent des scripts pour leur configuration : après les avoir modifiés, ils doivent être sourcés pour que les changements soient appliqués. Dans le cas de bash, par exemple, cela se fait en exécutant (vous pouvez également remplacer source par .) :\n\n```\n$ source ~/.bashrc\n```\n\nLorsque le wiki vous suggérera de modifier un tel script de configuration, il ne vous rappellera pas explicitement de sourcer le fichier et seulement dans certains cas, il vous dirigera vers cette section avec un lien de rappel.\n\n"
    },
    {
      "title": "Installation de paquets",
      "level": 2,
      "content": "Lorsqu'un article vous invite à installer certains paquets de manière conventionnelle, il n'indique pas les instructions détaillées pour le faire, mais mentionne simplement le nom des paquets à installer.\n\nLes sous-sections ci-dessous donnent un aperçu des procédures d'installation génériques en fonction du type de paquet.\n\n"
    },
    {
      "title": "Paquets officiels",
      "level": 3,
      "content": "Pour les paquets provenant des dépôts officiels, vous lirez quelque chose comme :\n\nCela signifie que vous devez exécuter :\n\n```\n# pacman -S foobar\n```\n\nL'article pacman contient des explications détaillées pour effectuer la gestion des paquets dans Arch Linux de manière efficace.\n\n"
    },
    {
      "title": "Arch User Repository",
      "level": 3,
      "content": "Pour les paquets provenant de l'Arch User Repository (AUR), vous lirez quelque chose comme :\n\nCela signifie qu'en général, vous devez suivre le lien foobarAUR, télécharger l'archive PKGBUILD, l'extraire, vérifier le contenu et enfin exécuter, dans le même dossier :\n\n```\n$ makepkg -sri\n```\n\nL'article Arch User Repository contient toutes les explications détaillées et les meilleures pratiques pour utiliser les paquets AUR.\n\n"
    },
    {
      "title": "Contrôle des unités de systemd",
      "level": 2,
      "content": "Lorsqu'un article invite à démarrer, activer, arrêter ou redémarrer certaines unités systemd (par exemple un service), il n'indiquera pas les instructions détaillées pour le faire, mais vous lirez plutôt quelque chose comme :\n\nCela signifie que vous devez exécuter :\n\n```\n# systemctl start exemple.service\n```\n\nLe lien démarrez vous mènera vers l'article systemd, qui contient toutes les explications détaillées pour utiliser les unités de systemd dans Arch Linux de manière efficace.\n\n"
    },
    {
      "title": "Configuration globale du système ou configuration spécifique à l'utilisateur",
      "level": 2,
      "content": "Il est important de se rappeler qu'il existe deux types de configurations différentes sur un système GNU/Linux. La configuration système affecte tous les utilisateurs. Étant donné que les configurations à l'échelle du système sont généralement situées dans le répertoire /etc, les privilèges root sont nécessaires pour les modifier. Par exemple, pour appliquer un paramètre Bash qui affecte tous les utilisateurs, il faut modifier /etc/bash.bashrc.\n\nUne configuration spécifique à un utilisateur n'affecte qu'un seul utilisateur. Les Dotfiles sont utilisés pour la configuration spécifique à un utilisateur. Par exemple, le fichier ~/.bashrc est le fichier de configuration spécifique à l'utilisateur. L'idée est que chaque utilisateur puisse définir ses propres paramètres, tels que les alias, les fonctions et autres caractéristiques interactives comme l'invite, sans affecter les préférences des autres utilisateurs.\n\n"
    },
    {
      "title": "Fichiers shell courants",
      "level": 3,
      "content": "Bash et d'autres interpréteurs de commandes compatibles avec Bourne, tels que Zsh, contiennent également des fichiers sources selon que l'interpréteur de commandes est un interpréteur de commandes de connexion ou un interpréteur de commandes interactif. Consultez Bash#Configuration files et Zsh#Startup/Shutdown files pour plus de détails.\n\n"
    },
    {
      "title": "Pseudo-variables dans les exemples de code",
      "level": 2,
      "content": "Certains blocs de code peuvent contenir des pseudo-variables qui, comme leur nom l'indique, ne sont pas des variables réelles utilisées dans le code. Il s'agit plutôt de substitutions génériques qui doivent être remplacées manuellement par des éléments de configuration spécifiques au système avant que le code ne soit exécuté ou analysé. Les shells courants tels que bash et zsh fournissent une auto-complétion pour compléter automatiquement les paramètres des commandes courantes telles que systemctl.\n\nDans les articles conformes à Help:Style/Formatting and punctuation, les pseudo-variables sont formatées en italique. Par exemple :\n\n- Activez le dhcpcd@interface_name.service pour l'interface réseau identifiée à partir de la sortie de la commande ip link.\n\nDans ce cas, nom_de_l'interface est utilisé comme un substitut de pseudo-variable dans une unité de modèle systemd. Toutes les unités de modèle systemd, identifiables par le signe @, nécessitent un élément de configuration spécifique au système comme argument. Consultez Systemd (Français)#Utilisation des unités.\n\n- La commande dd if=data_source of=/dev/sdX bs=sector_size count=sector_number seek=partitions_start_sector peut être exécutée en tant que root pour effacer une partition avec les paramètres spécifiques.\n\nDans ce cas, les pseudo-variables sont utilisées pour décrire les paramètres qui doivent leur être substitués. Les détails sur la façon de les rassembler sont développés dans la section Securely wipe disk#Calculate blocks to wipe manually, qui présente la commande.\n\nDans le cas des exemples de fichiers, coller des pseudo-variables dans des fichiers de configuration réels pourrait casser les programmes qui les utilisent.\n\n"
    },
    {
      "title": "Ellipses",
      "level": 3,
      "content": "Dans la plupart des cas, les ellipses (...) ne font pas partie du contenu réel du fichier ou de la sortie du code, et représentent plutôt du texte omis ou facultatif qui n'est pas pertinent pour le sujet traité.\n\nPar exemple HOOKS=\"... encrypt ... filesystems ...\" ou :\n\n```\n/etc/X11/xorg.conf.d/50-synaptics.conf\n```\n\n```\nSection \"InputClass\"\n    ...\n    Option \"CircularScrolling\" \"on\"\n    Option \"CircScrollTrigger\" \"0\"\n    ...\nEndSection\n```\n\nSachez cependant que, dans quelques cas, les ellipses peuvent être une partie significative de la syntaxe du code : les utilisateurs attentifs seront capables de reconnaître facilement ces cas par le contexte.\n\n"
    }
  ]
}