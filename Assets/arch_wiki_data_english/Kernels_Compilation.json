{
  "title": "Kernels/Compilation",
  "url": "https://wiki.archlinux.org/title/Kernels/Compilation",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Kernel modules\n- Compile kernel module\n- sysctl\n\nAccording to Wikipedia:\n\nArch Linux is based on the Linux kernel. There are various alternative Linux kernels available for Arch Linux in addition to the latest stable kernel. This article lists some of the options available in the repositories with a brief description of each. There is also a description of patches that can be applied to the system's kernel. The article ends with an overview of custom kernel compilation with links to various methods.\n\nKernel packages are installed under the /usr/lib/modules/ path and subsequently used to generate the vmlinuz executable image in /boot/. [1] When installing a different kernel or switching between multiple kernels, you must configure your boot loader to reflect the changes. For downgrading the kernel to an older version, see Downgrading packages#Downgrading the kernel.\n\n"
    },
    {
      "title": "Officially supported kernels",
      "level": 2,
      "content": "Community support on forum and bug reporting is available for officially supported kernels.\n\n- Stable — Vanilla Linux kernel and modules, with a few patches applied.\n\n- Hardened — A security-focused Linux kernel applying a set of hardening patches to mitigate kernel and userspace exploits. It also enables more upstream kernel hardening features than linux.\n\n- Longterm — Long-term support (LTS) Linux kernel and modules with configuration options targeting usage in servers.\n\n- Realtime kernel — Maintained by a small group of core developers led by Ingo Molnar. This patch allows nearly all of the kernel to be preempted, with the exception of a few very small regions of code (\"raw_spinlock critical regions\"). This is done by replacing most kernel spinlocks with mutexes that support priority inheritance, as well as moving all interrupt and software interrupts to kernel threads.\n\n- Zen Kernel — Result of a collaborative effort of kernel hackers to provide the best Linux kernel possible for everyday systems. For more details see FAQ and Detailed Feature List.\n\n"
    },
    {
      "title": "Compilation",
      "level": 2,
      "content": "Following methods can be used to compile your own kernel:\n\n- Using custom kernels may cause all kinds of stability and reliability issues, including data loss. Having backups is strongly advised.\n- Arch Linux only has official support for #Officially supported kernels. When using a different kernel, please mention so in support requests.\n\n- Best way to increase the speed of your system is to first tailor your kernel configuration to your architecture and processor type.\n- You can reduce the size of your kernel (and therefore build time) by not including support for things you do not have or use. For example support for things like Bluetooth, video4linux, 1000Mbit Ethernet, etc.\n\nSome of the listed packages may also be available as binary packages via Unofficial user repositories.\n\n"
    },
    {
      "title": "kernel.org kernels",
      "level": 3,
      "content": "- Git — Linux kernel and modules built using sources from Linus Torvalds' Git repository.\n\n- Mainline — Kernels where all new features are introduced, released every 2-3 months.\n\n- Next — Bleeding edge kernels with features pending to be merged into next mainline release.\n\n- DRM — Linux kernel with bleeding-edge GPU drivers.\n\n- Longterm — Long-term support (LTS) Linux kernel and modules.\n\n"
    },
    {
      "title": "Unofficial kernels",
      "level": 3,
      "content": "- Ck — Contains patches by Con Kolivas (including the MuQSS scheduler) designed to improve system responsiveness with specific emphasis on the desktop, but they are suitable to any workload.\n\n- Clear — Patches from Intel's Clear Linux project. Provides performance and security optimizations.\n\n- Libre — Without proprietary or obfuscated device drivers.\n\n- Liquorix — Kernel replacement built using Debian-targeted configuration and the Zen kernel sources. Designed for desktop, multimedia, and gaming workloads, it is often used as a Debian Linux performance replacement kernel. Damentz, the maintainer of the Liquorix patchset, is a developer for the Zen patchset as well.\n\n- pf-kernel — Provides a handful of awesome features which are not merged into a kernel mainline. Maintained by a kernel engineer. If the port for the included patch for new kernels was not released officially, the patchset provides and supports patch ports to new kernels. The current most prominent patches of linux-pf are UKSM, DDCCI, v4l2loopback and BBRv3.\n\n- Repository, linux-pfAUR by pf-kernel developer post-factum\n\n- Project C — Kernel with Alfred Chen's Project C patch set (BMQ and PDS schedulers).\n\n- Nitrous — Modified Linux kernel optimized for Skylake and newer.\n\n- tkg — A highly customizable kernel build system that provides a selection of patches and tweaks aiming for better desktop and gaming performance. It is maintained by Etienne Juvigny. Amongst other patches, it offers various CPU schedulers: CFS, Project C PDS, Project C BMQ, MuQSS and CacULE.\n\n- VFIO — The Linux kernel and a few patches written by Alex Williamson (acs override and i915) to enable the ability to do PCI Passthrough with KVM on some machines.\n\n- XanMod — Aiming to take full advantage in high-performance workstations, gaming desktops, media centers and others and built to provide a more rock-solid, responsive and smooth desktop experience. This kernel uses the BFQ I/O scheduler, TCP BBRv3 congestion control, x86_64 advanced instruction set support, partial clear linux patchset, and other default changes.\n\n- linux-cachyos — The Linux SCHED-EXT + BORE + Cachy Sauce Kernel by CachyOS with other patches and improvements kernel and modules\n\n"
    },
    {
      "title": "Kernel panics",
      "level": 3,
      "content": "A kernel panic occurs when the Linux kernel enters an unrecoverable failure state. The state typically originates from buggy hardware drivers resulting in the machine being deadlocked, non-responsive, and requiring a reboot. Just prior to deadlock, a diagnostic message is generated, consisting of: the machine state when the failure occurred, a call trace leading to the kernel function that recognized the failure, and a listing of currently loaded modules. Thankfully, kernel panics do not happen very often using mainline versions of the kernel--such as those supplied by the official repositories--but when they do happen, you need to know how to deal with them.\n\n"
    },
    {
      "title": "Examine panic message",
      "level": 4,
      "content": "If a kernel panic occurs very early in the boot process, you may see a message on the console containing \"Kernel panic - not syncing:\", but once Systemd is running, kernel messages will typically be captured and written to the system log. However, when a panic occurs, the diagnostic message output by the kernel is almost never written to the log file on disk because the machine deadlocks before system-journald gets the chance. Therefore, the only way to examine the panic message is to view it on the console as it happens (without resorting to setting up a kdump crashkernel). You can do this by booting with the following kernel parameters and attempting to reproduce the panic on tty1:\n\n```\nsystemd.journald.forward_to_console=1 console=tty1\n```\n\nIt is possible to make a best guess as to what subsystem or module is causing the panic using the information in the diagnostic message. In this scenario, we have a panic on some imaginary machine during boot. Pay attention to the lines highlighted in bold:\n\n```\nkernel: BUG: unable to handle kernel NULL pointer dereference at (null) 1\nkernel: IP: fw_core_init+0x18/0x1000 [firewire_core] 2\nkernel: PGD 718d00067\nkernel: P4D 718d00067\nkernel: PUD 7b3611067\nkernel: PMD 0\nkernel:\nkernel: Oops: 0002 [#1] PREEMPT SMP\nkernel: Modules linked in: firewire_core(+) crc_itu_t cfg80211 rfkill ipt_REJECT nf_reject_ipv4 nf_log_ipv4 nf_log_common xt_LOG nf_conntrack_ipv4 ... 3\nkernel: CPU: 6 PID: 1438 Comm: modprobe Tainted: P           O    4.13.3-1-ARCH #1\nkernel: Hardware name: Gigabyte Technology Co., Ltd. H97-D3H/H97-D3H-CF, BIOS F5 06/26/2014\nkernel: task: ffff9c667abd9e00 task.stack: ffffb53b8db34000\nkernel: RIP: 0010:fw_core_init+0x18/0x1000 [firewire_core]\nkernel: RSP: 0018:ffffb53b8db37c68 EFLAGS: 00010246\nkernel: RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\nkernel: RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffffffffc16d3af4\nkernel: RBP: ffffb53b8db37c70 R08: 0000000000000000 R09: ffffffffae113e95\nkernel: R10: ffffe93edfdb9680 R11: 0000000000000000 R12: ffffffffc16d9000\nkernel: R13: ffff9c6729bf8f60 R14: ffffffffc16d5710 R15: ffff9c6736e55840\nkernel: FS:  00007f301fc80b80(0000) GS:ffff9c675dd80000(0000) knlGS:0000000000000000\nkernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nkernel: CR2: 0000000000000000 CR3: 00000007c6456000 CR4: 00000000001406e0\nkernel: Call Trace:\nkernel:  do_one_initcall+0x50/0x190 4\nkernel:  ? do_init_module+0x27/0x1f2\nkernel:  do_init_module+0x5f/0x1f2\nkernel:  load_module+0x23f3/0x2be0\nkernel:  SYSC_init_module+0x16b/0x1a0\nkernel:  ? SYSC_init_module+0x16b/0x1a0\nkernel:  SyS_init_module+0xe/0x10\nkernel:  entry_SYSCALL_64_fastpath+0x1a/0xa5\nkernel: RIP: 0033:0x7f301f3a2a0a\nkernel: RSP: 002b:00007ffcabbd1998 EFLAGS: 00000246 ORIG_RAX: 00000000000000af\nkernel: RAX: ffffffffffffffda RBX: 0000000000c85a48 RCX: 00007f301f3a2a0a\nkernel: RDX: 000000000041aada RSI: 000000000001a738 RDI: 00007f301e7eb010\nkernel: RBP: 0000000000c8a520 R08: 0000000000000001 R09: 0000000000000085\nkernel: R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000c79208\nkernel: R13: 0000000000c8b4d8 R14: 00007f301e7fffff R15: 0000000000000030\nkernel: Code: <c7> 04 25 00 00 00 00 01 00 00 00 bb f4 ff ff ff e8 73 43 9c ec 48\nkernel: RIP: fw_core_init+0x18/0x1000 [firewire_core] RSP: ffffb53b8db37c68\nkernel: CR2: 0000000000000000\nkernel: ---[ end trace 71f4306ea1238f17 ]---\nkernel: Kernel panic - not syncing: Fatal exception 5\nkernel: Kernel Offset: 0x80000000 from 0xffffffff810000000 (relocation range: 0xffffffff800000000-0xfffffffffbffffffff\nkernel: ---[ end Kernel panic - not syncing: Fatal exception\n```\n\n1. Indicates the type of error that caused the panic. In this case it was a programmer bug.\n1. Indicates that the panic happened in a function called fw_core_init in module firewire_core.\n1. Indicates that firewire_core was the latest module to be loaded.\n1. Indicates that the function that called function fw_core_init was do_one_initcall.\n1. Indicates that this oops message is, in fact, a kernel panic and the system is now deadlocked.\n\nWe can surmise then, that the panic occurred during the initialization routine of module firewire_core as it was loaded. (We might assume then, that the machine's firewire hardware is incompatible with this version of the firewire driver module due to a programmer error, and will have to wait for a new release.) In the meantime, the easiest way to get the machine running again is to prevent the module from being loaded. We can do this in one of two ways:\n\n- If the module is being loaded during the execution of the initramfs, reboot with the kernel parameter rd.blacklist=firewire_core.\n- Otherwise reboot with the kernel parameter module_blacklist=firewire_core.\n\n"
    },
    {
      "title": "Reboot into root shell and fix problem",
      "level": 4,
      "content": "Note: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nYou will need a root shell to make changes to the system so the panic no longer occurs. If the panic occurs on boot, there are several strategies to obtain a root shell before the machine deadlocks:\n\n- Reboot with the kernel parameter emergency, rd.emergency, or -b to receive a prompt to login just after the root filesystem is mounted and systemd is started.\n\nNote: **read-only** \n\n- Reboot with the kernel parameter rescue, rd.rescue, single, s, S, or 1 to receive a prompt to login just after local filesystems are mounted.\n- Reboot with the kernel parameter systemd.debug_shell to obtain a very early root shell on tty9. Switch to it with by pressing Ctrl+Alt+F9.\n- Experiment by rebooting with different sets of kernel parameters to possibly disable the kernel feature that is causing the panic. Try the \"old standbys\" acpi=off and nolapic.\n\n- As a last resort, boot with an Arch Linux installation medium and mount the root filesystem on /mnt then execute arch-chroot /mnt as the root user.\n- Disable the service or program that is causing the panic, roll-back a faulty update, or fix a configuration problem.\n\n"
    },
    {
      "title": "Debugging regressions",
      "level": 3,
      "content": "See General troubleshooting#Debugging regressions.\n\nTry linux-mainlineAUR to check if the issue is already fixed upstream. The pinned comment also mentions a repository which contains already built kernels, so it may not be necessary to build it manually, which can take some time.\n\nIt may also be worth considering trying the LTS kernel (linux-lts) to debug issues which did not appear recently. Older versions of the LTS kernel can be found in the Arch Linux Archive.\n\nIf the issue still persists, bisect the linux-gitAUR kernel and report the bug in accordance to the kernel process for reporting regressions. Depending on the Bugtracker (B:) entry in the MAINTAINERS file this then entails opening an issue via the subsystems mailing lists, Kernel Bugzilla, or in other issue trackers like the DRM Gitlab. It is important to try the \"vanilla\" version without any patches to make sure it is not related to them. If a patch causes the issue, report it to the author of the patch.\n\n"
    },
    {
      "title": "Building a smaller kernel",
      "level": 4,
      "content": "You can shorten kernel build times by building only the modules required by the local system using modprobed-db, or by make localmodconfig. Of course you can completely drop irrelevant drivers, for example sound drivers to debug a network problem.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- O'Reilly - Linux Kernel in a Nutshell (free ebook)\n- What stable kernel should I use? by Greg Kroah-Hartman\n- Linux kernel documentation\n\n"
    }
  ]
}