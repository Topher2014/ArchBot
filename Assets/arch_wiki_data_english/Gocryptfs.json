{
  "title": "Gocryptfs",
  "url": "https://wiki.archlinux.org/title/Gocryptfs",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Data-at-rest encryption\n- Encfs\n\nFrom gocryptfs:\n\nSee the gocryptfs project home for further introduction of its features, benchmarks, etc. See Data-at-rest encryption#Comparison table for an overview of alternative methods and EncFS for the direct alternative.\n\n- To achieve its design goal of authenticated encryption, gocryptfs implements a AES-EME encryption mode (for filenames, the content is encrypted using standard libraries). While the EME mode is not widely used/audited yet, gocryptfs encryption modes bring integrity protection for the data.\n- See the project's tracking bug report regarding findings of the first security audit for more information.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install gocryptfs or gocryptfs-gitAUR.\n\nAs a FUSE filesystem, gocryptfs is fully configurable by the user and stores its configuration files in the user's directory paths.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "See gocryptfs(1) and its examples first. As a first-time user, check the gocryptfs best practices next.\n\nUpon initialization of the cryptography for a directory, the master key is output before it is cryptographically wrapped in the gocryptfs.conf file. It can be used to recreate the configuration with a restore procedure. If it happens that the master key itself is lost but the configuration file available, see gocryptfs-xray(1) for how to output it again with the encryption password.\n\n- Execute gocryptfs -speed to test throughput for available encryption modes. The automatic selection will choose the fastest mode available for the system.\n- A -fido2 option allows the convenience of U2F hardware tokens to initialize and mount the encrypted data.\n\n"
    },
    {
      "title": "Example using normal mode",
      "level": 3,
      "content": "Create cipher directory to store encrypted data, and plain directory to access them decrypted. Then, run gocryptfs initialization to setup encryption.\n\n```\n$ mkdir cipher plain\n$ gocryptfs -init cipher\nChoose a password for protecting your files.\nPassword:\nRepeat: \n\nYour master key is:\n[...]\n```\n\nTo open the encrypted directory cipher and access it from plain:\n\n```\n$ gocryptfs cipher plain\nPassword: \nDecrypting master key\nFilesystem mounted and ready\n```\n\nYou now have a working gocryptfs that is stored in cipher and mounted to plain. You can verify this by creating a blank file in the plain directory. This file will show up encrypted in the cipher directory.\n\n```\n$ touch plain/test.txt\n$ ls cipher\n  gocryptfs.conf  gocryptfs.diriv  ZSuIZVzYDy5-TbhWKY-ciA==\n```\n\n"
    },
    {
      "title": "Example using reverse mode",
      "level": 3,
      "content": "A major application for file-based encryption methods are encrypted backups. FUSE-based filesystems are flexible for this, since they allow a wide array of backup destinations using standard tools. For example, a gocryptfs-encrypted FUSE mount point can be easily created directly on a Samba/NFS share or Dropbox location, synchronized to a remote host with rsync, or just be manually copied to a remote backup storage.\n\nThe reverse mode of gocryptfs is particularly useful for creating encrypted backups, since it requires virtually no extra storage capacity on the machine to back up.\n\nThe following shows an example of user archie creating a backup of /home/archie:\n\nFirst, archie initializes the configuration for the home directory:\n\n```\n$ gocryptfs -init -reverse /home/archie\n```\n\n```\nChoose a password for protecting your files.\nPassword:\n...\n```\n\nSecond, an empty directory for the encrypted view of the home directory is created and mounted:\n\n```\n$ mkdir /tmp/crypt\n$ gocryptfs -reverse /home/archie /tmp/crypt\nPassword:\nDecrypting master key\n\nYour master key is:\n...\nFilesystem mounted and ready.\n$\n```\n\n- To account for above warning, a -config /home/archie/gocryptfs.conf during initialization could be used, thereby reverse-encrypting the configuration file as well.\n- A number of options to exclude files or directories from the reverse mount are available; see gocryptfs(1) ยง EXCLUDING_FILES. Note that with software like rsync errors or warnings may occur if exclusions are done later only.[2]\n\nThird, archie creates a backup of the encrypted directory, a simple local copy for this example:\n\n```\n$ cp -a /tmp/crypt /tmp/backup\n```\n\nand done.\n\nThe encrypted directory can stay mounted for the user session, or be unmounted manually:\n\n```\n$ fusermount -u /tmp/crypt\n$ rmdir /tmp/crypt\n```\n\nTo restore from the encrypted backup, a plain-text view is mounted using gocryptfs's normal mode:\n\n```\n$ mkdir /tmp/restore\n$ gocryptfs /tmp/backup/ /tmp/restore\nPassword: \nDecrypting master key\n...\nFilesystem mounted and ready.\n$\n```\n\nNow the required files can be restored.\n\n"
    },
    {
      "title": "Example using the FIDO2 option",
      "level": 3,
      "content": "Options to use U2F hardware tokens, instead of a password, to initialize and mount an encrypted directory are available. It is possible to enforce or toggle FIDO2 token options for PIN/user-presence (touch)/user-verification (fingerprint) verification for the decryption (see fido2-assert(1)).\n\nThe following initializes, mounts and unmounts an encrypted directory with a token and PIN-verification:\n\n```\n$ gocryptfs -init -fido2 /dev/hidraw0 -fido2-assert-option pin=true crypt\nFIDO2 Register: interact with your device ...\nEnter PIN for /dev/hidraw0: \nFIDO2 Secret: interact with your device ...\nEnter PIN for /dev/hidraw0:\nYour master key is:\n    ea6d7d00-...\n$ gocryptfs -fido2 /dev/hidraw0 crypt plain\nFIDO2 Secret: interact with your device ...\nEnter PIN for /dev/hidraw0: \nDecrypting master key\nFilesystem mounted and ready.\n$ fusermount -u plain\n```\n\nThe user-presence interaction (interact with your device ...) was used, because the token defaults to it. Using a -fido2-assert-option up=false option would toggle it during initialization.\n\n```\n$ gocryptfs -masterkey=ea6d7d00-e2187a69-fab9c952-223e7821-16fb0ac2-ae4ffa1e-5469f9f1-2a7b051c crypt plain\nUsing explicit master key.\nTHE MASTER KEY IS VISIBLE VIA \"ps ax\" AND MAY BE STORED IN YOUR SHELL HISTORY!\nONLY USE THIS MODE FOR EMERGENCIES\nFilesystem mounted and ready.\n```\n\n"
    },
    {
      "title": "Mounting automatically with pam_mount",
      "level": 2,
      "content": "If your encrypted directory uses the same password as your user account, you can automount it on login with pam_mount.\n\nWhile gocryptfs command works with fuse3 when directly invoked, pam_mount it tries to use mount.fuse from fuse2.\n\nYou need to add pam_mount to /etc/pam.d/system-login as specified in pam_mount#Login manager configuration, then you must configure the specific directories to mount in a /etc/security/pam_mount.conf.xml configuration. An example is given below:\n\n```\n/etc/security/pam_mount.conf.xml\n```\n\n```\n<!-- Example using gocryptfs -->\n  <volume\n      fstype=\"fuse\"\n      mountpoint=\"/home/YOURUSER/plain\"\n      path=\"/usr/bin/gocryptfs#/home/YOURUSER/cipher\"\n      options=\"nodev,nosuid\"\n      user=\"YOURUSER\"\n  />\n```\n\n"
    },
    {
      "title": "GUI wrappers",
      "level": 2,
      "content": "There are a couple of applications available that provide a graphical user interface for gocryptfs.\n\n"
    },
    {
      "title": "SiriKali",
      "level": 3,
      "content": "A Qt/C++ GUI application that manages gocryptfs, eCryptfs, cryfs, EncFS, fscrypt, and securefs encrypted folders. It can also connect to SSH servers using SSHFS. Install it from sirikaliAUR.\n\n"
    },
    {
      "title": "gocryptfs-ui",
      "level": 3,
      "content": "A bash script gocryptfs-ui provides a simple zenity GUI around the gocryptfs command line utility to mount and unmount an encrypted directory. It includes a desktop launcher. Install it from gocryptfs-uiAUR.\n\n"
    },
    {
      "title": "cryptor",
      "level": 3,
      "content": "cryptor is a vala/gtk3 based application providing a GUI to create and mount encrypted directories. It can store configuration files with a list of encrypted directories, has tray-icon support and includes a desktop launcher. Install it from cryptorAUR.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- A first security audit of gocryptfs\n- RFC 5297 Synthetic Initialization Vector (SIV) Authenticated Encryption Using the Advanced Encryption Standard (AES)\n\n"
    }
  ]
}