{
  "title": ".inputrc",
  "url": "https://wiki.archlinux.org/title/.inputrc",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Readline is a library by the GNU Project, used by Bash and other CLI programs to edit and interact with the command line. See readline(3) for more information.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "The readline package is most likely already installed as a dependency of Bash.\n\n"
    },
    {
      "title": "Editing mode",
      "level": 2,
      "content": "By default Readline uses Emacs style shortcuts for interacting with command line. However, vi style editing interface is also supported by adding the following to ~/.inputrc:\n\n```\n~/.inputrc\n```\n\n```\nset editing-mode vi\n```\n\nAlternatively, to set it only for Bash by adding the following line to ~/.bashrc:\n\n```\n~/.bashrc\n```\n\n```\nset -o vi\n```\n\n"
    },
    {
      "title": "Mode indicator in prompt",
      "level": 3,
      "content": "Vi-style editing has two modes: command and insert. You can display which one is currently active by adding the following option:\n\n```\n~/.inputrc\n```\n\n```\nset show-mode-in-prompt on\n```\n\nThis will print a string in your prompt ((cmd)/(ins) by default) that can be customized with the vi-ins-mode-string and vi-cmd-mode-string variables.\n\n"
    },
    {
      "title": "Different cursor shapes for each mode",
      "level": 3,
      "content": "You can set a different cursor shape for each mode by using \"\\1 .. \\2\" escapes:\n\n```\n~/.inputrc\n```\n\n```\nset vi-ins-mode-string \\1\\e[6 q\\2\nset vi-cmd-mode-string \\1\\e[2 q\\2\n```\n\nThis will set a block shaped cursor when in command mode and a pipe cursor when in insert mode. Note that you must have the mode indicator enabled for this to work (see #Mode indicator in prompt).\n\nThe Virtual Console uses different escape codes, so you should check first which term is being used:\n\n```\n~/.inputrc\n```\n\n```\n$if term=linux\n\tset vi-ins-mode-string \\1\\e[?0c\\2\n\tset vi-cmd-mode-string \\1\\e[?8c\\2\n$else\n\tset vi-ins-mode-string \\1\\e[6 q\\2\n\tset vi-cmd-mode-string \\1\\e[2 q\\2\n$endif\n```\n\nSee software cursor for VGA for further details.\n\n"
    },
    {
      "title": "Fast word movement",
      "level": 2,
      "content": "Xterm supports moving between words with Ctrl+Left and Ctrl+Right by default. To achieve this effect with other terminal emulators, find the correct terminal codes, and bind them to backward-word and forward-word in ~/.inputrc.\n\nFor example, for urxvt:\n\n```\n~/.inputrc\n```\n\n```\n\"\\e[1;5D\": backward-word\n\"\\e[1;5C\": forward-word\n```\n\nAnother example for macOS style (Alt+Left and Alt+Right) word moving:\n\n```\n~/.inputrc or /etc/inputrc\n```\n\n```\n\"\\e[1;9D\": backward-word\n\"\\e[1;9C\": forward-word\n```\n\n"
    },
    {
      "title": "History",
      "level": 2,
      "content": "The history configuration is split into:\n\n- controlling its operation, which is configured shell-specific, for example see Bash#History customization and\n- influencing the interaction, which may be configured via a shell-specific configuration, or its native inputrc configuration applicable for all shells, as explained in the following examples.\n\nUsually, pressing the up arrow key will cause the last command to be shown regardless of the command that has been typed so far. However, users may find it more practical to list only past commands that match the current input.\n\nFor example, if the user has typed the following commands:\n\n- ls /usr/src/linux-2.6.15-ARCH/kernel/power/Kconfig\n- who\n- mount\n- man mount\n\nIn this situation, when typing ls and pressing the up arrow key, current input will be replaced with man mount, the last performed command. If the history search has been enabled, only past commands beginning with ls (the current input) will be shown, in this case ls /usr/src/linux-2.6.15-ARCH/kernel/power/Kconfig.\n\nYou can enable the history search mode by adding the following lines to /etc/inputrc or ~/.inputrc:\n\n```\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n```\n\nIf you are using vi mode, you can add the following lines to the readline configuration file (from BBS#54972):\n\n```\n~/.inputrc\n```\n\n```\nset editing-mode vi\n$if mode=vi\nset keymap vi-command\n# these are for vi-command mode\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\nj: history-search-forward\nk: history-search-backward\nset keymap vi-insert\n# these are for vi-insert mode\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n$endif\n```\n\nIf you chose to add these lines to ~/.inputrc, it is recommended that you also add the following line at the beginning of this file to avoid strange things like BBS#112537:\n\n```\n$include /etc/inputrc\n```\n\nAlternatively, one can use reverse-search-history (incremental search) by pressing Ctrl+r, which does not search based on previous input but instead jumps backwards in the history buffer as commands are typed in a search term. Pressing Ctrl+r again during this mode will display the previous line in the buffer that matches the current search term, while pressing Ctrl+g (abort) will cancel the search and restore the current input line. So in order to search through all previous mount commands, press Ctrl+r, type 'mount' and keep pressing Ctrl+r until the desired line is found.\n\nThe forward equivalent to this mode is called forward-search-history and is bound to Ctrl+s by default. Beware that most terminals override Ctrl+s to suspend execution until Ctrl+q is entered. (This is called XON/XOFF flow control). For activating forward-search-history, either disable flow control by issuing:\n\n```\n$ stty -ixon\n```\n\nor use a different key in inputrc. For example, to use Alt+s which is not bound by default:\n\n```\n\"\\es\": forward-search-history\n```\n\n"
    },
    {
      "title": "Faster completion",
      "level": 2,
      "content": "When performing tab completion, a single tab attempts to partially complete the current word. If no partial completions are possible, a double tab shows all possible completions.\n\nThe double tab can be changed to a single tab by setting:\n\n```\n~/.inputrc\n```\n\n```\nset show-all-if-unmodified on\n```\n\nOr you can set it such that a single tab will perform both steps: partially complete the word and show all possible completions if it is still ambiguous:\n\n```\n~/.inputrc\n```\n\n```\nset show-all-if-ambiguous on\n```\n\n"
    },
    {
      "title": "Colorized completion",
      "level": 2,
      "content": "You can enable coloring of completion of filenames with the colored-stats option. You can also color the identical prefix of completion-lists with colored-completion-prefix. For example:\n\n```\n~/.inputrc\n```\n\n```\n# Color files by types\n# Note that this may cause completion text blink in some terminals (e.g. xterm).\nset colored-stats On\n# Append char to indicate type\nset visible-stats On\n# Mark symlinked directories\nset mark-symlinked-directories On\n# Color the common prefix\nset colored-completion-prefix On\n# Color the common prefix in menu-complete\nset menu-complete-display-prefix On\n```\n\n"
    },
    {
      "title": "Macros",
      "level": 2,
      "content": "Readline also supports binding keys to keyboard macros, for example:\n\n```\n$ bind '\"\\ew\": \"\\C-e # macro\"'\n```\n\nTo keep it permanently, add the part within single quotes to readline's configuration file:\n\n```\n~/.inputrc\n```\n\n```\n\"\\ew\": \"\\C-e # macro\"\n```\n\nNow type a line and press Alt+w. Readline will act as though Ctrl+e (end-of-line) had been pressed, appended with ' # macro'.\n\nUse any of the existing keybindings within a readline macro, which can be quite useful to automate frequently used idioms. For example, this one makes Ctrl+Alt+l append | less to the line and run it (Ctrl+m is equivalent to Enter):\n\n```\n\"\\e\\C-l\": \"\\C-e | less\\C-m\"\n```\n\nThe next one prefixes the line with yes | when pressing Ctrl+Alt+y, confirming any yes/no question the command might ask:\n\n```\n\"\\e\\C-y\": \"\\C-ayes | \\C-m\"\n```\n\nThis example wraps the line in su -c '' and runs it, if Alt+s is pressed:\n\n```\n\"\\es\": \"\\C-a su -c '\\C-e'\\C-m\"\n```\n\nThis example prefixes the line with sudo , if Alt+s is pressed. It lets you review the result and will not input the Enter key.\n\n```\n\"\\es\": \"\\C-asudo \\C-e\"\n```\n\nAs a last example, quickly send a command in the background with Ctrl+Alt+b, discarding all of its output:\n\n```\n\"\\e\\C-b\": \"\\C-e > /dev/null 2>&1 &\\C-m\"\n```\n\n"
    },
    {
      "title": "Disabling control echo",
      "level": 2,
      "content": "Readline causes the terminal to echo ^C after Ctrl+c is pressed. For users who wish to disable this, simply add the following to ~/.inputrc:\n\n```\nset echo-control-characters off\n```\n\n"
    },
    {
      "title": "Bracketed paste",
      "level": 2,
      "content": "By default, bracketed paste mode is on. It can be set manually in ~/.inputrc:\n\n```\nset enable-bracketed-paste on\n```\n\nThis ensures that pasting into Readline inserts the clipboard as single string of characters, instead of inserting characters as if they were entered from the keyboard. This is a safety measure to prevent Readline from automatically modifying and running pasted commands.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- vi readline editing cheat sheet\n- emacs readline editing cheat sheet\n\n"
    }
  ]
}