{
  "title": "Docker",
  "url": "https://wiki.archlinux.org/title/Docker",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Linux Containers\n- Podman\n- systemd-nspawn\n- Vagrant\n\nDocker is a utility to pack, ship and run any application as a lightweight container.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "To pull Docker images and run Docker containers, you need the Docker Engine. The Docker Engine includes a daemon to manage the containers, as well as the docker CLI frontend. Install the docker package or, for the development version, the docker-gitAUR package. Next enable/start docker.service or docker.socket. Note that docker.service starts the service on boot, whereas docker.socket starts docker on first usage which can decrease boot times. Then verify docker's status:\n\n```\n# docker info\n```\n\nNote that starting the docker service may fail if you have an active VPN connection due to IP conflicts between the VPN and Docker's bridge and overlay networks. If this is the case, try disconnecting the VPN before starting the docker service. You may reconnect the VPN immediately afterwards. You can also try to deconflict the networks (see solutions [1] or [2]).\n\nNext, verify that you can run containers. The following command downloads the latest Arch Linux image and uses it to run a Hello World program within a container:\n\n```\n# docker run -it --rm archlinux bash -c \"echo hello world\"\n```\n\nTo remove the downloaded archlinux docker image, see #Remove Docker and images.\n\nIf you want to be able to run the docker CLI command as a non-root user, add your user to the docker user group, re-login and restart docker.service.\n\nIf you plan to build container images using Docker, install docker-buildx to use the current builder instead of the deprecated legacy builder.\n\n"
    },
    {
      "title": "Docker Compose",
      "level": 3,
      "content": "Docker Compose is an alternate CLI frontend for the Docker Engine, which specifies properties of containers using a compose.yaml YAML file rather than, for example, a script with docker run options. This is useful for setting up reoccuring services that are used often and/or have complex configurations. To use it, install docker-compose.\n\n"
    },
    {
      "title": "Docker Desktop",
      "level": 3,
      "content": "Docker Desktop is a proprietary desktop application that runs the Docker Engine inside a Linux virtual machine. Additional features such as a Kubernetes cluster and a vulnerability scanner are included. This application is useful for software development teams who develop Docker containers using macOS and Windows. The Linux port of the application is relatively new, and complements Docker's CLI frontends [5].\n\nAn experimental package for Arch is provided directly by Docker; see the manual for more information. Unfortunately, it contains files which conflict with the docker-compose and docker-buildx packages, so you will first need to remove them if installed. Alternatively, you can install docker-desktopAUR package that does not conflict with existing packages.\n\nAlso, to run Docker Desktop you will need to ensure the Linux system requirements, including virtualization support via KVM. To see a tray icon under Gnome, gnome-shell-extension-appindicator will be needed.\n\nFinally, file sharing support requires mapping user and group ids via /etc/subuid and /etc/subgid. See the Docker Desktop For Linux File Sharing instructions for more details.\n\nNote: For more information see What is the difference between Docker Desktop for Linux and Docker Engine.\n\nFor more information see What is the difference between Docker Desktop for Linux and Docker Engine.\n\nFurthermore, expect degraded performance and higher cpu usage when using Docker Desktop on Linux.\n\nBy default, Docker Desktop enables a user-level systemd service that starts the application automatically on boot. Disabling the \"Autostart\" setting in the Docker Desktop dashboard does not prevent this service from starting (linked issue page includes fixes).\n\n"
    },
    {
      "title": "Front-ends",
      "level": 3,
      "content": "- DockStation — A developer-centric application (GUI) for managing projects based on Docker.\n\n- Ducker — A terminal app for managing docker containers.\n\n- goManageDocker — A TUI tool to manage docker objects.\n\n- Lazydocker — A simple terminal UI for docker and docker-compose, written in Go with the gocui library.\n\n- oxker — A simple TUI to view and control Docker containers.\n\n- Podman Desktop — Manage Podman and other container engines from a single UI and tray.\n\n- Portainer — A lightweight docker management UI.\n\n- Whaler — Docker container management designed for Pantheon.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "Docker consists of multiple parts:\n\n- The Docker daemon (sometimes also called the Docker Engine), which is a process which runs as docker.service. It serves the Docker API and manages Docker containers.\n- The docker CLI command, which allows users to interact with the Docker API via the command line and control the Docker daemon.\n- Docker containers, which are namespaced processes that are started and managed by the Docker daemon as requested through the Docker API.\n\nTypically, users use Docker by running docker CLI commands, which in turn request the Docker daemon to perform actions which in turn result in management of Docker containers. Understanding the relationship between the client (docker), server (docker.service) and containers is important to successfully administering Docker.\n\nNote that if the Docker daemon stops or restarts, all currently running Docker containers are also stopped or restarted.\n\nAlso note that it is possible to send requests to the Docker API and control the Docker daemon without the use of the docker CLI command. See the Docker API developer documentation for more information.\n\nSee the Docker Getting Started guide for more usage documentation.\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "The Docker daemon can be configured either through a configuration file at /etc/docker/daemon.json or by adding command line flags to the docker.service systemd unit. According to the Docker official documentation, the configuration file approach is preferred. If you wish to use the command line flags instead, use systemd drop-in files to override the ExecStart directive in docker.service.\n\nFor more information about options in daemon.json see dockerd documentation.\n\n"
    },
    {
      "title": "Storage driver",
      "level": 3,
      "content": "The storage driver controls how images and containers are stored and managed on your Docker host. The default overlay2 driver has good performance for most use cases.\n\nUsers of btrfs or ZFS may use the btrfs or zfs drivers, each of which take advantage of the unique features of these filesystems. See the btrfs driver and zfs driver documentation for more information and step-by-step instructions.\n\n"
    },
    {
      "title": "Daemon socket",
      "level": 3,
      "content": "Note: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nBy default, the Docker daemon serves the Docker API using a Unix socket at /var/run/docker.sock. This is an appropriate option for most use cases.\n\nIt is possible to configure the Daemon to additionally listen on a TCP socket, which can allow remote Docker API access from other computers. [7] This can be useful for allowing docker commands on a host machine to access the Docker daemon on a Linux virtual machine, such as an Arch virtual machine on a Windows or macOS system.\n\nNote that the default docker.service file sets the -H flag by default, and Docker will not start if an option is present in both the flags and /etc/docker/daemon.json file. Therefore, the simplest way to change the socket settings is with a drop-in file, such as the following which adds a TCP socket on port 2376:\n\n```\n/etc/systemd/system/docker.service.d/docker.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2376\n```\n\nReload the systemd daemon and restart docker.service to apply changes.\n\n"
    },
    {
      "title": "HTTP Proxies",
      "level": 3,
      "content": "There are two parts to configuring Docker to use an HTTP proxy: Configuring the Docker daemon and configuring Docker containers.\n\n"
    },
    {
      "title": "Docker daemon proxy configuration",
      "level": 4,
      "content": "See Docker documentation on configuring Docker daemon to use HTTP proxies.\n\n"
    },
    {
      "title": "Docker container proxy configuration",
      "level": 4,
      "content": "See Docker documentation on configuring proxies for information on how to automatically configure proxies for all containers created using the docker CLI.\n\n"
    },
    {
      "title": "Configuring DNS",
      "level": 3,
      "content": "See Docker's DNS documentation for the documented behavior of DNS within Docker containers and information on customizing DNS configuration. In most cases, the resolvers configured on the host are also configured in the container.\n\nMost DNS resolvers hosted on 127.0.0.0/8 are not supported due to conflicts between the container and host network namespaces. Such resolvers are removed from the container's /etc/resolv.conf. If this would result in an empty /etc/resolv.conf, Google DNS is used instead.\n\nAdditionally, a special case is handled if 127.0.0.53 is the only configured nameserver. In this case, Docker assumes the resolver is systemd-resolved and uses the upstream DNS resolvers from /run/systemd/resolve/resolv.conf.\n\nIf you are using a service such as dnsmasq to provide a local resolver, consider adding a virtual interface with a link local IP address in the 169.254.0.0/16 block for dnsmasq to bind to instead of 127.0.0.1 to avoid the network namespace conflict.\n\n"
    },
    {
      "title": "Images location",
      "level": 3,
      "content": "By default, docker images are located at /var/lib/docker. They can be moved to other partitions, e.g. if you wish to use a dedicated partition or disk for your images. In this example, we will move the images to /mnt/docker.\n\nFirst, stop docker.service, which will also stop all currently running containers and unmount any running images. You may then move the images from /var/lib/docker to the target destination, e.g. cp -r /var/lib/docker /mnt/docker.\n\nConfigure data-root in /etc/docker/daemon.json:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"data-root\": \"/mnt/docker\"\n}\n```\n\nRestart docker.service to apply changes.\n\n"
    },
    {
      "title": "Insecure registries",
      "level": 3,
      "content": "If you decide to use a self signed certificate for your private registries, Docker will refuse to use it until you declare that you trust it. For example, to allow images from a registry hosted at myregistry.example.com:8443, configure insecure-registries in the /etc/docker/daemon.json file:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"insecure-registries\": [\n    \"my.registry.example.com:8443\"\n  ]\n}\n```\n\nRestart docker.service to apply changes.\n\n"
    },
    {
      "title": "IPv6",
      "level": 3,
      "content": "In order to enable IPv6 support in Docker, you will need to do a few things. See [8][dead link 2025-03-15 ⓘ] and [9] for details.\n\nFirstly, enable the ipv6 setting in /etc/docker/daemon.json and set a specific IPv6 subnet. In this case, we will use the private fd00::/80 subnet. Make sure to use a subnet at least 80 bits as this allows a container's IPv6 to end with the container's MAC address which allows you to mitigate NDP neighbor cache invalidation issues.\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"ipv6\": true,\n  \"fixed-cidr-v6\": \"fd00::/80\"\n}\n```\n\nRestart docker.service to apply changes.\n\nFinally, to let containers access the host network, you need to resolve routing issues arising from the usage of a private IPv6 subnet. Add the IPv6 NAT in order to actually get some traffic:\n\n```\n# ip6tables -t nat -A POSTROUTING -s fd00::/80 ! -o docker0 -j MASQUERADE\n```\n\nNow Docker should be properly IPv6 enabled. To test it, you can run:\n\n```\n# docker run curlimages/curl curl -v -6 archlinux.org\n```\n\nIf you use firewalld, you can add the rule like this:\n\n```\n# firewall-cmd --zone=public --add-rich-rule='rule family=\"ipv6\" destination not address=\"fd00::1/80\" source address=\"fd00::/80\" masquerade'\n```\n\nIf you use ufw, you need to first enable ipv6 forwarding following Uncomplicated Firewall#Forward policy. Next you need to edit /etc/default/ufw and uncomment the following lines\n\n```\n/etc/ufw/sysctl.conf\n```\n\n```\nnet/ipv6/conf/default/forwarding=1\nnet/ipv6/conf/all/forwarding=1\n```\n\nThen you can add the iptables rule:\n\n```\n# ip6tables -t nat -A POSTROUTING -s fd00::/80 ! -o docker0 -j MASQUERADE\n```\n\nIt should be noted that, for docker containers created with docker-compose, you may need to set enable_ipv6: true in the networks part for the corresponding network. Besides, you may need to configure the IPv6 subnet. See [10] for details.\n\n"
    },
    {
      "title": "User namespace isolation",
      "level": 3,
      "content": "By default, processes in Docker containers run within the same user namespace as the main dockerd daemon, i.e. containers are not isolated by the user_namespaces(7) feature. This allows the process within the container to access configured resources on the host according to Users and groups#Permissions and ownership. This maximizes compatibility, but poses a security risk if a container privilege escalation or breakout vulnerability is discovered that allows the container to access unintended resources on the host. (One such vulnerability was published and patched in February 2019.)\n\nThe impact of such a vulnerability can be reduced by enabling user namespace isolation. This runs each container in a separate user namespace and maps the UIDs and GIDs inside that user namespace to a different (typically unprivileged) UID/GID range on the host.\n\n- The main dockerd daemon still runs as root on the host. Running Docker in rootless mode is a different feature.\n- Processes in the container are started as the user defined in the USER directive in the Dockerfile used to build the image of the container.\n- All containers are mapped into the same UID/GID range. This preserves the ability to share volumes between containers.\n- Enabling user namespace isolation has several limitations.\n- Enabling user namespace isolation effectively masks existing image and container layers, as well as other Docker objects in /var/lib/docker/, because Docker needs to adjust the ownership of these resources. The upstream documentation recommends to enable this feature on a new Docker installation rather than an existing one.\n\nConfigure userns-remap in /etc/docker/daemon.json. default is a special value that will automatically create a user and group named dockremap for use with remapping.\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"userns-remap\": \"default\"\n}\n```\n\nConfigure /etc/subuid and /etc/subgid with a username/group name, starting UID/GID and UID/GID range size to allocate to the remap user and group. This example allocates a range of 65536 UIDs and GIDs starting at 165536 to the dockremap user and group.\n\n```\n/etc/subuid\n```\n\n```\ndockremap:165536:65536\n```\n\n```\n/etc/subgid\n```\n\n```\ndockremap:165536:65536\n```\n\nRestart docker.service to apply changes.\n\nAfter applying this change, all containers will run in an isolated user namespace by default. The remapping may be partially disabled on specific containers passing the --userns=host flag to the docker command. See [11] for details.\n\n"
    },
    {
      "title": "Rootless Docker daemon",
      "level": 3,
      "content": "To run the Docker daemon itself as a regular user, install the docker-rootless-extrasAUR package.\n\nConfigure /etc/subuid and /etc/subgid with a username/group name, starting UID/GID and UID/GID range size to allocate to the remap user and group.\n\n```\n/etc/subuid\n```\n\n```\nyour_username:165536:65536\n```\n\n```\n/etc/subgid\n```\n\n```\nyour_username:165536:65536\n```\n\nEnable the docker.socket user unit: this will result in docker being started using systemd's socket activation.\n\nFinally set docker socket environment variable:\n\n```\n$ export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/docker.sock\n```\n\n"
    },
    {
      "title": "Enable native overlay diff engine",
      "level": 3,
      "content": "By default, Docker cannot use the native overlay diff engine on Arch Linux, which makes building Docker images slow. If you frequently build images, configure the native diff engine as described in [12]:\n\n```\n/etc/modprobe.d/disable-overlay-redirect-dir.conf\n```\n\n```\noptions overlay metacopy=off redirect_dir=off\n```\n\nThen stop docker.service, reload the overlay module as follows:\n\n```\n# modprobe -r overlay\n# modprobe overlay\n```\n\nYou can then start docker.service again.\n\nTo verify, run docker info and check that Native Overlay Diff is true.\n\n"
    },
    {
      "title": "Arch Linux",
      "level": 3,
      "content": "The following command pulls the archlinux x86_64 image. This is a stripped down version of Arch core without network, etc.\n\n```\n# docker pull archlinux\n```\n\nSee also README.md.\n\nFor a full Arch base, clone the repository from above and build your own image.\n\n```\n$ git clone https://gitlab.archlinux.org/archlinux/archlinux-docker.git\n```\n\nMake sure that the devtools, fakechroot and fakeroot packages are installed.\n\nTo build the base image:\n\n```\n$ make image-base\n```\n\n"
    },
    {
      "title": "Alpine Linux",
      "level": 3,
      "content": "Alpine Linux is a popular choice for small container images, especially for software compiled as static binaries. The following command pulls the latest Alpine Linux image:\n\n```\n# docker pull alpine\n```\n\nAlpine Linux uses the musl libc implementation instead of the glibc libc implementation used by most Linux distributions. Because Arch Linux uses glibc, there are a number of functional differences between an Arch Linux host and an Alpine Linux container that can impact the performance and correctness of software. A list of these differences is documented here.\n\nNote that dynamically linked software built on Arch Linux (or any other system using glibc) may have bugs and performance problems when run on Alpine Linux (or any other system using a different libc). See [13], [14] and [15] for examples.\n\n"
    },
    {
      "title": "Debian",
      "level": 3,
      "content": "The following command pulls the latest debian image:\n\n```\n# docker pull debian\n```\n\nSee the Docker Hub page for a full list of available tags, including both standard and slim versions for each Debian release.\n\n"
    },
    {
      "title": "Distroless",
      "level": 3,
      "content": "Google maintains distroless images which are minimal images without OS components such as package managers or shells, resulting in very small images for packaging software.\n\nSee the GitHub README for a list of images and instructions on their use with various programming languages.\n\n"
    },
    {
      "title": "Get the IP address of a running container",
      "level": 3,
      "content": "To grab the IP address of a running container:\n\n```\n$ docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container-name OR id>\n```\n\n```\n172.17.0.37\n```\n\nFor each running container, the name and corresponding IP address can be listed for use in /etc/hosts:\n\n```\n#!/usr/bin/env sh\nfor ID in $(docker ps -q | awk '{print $1}'); do\n    IP=$(docker inspect --format=\"{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}\" \"$ID\")\n    NAME=$(docker ps | grep \"$ID\" | awk '{print $NF}')\n    printf \"%s %s\\n\" \"$IP\" \"$NAME\"\ndone\n```\n\n"
    },
    {
      "title": "Run graphical programs inside a container",
      "level": 3,
      "content": "This section describes the necessary steps to allow graphical programs (including those that rely on OpenGL or Vulkan) to run on the host's X server.\n\nFirst, the correct drivers, compatible with the host's graphics hardware, need to be installed inside the container. The installation procedure depends on the type of the container, but for containers based on Arch Linux images, refer to OpenGL#Installation and Vulkan#Installation for packages specific to your hardware.\n\nNext, the container must be granted access to the host's X server. In a single-user environment, this can easily be done by running Xhost on the host system, which adds non-network local connections to the access control list:\n\n```\n$ xhost +local:\n```\n\nLastly, the following parameters need to be passed to docker run:\n\n- -e \"DISPLAY=$DISPLAY\" sets the environment variable DISPLAY within the container to the host's display;\n- --mount type=bind,src=/tmp/.X11-unix,dst=/tmp/.X11-unix mounts the host's X server sockets inside the container under the same path;\n- --device=/dev/dri:/dev/dri gives the container access to Direct Rendering Infrastructure devices on the host.\n\nTo confirm that everything is set up correctly, run glxgears from the package mesa-utils, or vkcube from the package vulkan-tools in the container.\n\n"
    },
    {
      "title": "Start Docker Compose projects on boot",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nFirst, create a template unit for Docker Compose which is parameterized by the name of the service (see systemd.service(5) § SERVICE TEMPLATES):\n\n```\n/etc/systemd/system/docker-compose@.service\n```\n\n```\n[Unit]\nDescription=%i service with docker compose\nRequires=docker.service\nAfter=docker.service\n\n[Service]\nWorkingDirectory=/opt/%i\nExecStartPre=-/usr/bin/docker compose pull\nExecStart=/usr/bin/docker compose up --remove-orphans\nExecStop=/usr/bin/docker compose down\nExecReload=/usr/bin/docker compose pull\nExecReload=/usr/bin/docker compose up --remove-orphans\n\n[Install]\nWantedBy=multi-user.target\n```\n\nThen, for each service you would like to run, set up a directory with the Compose file and any other required files (such as .env files) at /opt/project_name. [17]\n\nThen, enable/start docker-compose@project_name.service.\n\n"
    },
    {
      "title": "Using buildx for cross-compiling",
      "level": 3,
      "content": "The buildx CLI plugin makes use of the new BuildKit building toolkit. Install the docker-buildx package. The buildx interface supports building multi-platform images, including architectures other than that of the host.\n\nQEMU is required to cross-compile images. To setup the static build of QEMU within Docker, see the usage information for the multiarch/qemu-user-static image. Otherwise, to setup QEMU on the host system for use with Docker, see QEMU#Chrooting into arm/arm64 environment from x86_64. In either case, your system will be configured for user-mode emulation of the guest architecture.\n\n```\n$ docker buildx ls\n```\n\n```\nNAME/NODE DRIVER/ENDPOINT STATUS  PLATFORMS\ndefault * docker                  \n  default default         running linux/amd64, linux/386, linux/arm64, linux/riscv64, linux/s390x, linux/arm/v7, linux/arm/v6\n```\n\n"
    },
    {
      "title": "Run GPU accelerated Docker containers with NVIDIA GPUs",
      "level": 3,
      "content": "Starting from Docker version 19.03, NVIDIA GPUs are natively supported as Docker devices. NVIDIA Container Toolkit is the recommended way of running containers that leverage NVIDIA GPUs.\n\nInstall the nvidia-container-toolkit package and restart docker. You can now run containers that make use of NVIDIA GPUs using the --gpus option or by registering the NVIDIA container runtime.\n\n"
    },
    {
      "title": "With the --gpus option (recommended)",
      "level": 4,
      "content": "```\n# docker run --gpus all nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nSpecify how many GPUs are enabled inside a container:\n\n```\n# docker run --gpus 2 nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nSpecify which GPUs to use:\n\n```\n# docker run --gpus '\"device=1,2\"' nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nor\n\n```\n# docker run --gpus '\"device=UUID-ABCDEF,1\"' nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nFor more information see the documentation and install guide.\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nIf, when using the above commands, you receive an error such as Failed to initialize NVML: Unknown Error, you can try being more specific in specifying the GPU:\n\n```\n# docker run --gpus all --device /dev/nvidiactl:/dev/nvidiactl --device /dev/nvidia-uvm:/dev/nvidia-uvm --device /dev/nvidia0:/dev/nvidia0 nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nSpecify a capability (graphics, compute, ...) for the container (though this is rarely if ever used this way):\n\n```\n# docker run --gpus all,capabilities=utility nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\n"
    },
    {
      "title": "With NVIDIA container runtime",
      "level": 4,
      "content": "Register the NVIDIA runtime by editing /etc/docker/daemon.json\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"runtimes\": {\n    \"nvidia\": {\n      \"path\": \"/usr/bin/nvidia-container-runtime\",\n      \"runtimeArgs\": []\n    }\n  }\n}\n```\n\nand then restart docker.\n\nThe runtime can also be registered via a command line option to dockerd:\n\n```\n# /usr/bin/dockerd --add-runtime=nvidia=/usr/bin/nvidia-container-runtime\n```\n\nAfterwards GPU accelerated containers can be started with\n\n```\n# docker run --runtime=nvidia nvidia/cuda:9.0-base nvidia-smi\n```\n\nSee also README.md.\n\n"
    },
    {
      "title": "Arch Linux image with CUDA",
      "level": 4,
      "content": "You can use the following Dockerfile to build a custom Arch Linux image with CUDA. It uses the Dockerfile frontend syntax 1.2 to cache pacman packages on the host. The DOCKER_BUILDKIT=1 environment variable must be set on the client before building the Docker image.\n\n```\nDockerfile\n```\n\n```\n# syntax=docker/dockerfile:1.2\n\nFROM archlinux:base-devel\n\n# Install packages\nRUN --mount=type=cache,sharing=locked,target=/var/cache/pacman \\\n    pacman -Syu --noconfirm --needed cuda\n\n# Configure nvidia container runtime\n# https://github.com/NVIDIA/nvidia-container-toolkit/tree/main/cmd/nvidia-container-runtime#environment-variables-oci-spec\nENV NVIDIA_VISIBLE_DEVICES=all\nENV NVIDIA_DRIVER_CAPABILITIES=compute,utility\n```\n\n"
    },
    {
      "title": "Remove Docker and images",
      "level": 2,
      "content": "In case you want to remove Docker entirely you can do this by following the steps below:\n\nCheck for running containers:\n\n```\n# docker ps\n```\n\nList all containers running on the host for deletion:\n\n```\n# docker ps -a\n```\n\nStop a running container:\n\n```\n# docker stop <CONTAINER ID>\n```\n\nKilling still running containers:\n\n```\n# docker kill <CONTAINER ID>\n```\n\nDelete containers listed by ID:\n\n```\n# docker rm <CONTAINER ID>\n```\n\nList all Docker images:\n\n```\n# docker images\n```\n\nDelete images by ID:\n\n```\n# docker rmi <IMAGE ID>\n```\n\nDelete all images, containers, volumes, and networks that are not associated with a container (dangling):\n\n```\n# docker system prune\n```\n\nTo additionally remove any stopped containers and all unused images (not just dangling ones), add the -a flag to the command:\n\n```\n# docker system prune -a\n```\n\nDelete all Docker data (purge directory):\n\n```\n# rm -R /var/lib/docker\n```\n\n"
    },
    {
      "title": "docker0 Bridge gets no IP / no internet access in containers when using systemd-networkd",
      "level": 3,
      "content": "Docker attempts to enable IP forwarding globally, but by default systemd-networkd overrides the global sysctl setting for each defined network profile. Set IPForward=yes in the network profile. See Internet sharing#Enable packet forwarding for details.\n\nWhen systemd-networkd tries to manage the network interfaces created by Docker, e.g. when you configured Name=* or Type=ether in the Match section, this can lead to connectivity issues. The problem should be solved by matching interfaces more specifically, i.e. avoid using Name=* or Type=ether or other wildcard that matches an interface managed by Docker. Verify that networkctl list reports unmanaged in the SETUP column for all networks created by Docker.\n\n- You may need to restart docker.service each time you restart systemd-networkd.service or iptables.service.\n- Also be aware that nftables may block docker connections by default. Use nft list ruleset to check for blocking rules. nft flush chain inet filter forward removes all forwarding rules temporarily. Edit /etc/nftables.conf to make changes permanent. Remember to restart nftables.service to reload rules from the configuration file. See [19] for details about nftables support in Docker.\n\n"
    },
    {
      "title": "Default number of allowed processes/threads too low",
      "level": 3,
      "content": "If you run into error messages like\n\n```\n# e.g. Java\njava.lang.OutOfMemoryError: unable to create new native thread\n# e.g. C, bash, ...\nfork failed: Resource temporarily unavailable\n```\n\nthen you might need to adjust the number of processes allowed by systemd. Edit the docker.service with the following snippet:\n\n```\n[Service]\nTasksMax=infinity\n```\n\nFor more background, look for DefaultLimitNPROC at systemd-system.conf(5) § OPTIONS. And for TasksMax at systemd.resource-control(5) § OPTIONS.\n\n"
    },
    {
      "title": "Error initializing graphdriver: devmapper",
      "level": 3,
      "content": "Note: **This article or section is being considered for removal.** This article or section is being considered for removal.\n\nThis article or section is being considered for removal.\n\nIf systemctl fails to start docker and provides an error:\n\n```\nError starting daemon: error initializing graphdriver: devmapper: Device docker-8:2-915035-pool is not a thin pool\n```\n\nThen, try the following steps to resolve the error. Stop the service, back up /var/lib/docker/ (if desired), remove the contents of /var/lib/docker/, and try to start the service. See https://github.com/moby/moby/issues/21304 for details.\n\n"
    },
    {
      "title": "Failed to create some/path/to/file: No space left on device",
      "level": 3,
      "content": "If you are getting an error message like this:\n\n```\nERROR: Failed to create some/path/to/file: No space left on device\n```\n\nwhen building or running a Docker image, even though you do have enough disk space available, make sure:\n\n- Tmpfs is disabled or has enough memory allocation. Docker might be trying to write files into /tmp but fails due to restrictions in memory usage and not disk space.\n- If you are using XFS, you might want to remove the noquota mount option from the relevant entries in /etc/fstab (usually where /tmp and/or /var/lib/docker reside). Refer to Disk quota for more information, especially if you plan on using and resizing overlay2 Docker storage driver.\n- XFS quota mount options (uquota, gquota, prjquota, etc.) fail during re-mount of the file system. To enable quota for root file system, the mount option must be passed to initramfs as a kernel parameter rootflags=. Subsequently, it should not be listed among mount options in /etc/fstab for the root (/) filesystem.\n\n"
    },
    {
      "title": "Docker-machine fails to create virtual machines using the virtualbox driver",
      "level": 3,
      "content": "In case docker-machine fails to create the VM's using the virtualbox driver, with the following:\n\n```\nVBoxManage: error: VBoxNetAdpCtl: Error while adding new interface: failed to open /dev/vboxnetctl: No such file or directory\n```\n\nSimply reload the virtualbox via CLI with vboxreload.\n\n"
    },
    {
      "title": "Starting Docker breaks KVM bridged networking",
      "level": 3,
      "content": "The issue is that Docker's scripts add some iptables rules to block forwarding on other interfaces other than its own. This is a known issue.\n\nAdjust the solutions below to replace br0 with your own bridge name.\n\nQuickest fix (but turns off all Docker's iptables self-added adjustments, which you may not want):\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"iptables\": false\n}\n```\n\nIf there is already a network bridge configured for KVM, this may be fixable by telling docker about it. See [21] where docker configuration is modified as:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"bridge\": \"br0\"\n}\n```\n\nIf the above does not work, or you prefer to solve the issue through iptables directly, or through a manager like UFW, add this:\n\n```\niptables -I FORWARD -i br0 -o br0 -j ACCEPT\n```\n\nEven more detailed solutions are here.\n\n"
    },
    {
      "title": "Image pulls from Docker Hub are rate limited",
      "level": 3,
      "content": "Beginning on November 1st 2020, rate limiting is enabled for downloads from Docker Hub from anonymous and free accounts. See the rate limit documentation for more information.\n\nUnauthenticated rate limits are tracked by source IP. Authenticated rate limits are tracked by account.\n\nIf you need to exceed the rate limits, you can either sign up for a paid plan or mirror the images you need to a different image registry. You can host your own registry or use a cloud hosted registry such as Amazon ECR, Google Container Registry, Azure Container Registry or Quay Container Registry.\n\nTo mirror an image, use the pull, tag and push subcommands of the Docker CLI. For example, to mirror the 1.19.3 tag of the Nginx image to a registry hosted at cr.example.com:\n\n```\n$ docker pull nginx:1.19.3\n$ docker tag nginx:1.19.3 cr.example.com/nginx:1.19.3\n$ docker push cr.example.com/nginx:1.19.3\n```\n\nYou can then pull or run the image from the mirror:\n\n```\n$ docker pull cr.example.com/nginx:1.19.3\n$ docker run cr.example.com/nginx:1.19.3\n```\n\n"
    },
    {
      "title": "iptables (legacy): unknown option \"--dport\"",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nIf you see this error when running a container, install iptables-nft instead of iptables (legacy) and reboot[22].\n\n"
    },
    {
      "title": "\"Your password will be stored unencrypted\" when running docker login",
      "level": 3,
      "content": "By default Docker will try to use the pass or secretservice binaries to store your registry passwords. If they are not found, it will store them in plain text (base64-encoded) in $HOME/.docker/config.json and print the following message after successfully logging in:\n\n```\n$ WARNING! Your password will be stored unencrypted in /home/username/.docker/config.json.\n```\n\nIf you are using a password manager that implements the Secret Service Freedesktop DBUS API, like KDE's kwallet or GNOME's gnome-keyring, you can install the docker-credential-secretserviceAUR package to store your passwords in them.\n\n"
    },
    {
      "title": "\"Could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network\"",
      "level": 3,
      "content": "Sometimes if you use a lot of Docker projects (ex. using docker-compose) it can happens that you run out of available IPs for Docker containers triggering the error:\n\n```\nCould not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network\n```\n\nAs found on this Docker issue, the defaults are:\n\nTable content:\nType | Default Size | Default Pool\nlocal | /16 | 172.17.0.0/12\nlocal* | /20 | 192.168.0.0/16\n\nThis can be easily fixed increasing the Docker IP space by configuring default-address-pools in /etc/docker/daemon.json increasing the size value from 16 to 24 on the first IP range, keeping the second one unaltered to avoid ip collision on the local network:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  ...\n  \"default-address-pools\" : [\n    {\n      \"base\" : \"172.17.0.0/12\",\n      \"size\" : 24\n    },\n    {\n      \"base\" : \"192.168.0.0/16\",\n      \"size\" : 24\n    }\n  ]\n}\n```\n\nRestart docker.service to apply changes.\n\nMore details and technical explanations can be found on the following excellent article: The definitive guide to docker's default-address-pools option.\n\n"
    },
    {
      "title": "Slow golang compilation",
      "level": 3,
      "content": "Due to a ulimit configuration, building a docker image and its dependances with makepkg is very slow (stuck at \"Entering fakeroot environment...\" step).\n\nIt is related to [23] and [24].\n\nYou can add --ulimit \"nofile=1024:524288\" to your docker build option or create/edit:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"default-ulimits\": {\n    \"nofile\": {\n      \"Name\": \"nofile\",\n      \"Soft\": 1024,\n      \"Hard\": 524288\n    }\n  }\n}\n```\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Official website\n- Arch Linux on docs.docker.com\n- Are Docker containers really secure? — opensource.com\n- Awesome Docker\n- Why A Privileged Container in Docker Is a Bad Idea\n\n"
    }
  ]
}