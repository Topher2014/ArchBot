{
  "title": "PipeWire/Examples",
  "url": "https://wiki.archlinux.org/title/PipeWire/Examples",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- PipeWire\n- PulseAudio/Examples\n\n"
    },
    {
      "title": "Splitting front/rear",
      "level": 3,
      "content": "When using PipeWire as a PulseAudio/JACK replacement, you can set up PipeWire to replicate the PulseAudio example for splitting front/rear. Doing this allows you to send audio streams using PulseAudio to a separate sink for speakers or headphones.\n\nConnect speakers to the line-out port and headphones to the rear port. In pavucontrol set the soundcard used to Analog Surround 4.0 Output. Then using the following commands, make new sinks for the speakers and for the headphones, link the speakers to the front channels and link the headphones to the rear channels:\n\n```\npactl load-module module-null-sink sink_name=speakers object.linger=1 media.class=Audio/Sink channel_map=FL,FR\n pactl load-module module-null-sink sink_name=headphones object.linger=1 media.class=Audio/Sink channel_map=RL,RR\n```\n\nobject.linger=1 keeps the sinks alive after the creating client disconnects. You can name sink_name whatever you want.\n\nIn order to unload module, you can use pw-cli destroy ID, where ID is output of pactl load-module command. Unloading individual modules through pactl unload-module is not currently supported [1]. However, you may use it to unload all module-null-sink modules using pactl unload-module module-null-sink.\n\nUsing jack_connect, connect the monitors of the new sinks to the sound card's playback ports. Find out the name of the channels by running pw-link -iol[2].\n\n```\npw-link speakers:monitor_1 alsa_output.pci-0000_00_14.2.analog-surround-40:playback_FL\n pw-link speakers:monitor_2 alsa_output.pci-0000_00_14.2.analog-surround-40:playback_FR\n pw-link headphones:monitor_1 alsa_output.pci-0000_00_14.2.analog-surround-40:playback_RL\n pw-link headphones:monitor_2 alsa_output.pci-0000_00_14.2.analog-surround-40:playback_RR\n```\n\nTo individually control the volumes, one option is to use ALSA utilities—such as amixer(1)—to control Front and Rear/Surround (ALSA naming) channels. A script to automatically do that depending on what is your currently default PulseAudio sink can be found here.\n\n"
    },
    {
      "title": "Echo cancellation",
      "level": 2,
      "content": "PipeWire can remove your speakers' sounds from your microphone in real time, which makes it possible to attend audio chats without having to use headphones, even while other applications are playing audio.\n\nUsually, voice chat applications do cancel out feedback, but they are only aware of audio that goes through them. As an example, if another voice chat attendant talks on your speakers, the chat application \"knows\" about it and is able to selectively erase this noise from your microphone, which would otherwise be repeated back into the voice chat as an annoying echo. The problems with this approach tend to start when other applications are playing to your speakers, because this audio the voice chat does not know about, and the other participants may hear it and complain. Example situations:\n\n- Playing an online video game while using a separate voice chat application\n- Using a synchronized video playback solution, such as Jellyfin SyncPlay or Watch2Gether, while using a voice chat application\n\nThis is the problem that system-wide echo cancellation solves; instead of having the voice chat app suppress the echo – and fail in the above situations – you make PipeWire do that, which innately \"knows about\" all audio that is played on the speakers.\n\nAssuming a blank PipeWire configuration, system-wide echo cancellation can be enabled by creating a world-readable configuration file in /etc/pipewire/pipewire.conf.d/ whose name ends with \".conf\", for example 60-echo-cancel.conf:\n\nDefault values for \"aec.args\" can be found here, just search for \"webrtc.\" in the \"aec-webrtc.cpp\".\n\n```\ncontext.modules = [\n \n     # Echo cancellation\n     {   name = libpipewire-module-echo-cancel\n         args = {\n             # Monitor mode: Instead of creating a virtual sink into which all\n             # applications must play, in PipeWire the echo cancellation module can read\n             # the audio that should be cancelled directly from the current fallback\n             # audio output\n             monitor.mode = true\n             # The audio source / microphone wherein the echo should be cancelled is not\n             # specified explicitly; the module follows the fallback audio source setting\n             source.props = {\n                 # Name and description of the virtual source where you get the audio\n                 # without echoed speaker output\n                 node.name = \"source_ec\"\n                 node.description = \"Echo-cancelled source\"\n             }\n             aec.args = {\n                 # Settings for the WebRTC echo cancellation engine\n                 webrtc.gain_control = true\n                 webrtc.extended_filter = false\n                 # Other WebRTC echo cancellation settings which may or may not exist\n                 # Documentation for the WebRTC echo cancellation library is difficult\n                 # to find\n                 #webrtc.analog_gain_control = false\n                 #webrtc.digital_gain_control = true\n                 #webrtc.experimental_agc = true\n                 #webrtc.noise_suppression = true\n             }\n         }\n     }\n ]\n```\n\nConfiguration changes such as these require a PipeWire restart (i.e. the pipewire.service and pipewire-pulse.service user unit) to become effective.\n\n"
    },
    {
      "title": "Mixing additional audio into the microphone's audio",
      "level": 2,
      "content": "The echo cancellation example above can be extended to provide a virtual sink that copies audio into your microphone.\n\nIt is a re-creation of PulseAudio/Examples#Mixing additional audio into the microphone's audio and solves the same use-case.\n\nTo achieve this you additionally load two instances of the \"Combine stream\" module, as shown below.\n\nCurrently, after each reboot or PipeWire restart the setup requires manual user action in e.g. Helvum to complete it; see the \"TODO\" comment in the configuration example.\n\n```\ncontext.modules = [\n \n     # (Configuration for system-wide echo cancellation, see above)\n \n     # Audio effects sink (stereo)\n     {   name = libpipewire-module-combine-stream\n         args = {\n             combine.mode = sink\n             node.name = sink_fx\n             node.description = \"Effects sink (play shared audio here)\"\n             combine.props = {\n                 audio.position = [ FL FR ]\n             }\n             stream.props = {\n                 # If you have an upmix configuration in client.conf.d, set the same\n                 # parameters here, or else your sound effects application will not\n                 # be upmixed in your local audio output\n                 #channelmix.upmix = true  # (...)\n                 # Possible alternative: Poor man's stereo upmix, i.e. mirroring front\n                 # to rear speakers\n                 #combine.audio.position = [ FL FR FL FR ]\n                 #audio.position = [ FL FR RL RR ]\n             }\n         }\n     }\n \n     # Main source\n     # Virtual source that supplies these sources mixed together:\n     #  - source_ec (Echo-cancelled source)\n     #  - sink_fx.monitor (Monitor of the audio effects sink)\n     {   name = libpipewire-module-combine-stream\n         args = {\n             combine.mode = source\n             node.name = source_main\n             node.description = \"Main source (record from here)\"\n             #combine.latency-compensate = false\n             combine.props = {\n                 audio.position = [ FL FR ]\n             }\n             stream.rules = [\n                 {   matches = [\n                         {\n                             node.name = \"source_ec\"\n                             media.class = \"Audio/Source\"\n                         }\n                     ]\n                     actions = {\n                         create-stream {\n                         }\n                     }\n                 }\n                 # TODO Block with matches= and actions= that matches the monitor of\n                 # sink_fx and hooks it up to source_main\n                 # No PipeWire configuration known yet that automates this\n                 # See this PipeWire issue for news:\n                 # https://gitlab.freedesktop.org/pipewire/pipewire/-/issues/3710\n                 # For the time being, add the required connections manually in Helvum,\n                 # i.e. connect these points:\n                 #  - sink_fx.monitor_FL -> source_main.output.input_FL\n                 #  - sink_fx.monitor_FR -> source_main.output.input_FR\n             ]\n         }\n     }\n ]\n```\n\n"
    }
  ]
}