{
  "title": "Cifratura del sistema con eCryptfs",
  "url": "https://wiki.archlinux.org/title/Cifratura_del_sistema_con_eCryptfs",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "This article describes basic usage of eCryptfs. It guides you through the process of creating a private and secure encrypted directory within your home directory to store sensitive files and private data.\n\nIn implementation eCryptfs differs from dm-crypt, which provides a block device encryption layer, while eCryptfs is an actual file-system â€“ a stacked cryptographic file system. For comparison of the two you can refer to Data-at-rest encryption#Block device vs stacked filesystem encryption. One distinguished feature is that the encryption is stacked on an existing filesystem; eCryptfs can be mounted onto any single existing directory and does not require a separate partition (or size pre-allocation).\n\n"
    },
    {
      "title": "Basics",
      "level": 2,
      "content": "As mentioned in the summary eCryptfs does not require special on-disk storage allocation effort, such as a separate partition or pre-allocated space. Instead, you can mount eCryptfs on top of any single directory to protect it. That includes, for example, a user's entire home directory or single dedicated directories within it. All cryptographic metadata is stored in the headers of files, so encrypted data can be easily moved, stored for backup and recovered. There are other advantages, but there are also drawbacks, for instance eCryptfs is not suitable for encrypting complete partitions which also means you cannot protect swap space with it (but you can, of course, combine it with Dm-crypt/Swap encryption). If you are just starting to set up disk encryption, swap encryption and other points to consider are covered in Data-at-rest encryption#Preparation.\n\nTo familiarize with eCryptfs a few points:\n\n- As a stacked filesystem, a mounting of an eCryptfs directory refers to mounting a (stacked) encrypted directory to another unencrypted mount point (directory) at Linux kernel runtime.\n- It is possible to share an encrypted directory between users. However, the encryption is linked to one passphrase so this must be shared as well. It is also possible to share a directory with differently encrypted files (different passphrases).\n- Several eCryptfs terms are used throughout the documentation: The encrypted directory is referred to as the lower and the unencrypted as the upper directory throughout the eCryptfs documentation and this article. While not relevant for this article, the Overlay filesystem introduced with Linux 3.18 uses the same upper/lower nomenclature for the stacking of filesystems. The mount passphrase (or key) is what gives access to the encrypted files, i.e. unlocks the encryption. eCryptfs uses the term wrapped passphrase to refer to the cryptographically secured mount passphrase. FEKEK refers to a File's Encryption Key Encryption Key (see kernel documentation). FNEK refers to a File Name Encryption Key, a key to (optionally) encrypt the filenames stored in the encrypted directory.\n\n- The encrypted directory is referred to as the lower and the unencrypted as the upper directory throughout the eCryptfs documentation and this article. While not relevant for this article, the Overlay filesystem introduced with Linux 3.18 uses the same upper/lower nomenclature for the stacking of filesystems.\n- The mount passphrase (or key) is what gives access to the encrypted files, i.e. unlocks the encryption. eCryptfs uses the term wrapped passphrase to refer to the cryptographically secured mount passphrase.\n- FEKEK refers to a File's Encryption Key Encryption Key (see kernel documentation).\n- FNEK refers to a File Name Encryption Key, a key to (optionally) encrypt the filenames stored in the encrypted directory.\n\nBefore using eCryptfs, the following disadvantages should be checked for applicability.\n\n"
    },
    {
      "title": "Deficiencies",
      "level": 3,
      "content": "- Ease of use\n\n- File name length\n\n- Network storage mounts\n\n- Sparse files\n\n"
    },
    {
      "title": "Setup & mounting",
      "level": 2,
      "content": "Before starting setup, check the eCryptfs documentation. The software is distributed with a very comprehensive set of manual pages.\n\neCryptfs has been included in Linux since version 2.6.19. Start by loading the ecryptfs module:\n\n```\n# modprobe ecryptfs\n```\n\nTo actually mount an eCryptfs filesystem, you need to use userspace tools provided by the ecryptfs-utils package. Unfortunately, due to the poor design of these tools, you must choose between three ways of setting up eCryptfs, each with different tradeoffs:\n\n1. Use the high-level #Ubuntu tools, which sets things up automatically, but requires the lower directory to be ~/.Private/, and allows only one encrypted filesystem per user.\n1. Use ecryptfs-simple, which is an easy way to mount eCryptfs filesystems using any lower directory and upper directory.\n1. #Manual setup, which involves separate steps for loading the passphrase and mounting eCryptfs, but allows complete control over the directories and encryption settings.\n\n"
    },
    {
      "title": "Ubuntu tools",
      "level": 3,
      "content": "Most of the user-friendly convenience tools installed by the ecryptfs-utils package assume that a very specific eCryptfs setup is being used, namely the one that is officially used by Ubuntu (where it can be selected as an option during installation). Unfortunately, these choices are not just default options, but are actually hard-coded in the tools. If this setup does not suit your needs, then you cannot use the convenience tools and will have to follow the steps at #Manual setup instead.\n\nThe setup used by these tools is as follows:\n\n- each user can have only one encrypted directory that is managed by these tools: either full $HOME directory encryption, or a single encrypted data directory (by default ~/Private/, but this can be customized).\n- the lower directory for each user is always ~/.Private/Tip: In the case of full home dir encryption, this will be a symlink to the actual location at /home/.ecryptfs/username/.Private/.\n- the encryption options used are: cipher: AES key length: 16 bytes (128 bits) key management scheme: passphrase plaintext passthrough: enabled\n- the configuration / control info for the encrypted directory is stored in a bunch of files at ~/.ecryptfs/Tip: In the case of full home dir encryption, this will be a symlink to the actual location at /home/.ecryptfs/username/.ecryptfs/. Private.mnt [plain text file] - contains the path where the upper directory should be mounted (e.g. /home/lucy or /home/lucy/Private) Private.sig [plain text file] - contains the signature used to identify the mount passphrase in the kernel keyring wrapped-passphrase [binary file] - the mount passphrase, encrypted with the login passphrase auto-mount, auto-umount [empty files] - if they exist, the pam_ecryptfs.so module will (assuming it is loaded) automatically mount/unmount this encrypted directory when the user logs in/out\n\n- either full $HOME directory encryption, or\n- a single encrypted data directory (by default ~/Private/, but this can be customized).\n\n- cipher: AES\n- key length: 16 bytes (128 bits)\n- key management scheme: passphrase\n- plaintext passthrough: enabled\n\n- Private.mnt [plain text file] - contains the path where the upper directory should be mounted (e.g. /home/lucy or /home/lucy/Private)\n- Private.sig [plain text file] - contains the signature used to identify the mount passphrase in the kernel keyring\n- wrapped-passphrase [binary file] - the mount passphrase, encrypted with the login passphrase\n- auto-mount, auto-umount [empty files] - if they exist, the pam_ecryptfs.so module will (assuming it is loaded) automatically mount/unmount this encrypted directory when the user logs in/out\n\n"
    },
    {
      "title": "Encrypting a data directory",
      "level": 4,
      "content": "For a full $HOME directory encryption see #Encrypting a home directory\n\nBefore the data directory encryption is setup, decide whether it should later be mounted manually or automatically with the user log-in.\n\nTo encrypt a single data directory as a user and mount it manually later, run:\n\n```\n$ ecryptfs-setup-private --nopwcheck --noautomount\n```\n\nand follow the instructions. The option --nopwcheck enables you to choose a passphrase different to the user login passphrase and the option --noautomount is self-explanatory. So, if you want to setup the encrypted directory automatically on log-in later, just leave out both options right away.\n\nThe script will automatically create the ~/.Private/ and ~/.ecryptfs/ directory structures as described in the box above. It will also ask for two passphrases:\n\nThe mount point (\"upper directory\") for the encrypted folder will be at ~/Private/ by default. However, you can manually change this right after the setup command has finished running, by doing:\n\n```\n$ mv ~/Private /path/to/new/folder\n$ echo /path/to/new/folder > ~/.ecryptfs/Private.mnt\n```\n\nTo actually use your encrypted folder, you will have to mount it - see #Mounting below.\n\n"
    },
    {
      "title": "Encrypting a home directory",
      "level": 4,
      "content": "The wrapper script ecryptfs-migrate-home will set up an encrypted home directory for a user and take care of migrating any existing files they have in their not yet encrypted home directory.\n\nTo run it, the user must be logged out and own no processes. The best way to achieve this is to log the user out, log into a console as the root user, and check that ps -U username returns no output. You also need to ensure that you have rsync, lsof, and which installed. Once the prerequisites have been met, run:\n\n```\n# modprobe ecryptfs\n# ecryptfs-migrate-home -u username\n```\n\nand follow the instructions. After the wrapper script is complete, follow the instructions for auto-mounting - see #Auto-mounting below. To complete this process, it is imperative that the user logs in before the next reboot.\n\nOnce everything is working, the unencrypted backup of the user's home directory, which is saved to /home/username.random_characters, should be deleted.\n\n"
    },
    {
      "title": "Mounting",
      "level": 4,
      "content": "Executing the wrapper\n\n```\n$ ecryptfs-mount-private\n```\n\nand entering the passphrase is all needed to mount the encrypted directory to the upper directory ~/Private/, described in #Ubuntu tools.\n\nLikewise, executing\n\n```\n$ ecryptfs-umount-private\n```\n\nwill unmount it again.\n\nThe tools include another script useful in accessing the encrypted .Private data or home directory. Executing ecryptfs-recover-private as root will search the system (or an optional specific path) for the directory, interactively query the passphrase for it, and mount the directory. It can, for example, be used from a live-CD or different system to access the encrypted data in case of a recovery. Note that if booting from an Arch Linux ISO you must first install the ecryptfs-utils. Further, it will only be able to mount .Private directories created with the Ubuntu tools.\n\nThe default way to auto-mount an encrypted directory is via PAM. See pam_ecryptfs(8) and - for more details - 'PAM MODULE' in:\n\n```\n/usr/share/doc/ecryptfs-utils/README\n```\n\nFor auto-mounting, it is required that the encrypted directory passphrase is identical to the user's log-in password.\n\nUse these steps to set up auto-mounting:\n\n1. Check if ~/.ecryptfs/auto-mount, ~/.ecryptfs/auto-umount and ~/.ecryptfs/wrapped-passphrase exist (these are automatically created by ecryptfs-setup-private).\n\n2. Add ecryptfs to the pam-stack exactly as following to allow transparent unwrapping of the passphrase on login:\n\nOpen /etc/pam.d/system-auth and after the line containing auth required pam_unix.so (or auth [default=die] pam_faillock.so authfail if present) add:\n\n```\nauth [success=1 default=ignore] pam_succeed_if.so service = systemd-user quiet\nauth    required    pam_ecryptfs.so unwrap\n```\n\nNext, above the line containing password required pam_unix.so (or -password [success=1 default=ignore] pam_systemd_home.so if present) insert:\n\n```\npassword    optional    pam_ecryptfs.so\n```\n\nAnd finally, after the line session required pam_unix.so add:\n\n```\nsession [success=1 default=ignore] pam_succeed_if.so service = systemd-user quiet\nsession    optional    pam_ecryptfs.so unwrap\n```\n\n3. Re-login and check output of mount which should now contain a mountpoint, e.g.:\n\n```\n/home/username/.Private on /home/username/Private type ecryptfs (...)\n```\n\nfor the user's encrypted directory. It should be perfectly readable at ~/Private/.\n\nThe latter should be automatically unmounted and made unavailable when the user logs off.\n\n"
    },
    {
      "title": "ecryptfs-simple",
      "level": 3,
      "content": "Use ecryptfs-simple if you just want to use eCryptfs to mount arbitrary directories the way you can with EncFS. ecryptfs-simple does not require root privileges or entries in /etc/fstab, nor is it limited to hard-coded directories such as ~/.Private/. The package is available to be installed as ecryptfs-simpleAUR and from Xyne's repos.\n\nAs the name implies, usage is simple:\n\nSimple mounting:\n\n```\n$ ecryptfs-simple /path/to/foo /path/to/bar\n```\n\nAutomatic mounting: prompts for options on the first mount of a directory then reloads them next time:\n\n```\n$ ecryptfs-simple -a /path/to/foo /path/to/bar\n```\n\nUnmounting by source directory:\n\n```\n$ ecryptfs-simple -u /path/to/foo\n```\n\nUnmounting by mountpoint:\n\n```\n$ ecryptfs-simple -u /path/to/bar\n```\n\n"
    },
    {
      "title": "Manual setup",
      "level": 3,
      "content": "The following details instructions to set up eCryptfs encrypted directories manually. This involves two steps. First, the passphrase is processed and loaded into the kernel keyring. Second, the filesystem is actually mounted using the key from the keyring.\n\nThere are two ways to add the passphrase to the kernel keyring in the first step. The simpler option is ecryptfs-add-passphrase, which uses a single passphrase to encrypt the files. The disadvantage is that you cannot change the passphrase later. It works like this:\n\n```\n$ ecryptfs-add-passphrase\nPassphrase:\nInserted auth tok with sig [78c6f0645fe62da0] into the user session keyring\n```\n\nYou can also pipe a passphrase into ecryptfs-add-passphrase -. Keep in mind that if you leave your passphrase in a file, it will usually defeat the purpose of using encryption.\n\nAs an alternative to a plain passphrase, you can use a \"wrapped passphrase\", where the files are encrypted using a randomly generated key, which is itself encrypted with your passphrase and stored in a file. In this case, you can change your passphrase by unwrapping the key file with your old passphrase and rewrapping it using your new passphrase.\n\nIn the following we prompt for the wrapping passphrase and do a generation similar to the source and then use ecryptfs-wrap-passphrase to wrap it with the given password to ~/.ecryptfs/wrapped-passphrase:\n\n```\n$ mkdir ~/.ecryptfs\n$ ( stty -echo; printf \"Passphrase: \" 1>&2; read PASSWORD; stty echo; echo 1>&2; head -c 48 /dev/random | base64; echo \"$PASSWORD\"; ) \\\n  | ecryptfs-wrap-passphrase ~/.ecryptfs/wrapped-passphrase >/dev/null\n```\n\nDo not use a passphrase with more than 64 characters as this will result in an error later when using ecryptfs-insert-wrapped-passphrase-into-keyring.\n\nNext, we can enter our passphrase to load the key into the keyring:\n\n```\n$ ( stty -echo; printf \"Passphrase: \" 1>&2; read PASSWORD; stty echo; echo $PASSWORD; ) | ecryptfs-insert-wrapped-passphrase-into-keyring ~/.ecryptfs/wrapped-passphrase -\nInserted auth tok with sig [7c5d3dd8a1b49db0] into the user session keyring\n```\n\nIn either case, when you successfully add the passphrase to the kernel keyring, you will get a \"key signature\" like 78c6f0645fe62da0 which you will need in the next step.\n\nThere are two different ways of manually mounting eCryptfs, described in the following sections. The first way, using mount.ecryptfs_private, can be run as a regular user and involves setting up some configuration files. This method does not allow you to change the encryption settings, such as key size. The second way is to use a raw mount command, which gives you complete control over all settings, but requires you to either run it as root, or add an entry to /etc/fstab which lets a user mount eCryptfs.\n\n"
    },
    {
      "title": "With configuration files",
      "level": 4,
      "content": "This method involves running mount.ecryptfs_private from the ecryptfs-utils package, after first loading your passphrase. This binary requires no root privileges to work by default.\n\nFirst choose a name for your configuration files in ~/.ecryptfs/ and decide on the lower and upper directories. In this example we use secret for the configuration files, put in encrypted data in ~/.secret/, and mount the decrypted files at ~/secret/. Create the required directories:\n\n```\n$ mkdir ~/.secret ~/secret ~/.ecryptfs\n```\n\nNow specify the directories in ~/.ecryptfs/secret.conf, using full paths. Its format looks like the one in /etc/fstab without the mount options:\n\n```\n$ echo \"$HOME/.secret $HOME/secret ecryptfs\" > ~/.ecryptfs/secret.conf\n```\n\nWrite the key signature you got from ecryptfs-add-passphrase or ecryptfs-insert-wrapped-passphrase-into-keyring (see above) into ~/.ecryptfs/secret.sig:\n\n```\n$ echo 78c6f0645fe62da0 > ~/.ecryptfs/secret.sig\n```\n\nIf you also want to enable filename encryption, add a second passphrase to the keyring (or reuse the first passphrase) and append its key signature to ~/.ecryptfs/secret.sig:\n\n```\n$ echo 326a6d3e2a5d444a >> ~/.ecryptfs/secret.sig\n```\n\nFinally, mount ~/.secret/ on ~/secret/:\n\n```\n$ mount.ecryptfs_private secret\n```\n\nWhen you are done, unmount it:\n\n```\n$ umount.ecryptfs_private secret\n```\n\n"
    },
    {
      "title": "Raw mount command",
      "level": 4,
      "content": "By running the actual mount command manually, you get complete control over the encryption options. The disadvantage is that you need to either run mount as root, or add an entry to /etc/fstab for each eCryptfs directory so users can mount them.\n\nFirst create your private directories. In this example, we use the same ones as the previous section:\n\n```\n$ mkdir -m 700 ~/.secret\n$ mkdir -m 500 ~/secret\n```\n\nTo summarize:\n\n- Actual encrypted data will be stored in the lower ~/.secret/ directory\n- While mounted, decrypted data will be available in ~/secret/ directory While not mounted nothing can be written to this directory While mounted it has the same permissions as the lower directory\n\n- While not mounted nothing can be written to this directory\n- While mounted it has the same permissions as the lower directory\n\nNow, supposed you have created the wrapped keyphrase above, you need to insert the encryption key once to the root user's keyring:\n\n```\n# ( stty -echo; printf \"Passphrase: \" 1>&2; read PASSWORD; stty echo; echo $PASSWORD; ) | ecryptfs-insert-wrapped-passphrase-into-keyring /home/username/.ecryptfs/wrapped-passphrase -\nInserted auth tok with sig [7c5d3dd8a1b49db0] into the user session keyring\n```\n\nso that the following mount command succeeds:\n\n```\n# mount -i -t ecryptfs /home/username/.secret /home/username/secret -o ecryptfs_sig=7c5d3dd8a1b49db0,ecryptfs_fnek_sig=7c5d3dd8a1b49db0,ecryptfs_cipher=aes,ecryptfs_key_bytes=32,ecryptfs_unlink_sigs\n```\n\n- ecryptfs_sig sets the data passphrase key signature.\n- ecryptfs_fnek_sig sets the filename passphrase key signature; you can omit this option if you do not want to encrypt filenames.\n- ecryptfs_key_bytes can be 16, 24, or 32 to change the encryption key size.\n- ecryptfs_unlink_sigs will remove the passphrase(s) from the keyring when you unmount, so you have to add the passphrase(s) back again in order to re-mount the filesystem.\n- There are a few other options listed in ecryptfs(7) Â§ OPTIONS.\n\nOnce you have chosen the right mount options, you can add an entry to /etc/fstab so regular users can mount eCryptfs on these directories. Copy the mount options to a new /etc/fstab entry and add the options user and noauto. The full entry will look similar to (bold entries added):\n\n```\n/etc/fstab\n```\n\n```\n/home/username/.secret /home/username/secret ecryptfs noauto,user,ecryptfs_sig=7c5d3dd8a1b49db0,ecryptfs_fnek_sig=7c5d3dd8a1b49db0,ecryptfs_cipher=aes,ecryptfs_key_bytes=32,ecryptfs_unlink_sigs 0 0\n```\n\n- The noauto option is important, because otherwise systemd will error trying to mount the entry directly on boot.\n- The user option enables to mount the directory as a user. The user mount will default to option noexec. If you want to have at least executable files in your private directory, you can add exec to the fstab options.\n\n- The user mount will default to option noexec. If you want to have at least executable files in your private directory, you can add exec to the fstab options.\n\nThe setup is now complete and the directory should be mountable by the user.\n\nTo mount the encrypted directory as the user, the passphrase must be unwrapped and made available in the user's keyring. Following above section example:\n\n```\n$ ecryptfs-insert-wrapped-passphrase-into-keyring ~/.ecryptfs/wrapped-passphrase\nPassphrase:\nInserted auth tok with sig [7c5d3dd8a1b49db0] into the user session keyring\n```\n\nNow the directory can be mounted without the mount helper questions:\n\n```\n$ mount -i ~/secret\n```\n\nand files be placed into the secret directory. The above two steps are necessary every time to mount the directory manually.\n\nTo unmount it again:\n\n```\n$ umount ~/secret\n```\n\nTo finalize, the preliminary passphrase to wrap the encryption passphrase may be changed:\n\n```\n$ ecryptfs-rewrap-passphrase ~/.ecryptfs/wrapped-passphrase\nOld wrapping passphrase:\nNew wrapping passphrase:\nNew wrapping passphrase (again):\n```\n\nThe unmounting should also clear the keyring, to check the user's keyring or clear it manually:\n\n```\n$ keyctl list @u\n$ keyctl clear @u\n```\n\nDifferent methods can be employed to automount the previously defined user-mount in /etc/fstab on login. As a first general step, follow point (1) and (2) of #Auto-mounting.\n\nThen, if you login via console, a simple way is to specify the user-interactive mount and umount in the user's shell configuration files, for example Bash#Configuration files.\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nAnother method is to automount the eCryptfs directory on user login using pam_mount. To configure this method, add the following lines to /etc/security/pam_mount.conf.xml:\n\n```\n<luserconf name=\".pam_mount.conf.xml\" />\n<mntoptions require=\"\" /> \n<lclmount>mount -iÂ %(VOLUME) \"%(before=\\\"-o\\\" OPTIONS)\"</lclmount>\n```\n\nPlease prefer writing manually these lines instead of simply copy/pasting them (especially the lclmount line). Otherwise, you might get some corrupted characters. Explanation:\n\n- the first line indicates where the user-based configuration file is located (here ~/.pam_mount.conf.xml)\n- the second line overwrites the default required mount options which are unnecessary (\"nosuid,nodev\")\n- the last line indicates which mount command to run (eCryptfs needs the -i switch).\n\nThen set the volume definition, preferably to ~/.pam_mount.conf.xml:\n\n```\n<pam_mount>\n    <volume noroot=\"1\" fstype=\"ecryptfs\" path=\"/home/username/.secret/\" mountpoint=\"/home/username/secret/\" />\n</pam_mount>\n```\n\n\"noroot\" is needed because the encryption key will be added to the user's keyring.\n\nFinally, edit /etc/pam.d/system-login as described in the pam_mount article.\n\nTo avoid needlessly wasting time unwrapping the passphrase, you can create a script that will check pmvarrun to see the number of open sessions:\n\n```\n/usr/local/bin/doecryptfs\n```\n\n```\n#!/bin/sh\nexit $(/usr/sbin/pmvarrun -u$PAM_USER -o0)\n```\n\nWith the following line added before the eCryptfs unwrap module in your PAM stack:\n\n```\nauth    [success=ignore default=1]    pam_exec.so     quiet /usr/local/bin/doecryptfs\nauth    required                      pam_ecryptfs.so unwrap\n```\n\nThe article suggests adding these to /etc/pam.d/login, but the changes will need to be added to all other places you login, such as /etc/pam.d/kde.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n- point to the above \"Setup & Mounting\" section for how to mount and unmount [this section here will cover all other (i.e. setup-independent) usage info] - reference ecryptfs tools not used/mentioned in the prior sections (e.g. with a short link to the online manpages and mention of the other tools usage, as it seems useful (not covered yet are, e.g. ecryptfs-stat, ecryptfs-find, ecryptfs-rewrite-file.) - mention the options to share an encrypted folder between users and to place non-encrypted files or folders in the encrypted container (\"pass-through\") (references for the points: [5] and (maybe) [6])\n\n"
    },
    {
      "title": "Symlinking into the encrypted directory",
      "level": 3,
      "content": "Besides using your private directory as storage for sensitive files, and private data, you can also use it to protect application data. Firefox for example has an internal password manager, but the browsing history and cache can also be sensitive. Protecting it is easy:\n\n```\n$ mv ~/.mozilla ~/Private/mozilla\n$ ln -s ~/Private/mozilla ~/.mozilla\n```\n\n"
    },
    {
      "title": "Removal of encryption",
      "level": 3,
      "content": "There are no special steps involved, if you want to remove your private directory. Make sure it is un-mounted and delete the respective lower directory (e.g. ~/.Private/), along with all the encrypted files. After also removing the related encryption signatures and configuration in ~/.ecryptfs/, all is gone.\n\nIf you were using the #Ubuntu tools to setup a single directory encryption, you can directly follow the steps detailed by:\n\n```\n$ ecryptfs-setup-private --undo\n```\n\nand follow the instructions.\n\n"
    },
    {
      "title": "Backup",
      "level": 3,
      "content": "If you want to move a file out of the private directory just move it to the new destination while ~/Private/ is mounted.\n\nWith eCryptfs the cryptographic metadata is stored in the header of the files. Setup variants explained in this article separate the directory with encrypted data from the mount point. The unencrypted mount point is fully transparent and available for a backup. Obviously this has to be considered for automated backups, if one has to avoid leaking sensitive unencrypted data into a backup.\n\nYou can do backups, or incremental backups, of the encrypted (e.g. ~/.Private/) directory, treating it like any other directory.\n\nFurther points to note:\n\n- If you used the Ubuntu tools for #Encrypting a home directory, be aware the location of the lower directory with the encrypted files is outside the regular user's $HOME at /home/.ecryptfs/username/.Private/.\n- It should be ensured to include the eCryptfs setup files (located in ~/.ecryptfs/ usually) into the regular or a separate backup.\n- If you use special filesystem mount options, for example ecryptfs_xattr, do extra checks on restore integrity.\n\n"
    },
    {
      "title": "Mounting may fail on a remote host when connecting via Mosh",
      "level": 3,
      "content": "This is a known issue of Mosh server, which does not keep the eCryptfs /home directory mounted.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- eCryptfs - Manpages and project home\n- Security audit of eCryptfs by Taylor Hornby (January 22, 2014).\n- eCryptfs and $HOME by Adrian C. (anrxc) - Article with installation instructions and discussion of eCryptfs usage\n- Chromium data protection (November 2009) - Design document detailing encryption options for Chromium OS, including explanation on its eCryptfs usage\n- eCryptfs design by Michael Halcrow (May 2005) - Original design document detailing and discussing eCryptfs\n\n"
    }
  ]
}