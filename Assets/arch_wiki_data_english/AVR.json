{
  "title": "AVR",
  "url": "https://wiki.archlinux.org/title/AVR",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "AVR is a family of microcontrollers (MCUs) developed by Microchip Technology (former AVR). AVRs are especially common in hobbyist and educational embedded applications, popularized by Arduino project. This page deals with 8-bit series of these MCUs.\n\n"
    },
    {
      "title": "Toolchain",
      "level": 2,
      "content": "Install avr-gcc to get toolchain and GNU compiler.\n\n"
    },
    {
      "title": "Programmers",
      "level": 2,
      "content": "To flash compiled firmware to the AVR chip you will need programmer and software to rule it. Most popular programmers are USBasp, AVRISP mkII, Atmel-ICE and STK500. There also exists a simple DIY-programmer which works with LPT port. avrdude supports them all great.\n\n"
    },
    {
      "title": "udev rules",
      "level": 3,
      "content": "To be able to run avrdude without superuser rights, a Udev rule needs to be created to change ownership of the usb device to another group (the commonly used group for this is uucp):\n\n```\n/etc/udev/rules.d/99-avrprogrammer.rules\n```\n\n```\n# Set group for a programmer matching with vendor and product IDs\n SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"your Vendor ID\", ATTRS{idProduct}==\"your Product ID\", GROUP=\"uucp\", MODE=\"0666\"\n```\n\nReplace the italic parts with your programmer's vendor and product IDs (these can be found with the lsusb command from usbutils) and add the uucp group to your user's supplementary groups.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "To compile C program for AVR chip (let us consider ATmega8A running at 8 MHz as example) you can use avr-gcc directly. You should only specify target MCU (full list of supported MCUs could be found with avr-gcc(1) § mmcu=) and its working frequency:\n\n```\n$ avr-gcc -DF_CPU=8000000UL -mmcu=atmega8a -std=gnu99 main.c -o main.elf\n```\n\navrdude is smart enough to work with the resulting ELF file but you can convert it explicitly to Intel HEX:\n\n```\n$ avr-objcopy -O ihex -j .text -j .data main.elf main.hex\n```\n\nThen run avrdude and specify flash ROM as destination for firmware burning (in this example AVRISP mkII is used and clock speed is lowered to the 125 kHz to be on safe side):\n\n```\n$ avrdude -p atmega8 -c avrispmkII -B 125kHz -U flash:w:main.hex\n```\n\nThat's all. Among other things avrdude can work with EEPROM memory, fuse and lock bits. For example, to set up low and high fuses to the 0x9F and 0xD1 respectively use the following incantation:\n\n```\n$ avrdude -p atmega8 -c avrispmkII -B 125kHz -U lfuse:w:0x9F:m -U hfuse:w:0xD1:m\n```\n\nJust remember that ISP programming speed should not exceed 1/8 of MCU's working frequency. A lot of new chips comes with 1 MHz speed settings so using 125 kHz as starting value should be fine enough.\n\n"
    },
    {
      "title": "Optimization",
      "level": 3,
      "content": "Because AVRs come with tight flash ROM size and relatively weak CPUs you can consider some optimizations to improve space usage and overall performance of your device. It is common practice to enable GCC optimization level -Os and turn on some extra features: -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums. To exclude unnecessary library references perform garbage collection: -ffunction-sections -fdata-sections -Wl,--gc-sections.\n\n"
    },
    {
      "title": "Sample Makefile",
      "level": 3,
      "content": "Managing huge project could be tedious and Makefile workflow is the most efficient way to deal with it. Here are sample Makefile based on AVRfreaks version:\n\n```\nCC = avr-gcc\nOBJCOPY = avr-objcopy\nSIZE = avr-size\nNM = avr-nm\nAVRDUDE = avrdude\nREMOVE = rm -f\n\nMCU = atmega8a\nF_CPU = 8000000\n\nLFUSE = 0x9f\nHFUSE = 0xd1\n\nTARGET = firmware\nSRC = main.c lcd.c twi.c\nOBJ = $(SRC:.c=.o)\nLST = $(SRC:.c=.lst)\n\nFORMAT = ihex\n\nOPTLEVEL = s\n\nCDEFS = \n\nCFLAGS = -DF_CPU=$(F_CPU)UL\nCFLAGS += $(CDEFS)\nCFLAGS += -O$(OPTLEVEL)\nCFLAGS += -mmcu=$(MCU)\nCFLAGS += -std=gnu99\nCFLAGS += -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums\nCFLAGS += -ffunction-sections -fdata-sections\nCFLAGS += -Wall -Wstrict-prototypes\nCFLAGS += -Wa,-adhlns=$(<:.c=.lst)\n\nLDFLAGS = -Wl,--gc-sections\nLDFLAGS += -Wl,--print-gc-sections\n\nAVRDUDE_MCU = atmega8\nAVRDUDE_PROGRAMMER = avrispmkII\nAVRDUDE_SPEED = -B 1MHz\n\nAVRDUDE_FLAGS = -p $(AVRDUDE_MCU)\nAVRDUDE_FLAGS += -c $(AVRDUDE_PROGRAMMER)\nAVRDUDE_FLAGS += $(AVRDUDE_SPEED)\n\nMSG_LINKING = Linking:\nMSG_COMPILING = Compiling:\nMSG_FLASH = Preparing HEX file:\n\nall: gccversion $(TARGET).elf $(TARGET).hex size\n\n.SECONDARY: $(TARGET).elf\n.PRECIOUS: $(OBJ)\n\n%.hex: %.elf\n        @echo\n        @echo $(MSG_FLASH) $@\n        $(OBJCOPY) -O $(FORMAT) -j .text -j .data $< $@\n\n%.elf: $(OBJ)\n        @echo\n        @echo $(MSG_LINKING) $@\n        $(CC) -mmcu=$(MCU) $(LDFLAGS) $^ --output $(@F)\n\n%.o : %.c\n        @echo $(MSG_COMPILING) $<\n        $(CC) $(CFLAGS) -c $< -o $(@F)\n\ngccversion:\n        @$(CC) --version\n\nsize: $(TARGET).elf\n        @echo\n        $(SIZE) -C --mcu=$(AVRDUDE_MCU) $(TARGET).elf\n\nanalyze: $(TARGET).elf\n        $(NM) -S --size-sort -t decimal $(TARGET).elf\n\nisp: $(TARGET).hex\n        $(AVRDUDE) $(AVRDUDE_FLAGS) -U flash:w:$(TARGET).hex\n\nfuses:\n        $(AVRDUDE) $(AVRDUDE_FLAGS) -U lfuse:w:$(LFUSE):m -U hfuse:w:$(HFUSE):m\n\nrelease: fuses isp\n\nclean:\n        $(REMOVE) $(TARGET).hex $(TARGET).elf $(OBJ) $(LST) *~\n```\n\n"
    },
    {
      "title": "Calculating control register values",
      "level": 3,
      "content": "To speed up development of your projects you can use avrcalcAUR utility which helps to calculate different parameters for control registers regarding timers, frequencies etc.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Arduino\n- https://www.microchip.com/design-centers/8-bit/avr-mcus\n\n"
    }
  ]
}