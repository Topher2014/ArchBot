{
  "title": "Z shell",
  "url": "https://wiki.archlinux.org/title/Z_shell",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Zsh is a powerful shell that operates as both an interactive shell and as a scripting language interpreter. While being compatible with the POSIX sh (not by default, only if issuing emulate sh), it offers advantages such as improved tab completion and globbing.\n\nThe Zsh FAQ offers more reasons to use Zsh.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Before starting, users may want to see what shell is currently being used:\n\n```\n$ echo $SHELL\n```\n\nInstall the zsh package. For additional completion definitions, install the zsh-completions package as well.\n\n"
    },
    {
      "title": "Initial configuration",
      "level": 3,
      "content": "Make sure that Zsh has been installed correctly by running the following in a terminal:\n\n```\n$ zsh\n```\n\nYou should now see zsh-newuser-install, which will walk you through some basic configuration. If you want to skip this, press q. If you did not see it, you can invoke it manually with:\n\n```\n$ autoload -Uz zsh-newuser-install\n$ zsh-newuser-install -f\n```\n\n"
    },
    {
      "title": "Making Zsh your default shell",
      "level": 3,
      "content": "Change your shell to /usr/bin/zsh. See Command-line shell#Changing your default shell.\n\n"
    },
    {
      "title": "Startup/Shutdown files",
      "level": 2,
      "content": "- If $ZDOTDIR is not set, $HOME is used instead.\n- If option RCS is unset in any of the files, no configuration files will be read after that file.\n- If option GLOBAL_RCS is unset in any of the files, no global configuration files (/etc/zsh/*) will be read after that file.\n\nWhen starting, Zsh will read commands from the following files in this order by default, provided they exist.\n\n- /etc/zsh/zshenv Used for setting environment variables for all users; it should not contain commands that produce output or assume the shell is attached to a TTY. When this file exists it will always be read, this cannot be overridden.\n- $ZDOTDIR/.zshenv Used for setting user's environment variables; it should not contain commands that produce output or assume the shell is attached to a TTY. When this file exists it will always be read.\n- /etc/zsh/zprofile Used for executing commands at start for all users, will be read when starting as a login shell. Please note that on Arch Linux, by default it contains one line which sources /etc/profile. See warning below before wanting to remove that! /etc/profile This file should be sourced by all POSIX sh-compatible shells upon login: it sets up $PATH and other environment variables and application-specific (/etc/profile.d/*.sh) settings upon login.\n- $ZDOTDIR/.zprofile Used for executing user's commands at start, will be read when starting as a login shell. Typically used to autostart graphical sessions and to set session-wide environment variables.\n- /etc/zsh/zshrc Used for setting interactive shell configuration and executing commands for all users, will be read when starting as an interactive shell.\n- $ZDOTDIR/.zshrc Used for setting user's interactive shell configuration and executing commands, will be read when starting as an interactive shell.\n- /etc/zsh/zlogin Used for executing commands for all users at ending of initial progress, will be read when starting as a login shell.\n- $ZDOTDIR/.zlogin Used for executing user's commands at ending of initial progress, will be read when starting as a login shell. Typically used to autostart command line utilities. Should not be used to autostart graphical sessions, as at this point the session might contain configuration meant only for an interactive shell.\n- $ZDOTDIR/.zlogout Used for executing commands when a login shell exits.\n- /etc/zsh/zlogout Used for executing commands for all users when a login shell exits.\n\n- /etc/profile This file should be sourced by all POSIX sh-compatible shells upon login: it sets up $PATH and other environment variables and application-specific (/etc/profile.d/*.sh) settings upon login.\n\nSee the graphic representation.\n\nNote: **is not sourced** \n\n"
    },
    {
      "title": "Configure Zsh",
      "level": 2,
      "content": "Although Zsh is usable out of the box, it is almost certainly not set up the way most users would like to use it. But due to the sheer amount of customization available in Zsh, configuring Zsh can be a daunting and time-consuming experience. For automatic configuration, see #Third-party extensions.\n\n"
    },
    {
      "title": "Simple .zshrc",
      "level": 3,
      "content": "Included below is a sample configuration file. It provides a decent set of default options as well as giving examples of many ways that Zsh can be customized. In order to use this configuration save it as a file named .zshrc.\n\nHere is a simple .zshrc:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz compinit promptinit\ncompinit\npromptinit\n\n# This will set the default prompt to the walters theme\nprompt walters\n```\n\nSee #Prompt themes for more details about the prompt theme system.\n\n"
    },
    {
      "title": "Configuring $PATH",
      "level": 3,
      "content": "Zsh ties the PATH variable to a path array. This allows you to manipulate PATH by simply modifying the path array. See A User's Guide to the Z-Shell for details.\n\nTo add ~/.local/bin/ to the PATH:\n\n```\n~/.zshenv\n```\n\n```\ntypeset -U path PATH\npath=(~/.local/bin $path)\nexport PATH\n```\n\n"
    },
    {
      "title": "Command completion",
      "level": 3,
      "content": "Perhaps the most compelling feature of Zsh is its advanced autocompletion abilities. At the very least, enable autocompletion in .zshrc. To enable autocompletion, add the following to your ~/.zshrc:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz compinit\ncompinit\n```\n\nThe above configuration includes ssh/scp/sftp hostnames completion but in order for this feature to work, users must not enable ssh's hostname hashing (i.e. option HashKnownHosts in ssh client configuration).\n\nFor autocompletion with an arrow-key driven interface, add the following to:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion:*' menu select\n```\n\nTo activate the menu, press Tab twice.\n\nFor enabling autocompletion of privileged environments in privileged commands (e.g. if you complete a command starting with sudo, completion scripts will also try to determine your completions with sudo), include:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion::complete:*' gain-privileges 1\n```\n\n"
    },
    {
      "title": "Custom completion",
      "level": 4,
      "content": "You can write custom completions on your own. Should you do so, you can refer to the zshcompsys(1) man page.\n\nNote that the official documentation can be hard to read. You can consider trying the simpler zsh-completion-howto tutorial for an easy start.\n\n"
    },
    {
      "title": "Key bindings",
      "level": 3,
      "content": "Zsh does not use readline, instead it uses its own and more powerful Zsh Line Editor (ZLE). It does not read /etc/inputrc or ~/.inputrc. Read A closer look at the zsh line editor and creating custom widgets for an introduction to ZLE configuration.\n\nZLE has an Emacs mode and a vi mode. If one of the VISUAL or EDITOR environment variables contain the string vi then vi mode will be used; otherwise, it will default to Emacs mode. Set the mode explicitly with bindkey -e or bindkey -v respectively for Emacs mode or vi mode. The delay of pressing Esc key in vi mode is 0.4s by default, and you can make it shorter (0.05s) with export KEYTIMEOUT=5.\n\nKey bindings are assigned by mapping an escape sequence matching a keypress to a ZLE widget. The available widgets, with descriptions of their actions and their default keybindings, are listed in zshzle(1) § STANDARD WIDGETS and zshcontrib(1) § ZLE FUNCTIONS.\n\nThe recommended way to set key bindings in Zsh is by using string capabilities from terminfo(5). For example[1][2]:\n\n```\n~/.zshrc\n```\n\n```\n# create a zkbd compatible hash;\n# to add other keys to this hash, see: man 5 terminfo\ntypeset -g -A key\n\nkey[Home]=\"${terminfo[khome]}\"\nkey[End]=\"${terminfo[kend]}\"\nkey[Insert]=\"${terminfo[kich1]}\"\nkey[Backspace]=\"${terminfo[kbs]}\"\nkey[Delete]=\"${terminfo[kdch1]}\"\nkey[Up]=\"${terminfo[kcuu1]}\"\nkey[Down]=\"${terminfo[kcud1]}\"\nkey[Left]=\"${terminfo[kcub1]}\"\nkey[Right]=\"${terminfo[kcuf1]}\"\nkey[PageUp]=\"${terminfo[kpp]}\"\nkey[PageDown]=\"${terminfo[knp]}\"\nkey[Shift-Tab]=\"${terminfo[kcbt]}\"\n\n# setup key accordingly\n[[ -n \"${key[Home]}\"      ]] && bindkey -- \"${key[Home]}\"       beginning-of-line\n[[ -n \"${key[End]}\"       ]] && bindkey -- \"${key[End]}\"        end-of-line\n[[ -n \"${key[Insert]}\"    ]] && bindkey -- \"${key[Insert]}\"     overwrite-mode\n[[ -n \"${key[Backspace]}\" ]] && bindkey -- \"${key[Backspace]}\"  backward-delete-char\n[[ -n \"${key[Delete]}\"    ]] && bindkey -- \"${key[Delete]}\"     delete-char\n[[ -n \"${key[Up]}\"        ]] && bindkey -- \"${key[Up]}\"         up-line-or-history\n[[ -n \"${key[Down]}\"      ]] && bindkey -- \"${key[Down]}\"       down-line-or-history\n[[ -n \"${key[Left]}\"      ]] && bindkey -- \"${key[Left]}\"       backward-char\n[[ -n \"${key[Right]}\"     ]] && bindkey -- \"${key[Right]}\"      forward-char\n[[ -n \"${key[PageUp]}\"    ]] && bindkey -- \"${key[PageUp]}\"     beginning-of-buffer-or-history\n[[ -n \"${key[PageDown]}\"  ]] && bindkey -- \"${key[PageDown]}\"   end-of-buffer-or-history\n[[ -n \"${key[Shift-Tab]}\" ]] && bindkey -- \"${key[Shift-Tab]}\"  reverse-menu-complete\n\n# Finally, make sure the terminal is in application mode, when zle is\n# active. Only then are the values from $terminfo valid.\nif (( ${+terminfo[smkx]} && ${+terminfo[rmkx]} )); then\n\tautoload -Uz add-zle-hook-widget\n\tfunction zle_application_mode_start { echoti smkx }\n\tfunction zle_application_mode_stop { echoti rmkx }\n\tadd-zle-hook-widget -Uz zle-line-init zle_application_mode_start\n\tadd-zle-hook-widget -Uz zle-line-finish zle_application_mode_stop\nfi\n```\n\n"
    },
    {
      "title": "History search",
      "level": 4,
      "content": "You need to set up the key array and make sure that ZLE enters application mode to use the following instructions; see #Key bindings.\n\nTo enable history search add these lines to .zshrc file:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz up-line-or-beginning-search down-line-or-beginning-search\nzle -N up-line-or-beginning-search\nzle -N down-line-or-beginning-search\n\n[[ -n \"${key[Up]}\"   ]] && bindkey -- \"${key[Up]}\"   up-line-or-beginning-search\n[[ -n \"${key[Down]}\" ]] && bindkey -- \"${key[Down]}\" down-line-or-beginning-search\n```\n\nBy doing this, only the past commands matching the current line up to the current cursor position will be shown when Up or Down keys are pressed.\n\n"
    },
    {
      "title": "Shift, Alt, Ctrl and Meta modifiers",
      "level": 4,
      "content": "xterm-compatible terminals can use extended key-definitions from user_caps(5). Those are combinations of Shift, Alt, Ctrl and Meta together with Up, Down, Left, Right, PageUp, PageDown, Home, End or Del. Refer to the zkbd source for a list of recommended names for the modifier keys and key combinations.\n\nFor example, for Ctrl+Left to move to the beginning of the previous word and Ctrl+Right to move to the beginning of the next word:\n\n```\n~/.zshrc\n```\n\n```\nkey[Control-Left]=\"${terminfo[kLFT5]}\"\nkey[Control-Right]=\"${terminfo[kRIT5]}\"\n\n[[ -n \"${key[Control-Left]}\"  ]] && bindkey -- \"${key[Control-Left]}\"  backward-word\n[[ -n \"${key[Control-Right]}\" ]] && bindkey -- \"${key[Control-Right]}\" forward-word\n```\n\n"
    },
    {
      "title": "Prompts",
      "level": 3,
      "content": "Zsh offers the options of using a prompt theme or, for users who are dissatisfied with the themes (or want to expand their usefulness), the possibility to build a custom prompt.\n\n"
    },
    {
      "title": "Prompt themes",
      "level": 4,
      "content": "Prompt themes are a quick and easy way to set up a colored prompt in Zsh. See zshcontrib(1) § PROMPT THEMES for information about prompt themes and how to write your own theme.\n\nTo use a theme, make sure that prompt theme system is set to autoload in .zshrc. This can be done by adding these lines to:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz promptinit\npromptinit\n```\n\nAvailable prompt themes are listed by running the command:\n\n```\n$ prompt -l\n```\n\nFor example, to use the walters theme, enter:\n\n```\n$ prompt walters\n```\n\nTo preview all available themes, use this command:\n\n```\n$ prompt -p\n```\n\nIt is possible to install themes manually, without external configuration manager tools. For a local installation, first create a folder and add it to the fpath array, eg:\n\n```\n$ mkdir ~/.zprompts\n$ fpath=(\"$HOME/.zprompts\" \"$fpath[@]\")\n```\n\nNow create a symbolic link of your theme file in this folder:\n\n```\n$ ln -s mytheme.zsh ~/.zprompts/prompt_mytheme_setup\n```\n\nIf instead you wish to install a theme globally, do:\n\n```\n# ln -s mytheme.zsh /usr/share/zsh/functions/Prompts/prompt_mytheme_setup\n```\n\nNow you should be able to activate it using:\n\n```\n$ prompt mytheme\n```\n\nIf everything works, you can edit your .zshrc accordingly.\n\nIn addition to adding a prompt theme through its own file, it is possible to add themes from within another file (like your .zshrc), eg:\n\n```\n~/.zshrc\n```\n\n```\n# Load promptinit\nautoload -Uz promptinit && promptinit\n\n# Define the theme\nprompt_mytheme_setup() {\n  PS1=\"%~%# \"\n}\n\n# Add the theme to promptsys\nprompt_themes+=( mytheme )\n\n# Load the theme\nprompt mytheme\n```\n\n"
    },
    {
      "title": "Customized prompt",
      "level": 4,
      "content": "Additionally to a primary left-sided prompt PS1 (PROMPT, prompt) that is common to all shells, Zsh also supports a right-sided prompt RPS1 (RPROMPT). These two variables are the ones you will want to set to a custom value.\n\nOther special purpose prompts, such as PS2 (PROMPT2), PS3 (PROMPT3), PS4 (PROMPT4), RPS1 (RPROMPT), RPS2 (RPROMPT2) and SPROMPT, are explained in zshparam(1) § PARAMETERS USED BY THE SHELL.\n\nAll prompts can be customized with prompt escapes. The available prompt escapes are listed in zshmisc(1) § EXPANSION OF PROMPT SEQUENCES.\n\nZsh sets colors differently than Bash; You do not need to use profuse ANSI escape sequences or terminal capabilities from terminfo(5). Zsh provides convenient prompt escapes to set the foreground color, background color and other visual effects; see zshmisc(1) § Visual effects for a list of them and their descriptions.\n\nColors can be specified using a decimal integer, the name of one of the eight most widely-supported colors or as a # followed by an RGB triplet in hexadecimal format. See the description of fg=colour in zshzle(1) § CHARACTER HIGHLIGHTING for more details.\n\nMost terminals support the following colors by name:\n\nTable content:\nName | Number\nblack | 0\nred | 1\ngreen | 2\nyellow | 3\nblue | 4\nmagenta | 5\ncyan | 6\nwhite | 7\n\nColor numbers 0–255 for terminal emulators compatible with xterm 256 colors can be found in the xterm-256color chart.\n\nWith a correctly set TERM environment variable, the terminal's supported maximum number of colors can be found from the terminfo(5) database using echoti colors. In the case of 24-bit colors, also check the COLORTERM environment variable with print $COLORTERM. If it returns 24bit or truecolor then your terminal supports 16777216 (224) colors even if terminfo shows a smaller number.\n\n- The colors 0–15 may differ between terminal emulators and their used color schemes.\n- Many terminal emulators display bold with a brighter color.\n\n- Prompt escapes can be tested with command print -P \"prompt escapes\", for example: $ print -P '%B%F{red}co%F{green}lo%F{blue}rs%f%b'\n- If you use 24-bit colors, you might want to load the zsh/nearcolor module in terminals that do not support them. E.g.: [[ \"$COLORTERM\" == (24bit|truecolor) || \"${terminfo[colors]}\" -eq '16777216' ]] || zmodload zsh/nearcolor See zshmodules(1) § THE ZSH/NEARCOLOR MODULE for details about the zsh/nearcolor module.\n\n```\n$ print -P '%B%F{red}co%F{green}lo%F{blue}rs%f%b'\n```\n\n```\n[[ \"$COLORTERM\" == (24bit|truecolor) || \"${terminfo[colors]}\" -eq '16777216' ]] || zmodload zsh/nearcolor\n```\n\nAn example of a simple colorless prompt:\n\n```\nPROMPT='%n@%m %~ %# '\n```\n\nHow it will be displayed:\n\nThis is an example of a two-sided prompt with color:\n\n```\nPROMPT='%F{green}%n%f@%F{magenta}%m%f %F{blue}%B%~%b%f %# '\nRPROMPT='[%F{yellow}%?%f]'\n```\n\nAnd here is how it will be displayed:\n\nTo use colors from the 16-255 range and 24-bit true color, you can use the number from 0 to 255 assigned to the wanted color and its hexadecimal color code, respectively:\n\n```\nPROMPT='%F{2}%n%f@%F{5}%m%f %F{4}%B%~%b%f %# '\nRPROMPT='[%F{3}%?%f]'\n```\n\n```\nPROMPT='%F{#c0c0c0}%n%f@%F{#008000}%m%f %F{#800080}%B%~%b%f %# '\nRPROMPT='[%F{#0000ff}%?%f]'\n```\n\n"
    },
    {
      "title": "Sample .zshrc files",
      "level": 3,
      "content": "- To get the same setup as the monthly ISO releases (which use Zsh by default), install grml-zsh-config. It includes the many tweaks and advanced optimizations from grml.\n- https://github.com/MrElendig/dotfiles-alice/blob/master/.zshrc - basic setup, with dynamic prompt and window title/hardinfo.\n- https://github.com/slashbeast/conf-mgmt/blob/master/roles/home_files/files/DOTzshrc - zshrc with multiple features, be sure to check out comments into it. Notable features: confirm function to ensure that user want to run poweroff, reboot or hibernate, support for GIT in prompt (done without vcsinfo), tab completion with menu, printing current executed command into window's title bar and more.\n\nSee dotfiles#User repositories for more.\n\n"
    },
    {
      "title": "Autostart X at login",
      "level": 3,
      "content": "See xinit#Autostart X at login.\n\n"
    },
    {
      "title": "Restore terminal settings after a program exits abnormally",
      "level": 3,
      "content": "Many programs change the terminal state, and often do not restore terminal settings on exiting abnormally (e.g. when crashing or encountering SIGINT).\n\nThis can typically be solved by executing reset(1):\n\n```\n$ reset\n```\n\nThe following sections describe ways to avoid the need to manually reset the terminal.\n\n"
    },
    {
      "title": "The ttyctl command",
      "level": 4,
      "content": "The ttyctl command can be used to \"freeze/unfreeze\" the terminal. To freeze the interactive shell on launch, use the following:\n\n```\n~/.zshrc\n```\n\n```\nttyctl -f\n```\n\n"
    },
    {
      "title": "Resetting the terminal with escape sequences",
      "level": 4,
      "content": "Alternate linedrawing character set can screw up the terminal in a way which ttyctl cannot prevent.\n\nA simple solution is to output the escape sequences that reset the terminal from the precmd hook function, so that they are executed every time before the prompt is drawn. For example, using the escape sequence \\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[0;0r\\e8:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nfunction reset_broken_terminal () {\n\tprintf '%b' '\\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[0;0r\\e8'\n}\n\nadd-zsh-hook -Uz precmd reset_broken_terminal\n```\n\nTo test if it works, run:\n\n```\n$ print '\\e(0\\e)B'\n```\n\n"
    },
    {
      "title": "Dirstack",
      "level": 4,
      "content": "Zsh can be configured to remember the DIRSTACKSIZE last visited folders. This can then be used to cd them very quickly. You need to add some lines to your configuration file:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nDIRSTACKFILE=\"${XDG_CACHE_HOME:-$HOME/.cache}/zsh/dirs\"\nif [[ -f \"$DIRSTACKFILE\" ]] && (( ${#dirstack} == 0 )); then\n\tdirstack=(\"${(@f)\"$(< \"$DIRSTACKFILE\")\"}\")\n\t[[ -d \"${dirstack[1]}\" ]] && cd -- \"${dirstack[1]}\"\nfi\nchpwd_dirstack() {\n\tprint -l -- \"$PWD\" \"${(u)dirstack[@]}\" > \"$DIRSTACKFILE\"\n}\nadd-zsh-hook -Uz chpwd chpwd_dirstack\n\nDIRSTACKSIZE='20'\n\nsetopt AUTO_PUSHD PUSHD_SILENT PUSHD_TO_HOME\n\n## Remove duplicate entries\nsetopt PUSHD_IGNORE_DUPS\n\n## This reverts the +/- operators.\nsetopt PUSHD_MINUS\n```\n\nNow use\n\n```\n$ dirs -v\n```\n\nto print the dirstack. Use cd -<NUM> to go back to a visited folder. Use autocompletion after the dash. This proves very handy if using the autocompletion menu.\n\n- This will not work if you have more than one zsh session open, and attempt to cd, due to a conflict in both sessions writing to the same file.\n- You might need to create $HOME/.cache/zsh directory not to get no such file or directory error.\n\n"
    },
    {
      "title": "cdr",
      "level": 4,
      "content": "cdr allows you to change the working directory to a previous working directory from a list maintained automatically. It stores all entries in files that are maintained across sessions and (by default) between terminal emulators in the current session.\n\nSee zshcontrib(1) § REMEMBERING RECENT DIRECTORIES for setup instructions.\n\n"
    },
    {
      "title": "zoxide",
      "level": 4,
      "content": "zoxide is a smarter cd command that lets you navigate anywhere in just a few keystrokes. It remembers your frequently used directories and uses a scoring mechanism to guess where you want to go.\n\n"
    },
    {
      "title": "Help command",
      "level": 3,
      "content": "Unlike Bash, Zsh does not enable a built in help command, instead it provides run-help. By default run-help is an alias to man, it can be either executed manually by prepending it to a command or it can be invoked for the currently typed command with the keyboard shortcuts Alt+h or Esc h.\n\nSince by default it is just an alias to man, it will only work on external commands. To improve its functionality, so that it works on shell builtins and other shell features, you need to use the run-help function. See zshcontrib(1) for more information on the run-help and its assistant functions.\n\nFirst load the run-help function and then remove the existing run-help alias. For convenience help can be aliased to run-help. For example, add following to your zshrc:\n\n```\nautoload -Uz run-help\n(( ${+aliases[run-help]} )) && unalias run-help\nalias help=run-help\n```\n\nAssistant functions have to be enabled separately:\n\n```\nautoload -Uz run-help-git run-help-ip run-help-openssl run-help-p4 run-help-sudo run-help-svk run-help-svn\n```\n\nFor example, run-help git commit command will now open the man page git-commit(1) instead of git(1).\n\n"
    },
    {
      "title": "Persistent rehash",
      "level": 3,
      "content": "Typically, compinit will not automatically find new executables in the $PATH. For example, after you install a new package, the files in /usr/bin/ would not be immediately or automatically included in the completion. Thus, to have these new executables included, one would run:\n\n```\n$ rehash\n```\n\nThis 'rehash' can be set to happen automatically.[3] Simply include the following in your zshrc:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion:*' rehash true\n```\n\n"
    },
    {
      "title": "On-demand rehash",
      "level": 4,
      "content": "As above, however pacman can be configured with hooks to automatically request a rehash, which does not incur the performance penalty of constant rehashing as above. To enable this, create the /etc/pacman.d/hooks directory, and a /var/cache/zsh directory, then create a hook file:\n\n```\n/etc/pacman.d/hooks/zsh.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nOperation = Remove\nType = Path\nTarget = usr/bin/*\n[Action]\nDepends = zsh\nWhen = PostTransaction\nExec = /usr/bin/install -Dm644 /dev/null /var/cache/zsh/pacman\n```\n\nThis keeps the modification date of the file /var/cache/zsh/pacman consistent with the last time a package was installed, upgraded or removed. Then, zsh must be coaxed into rehashing its own command cache when it goes out of date, by adding to your ~/.zshrc:\n\n```\n~/.zshrc\n```\n\n```\nzshcache_time=\"$(date +%s%N)\"\n\nautoload -Uz add-zsh-hook\n\nrehash_precmd() {\n  if [[ -a /var/cache/zsh/pacman ]]; then\n    local paccache_time=\"$(date -r /var/cache/zsh/pacman +%s%N)\"\n    if (( zshcache_time < paccache_time )); then\n      rehash\n      zshcache_time=\"$paccache_time\"\n    fi\n  fi\n}\n\nadd-zsh-hook -Uz precmd rehash_precmd\n```\n\nIf the precmd hook is triggered before /var/cache/zsh/pacman is updated, completion may not work until a new prompt is initiated. Running an empty command, e.g. pressing enter, should be sufficient.\n\n"
    },
    {
      "title": "Alternative on-demand rehash using SIGUSR1",
      "level": 4,
      "content": "As above, however the hook file looks like this:\n\n```\n/etc/pacman.d/hooks/zsh-rehash.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nOperation = Remove\nType = Path\nTarget = usr/bin/*\n\n[Action]\nDepends = zsh\nDepends = procps-ng\nWhen = PostTransaction\nExec = /usr/bin/pkill zsh --signal=USR1\n```\n\n```\n~/.zshrc\n```\n\n```\nTRAPUSR1() { rehash }\n```\n\nThe function trap above can be replaced with a list trap trap 'rehash' USR1. See zshmisc(1) § Trap Functions for differences between types of traps.\n\nThis method will instantly rehash all zsh instances, removing the need to press enter to trigger precmd.\n\n"
    },
    {
      "title": "Bind key to ncurses application",
      "level": 3,
      "content": "Bind a ncurses application to a keystroke, but it will not accept interaction. Use BUFFER variable to make it work. The following example lets users open ncmpcpp using Alt+\\:\n\n```\n~/.zshrc\n```\n\n```\nncmpcppShow() {\n  BUFFER=\"ncmpcpp\"\n  zle accept-line\n}\nzle -N ncmpcppShow\nbindkey '^[\\' ncmpcppShow\n```\n\nAn alternate method, that will keep everything you entered in the line before calling application:\n\n```\n~/.zshrc\n```\n\n```\nncmpcppShow() {\n  ncmpcpp <$TTY\n  zle redisplay\n}\nzle -N ncmpcppShow\nbindkey '^[\\' ncmpcppShow\n```\n\n"
    },
    {
      "title": "File manager key binds",
      "level": 3,
      "content": "Key binds like those used in graphic file managers may come handy. The first comes back in directory history (Alt+Left), the second let the user go to the parent directory (Alt+Up). They also display the directory content.\n\n```\n~/.zshrc\n```\n\n```\ncdUndoKey() {\n  popd\n  zle       reset-prompt\n  print\n  ls\n  zle       reset-prompt\n}\n\ncdParentKey() {\n  pushd ..\n  zle      reset-prompt\n  print\n  ls\n  zle       reset-prompt\n}\n\nzle -N                 cdParentKey\nzle -N                 cdUndoKey\nbindkey '^[[1;3A'      cdParentKey\nbindkey '^[[1;3D'      cdUndoKey\n```\n\n"
    },
    {
      "title": "xterm title",
      "level": 3,
      "content": "If your terminal emulator supports it, you can set its title from Zsh. This allows dynamically changing the title to display relevant information about the shell state, for example showing the user name and current directory or the currently executing command.\n\nThe xterm title is set with the xterm control sequence operating system command \\e]2;\\a or \\e]2;\\e\\\\. For example:\n\n```\n$ print -n '\\e]2;My xterm title\\a'\n```\n\nwill set the title to\n\n```\nMy xterm title\n```\n\nA simple way to have a dynamic title is to set the title in the precmd and preexec hook functions. See zshmisc(1) § Hook Functions for a list of available hook functions and their descriptions.\n\nBy using print -P you can additionally take advantage of Zsh's prompt escapes.\n\n- Title printing can be split up in multiple commands as long as they are sequential.\n- GNU Screen sends the xterm title to the hardstatus (%h). If you want to use Screen's string escapes (e.g. for colors) you should set the hardstatus with the \\e_\\e\\\\ escape sequence. Otherwise, if string escapes are used in \\e]2;\\a, the terminal emulator will get a garbled title due to it being incapable of interpreting Screen's string escapes.\n\n- Do not use the -P option of print when printing variables to prevent them from being parsed as prompt escapes.\n- Use the q parameter expansion flag when printing variables to prevent them from being parsed as escape sequences.\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nfunction xterm_title_precmd () {\n\tprint -Pn -- '\\e]2;%n@%m %~\\a'\n\t[[ \"$TERM\" == 'screen'* ]] && print -Pn -- '\\e_\\005{2}%n\\005{-}@\\005{5}%m\\005{-} \\005{+b 4}%~\\005{-}\\e\\\\'\n}\n\nfunction xterm_title_preexec () {\n\tprint -Pn -- '\\e]2;%n@%m %~ %# ' && print -n -- \"${(q)1}\\a\"\n\t[[ \"$TERM\" == 'screen'* ]] && { print -Pn -- '\\e_\\005{2}%n\\005{-}@\\005{5}%m\\005{-} \\005{+b 4}%~\\005{-} %# ' && print -n -- \"${(q)1}\\e\\\\\"; }\n}\n\nif [[ \"$TERM\" == (Eterm*|alacritty*|aterm*|foot*|gnome*|konsole*|kterm*|putty*|rxvt*|screen*|wezterm*|tmux*|xterm*) ]]; then\n\tadd-zsh-hook -Uz precmd xterm_title_precmd\n\tadd-zsh-hook -Uz preexec xterm_title_preexec\nfi\n```\n\n"
    },
    {
      "title": "Terminal emulator tab title",
      "level": 4,
      "content": "Some terminal emulators and multiplexers support setting the title of the tab. The escape sequences depend on the terminal:\n\nTable content:\nTerminal | Escape sequences | Description\nGNU Screen | \\ek\\e\\\\ | Screen's window title (%t).\nKonsole | \\e]30;\\a | Konsole's tab title.\n\n"
    },
    {
      "title": "Shell environment detection",
      "level": 3,
      "content": "See a repository about shell environment detection for tests to detect the shell environment. This includes login/interactive shell, Xorg session, TTY and SSH session.\n\n"
    },
    {
      "title": "/dev/tcp equivalent: ztcp",
      "level": 3,
      "content": "Use the zsh/net/tcp module:\n\n```\n$ zmodload zsh/net/tcp\n```\n\nYou can now establish TCP connections:\n\n```\n$ ztcp example.com 80\n```\n\nMore details are available in zshmodules(1) § THE_ZSH/NET/TCP_MODULE and zshtcpsys(1).\n\n"
    },
    {
      "title": "Shortcut to exit shell on partial command line",
      "level": 3,
      "content": "By default, Ctrl+d will not close your shell if the command line is filled, this fixes it:\n\n```\n.zshrc\n```\n\n```\nexit_zsh() { exit }\nzle -N exit_zsh\nbindkey '^D' exit_zsh\n```\n\n"
    },
    {
      "title": "pacman -F \"command not found\" handler",
      "level": 3,
      "content": "pacman includes functionality to search for packages containing a file. The following command-not-found handler will use pacman directly to search for matching packages when an unknown command is executed.\n\n```\n~/.zshrc\n```\n\n```\n...\nfunction command_not_found_handler {\n    local purple='\\e[1;35m' bright='\\e[0;1m' green='\\e[1;32m' reset='\\e[0m'\n    printf 'zsh: command not found: %s\\n' \"$1\"\n    local entries=(\n        ${(f)\"$(/usr/bin/pacman -F --machinereadable -- \"/usr/bin/$1\")\"}\n    )\n    if (( ${#entries[@]} ))\n    then\n        printf \"${bright}$1${reset} may be found in the following packages:\\n\"\n        local pkg\n        for entry in \"${entries[@]}\"\n        do\n            # (repo package version file)\n            local fields=(\n                ${(0)entry}\n            )\n            if [[ \"$pkg\" != \"${fields[2]}\" ]]\n            then\n                printf \"${purple}%s/${bright}%s ${green}%s${reset}\\n\" \"${fields[1]}\" \"${fields[2]}\" \"${fields[3]}\"\n            fi\n            printf '    /%s\\n' \"${fields[4]}\"\n            pkg=\"${fields[2]}\"\n        done\n    fi\n    return 127\n}\n...\n```\n\nFor an alternative using pkgfile, see #pkgfile \"command not found\" handler.\n\n"
    },
    {
      "title": "Clear the backbuffer using a key binding",
      "level": 3,
      "content": "By default, the clear screen keybinding will not clear the backbuffer (the part you need to scroll up for to see it) on most terminal emulators. A possible solution to this problem is the following.\n\n```\n~/.zshrc\n```\n\n```\n...\nfunction clear-screen-and-scrollback() {\n    printf '\\x1Bc'\n    zle clear-screen\n}\n\nzle -N clear-screen-and-scrollback\nbindkey '^L' clear-screen-and-scrollback\n...\n```\n\n"
    },
    {
      "title": "Configuration frameworks",
      "level": 3,
      "content": "- oh-my-posh — Oh My Posh is a custom prompt engine for any shell that has the ability to adjust the prompt string with a function or variable.\n\n- oh-my-zsh — A popular, community-driven framework for managing your Zsh configuration. It comes bundled with a ton of helpful functions, helpers, plugins, themes.\n\n- Prezto — A configuration framework for Zsh. It comes with modules, enriching the command line interface environment with sane defaults, aliases, functions, auto completion, and prompt themes.\n\n- ZIM — A configuration framework with blazing speed and modular extensions. Zim is very easy to customize, and comes with a rich set of modules and features without compromising on speed or functionality.\n\n"
    },
    {
      "title": "Plugin managers",
      "level": 3,
      "content": "- Antidote — A feature complete Zsh implementation of the legacy Antibody plugin manager.\n\n- zinit (previously \"zplugin\") — Flexible Zsh plugin manager with clean fpath, reports, completion management, turbo mode REVIVED\n\n- zi (previously \"zplugin\") — Alternative fork of zplugin aiming to expand on the original project, instead of preservation and maintenance of the original project like zinit.\n\n- sheldon — Fast, configurable, shell plugin manager, written in Rust [4]\n\n- Antigen — A plugin manager for Zsh, inspired by oh-my-zsh and vundle. ABANDONED\n\n- zgen — A lightweight and simple plugin manager for Zsh. ABANDONED\n\n- zplug — A next-generation plugin manager for Zsh. ABANDONED\n\n"
    },
    {
      "title": "Fish-like syntax highlighting and autosuggestions",
      "level": 3,
      "content": "Fish provides very powerful shell syntax highlighting and autosuggestions. To use both in Zsh, you can install zsh-syntax-highlighting, zsh-autosuggestions, and finally source one or both of the provided scripts from your zshrc:\n\n```\n~/.zshrc\n```\n\n```\nsource /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\nsource /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh\n```\n\n"
    },
    {
      "title": "pkgfile \"command not found\" handler",
      "level": 3,
      "content": "pkgfile includes a Zsh script file that provides a command_not_found_handler function that will automatically search the pkgfile database when entering an unrecognized command.\n\nYou need to source the script to enable it. For example:\n\n```\n~/.zshrc\n```\n\n```\nsource /usr/share/doc/pkgfile/command-not-found.zsh\n```\n\nFor an alternative using pacman's native functionality, see #pacman -F \"command not found\" handler.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Wikipedia:Zsh\n- An Introduction to the Z Shell\n- A User's Guide to ZSH\n- The Z Shell Manual (different format available here)\n- Zsh FAQ\n- zsh-lovers(1) (available as zsh-lovers package)\n- Gentoo: Zsh/Guide\n- Bash2Zsh Reference Card\n\n"
    }
  ]
}