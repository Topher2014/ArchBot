{
  "title": "Nft",
  "url": "https://wiki.archlinux.org/title/Nft",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- iptables\n- Firewalld\n\nnftables is a netfilter project that aims to replace the existing {ip,ip6,arp,eb}tables framework. It provides a new packet filtering framework, a new user-space utility (nft), and a compatibility layer for {ip,ip6}tables. It uses the existing hooks, connection tracking system, user-space queueing component, and logging subsystem of netfilter.\n\nIt consists of three main components: a kernel implementation, the libnl netlink communication and the nftables user-space front-end. The kernel provides a netlink configuration interface, as well as run-time rule-set evaluation, libnl contains the low-level functions for communicating with the kernel, and the nftables front-end is what the user interacts with via nft.\n\nYou can also visit the official nftables wiki page for more information.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the userspace utilities package nftables or the git version nftables-gitAUR.\n\nAlternatively, install iptables-nft, which includes nftables as a dependency, will automatically uninstall iptables (an indirect dependency of the base meta package) and prevent conflicts between iptables and nftables when used together. See #Using iptables-nft for details.\n\n"
    },
    {
      "title": "Front-ends",
      "level": 3,
      "content": "- firewalld (firewall-cmd) — Daemon and console interface for configuring network and firewall zones as well as setting up and configuring firewall rules.\n\n- nft-blackhole — Script / daemon to blocking IP in nftables by country and black lists.\n\n- ufw — Ufw stands for Uncomplicated Firewall, and is a program for managing a netfilter firewall.\n\n- reaction — A daemon that scans program outputs for repeated patterns, and takes action. A lightweight alternative to fail2ban.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "nftables makes no distinction between temporary rules made in the command line and permanent ones loaded from or saved to a file.\n\nAll rules have to be created or loaded using nft command line utility.\n\nRefer to #Configuration section on how to use.\n\nCurrent ruleset can be printed with:\n\n```\n# nft list ruleset\n```\n\nRemove all ruleset leaving the system with no firewall:\n\n```\n# nft flush ruleset\n```\n\nRead ruleset from /etc/nftables.conf by restarting nftables.service.\n\n"
    },
    {
      "title": "Simple firewall",
      "level": 3,
      "content": "nftables comes with a simple and secure firewall configuration stored in the /etc/nftables.conf file.\n\nThe nftables.service will load rules from that file when started or enabled.\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "nftables user-space utility nft performs most of the rule-set evaluation before handing rule-sets to the kernel. Rules are stored in chains, which in turn are stored in tables. The following sections indicate how to create and modify these constructs.\n\nTo read input from a file use the -f/--file option:\n\n```\n# nft --file filename\n```\n\nNote that any rules already loaded are not automatically flushed.\n\nSee nft(8) for a complete list of all commands.\n\n"
    },
    {
      "title": "Tables",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nTables hold #Chains. Unlike tables in iptables, there are no built-in tables in nftables. The number of tables and their names is up to the user. However, each table only has one address family and only applies to packets of this family. Tables can have one of five families specified:\n\nTable content:\nnftables family | iptables utility\nip | iptables\nip6 | ip6tables\ninet | iptables and ip6tables\narp | arptables\nbridge | ebtables\n\nip (i.e. IPv4) is the default family and will be used if family is not specified.\n\nTo create one rule that applies to both IPv4 and IPv6, use inet. inet allows for the unification of the ip and ip6 families to make defining rules for both easier.\n\nSee nft(8) § ADDRESS FAMILIES for a complete description of address families.\n\nIn all of the following, family_type is optional, and if not specified is set to ip.\n\n"
    },
    {
      "title": "Create table",
      "level": 4,
      "content": "The following adds a new table:\n\n```\n# nft add table family_type table_name\n```\n\n"
    },
    {
      "title": "List tables",
      "level": 4,
      "content": "To list all tables:\n\n```\n# nft list tables\n```\n\n"
    },
    {
      "title": "List chains and rules in a table",
      "level": 4,
      "content": "To list all chains and rules of a specified table:\n\n```\n# nft list table family_type table_name\n```\n\nFor example, to list all the rules of the my_table table of the inet family:\n\n```\n# nft list table inet my_table\n```\n\n"
    },
    {
      "title": "Delete table",
      "level": 4,
      "content": "To delete a table:\n\n```\n# nft delete table family_type table_name\n```\n\nThis will destroy all chains in the table.\n\n"
    },
    {
      "title": "Flush table",
      "level": 4,
      "content": "To flush/clear all rules from a table:\n\n```\n# nft flush table family_type table_name\n```\n\n"
    },
    {
      "title": "Chains",
      "level": 3,
      "content": "The purpose of chains is to hold #Rules. Unlike chains in iptables, there are no built-in chains in nftables. This means that if no chain uses any types or hooks in the netfilter framework, packets that would flow through those chains will not be touched by nftables, unlike iptables.\n\nChains have two types. A base chain is an entry point for packets from the networking stack, where a hook value is specified. A regular chain may be used as a jump target for better organization.\n\nSee the traffic flow diagram showing the ordering between individual hooks. Within a given hook, netfilter performs operations in order of increasing numerical priority.\n\nIn all of the following family_type is optional, and if not specified is set to ip.\n\n"
    },
    {
      "title": "Create chain",
      "level": 4,
      "content": "To add a base chain it is mandatory to specify type, hook and priority values:\n\n```\n# nft add chain family_type table_name chain_name '{ type chain_type hook hook_type priority priority_value ; policy policy ;}'\n```\n\nchain_type can be filter, route, or nat.\n\nFor IPv4/IPv6/Inet address families hook_type can be prerouting, input, forward, output, or postrouting. See nft(8) § CHAINS for a list of supported family_type, chain_type and hook_type combinations.\n\npriority_value takes either a priority name or an integer value. See nft(8) § CHAINS for a list of standard priority names and values. Chains with lower numbers are processed first and can be negative. [5]\n\nOptionally base chains can have a policy (drop or the default accept), to define what happens to packets not explicitly accepted or refused in contained rules.\n\nFor example, to add a base chain that filters input packets:\n\n```\n# nft add chain inet my_table my_chain '{ type filter hook input priority 0; }'\n```\n\nReplace add with create in any of the above to add a new chain but return an error if the chain already exists.\n\nThe following adds a regular chain named chain_name to the table named table_name:\n\n```\n# nft add chain family_type table_name chain_name\n```\n\nFor example, to add a regular chain named my_tcp_chain to the my_table table of the inet address family:\n\n```\n# nft add chain inet my_table my_tcp_chain\n```\n\n"
    },
    {
      "title": "List chains",
      "level": 4,
      "content": "The following lists all chains without rules (see #List rules) of a family_type:\n\n```\n# nft list chains family_type\n```\n\nFor example, the following lists the chains of ipv6:\n\n```\n# nft list chains ip6\n```\n\nif you omit the family_type all chains are printed.\n\n"
    },
    {
      "title": "Edit a chain",
      "level": 4,
      "content": "To edit a chain, simply call it by its name and define the rules you want to change.\n\n```\n# nft chain family_type table_name chain_name '{ [ type chain_type hook hook_type device device_name priority priority_value ; policy policy_type ; ] }'\n```\n\nFor example, to change the my_input chain policy of the default table from accept to drop\n\n```\n# nft chain inet my_table my_input '{ policy drop ; }'\n```\n\n"
    },
    {
      "title": "Delete a chain",
      "level": 4,
      "content": "To delete a chain:\n\n```\n# nft delete chain family_type table_name chain_name\n```\n\nThe chain must not contain any rules or be a jump target.\n\n"
    },
    {
      "title": "Flush rules from a chain",
      "level": 4,
      "content": "To flush rules from a chain:\n\n```\n# nft flush chain family_type table_name chain_name\n```\n\n"
    },
    {
      "title": "Rules",
      "level": 3,
      "content": "Rules are either constructed from expressions or statements and are contained within chains.\n\n"
    },
    {
      "title": "Add rule",
      "level": 4,
      "content": "To add a rule to a chain:\n\n```\n# nft add rule family_type table_name chain_name handle handle_value statement\n```\n\nThe rule is appended at handle_value, which is optional. If not specified, the rule is appended to the end of the chain.\n\nThe --handle switch, which can be added to any valid list command, must be used to determine a rule handle. This switch tells nft to list the handles in its output. The --numeric argument is useful for viewing some numeric output, like unresolved IP addresses.\n\n```\n# nft --handle --numeric list chain inet my_table my_input\n```\n\n```\ntable inet my_table {\n     chain input {\n          type filter hook input priority 0;\n          ip saddr 127.0.0.1 accept # handle 10\n     }\n}\n```\n\nTo prepend the rule to the position:\n\n```\n# nft insert rule family_type table_name chain_name handle handle_value statement\n```\n\nIf handle_value is not specified, the rule is prepended to the chain.\n\nTypically a statement includes some expression to be matched and then a verdict statement. Verdict statements include accept, drop, queue, continue, return, jump chain_name, and goto chain_name. Other statements than verdict statements are possible. See nft(8) for more information.\n\nThere are various expressions available in nftables and, for the most part, coincide with their iptables counterparts. The most noticeable difference is that there are no generic or implicit matches. A generic match was one that was always available, such as --protocol or --source. Implicit matches were protocol-specific, such as --sport when a packet was determined to be TCP.\n\nThe following is an incomplete list of the matches available:\n\n- meta (meta properties, e.g. interfaces)\n- icmp (ICMP protocol)\n- icmpv6 (ICMPv6 protocol)\n- ip (IP protocol)\n- ip6 (IPv6 protocol)\n- tcp (TCP protocol)\n- udp (UDP protocol)\n- sctp (SCTP protocol)\n- ct (connection tracking)\n\nThe following is an incomplete list of match arguments (for a more complete list, see nft(8)):\n\n```\nmeta:\n  oif <output interface INDEX>\n  iif <input interface INDEX>\n  oifname <output interface NAME>\n  iifname <input interface NAME>\n\n  (oif and iif accept string arguments and are converted to interface indexes)\n  (oifname and iifname are more dynamic, but slower because of string matching)\n\nicmp:\n  type <icmp type>\n\nicmpv6:\n  type <icmpv6 type>\n\nip:\n  protocol <protocol>\n  daddr <destination address>\n  saddr <source address>\n\nip6:\n  daddr <destination address>\n  saddr <source address>\n\ntcp:\n  dport <destination port>\n  sport <source port>\n\nudp:\n  dport <destination port>\n  sport <source port>\n\nsctp:\n  dport <destination port>\n  sport <source port>\n\nct:\n  state <new | established | related | invalid>\n```\n\n"
    },
    {
      "title": "List rules",
      "level": 4,
      "content": "The following lists all rules of a chain:\n\n```\n# nft list chain family_type table_name chain_name\n```\n\nFor example, the following lists the rules of the chain named my_output in the inet table named my_table:\n\n```\n# nft list chain inet my_table my_output\n```\n\n"
    },
    {
      "title": "Deletion",
      "level": 4,
      "content": "Individual rules can only be deleted by their handles. Obtaining the handles was shown at #Add rule. Assuming\n\n```\n# nft --handle --numeric list chain inet my_table my_input\n```\n\n```\ntable inet my_table {\n     chain input {\n          type filter hook input priority 0;\n          ip saddr 127.0.0.1 accept # handle 10\n     }\n}\n```\n\n```\n# nft delete rule inet my_table my_input handle 10\n```\n\ndeletes it.\n\nAll the chains in a table can be flushed with the nft flush table command. Individual chains can be flushed using either the nft flush chain or nft delete rule commands.\n\n```\n# nft flush table table_name\n# nft flush chain family_type table_name chain_name\n# nft delete rule family_type table_name chain_name\n```\n\nThe first command flushes all of the chains in the ip table_name table. The second flushes the chain_name chain in the family_type table_name table. The third deletes all of the rules in chain_name chain in the family_type table_name table.\n\n"
    },
    {
      "title": "Sets",
      "level": 3,
      "content": "Sets are named or anonymous, and consist of one or more elements, separated by commas, enclosed by curly braces. Anonymous sets are embedded in rules and cannot be updated, you must delete and re-add the rule. E.g., you cannot just remove \"http\" from the dports set in the following:\n\n```\n# nft add rule ip6 filter input tcp dport {telnet, http, https} accept\n```\n\nNamed sets can be updated, and can be typed and flagged. sshguard uses named sets for the IP addresses of blocked hosts.\n\n```\ntable ip sshguard {\n       set attackers {\n               type ipv4_addr\n               flags interval\n               elements = { 1.2.3.4 }\n       }\n```\n\nTo add or delete elements from the set, use:\n\n```\n# nft add element ip sshguard attackers { 5.6.7.8/32 }\n# nft delete element ip sshguard attackers { 1.2.3.4/32 }\n```\n\nNote the type ipv4_addr can include a CIDR netmask (the /32 here is not necessary, but is included for completeness' sake). Note also, the set defined here by TABLE ip sshguard { SET attackers } is addressed as ip sshguard attackers.\n\n"
    },
    {
      "title": "Atomic reloading",
      "level": 3,
      "content": "Flush the current ruleset:\n\n```\n# echo \"flush ruleset\" > /tmp/nftables\n```\n\nDump the current ruleset:\n\n```\n# nft -s list ruleset >> /tmp/nftables\n```\n\nNow you can edit /tmp/nftables and apply your changes with:\n\n```\n# nft -f /tmp/nftables\n```\n\n"
    },
    {
      "title": "Workstation",
      "level": 3,
      "content": "```\n/etc/nftables.conf\n```\n\n```\nflush ruleset\n\ntable inet my_table {\n\tset LANv4 {\n\t\ttype ipv4_addr\n\t\tflags interval\n\n\t\telements = { 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 169.254.0.0/16 }\n\t}\n\tset LANv6 {\n\t\ttype ipv6_addr\n\t\tflags interval\n\n\t\telements = { fd00::/8, fe80::/10 }\n\t}\n\n\tchain my_input_lan {\n\t\tudp sport 1900 udp dport >= 1024 meta pkttype unicast limit rate 4/second burst 20 packets accept comment \"Accept UPnP IGD port mapping reply\"\n\n\t\tudp sport netbios-ns udp dport >= 1024 meta pkttype unicast accept comment \"Accept Samba Workgroup browsing replies\"\n\n\t}\n\n\tchain my_input {\n\t\ttype filter hook input priority filter; policy drop;\n\n\t\tiif lo accept comment \"Accept any localhost traffic\"\n\t\tct state invalid drop comment \"Drop invalid connections\"\n\t\tfib daddr . iif type != { local, broadcast, multicast } drop comment \"Drop packets if the destination IP address is not configured on the incoming interface (strong host model)\"\n\t\tct state { established, related } accept comment \"Accept traffic originated from us\"\n\n\t\tmeta l4proto { icmp, ipv6-icmp } accept comment \"Accept ICMP\"\n\t\tip protocol igmp accept comment \"Accept IGMP\"\n\n\t\tudp dport mdns ip6 daddr ff02::fb accept comment \"Accept mDNS\"\n\t\tudp dport mdns ip daddr 224.0.0.251 accept comment \"Accept mDNS\"\n\n\t\tip6 saddr @LANv6 jump my_input_lan comment \"Connections from private IP address ranges\"\n\t\tip saddr @LANv4 jump my_input_lan comment \"Connections from private IP address ranges\"\n\n\t\tcounter comment \"Count any other traffic\"\n\t}\n\n\tchain my_forward {\n\t\ttype filter hook forward priority filter; policy drop;\n\t\t# Drop everything forwarded to us. We do not forward. That is routers job.\n\t}\n\n\tchain my_output {\n\t\ttype filter hook output priority filter; policy accept;\n\t\t# Accept every outbound connection\n\t}\n\n}\n```\n\n"
    },
    {
      "title": "Server",
      "level": 3,
      "content": "```\n/etc/nftables.conf\n```\n\n```\nflush ruleset\n\ntable inet my_table {\n\tset LANv4 {\n\t\ttype ipv4_addr\n\t\tflags interval\n\n\t\telements = { 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 169.254.0.0/16 }\n\t}\n\tset LANv6 {\n\t\ttype ipv6_addr\n\t\tflags interval\n\n\t\telements = { fd00::/8, fe80::/10 }\n\t}\n\n\tchain my_input_lan {\n\t\tmeta l4proto { tcp, udp } th dport 2049 accept comment \"Accept NFS\"\n\n\t\tudp dport netbios-ns accept comment \"Accept NetBIOS Name Service (nmbd)\"\n\t\tudp dport netbios-dgm accept comment \"Accept NetBIOS Datagram Service (nmbd)\"\n\t\ttcp dport netbios-ssn accept comment \"Accept NetBIOS Session Service (smbd)\"\n\t\ttcp dport microsoft-ds accept comment \"Accept Microsoft Directory Service (smbd)\"\n\n\t\tudp sport { bootpc, 4011 } udp dport { bootps, 4011 } accept comment \"Accept PXE\"\n\t\tudp dport tftp accept comment \"Accept TFTP\"\n\t}\n\n\tchain my_input {\n\t\ttype filter hook input priority filter; policy drop;\n\n\t\tiif lo accept comment \"Accept any localhost traffic\"\n\t\tct state invalid drop comment \"Drop invalid connections\"\n\t\tfib daddr . iif type != { local, broadcast, multicast } drop comment \"Drop packets if the destination IP address is not configured on the incoming interface (strong host model)\"\n\t\tct state { established, related } accept comment \"Accept traffic originated from us\"\n\n\t\tmeta l4proto { icmp, ipv6-icmp } accept comment \"Accept ICMP\"\n\t\tip protocol igmp accept comment \"Accept IGMP\"\n\n\t\tudp dport mdns ip6 daddr ff02::fb accept comment \"Accept mDNS\"\n\t\tudp dport mdns ip daddr 224.0.0.251 accept comment \"Accept mDNS\"\n\n\t\tip6 saddr @LANv6 jump my_input_lan comment \"Connections from private IP address ranges\"\n\t\tip saddr @LANv4 jump my_input_lan comment \"Connections from private IP address ranges\"\n\n\t\ttcp dport ssh accept comment \"Accept SSH on port 22\"\n\n\t\ttcp dport ipp accept comment \"Accept IPP/IPPS on port 631\"\n\n\t\ttcp dport { http, https, 8008, 8080 } accept comment \"Accept HTTP (ports 80, 443, 8008, 8080)\"\n\n\t\tudp sport bootpc udp dport bootps ip saddr 0.0.0.0 ip daddr 255.255.255.255 accept comment \"Accept DHCPDISCOVER (for DHCP-Proxy)\"\n\t}\n\n\tchain my_forward {\n\t\ttype filter hook forward priority filter; policy drop;\n\t\t# Drop everything forwarded to us. We do not forward. That is routers job.\n\t}\n\n\tchain my_output {\n\t\ttype filter hook output priority filter; policy accept;\n\t\t# Accept every outbound connection\n\t}\n\n}\n```\n\n"
    },
    {
      "title": "Limit rate",
      "level": 3,
      "content": "```\ntable inet my_table {\n\tchain my_input {\n\t\ttype filter hook input priority filter; policy drop;\n\n\t\tiif lo accept comment \"Accept any localhost traffic\"\n\t\tct state invalid drop comment \"Drop invalid connections\"\n\t\tfib daddr . iif type != { local, broadcast, multicast } drop comment \"Drop packets if the destination IP address is not configured on the incoming interface (strong host model)\"\n\n\t\tmeta l4proto icmp icmp type echo-request limit rate over 10/second burst 4 packets drop comment \"No ping floods\"\n\t\tmeta l4proto ipv6-icmp icmpv6 type echo-request limit rate over 10/second burst 4 packets drop comment \"No ping floods\"\n\n\t\tct state { established, related } accept comment \"Accept traffic originated from us\"\n\n\t\tmeta l4proto { icmp, ipv6-icmp } accept comment \"Accept ICMP\"\n\t\tip protocol igmp accept comment \"Accept IGMP\"\n\n\t\ttcp dport ssh ct state new limit rate 15/minute accept comment \"Avoid brute force on SSH\"\n\n\t}\n\n}\n```\n\n"
    },
    {
      "title": "Jump",
      "level": 3,
      "content": "When using jumps in configuration file, it is necessary to define the target chain first. Otherwise one could end up with Error: Could not process rule: No such file or directory.\n\n```\ntable inet my_table {\n    chain web {\n        tcp dport http accept\n        tcp dport 8080 accept\n    }\n    chain my_input {\n        type filter hook input priority filter;\n        ip saddr 10.0.2.0/24 jump web\n        drop\n    }\n}\n```\n\n"
    },
    {
      "title": "Different rules for different interfaces",
      "level": 3,
      "content": "If your box has more than one network interface, and you would like to use different rules for different interfaces, you may want to use a \"dispatching\" filter chain, and then interface-specific filter chains. For example, let us assume your box acts as a home router, you want to run a web server accessible over the LAN (interface enp3s0), but not from the public internet (interface enp2s0), you may want to consider a structure like this:\n\n```\ntable inet my_table {\n  chain my_input { # this chain serves as a dispatcher\n    type filter hook input priority filter; policy drop;\n\n    iif lo accept comment \"always accept loopback\"\n    iifname enp2s0 jump my_input_public\n    iifname enp3s0 jump my_input_private\n  }\n  chain my_input_public { # rules applicable to public interface interface\n    ct state {established,related} accept\n    ct state invalid drop\n    udp dport bootpc accept\n    tcp dport bootpc accept\n  }\n  chain my_input_private {\n    ct state {established,related} accept\n    ct state invalid drop\n    udp dport bootpc accept\n    tcp dport bootpc accept\n    tcp port http accept\n    tcp port https accept\n    reject with icmpx port-unreachable comment \"all other traffic\"\n  }\n  chain my_output { # we let everything out\n    type filter hook output priority filter;\n    accept\n  }\n}\n```\n\nAlternatively you could choose only one iifname statement, such as for the single upstream interface, and put the default rules for all other interfaces in one place, instead of dispatching for each interface.\n\n"
    },
    {
      "title": "Masquerading",
      "level": 3,
      "content": "nftables has a special keyword masquerade \"where the source address is automagically set to the address of the output interface\" (source). This is particularly useful for situations in which the IP address of the interface is unpredictable or unstable, such as the upstream interface of routers connecting to many ISPs. Without it, the Network Address Translation rules would have to be updated every time the IP address of the interface changed.\n\nTo use it:\n\n- make sure masquerading is enabled in the kernel (true if you use the default kernel), otherwise during kernel configuration, set CONFIG_NFT_MASQ=m.\n- the masquerade keyword can only be used in chains of type nat.\n- masquerading is a kind of source NAT, so only works in the output path.\n\nExample for a machine with two interfaces: LAN connected to enp3s0, and public internet connected to enp2s0:\n\n```\ntable inet my_nat {\n  chain my_masquerade {\n    type nat hook postrouting priority srcnat;\n    oifname \"enp2s0\" masquerade\n  }\n}\n```\n\nSince the table type is inet both IPv4 and IPv6 packets will be masqueraded. If you want only ipv4 packets to be masqueraded (since extra adress space of IPv6 makes NAT not required) meta nfproto ipv4 expression can be used infront of oifname \"enp2s0\" or the table type can be changed to ip.\n\n"
    },
    {
      "title": "NAT with port forwarding",
      "level": 3,
      "content": "This example will masquerade traffic exiting through a WAN interface called eth0 and forward ports 22 and 80 to 10.0.0.2. You will need to set net.ipv4.ip_forward to 1 via sysctl.\n\n```\ntable nat {\n    chain prerouting {\n        type nat hook prerouting priority dstnat;\n        iif eth0 tcp dport {22, 80} dnat to 10.0.0.2\n    }\n    chain postrouting {\n        type nat hook postrouting priority srcnat;\n        oif eth0 masquerade\n    }\n}\n```\n\n"
    },
    {
      "title": "Count new connections per IP",
      "level": 3,
      "content": "Use this snippet to count HTTPS connections:\n\n```\n/etc/nftables.conf\n```\n\n```\ntable inet filter {\n    set https {\n        type ipv4_addr;\n        flags dynamic;\n        size 65536;\n        timeout 60m;\n    }\n\n    chain input {\n        type filter hook input priority filter;\n        ct state new tcp dport 443 update @https { ip saddr counter }\n    }\n}\n```\n\nTo print the counters, run nft list set inet filter https.\n\n"
    },
    {
      "title": "Dynamic blackhole",
      "level": 3,
      "content": "Use this snippet to drop all HTTPS connections for 1 minute from a source IP (or /64 IPv6 range) that exceeds the limit of 10/second.\n\n```\n/etc/nftables.conf\n```\n\n```\ntable inet dev {\n    set blackhole_ipv4 {\n        type ipv4_addr;\n        flags dynamic, timeout;\n        size 65536;\n    }\n    set blackhole_ipv6 {\n        type ipv6_addr;\n        flags dynamic, timeout;\n        size 65536;\n    }\n\n    chain input {\n        type filter hook input priority filter; policy accept;\n        ct state new tcp dport 443 \\\n                meter flood_ipv4 size 128000 { ip saddr timeout 10s limit rate over 10/second } \\\n                add @blackhole_ipv4 { ip saddr timeout 1m }\n        ct state new tcp dport 443 \\\n                meter flood_ipv6 size 128000 { ip6 saddr and ffff:ffff:ffff:ffff:: timeout 10s limit rate over 10/second } \\\n                add @blackhole_ipv6 { ip6 saddr and ffff:ffff:ffff:ffff:: timeout 1m }\n\n        ip saddr @blackhole_ipv4 counter drop\n        ip6 saddr and ffff:ffff:ffff:ffff:: @blackhole_ipv6 counter drop\n    }\n}\n```\n\nTo print the blackholed IPs, run nft list set inet dev blackhole_ipvX.\n\n"
    },
    {
      "title": "Saving current rule set",
      "level": 3,
      "content": "The output of nft list ruleset command is a valid input file for it as well. Current rule set can be saved to file and later loaded back in.\n\n```\n# nft -s list ruleset | tee filename\n```\n\n"
    },
    {
      "title": "Simple stateful firewall",
      "level": 3,
      "content": "See Simple stateful firewall for more information.\n\n"
    },
    {
      "title": "Single machine",
      "level": 4,
      "content": "Flush the current ruleset:\n\n```\n# nft flush ruleset\n```\n\nAdd a table:\n\n```\n# nft add table inet my_table\n```\n\nAdd the input, forward, and output base chains. The policy for input and forward will be to drop. The policy for output will be to accept.\n\n```\n# nft add chain inet my_table my_input '{ type filter hook input priority 0 ; policy drop ; }'\n# nft add chain inet my_table my_forward '{ type filter hook forward priority 0 ; policy drop ; }'\n# nft add chain inet my_table my_output '{ type filter hook output priority 0 ; policy accept ; }'\n```\n\nAdd two regular chains that will be associated with tcp and udp:\n\n```\n# nft add chain inet my_table my_tcp_chain\n# nft add chain inet my_table my_udp_chain\n```\n\nRelated and established traffic will be accepted:\n\n```\n# nft add rule inet my_table my_input ct state '{ related, established }' accept\n```\n\nAll loopback interface traffic will be accepted:\n\n```\n# nft add rule inet my_table my_input iif lo accept\n```\n\nDrop any invalid traffic:\n\n```\n# nft add rule inet my_table my_input ct state invalid drop\n```\n\nAccept ICMP and IGMP:\n\n```\n# nft add rule inet my_table my_input meta l4proto '{ icmp, ipv6-icmp }' accept\n# nft add rule inet my_table my_input ip protocol igmp accept\n```\n\nNew udp traffic will jump to the UDP chain:\n\n```\n# nft add rule inet my_table my_input meta l4proto udp ct state new jump my_udp_chain\n```\n\nNew tcp traffic will jump to the TCP chain:\n\n```\n# nft add rule inet my_table my_input 'meta l4proto tcp tcp flags & (fin|syn|rst|ack) == syn ct state new jump my_tcp_chain'\n```\n\nAt this point you should decide what ports you want to open to incoming connections, which are handled by the TCP and UDP chains. For example to open connections for a web server add:\n\n```\n# nft add rule inet my_table my_tcp_chain tcp dport 80 accept\n```\n\nTo accept HTTPS connections for a webserver on port 443:\n\n```\n# nft add rule inet my_table my_tcp_chain tcp dport 443 accept\n```\n\nTo accept SSH traffic on port 22:\n\n```\n# nft add rule inet my_table my_tcp_chain tcp dport 22 accept\n```\n\nTo accept incoming DNS requests:\n\n```\n# nft add rule inet my_table my_tcp_chain tcp dport 53 accept\n# nft add rule inet my_table my_udp_chain udp dport 53 accept\n```\n\nBe sure to make your changes permanent when satisfied.\n\n"
    },
    {
      "title": "Prevent brute-force attacks",
      "level": 3,
      "content": "Sshguard is program that can detect brute-force attacks and modify firewalls based on IP addresses it temporarily blacklists. See Sshguard#nftables on how to set up nftables to be used with it.\n\n"
    },
    {
      "title": "Logging traffic",
      "level": 3,
      "content": "You can log packets using the log action. The most simple rule to log all incoming traffic is:\n\n```\n# nft add rule inet filter input log\n```\n\nSee nftables wiki for details.\n\n"
    },
    {
      "title": "Monitor",
      "level": 3,
      "content": "Listen to all events, report in native nft format.\n\n```\n# nft monitor\n```\n\nSee nft(8) § MONITOR\n\n"
    },
    {
      "title": "Ruleset debugging trace temporary",
      "level": 4,
      "content": "meta nftrace set 1 ruleset packet tracing on/off. Use monitor trace command to watch traces.\n\nIn another shell \"include\" the file inside the interactive shell:\n\n```\n# nft -i\nnft> include \"/root/nftables.trace\"\n```\n\nExample, adjust to your needs:\n\n```\n/root/nftables.trace\n```\n\n```\nadd table ip temp-trace {comment \"Temporary table!!\"; flags owner;}\nadd chain ip temp-trace icmp-prerouting { type filter hook prerouting priority raw - 1 ; }\nadd rule ip temp-trace icmp-prerouting ip protocol icmp meta nftrace set 1\n```\n\nThis file adds a temporary table (flags owner) so that it gets automatically removed, if the calling (process) interactive nft is closed. The Base Chain needs to be adjusted for your use case. You can create multiple chains and multiple rules with \"meta nftrace set 1\" \"ip protocol icmp\" is used just as an example and is not necessary. There are many ways to achieve a similar effect, the advantage is that by closing the interactive shell the previous state is automatically restored, and if an error is inside the file nothing gets executed.\n\nSee nftables wiki and a python tool automating the process and coloring.\n\n"
    },
    {
      "title": "Using iptables-nft",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nThe older iptables language remains quite dominant in Linux documentation, and quite a few things still depend on iptables to run (such as Docker's networking). Although it's also perfectly workable to use legacy iptables and nftables at the same time, using iptables-nft's translation is preferred because:\n\n- It puts everything in the same place, using the newer, more efficient, non-locking framework.\n- It checks for conflicts.\n\nThere are two ways to use the old iptables language with nftables:\n\n- iptables-translate and iptables-restore-translate (plus vice versa for ip6tables, ebtables, etc.) take iptable language and output nft language. They do not change running nft settings. See xtables-translate(8).\n\n- iptables and iptables-restore (again vice versa for ip6tables etc.) uses the above translation and put them into the running nft settings. It also offers statistics like regular iptables does. See xtables-nft(8).\n\n"
    },
    {
      "title": "Dynamic named sets using systemd-networkd",
      "level": 3,
      "content": "systemd-networkd's connections can use the NFTSet= option to populate predefined named sets with host IP addresses, network prefixes and interface indexes. This allows to avoid hardcoding them in /etc/nftables.conf. The NFTSet= option is supported in [Address], [DHCPv4], [DHCPv6] and [IPv6AcceptRA] sections. See systemd.network(5) § [ADDRESS] SECTION OPTIONS.\n\nFor example, to process connections from a local network (where IP addresses are assigned via DHCP or SLAAC) in a separate my_input_lan chain:\n\n```\n/etc/nftables.conf\n```\n\n```\n...\ntable inet my_table {\n\n\tset eth_ipv4_prefix {\n\t\ttype ipv4_addr\n\t\tflags interval\n\t\tcomment \"Populated by systemd-networkd\"\n\t}\n\tset eth_ipv6_prefix {\n\t\ttype ipv6_addr\n\t\tflags interval\n\t\tcomment \"Populated by systemd-networkd\"\n\n\t\telements = { fe80::/10 }\n\t}\n\tset eth_ifindex {\n\t\ttype iface_index\n\t\tcomment \"Populated by systemd-networkd\"\n\t}\n...\n\tchain my_input {\n\t\ttype filter hook input priority filter; policy drop;\n\n\t\tiif @eth_ifindex ip6 saddr @eth_ipv6_prefix jump my_input_lan comment \"Connections from LAN\"\n\t\tiif @eth_ifindex ip saddr @eth_ipv4_prefix jump my_input_lan comment \"Connections from LAN\"\n\t}\n...\n}\n```\n\n```\n/etc/systemd/network/my-network.network\n```\n\n```\n...\n\n[DHCPv4]\nNFTSet=prefix:inet:my_table:eth_ipv4_prefix\nNFTSet=ifindex:inet:my_table:eth_ifindex\n\n[DHCPv6]\nNFTSet=prefix:inet:my_table:eth_ipv6_prefix\nNFTSet=ifindex:inet:my_table:eth_ifindex\n\n[IPv6AcceptRA]\nNFTSet=prefix:inet:my_table:eth_ipv6_prefix\nNFTSet=ifindex:inet:my_table:eth_ifindex\n...\n```\n\n"
    },
    {
      "title": "Working with Docker",
      "level": 3,
      "content": "- With the following setup, you will not be able to use protocols like AF_BLUETOOTH inside containers even with --net host --privileged.\n- Rootless Docker containers already run in a separate network namespace. You may not need to do anything.\n\nUsing nftables can interfere with Docker networking (and probably other container runtimes as well). You can find various workarounds on the internet which either involve patching iptables rules and ensuring a defined service start order or disabling dockers iptables management completely which makes using docker very restrictive (think port forwarding or docker-compose).\n\nA reliable method is letting docker run in a separate network namespace where it can do whatever it wants. It is probably best to not use iptables-nft to prevent docker from mixing nftables and iptables rules.\n\nUse the following docker service drop-in file:\n\n```\n/etc/systemd/system/docker.service.d/netns.conf\n```\n\n```\n[Service]\nPrivateNetwork=yes\nPrivateMounts=No\n\n# cleanup\nExecStartPre=-nsenter -t 1 -n -- ip link delete docker0\n\n# add veth\nExecStartPre=nsenter -t 1 -n -- ip link add docker0 type veth peer name docker0_ns\nExecStartPre=sh -c 'nsenter -t 1 -n -- ip link set docker0_ns netns \"$$BASHPID\" && true'\nExecStartPre=ip link set docker0_ns name eth0\n\n# bring host online\nExecStartPre=nsenter -t 1 -n -- ip addr add 10.0.0.1/24 dev docker0\nExecStartPre=nsenter -t 1 -n -- ip link set docker0 up\n\n# bring ns online\nExecStartPre=ip addr add 10.0.0.100/24 dev eth0\nExecStartPre=ip link set eth0 up\nExecStartPre=ip route add default via 10.0.0.1 dev eth0\n```\n\nAdjust the 10.0.0.* IP addresses if they are not appropriate for your setup.\n\nEnable IP forwarding and set-up NAT for docker0 with the following postrouting rule:\n\n```\niifname docker0 oifname eth0 masquerade\n```\n\nThen, ensure that kernel IP forwarding is enabled.\n\nNow you can setup a firewall and port forwarding for the docker0 interface using nftables without any interference.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- netfilter nftables wiki\n- debian:nftables\n- gentoo:nftables\n- First release of nftables\n- nftables quick howto\n- The return of nftables\n- What comes after ‘iptables’? Its successor, of course: `nftables`\n- Gene's Tech Blog – additional nftables samples for workstation and firewall\n\n"
    }
  ]
}