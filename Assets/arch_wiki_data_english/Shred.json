{
  "title": "Shred",
  "url": "https://wiki.archlinux.org/title/Shred",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Securely wipe disk/Tips and tricks\n- File recovery\n- Benchmarking/Data storage devices\n- Data-at-rest encryption#Preparing the disk\n- dm-crypt\n\nWiping a disk is done by writing new data over every single bit.\n\n"
    },
    {
      "title": "Wipe all data left on the device",
      "level": 3,
      "content": "The most common usecase for completely and irrevocably wiping a device is when the device is going to be given away or sold. There may be (unencrypted) data left on the device and you want to protect against simple forensic investigation that is mere child's play with for example File recovery software.\n\nIf you want to quickly wipe everything from the disk, /dev/zero or simple patterns allow maximum performance while adequate randomness can be advantageous in some cases that should be covered up in #Data remanence.\n\nEvery overwritten bit means to provide a level of data erasure not allowing recovery with normal system functions (like standard ATA/SCSI commands) and hardware interfaces. Any file recovery software mentioned above then would need to be specialized on proprietary storage-hardware features.\n\nIn case of a HDD, data recreation will not be possible without at least undocumented drive commands or tinkering with the device's controller or firmware to make them read out for example reallocated sectors (bad blocks that S.M.A.R.T. retired from use).\n\nThere are different wiping issues with different physical storage technologies. Most notably, all Flash memory based devices and older magnetic storage (old HDDs, floppy disks, tape).\n\n"
    },
    {
      "title": "Preparations for block device encryption",
      "level": 3,
      "content": "To prepare a drive for block device encryption inside the wiped area afterwards, it is recommended to use #Random data generated by a cryptographically strong random number generator (referred to as RNG in this article from now on).\n\nSee also Wikipedia:Random number generation.\n\n"
    },
    {
      "title": "Data remanence",
      "level": 2,
      "content": "See also Wikipedia:Data remanence. The representation of data may remain even after attempts have been made to remove or erase the data.\n\n"
    },
    {
      "title": "Operating system, programs and filesystem",
      "level": 3,
      "content": "The operating system, executed programs or journaling file systems may copy your unencrypted data throughout the block device. When writing to plain disks, this should only be relevant in conjunction with one of the above.\n\nIf the data can be exactly located on the disk and was never copied anywhere else, wiping with pseudorandom data can be thoroughgoing and impressively quick.\n\nA good example is cryptsetup using /dev/urandom for wiping the LUKS keyslots.\n\n"
    },
    {
      "title": "Flash memory",
      "level": 4,
      "content": "Write amplification and other characteristics make Flash memory, including SSDs, a stubborn target for reliable wiping. As there is a lot of transparent abstraction in between data as seen by a device's controller chip and the operating system, sight data is never overwritten in place and wiping particular blocks or files is not reliable.\n\nOther \"features\" like transparent compression (all SandForce SSDs) can compress your zeros or repetitive patterns, so if wiping is fast beyond belief this might be the cause.\n\nDisassembling Flash memory devices, unsoldering the chips and analyzing data content without the controller in between is feasible without difficulty using simple hardware. Data recovery companies do it for cheap money.\n\nFor more information see:\n\n- Solid state drive/Memory cell clearing\n- Reliably Erasing Data From Flash-Based Solid State Drives.\n- #Select a target\n\n"
    },
    {
      "title": "Marked Bad Sectors",
      "level": 4,
      "content": "If a hard drive marks a sector as bad, it cordons it off, and the section becomes impossible to write to via software. Thus a full overwrite would not reach it. However because of block sizes, these sections would only amount to a few theoretically recoverable KiB.\n\n"
    },
    {
      "title": "Residual magnetism",
      "level": 4,
      "content": "A single, full overwrite with zeros or random data does not lead to any recoverable data on a modern high-density storage device. Note that repeating the operation should not be necessary nowadays. [1] Indications otherwise refer to single residual bits; reconstruction of byte patterns is generally not feasible.[2] See also [3], [4] and [5].\n\n"
    },
    {
      "title": "Select a target",
      "level": 2,
      "content": "Use fdisk to locate all read/write devices the user has read access to.\n\nCheck the output for lines that start with devices such as /dev/sdX.\n\nThis is an example for a HDD formatted to boot a linux system:\n\n```\n# fdisk -l\n```\n\n```\nDisk /dev/sda: 250.1 GB, 250059350016 bytes, 488397168 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk identifier: 0x00ff784a\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sda1   *        2048      206847      102400   83  Linux\n/dev/sda2          206848   488397167   244095160   83  Linux\n```\n\nOr another example with the Arch Linux image written to a 4GB USB thumb drive:\n\n```\n# fdisk -l\n```\n\n```\nDisk /dev/sdb: 4075 MB, 4075290624 bytes, 7959552 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk identifier: 0x526e236e\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdb1   *           0      802815      401408   17  Hidden HPFS/NTFS\n```\n\nIf you are worried about unintentional damage of important data on the primary computer, consider using an isolated environment such as a virtual environment (VirtualBox, VMWare, QEMU, etc...) with direct connected disk drives to it or a single computer only with a storage disk(s) that need to be wiped booted from a Live Media (USB, CD, PXE, etc...) or use a script to prevent wiping mounted partitions by typo.\n\n"
    },
    {
      "title": "Select a data source",
      "level": 2,
      "content": "To wipe sensitive data, one can use any data pattern matching the needs.\n\n"
    },
    {
      "title": "Zeros",
      "level": 3,
      "content": "Overwriting with /dev/zero or simple patterns is considered secure in most situations. With today's HDDs, it is deemed appropriate and fast for disk wiping.\n\nHowever, a drive that is abnormally fast in writing patterns or zeroing could be doing transparent compression. It is obviously presumable not all blocks get wiped this way. Some #Flash memory devices do \"feature\" that.\n\nTo setup block device encryption afterwards, one should wipe the area with random data (see next section) to avoid weakening the encryption.\n\n"
    },
    {
      "title": "Random data",
      "level": 3,
      "content": "/dev/urandom can be used as a fast and secure source of cryptographically secure pseudorandom data from the Linux kernel. For more details about sources of random and pseudorandom data, see Random number generation.\n\nIn the past when the kernel's random number generator was slow, a common alternative for pseudorandom data generation was to use an encrypted datastream, such as by encrypting /dev/zero with a random key. While this should in theory be secure, it no longer presents any advantages over the kernel's new, faster random number generator, and there is a risk that the temporary key may accidentally be saved someplace.\n\n"
    },
    {
      "title": "Select a block size",
      "level": 2,
      "content": "See also Wikipedia:Dd (Unix)#Block size, blocksize io-limits.\n\nIf you have an Advanced Format hard drive it is recommended that you specify a block size larger than the default 512 bytes. To speed up the overwriting process choose a block size matching your drive's physical geometry by appending the block size option to the dd command (i.e. bs=4096 for 4 KiB).\n\nfdisk prints physical and logical sector size for every disk. Alternatively sysfs does expose information:\n\n```\n/sys/block/sdX/size\n/sys/block/sdX/queue/physical_block_size\n/sys/block/sdX/queue/logical_block_size\n/sys/block/sdX/sdXY/alignment_offset\n/sys/block/sdX/sdXY/start\n/sys/block/sdX/sdXY/size\n```\n\n"
    },
    {
      "title": "Calculate blocks to wipe manually",
      "level": 3,
      "content": "Block storage devices are divided in sectors, and the size of a single sector can be used to calculate the size of the entire device in bytes. To do so, multiply the number of sectors by the drive sector size.\n\nAs an example we use the parameters with the dd command to wipe a partition:\n\n```\n# dd if=data_source of=/dev/sdX bs=sector_size count=sector_number seek=partitions_start_sector status=progress\n```\n\nHere, to illustrate with a practical example, we will show the output of the fdisk command on the partition /dev/sdX:\n\n```\n# fdisk -l /dev/sdX\n```\n\n```\nDisk /dev/sdX: 1.8 TiB, 2000398934016 bytes, 3907029168 sectors\nDisk model: ST3500413AS\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 4096 bytes\n...\nDevice     Boot      Start        End         Sectors     Size  Id Type\n/dev/sdX1            2048         3839711231  3839709184  1,8T  83 Linux\n/dev/sdX2            3839711232   3907029167  67317936    32,1G  5 Extended\n```\n\n- The first line of the fdisk output shows the disk size in bytes and in logical sectors.\n- The size in bytes of the storage device or of the partition can also be obtained with the command blockdev --getsize64 /dev/sdXY.\n- The Units line of the fdisk output shows the size of single logical sector; the logical sector size can also be derived from the number of bytes divided by the number of logical sectors, here use: echo $((2000398934016 / 3907029168)).\n- To know the physical sector size in bytes (that will make it work faster), we can use the next line.\n- To get the disk size in physical sectors, one can divide the disk size in bytes by the size of a single physical sector, here echo $((2000398934016 / 4096)),\n\n- In the examples below we will use the logical sector size.\n- You can even wipe unallocated disk space with a dd command by calculating the difference between the end of one and start of the next partition.\n\nTo wipe partition /dev/sdX1, the example parameters with logical sectors would be used like follows.\n\n- By using the starting address of the partition on the device using the seek= parameter:\n\n```\n# dd if=data_source of=/dev/sdX bs=${BytesInSector} count=${End - Start} seek=${Start} status=progress\n```\n\nwith Start=2048, End=3839711231 and BytesInSector=512.\n\n- Or by using the partitions size in logical sectors:\n\n```\n# dd if=data_source of=/dev/sdX1 bs=${BytesInSector} count=${LogicalSectors} status=progress\n```\n\nwith LogicalSectors=3839709184.\n\nOr, to wipe the whole disk by using physical sectors:\n\n```\n# dd if=data_source of=/dev/sdX bs=${PhysicalSectorSizeBytes} count=${AllDiskPhysicalSectors} seek=0 status=progress\n```\n\nwith AllDiskPhysicalSectors=488378646 and PhysicalSectorSizeBytes=4096.\n\n"
    },
    {
      "title": "Overwrite the target",
      "level": 2,
      "content": "You can choose from several utilities to overwrite a drive. If you only want to wipe a single file, Securely wipe disk/Tips and tricks#Wipe a single file has considerations in addition to the utilities mentioned below.\n\n"
    },
    {
      "title": "By redirecting output",
      "level": 3,
      "content": "The redirected output can be used to create files, rewrite free space on the partition, and to wipe the whole device or a single partition on it. The examples here use /dev/zero to zero the device, but /dev/urandom may be substituted if a random wipe is desired.\n\nThe following examples show how to rewrite the partition or a block device by redirecting stdout from other utilities:\n\n```\n# cat /dev/zero > /dev/sdXY\n```\n\n```\ncat: write error: No space left on device\n```\n\n```\n# xz -z0 /dev/zero -c > /dev/sdXY\n```\n\n```\nxz: (stdout): Write error: No space left on device\n```\n\n```\n# dd if=/dev/zero status=progress > /dev/sdXY\n```\n\n```\ndd: writing to ‘standard output’: No space left on device\n20481+0 records in\n20480+0 records out\n10485760 bytes (10 MB, 10 MiB) copied, 2.29914 s, 4.6 MB/s\n```\n\n"
    },
    {
      "title": "dd",
      "level": 3,
      "content": "See also dd and Securely wipe disk/Tips and tricks#Wipe a single file.\n\nNote: **double-check** \n\nZero-fill the disk by writing a zero byte to every addressable location on the disk using the /dev/zero stream.\n\n```\n# dd if=/dev/zero of=/dev/sdX bs=4096 status=progress\n```\n\nOr the /dev/urandom stream:\n\n```\n# dd if=/dev/urandom of=/dev/sdX bs=4096 iflag=fullblock status=progress\n```\n\nThe process is finished when dd reports No space left on device and returns control back:\n\n```\ndd: writing to ‘/dev/sdX’: No space left on device\n7959553+0 records in\n7959552+0 records out\n4075290624 bytes (4.1 GB, 3.8 GiB) copied, 1247.7 s, 3.3 MB/s\n```\n\nTo speed up wiping a large drive, see also:\n\n- Securely wipe disk/Tips and tricks#dd - advanced example which uses OpenSSL,\n- Securely wipe disk/Tips and tricks#Using a template file which wipes with non-random preset data (e.g. overwrite a whole disk with a single file) but is very fast\n- Dm-crypt/Drive preparation#dm-crypt specific methods which uses dm-crypt.\n\n"
    },
    {
      "title": "cp",
      "level": 3,
      "content": "The file copy command cp(1) can also be used to rewrite the device, because it ignores the type of the destination:\n\n```\n# cp /dev/zero /dev/sdXY\n```\n\n```\ncp: error writing ‘/dev/sdXY’: No space left on device\n cp: failed to extend ‘/dev/sdXY’: No space left on device\n```\n\n"
    },
    {
      "title": "pv",
      "level": 3,
      "content": "Using pv will show a progress bar, the time spent and the estimated time till completion. Pass the selected data source to pv(1) and use the -o/--output option to specify the disk which will be written to. For example, to fill the disk /dev/sdX with /dev/zero:\n\n```\n# pv /dev/zero -o /dev/sdX\n```\n\n"
    },
    {
      "title": "wipe",
      "level": 3,
      "content": "A program specialized on wiping files. It is available as part of the wipe package. To make a quick wipe of a destination, you can use something like:\n\n```\n$ wipe -r /path/to/wipe\n```\n\nSee also wipe(1). The tool was last updated in 2009. Its SourceForge page suggests that it is currently unmaintained.\n\n"
    },
    {
      "title": "shred",
      "level": 3,
      "content": "shred (from the coreutils package) is a Unix command that can be used to securely delete individual files or full devices so that they can be recovered only with great difficulty with specialised hardware, if at all. By default shred uses three passes, writing pseudo-random data to the device during each pass. This can be reduced or increased.\n\nThe following command invokes shred with its default settings and displays the progress.\n\n```\n# shred -v /dev/sdX\n```\n\nShred can also be used on a single partition, e.g. to wipe the first partition use shred -v /dev/sdX1.\n\nAlternatively, shred can be instructed to do only one pass, with entropy from e.g. /dev/urandom, and a final overwrite with zeros.\n\n```\n# shred --verbose --random-source=/dev/urandom -n1 --zero /dev/sdX\n```\n\n"
    },
    {
      "title": "scrub",
      "level": 3,
      "content": "scrub iteratively writes patterns on files or disk devices to make retrieving the data more difficult.\n\nThe following command invokes scrub with the default settings, in mode 1, overwriting the target device using patterns compliant with NNSA Policy Letter NAP-14.x. This is the most effective method.\n\n```\n$ scrub /dev/sdX\n```\n\nThe following command invokes scrub with the default settings, in mode 2, overwriting the target file using patterns compliant with NNSA Policy Letter NAP-14.x, rounding the bytes written up to fill out the last file system block. Note that there are caveats for this mode, see the manual for further details.\n\n```\n$ scrub /path/to/file # where file is a regular file\n```\n\nThe following command invokes scrub with the default settings, in mode 3, creating a directory and filling it with files until the file system is full. The files are then scrubbed using patterns compliant with NNSA Policy Letter NAP-14.x, rounding the bytes written up to fill out the last file system block. Note that there are caveats for this mode, see the manual for further details.\n\n```\n$ scrub /path/to/dir # where dir is a new directory name.\n```\n\nFor further usage and information, see the manual.\n\n"
    },
    {
      "title": "badblocks",
      "level": 3,
      "content": "The tool badblocks from e2fsprogs is able to perform destructive read-write test, effectively wiping the device. By default, it performs four passes and can take a long time.\n\n```\n# badblocks -wsv /dev/device\n```\n\n"
    },
    {
      "title": "hdparm",
      "level": 3,
      "content": "hdparm supports ATA Secure Erase, which is functionally equivalent to zero-filling a disk. It is however handled by the hard drive firmware itself, and includes \"hidden data areas\". As such, it can be seen as a modern-day \"low-level format\" command. SSD drives reportedly achieve factory performance after issuing this command, but may not be sufficiently wiped (see #Flash memory).\n\nSome drives support Enhanced Secure Erase, which uses distinct patterns defined by the manufacturer. If the output of hdparm -I for the device indicates a many-fold time advantage for the Enhanced erasure, the device probably has a hardware encryption feature and the wipe will be performed to the encryption keys only.\n\nFor detailed instructions on using ATA Secure Erase, see Solid state drive/Memory cell clearing and the Linux ATA wiki.\n\n"
    },
    {
      "title": "blkdiscard",
      "level": 3,
      "content": "See Solid state drive/Memory cell clearing#Common method with blkdiscard\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Wipe free space in Linux\n\n"
    }
  ]
}