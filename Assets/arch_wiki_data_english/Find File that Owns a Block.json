{
  "title": "Find File that Owns a Block",
  "url": "https://wiki.archlinux.org/title/Find_File_that_Owns_a_Block",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- badblocks\n- File recovery\n\nThis article gives details on how to find out which file owns a given disk sector. The main purpose for doing so is finding out which file was damaged in the event a storage device develops any bad sectors (that way you will know if you lost anything important).\n\nFor most of these commands you will have to be either root or a user that has direct read access to the drive you are checking (being a member of the disk group should be enough). As usual, a current backup is always a good idea, especially if imminent drive failure is suspected. S.M.A.R.T. can help determining that.\n\n"
    },
    {
      "title": "btrfs",
      "level": 3,
      "content": "Unlike other filesystem types, btrfs has native support for reporting on damaged files. When scrubbing a partition, btrfs reads all data and metadata blocks and verifies checksums. It automatically repairs corrupted blocks if there is a correct copy available in a RAID configuration. btrfs also reports any unreadable sector along with the affected file via system log.\n\n"
    },
    {
      "title": "Find damaged files",
      "level": 4,
      "content": "First of all, scrub the damaged partition:\n\n```\n# btrfs scrub start -Bd /dev/sdxy\n```\n\nThe same partition can be scrubbed when mounted by providing its mount point:\n\n```\n# btrfs scrub start -Bd /mnt/point\n```\n\nScrub reports can be retrieved as many times as need with the status subcommand:\n\n```\n# btrfs scrub status /mnt/point\n```\n\n```\nscrub status for e11013b3-b244-4d1a-a9c7-3956db1a699c\n        scrub started at Thu Apr 23 19:07:45 2015 and finished after 372 seconds\n        total bytes scrubbed: 301.13GiB with 1 errors\n        error details: read=1\n        corrected errors: 0, uncorrectable errors: 1, unverified errors: 0\n```\n\nWhen done, search the kernel log for I/O errors:\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\n```\n# journalctl --output=cat --grep='BTRFS .* i/o error' | sort | uniq | less\n```\n\n```\nJan 16 23:14:19 my_server kernel: BTRFS: i/o error at logical 398602014720 on dev /dev/sdxy, sector 4621320, root 5, inode 23839, offset 4378624, length 4096, links 1 (path: my/damaged/file)\n```\n\nThe output above reveals that sector 4621320 could not be read and it contains data for file my/damaged/file. The sector number can be directly used with hdparm when reallocating (see #Force the disk to reallocate bad block).\n\n"
    },
    {
      "title": "Debug the filesystem",
      "level": 4,
      "content": "The tune2fs command will give you access to all the low level structures within any ext2/ext3/ext4 filesystem.\n\nThe first thing we want to do is get the block size from the filesystem in question. Just run:\n\n```\n# tune2fs -l /dev/sdxy | grep Block\n```\n\n```\nBlock count:              29119820\nBlock size:               4096\n```\n\nIn this case 4096 is the block size being used (it appears to be the default).\n\nIf you did not run badblocks using the block size that your filesystem is using then you will need to convert your block number(s) to match it (remember to use the block number(s) relative to the partition they are on).\n\ni.e. block number 100 with a block size of 1024 bytes becomes block number 25 at 4096 bytes. The formula is:\n\n```\n(original block number) / ((filesystem block size) / (badblocks block size))\n```\n\nNow the entire point of running this program (for the purpose of this article) is to get the inode number. Before continuing to debug it, unmount the partition. Then, run the command:\n\n```\n# debugfs\n```\n\nThen in the debugfs console, use the open command on the ext partition containing the bad sector:\n\n```\ndebugfs:  open /dev/sdxy\n```\n\nFinally, use the testb command to get information about the block in question (in this example block 1000):\n\n```\ndebugfs:  testb blocknumber\n```\n\nIf the block is in use then run this command to get the inode number\n\n```\nicheck blocknumber\n```\n\nThis will return two numbers. The block number and the inode number.\n\n"
    },
    {
      "title": "Find damaged files",
      "level": 4,
      "content": "Use the inode number (second number from the icheck command) with the ncheck command:\n\n```\nncheck inodenumber\n```\n\nThe debugfs console will give you the full pathname to the file using the bad block. Now you will know what was actually damaged.\n\nIf the inode number is very small and ncheck fails to return a path then it is probably the journal itself that is damaged. To delete the journal simply run this command on the partition:\n\n```\n# tune2fs -O ^has_journal /dev/sdxy\n```\n\nRun the testb command again from the debugfs console on the bad block and it should be no longer marked as used if it was indeed used by the journal. To build a new journal run:\n\n```\n# tune2fs -j /dev/sdxy\n```\n\n"
    },
    {
      "title": "Debug the filesystem",
      "level": 4,
      "content": "The jfs_debugfs command will give you access to all the low level structures within any JFS filesystem. Other filesystems such as the ext3 and ext4 filesystems have similar tools. It is probably a good idea to umount any filesystem before you run this on them. To use it just run:\n\n```\n# jfs_debugfs /dev/sdxy\n```\n\nThis puts you into a command console. The first thing you should note is your aggregate block size. This is (presumably) the block size the filesystem is using. JFS seems to default to 4096 bytes.\n\nIf you did not run badblocks using the block size that your filesystem is using then you will need to convert your block number(s) to match it (remember to use the block number(s) relative to the partition they are on).\n\ni.e. block number 100 with a block size of 1024 bytes becomes block number 25 at 4096 bytes. The formula is:\n\n```\n(original block number) / ((filesystem block size) / (badblocks block size))\n```\n\nNow the entire point of running this program (for the purpose of this article) is to get the inode number. To do this run the command:\n\n```\nd blocknumber 0 i\n```\n\nThe syntax is the d command for display, the block number, the offset (just set it to 0), and the display format i for inode.\n\nThe decimal number that di_number is set to is the one we want. From here you type x to exit out of the display mode. Repeat the display command for each bad block that you have and note all of their inode numbers. For more info on the inode such as permissions and filetype type:\n\n```\ni inodenumber\n```\n\nWhen you have all the inode numbers type q to quit.\n\n"
    },
    {
      "title": "Find damaged files",
      "level": 4,
      "content": "Finally to find the damaged file you can simply use the gnu find utility. Mount your filesystem and run:\n\n```\n# find / -inum inodenumber\n```\n\nSubstitute / for the mountpoint of the filesystem that the inode belongs to. If you search root and have more than one filesystem mounted you can find multiple files with the same inode number on different filesystems, plus find will take significantly longer. Remember, an inode is only unique to the filesystem that it is in.\n\n"
    },
    {
      "title": "Debug the filesystem",
      "level": 4,
      "content": "The xfs_info command will give you basic information about an XFS formatted partition and the xfs_db command will give you access to all the low level structures within any XFS filesystem.\n\nThe first thing we want to do is get the block size from the filesystem in question. Just run:\n\n```\n# xfs_info /dev/sdxy | grep bsize\n```\n\n```\ndata     =                       bsize=4096   blocks=127739, imaxpct=25\nnaming   =version 2              bsize=4096   ascii-ci=0 ftype=1\nlog      =internal               bsize=4096   blocks=855, version=2\n```\n\nIn this case 4096 is the block size being used (it appears to be the default).\n\nIf you did not run badblocks using the block size that your filesystem is using then you will need to convert your block number(s) to match it (remember to use the block number(s) relative to the partition they are on).\n\ni.e. block number 100 with a block size of 1024 bytes becomes block number 25 at 4096 bytes. The formula is:\n\n```\n(original block number) / ((filesystem block size) / (badblocks block size))\n```\n\nNow the entire point of running this program (for the purpose of this article) is to get the inode number. Before continuing to debug it, unmount the partition. Then, run the command:\n\n```\n# xfs_db -c 'blockget -b blocknumber' /dev/sdxy\n```\n\nYou should get output similar to this:\n\n```\nsetting block 0/9 to data\n   setting inode to 131 for block 0/9\n   inode 131 block 9 at offset 0\n```\n\nIn this example we now know the inode is 131 and can proceed to the next section\n\nIf instead you do not get an inode number in your output but do see the word free then likely this means that the bad block belongs to free space and nothing important was damaged.\n\n"
    },
    {
      "title": "Find damaged files",
      "level": 4,
      "content": "Finally to find the damaged file you can simply use the gnu find utility. Mount your filesystem and run:\n\n```\n# find / -inum inodenumber\n```\n\nSubstitute / for the mountpoint of the filesystem that the inode belongs to. If you search root and have more than one filesystem mounted you can find multiple files with the same inode number on different filesystems, plus find will take significantly longer. Remember, an inode is only unique to the filesystem that it is in.\n\n```\n# xfs_db -c 'blockget -n -b blocknumber' -c 'blockuse -n' /dev/sdXy\n```\n\n"
    },
    {
      "title": "Force the disk to reallocate bad block",
      "level": 2,
      "content": "First you will want to see how many badblocks the harddrive is aware of through the smartctl command:\n\n```\n# smartctl -t long /dev/sdx\n```\n\nWait until test completes, then:\n\n```\n# smartctl -l selftest /dev/sdx\n```\n\n```\nID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE\n  5 Reallocated_Sector_Ct   0x0033   100   100   005    Pre-fail  Always       -       0\n196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0\n197 Current_Pending_Sector  0x0022   100   100   000    Old_age   Always       -       0\n198 Offline_Uncorrectable   0x0008   100   100   000    Old_age   Offline      -       0\n```\n\nTo make the harddrive transparently map out the badblock with a spare good sector you will have to simply write zeros to the bad block using the dd command as root. Remember that with this command you have to work with the same block size as your filesystem and the block has to be relative to the partition the filesystem is on and not the harddrive as a whole:\n\n```\n# dd if=/dev/zero of=/dev/sdxy bs=4096 count=1 seek=2269012\n$ sync\n```\n\nAlternatively, hdparm provides a couple of nice and simple options to read and write a given sector (4621327, in the following example):\n\n```\n# hdparm --read-sector 4621327 /dev/sdxy\n# hdparm --repair-sector 4621327 --yes-i-know-what-i-am-doing /dev/sdxy\n```\n\nYou can see if the harddrive did indeed map out an additional bad sector by checking with the smartctl command and seeing if the reallocated sector or event count went up:\n\n```\n# smartctl -A /dev/sdx\n```\n\n```\nID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE\n  5 Reallocated_Sector_Ct   0x0033   100   100   005    Pre-fail  Always       -       1\n196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       1\n197 Current_Pending_Sector  0x0022   100   100   000    Old_age   Always       -       0\n198 Offline_Uncorrectable   0x0008   100   100   000    Old_age   Offline      -       1\n```\n\nTo get Offline_Uncorrectable to go back to 0 you need to run a SMART long test and a selftest:\n\n```\n# smartctl -t long /dev/sdx\n```\n\nWait until test completes, then:\n\n```\n# smartctl -l selftest /dev/sdx\n```\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Tracing a disk's sector number through md and LVM to a filesystem by Andy Smith of BitFolk\n- EXT2/3 badblocks howto\n\n"
    }
  ]
}