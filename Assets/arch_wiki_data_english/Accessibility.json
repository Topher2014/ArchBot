{
  "title": "Accessibility",
  "url": "https://wiki.archlinux.org/title/Accessibility",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "There are many different methods of providing accessibility to users that have a physical or visual handicap. However, unless a desktop environment is used, the configuration might require some tinkering until one gets it right.\n\n"
    },
    {
      "title": "Desktop environments",
      "level": 2,
      "content": "Most modern desktop environments ship with an extensive set of features, among which one can find a tool for configuring the accessibility options. Generally, these options can be found listed under those of 'accessibility', or under those of the corresponding input device (e.g. 'keyboard' and 'mouse'). For example, with GNOME and KDE.\n\n"
    },
    {
      "title": "Xorg accessibility features",
      "level": 2,
      "content": "The Xorg server has features (accessx) for physical assistance by setting parameters via the X keyboard extension. This section covers examples.\n\nFor speech recognition, see also Text to speech\n\n"
    },
    {
      "title": "Sticky keys with xserverrc",
      "level": 3,
      "content": "One method of enabling desktop environment-independent accessibility function is by passing it through X, given that it is build with XKB support. This can be done by setting parameters for the X server, as specified in its man page:\n\n```\n[+-]accessx [ timeout [ timeout_mask [ feedback [ options_mask ] ] ] ]\n              enables(+) or disables(-) AccessX key sequences (Sticky Keys).\n\n-ardelay milliseconds\n              sets the autorepeat delay (length of time in milliseconds  that\n              a key must be depressed before autorepeat starts).\n\n-arinterval milliseconds\n              sets  the  autorepeat  interval (length of time in milliseconds\n              that should elapse between autorepeat-generated keystrokes).\n```\n\nThese parameters must be placed in the file ~/.xserverrc, which you may need to create.\n\nFor example, to enable Sticky Keys without timeout and without audible or visible feedback, the following can be used:\n\n```\nif [ -z \"$XDG_VTNR\" ]; then\n  exec /usr/bin/X -nolisten tcp \"$@\" +accessx 0 0x1e 0 0xcef\nelse\n  exec /usr/bin/X -nolisten tcp \"$@\" vt$XDG_VTNR +accessx 0 0x1e 0 0xcef\nfi\n```\n\nNote that once X has started, e.g. by executing startx, it still requires you to press the shift key 5 times to enable Sticky Keys. Unfortunately, this is needed each time X starts. Alternatively, a script can be used to automate this process.\n\nSimilar to most implementations, Sticky Keys can be disabled by pressing a modifier key and any other key at the same time.\n\n"
    },
    {
      "title": "Remapping mouse buttons",
      "level": 3,
      "content": "By using xmodmap, you can map functions to mouse buttons independent of your graphical environment. For this, you need to know which physical button on your mouse is read as which number, which can be found by a tool such as xorg-xev. Generally, the physical buttons of left, middle, and right are read as the first, second, and third button, respectively.\n\nOnce you have acquired these, continue by creating a configuration file on a suitable location, e.g. ~/.mouseconfig. Next, open the file with your favourite editor, and write the keyword pointer = followed by an enumeration of the previously-found number of mouse buttons.\n\nFor example, a three button mouse with a scroll wheel is able to provide five physical actions: left, middle, and right click, as well as scroll up and scroll down. This can be mapped to the same functions by using the following line in the configuration file:\n\n```\npointer = 1 2 3 4 5\n```\n\nHere, the location will tell the action required to perform an internal mouse-button function. For example, a mapping for left-handed people (left- and right button switched) might look like\n\n```\npointer = 3 2 1 4 5\n```\n\nWhen you are done, you can test and inspect your mapping by running xmodmap:\n\n```\n$ xmodmap ~/.mouseconfig\n$ xmodmap -pp\n```\n\nOnce satisfied, you can enable it on start by placing the first line in ~/.xinitrc.\n\n"
    },
    {
      "title": "Mouse keys",
      "level": 3,
      "content": "Mouse keys is a Xorg feature (like StickyKeys) to use the keyboard (especially a numeric keypad) as a pointing device. It can replace a mouse, or work beside it. It is disabled by default. You can use\n\n```\n$ xset q | grep \"Mouse Keys\"\n```\n\nto see status. To enable it for a session:\n\n```\n$ setxkbmap -option keypad:pointerkeys\n```\n\nIf you use a xmodmap configuration, be aware setxkbmap resets it.\n\nTo enable Mouse keys permanently, add\n\n```\nOption \"XkbOptions\" \"keypad:pointerkeys\"\n```\n\nto the keyboard configuration file. This will make the Shift+NumLock shortcut toggle mouse keys.\n\nFor more, see Keyboard configuration in Xorg#Using X configuration files and X keyboard extension#Mouse control for advanced configuration.\n\n"
    },
    {
      "title": "Generic solutions",
      "level": 2,
      "content": "The following solutions are agnostic the chosen display server and desktop environment.\n\n"
    },
    {
      "title": "Sticky keys in a TTY",
      "level": 3,
      "content": "In order to enable Sticky Keys in a TTY, you require to know the exact keycodes of the keys to be used. These can be found by a tool like xorg-xev or xkeycaps. Alternatively, you can inspect the output of dumpkeys, provided that the current keymap is correct.\n\nFor example, a Logitech Ultra-X will provide the following keycodes for the modifier keys:\n\n```\nLCtrl = 29\nLShift = 42\nLAlt = 56\nRShift = 54\nRCtrl = 97\n```\n\nNext, use dumpkeys to determine the range of the keycodes:\n\n```\n# dumpkeys | head -1\n```\n\n```\nkeymaps 0-63\n```\n\nContinue by creating a new file with a suitable name, e.g. \"stickyKeys\", and use your favourite editor to combine the previously-found information with the desired key function.\n\nIn case of the keycodes found earlier, you would get:\n\n```\nkeymaps 0-63\nkeycode 29 = SCtrl\nkeycode 42 = SShift\nkeycode 56 = SAlt\nkeycode 54 = SShift\nkeycode 97 = SCtrl\n```\n\nHere, the letter \"S\" in front of a modifier key denotes that we want the sticky version of that key.\n\nLoad your new mapping by running the following command:\n\n```\n# loadkeys ./stickyKeys\n```\n\nIf you are satisfied by the results, then move the file to a suitable directory. To have it enabled on boot, see the following systemd unit:\n\n```\n/etc/systemd/system/loadkeys.service\n```\n\n```\n[Unit]\nDescription=\"load custom keymap (sticky keys)\"\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/loadkeys /path/to/stickyKeys\nStandardInput=tty\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target emergency.target rescue.target\n```\n\n"
    },
    {
      "title": "Sticky keys with keyd",
      "level": 3,
      "content": "keyd (keyd) is a system-wide key remapping daemon for Linux that can be configured to provide sticky keys functionality for Xorg and Wayland, and for the Linux virtual console.\n\nTo enable this functionality, first install and enable keyd. Next, create the configuration file:\n\n```\n/etc/keyd/sticky_keys.conf\n```\n\n```\n# Tapping the modifier once causes it to apply to the next key, tapping it twice\n# activates it until it is pressed again, and holding it produces expected\n# behaviour.\n\n[ids]\n*\n\n[main]\n\ncontrol = oneshot(control)\nmeta = oneshot(meta)\nshift = oneshot(shift)\nleftalt = oneshot(alt)\n\n[control]\ncontrol = toggle(control)\n\n[meta]\nmeta = toggle(meta)\n\n[shift]\nshift = toggle(shift)\n\n[alt]\nleftalt = toggle(alt)\n```\n\nYou can now enable/start the keyd.service.\n\n"
    },
    {
      "title": "Visual assistance",
      "level": 3,
      "content": "As with physical assistance, most modern desktop environments ship with an extensive set of features to tweak the visual aspects of your system. Generally, these options can be found listed under those of 'accessibility' or 'visual assistance'. Alternatively, useful options might be found in the settings of the individual applications.\n\n"
    },
    {
      "title": "Speech recognition",
      "level": 4,
      "content": "See Speech recognition.\n\n"
    },
    {
      "title": "Console and virtual terminal emulators",
      "level": 4,
      "content": "- Edit /etc/vconsole.conf.\n- Edit ~/.Xresources.\n\n"
    },
    {
      "title": "Known issues",
      "level": 2,
      "content": "Configuration of input devices is not recognized by software that circumvents the software layer, e.g. Wine, VirtualBox, and QEMU.\n\n"
    },
    {
      "title": "Troubleshooting",
      "level": 2,
      "content": "Most graphical applications should work out of the box, such as Gtk-, Qt- or Gecko-based ones. You can verify the functionality by running accerciser. The application of choice should appear and have a deeply nested tree structure of children. Issues may arise if:\n\n- The application is Chromium- or Electron-based. These programs typically need both the environment variable ACCESSIBILITY_ENABLED=1, and an additional argument --force-renderer-accessibility when launching. For Chrome you can replace the latter step with enabling the accessibility options inside chrome://accessibility, however this seems to not persist after restart.\n- The application is Java-based. In this case, you need to install the ATK bridge java-atk-wrapper-openjdk8 (depending on your Java version).\n- In the rare case that the application is an exotic, old application built with qt4AUR, such as some programs that have not been maintained since 2015, you need to install at-spi2-core.\n- As a last resort, any of these other environment variables may help: GTK_MODULES=gail:atk-bridge, OOO_FORCE_DESKTOP=gnome, GNOME_ACCESSIBILITY=1, QT_ACCESSIBILITY=1, QT_LINUX_ACCESSIBILITY_ALWAYS_ON=1.\n\n"
    },
    {
      "title": "Disable accessibility",
      "level": 2,
      "content": "If you do not need accessibility and want to save processes a little, set the NO_AT_BRIDGE=1 and GTK_A11Y=none environment variables and mask the at-spi-dbus-bus.service user unit.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- KDE's Advanced accessibility applications.\n- Assistive technologies for the GNOME desktop.\n\n"
    }
  ]
}