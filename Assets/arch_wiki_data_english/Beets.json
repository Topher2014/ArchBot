{
  "title": "Beets",
  "url": "https://wiki.archlinux.org/title/Beets",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Beets is a music tagger and library organizer using the MusicBrainz database. It has been initially released in 2010 and is regularly updated since.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the beets package or beets-gitAUR for the development version.\n\nThe audio file decoding backend of Beets is audioread, a project developed by the same team. This backend works itself by using, among others, FFmpeg and/or GStreamer (including its gst-libav and gst-plugins-good packages) as backends.\n\nAdditionally, see the #Plugins for plugin specific dependencies.\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "User configuration is done using YAML syntax. For example:\n\n```\n~/.config/beets/config.yaml\n```\n\n```\ndirectory: ~/beets/library/     # Library directory to store music.\nlibrary: ~/beets/library.db     # Database file to store library state and metada.\n```\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "See the Getting Started guide to start with Beets. In this section, we assume that the reader already know the basics. The following operations are organized by their goal and are more advanced examples than the basics.\n\n"
    },
    {
      "title": "Get help and generalities",
      "level": 3,
      "content": "The beet command and its subcommands (e.g., import, list, etc.) supports a -h/--help flag to print the help. You can list enabled/loaded plugins using beet version. You can enable a verbose output for debugging using the -vv flag. Finally, you can ensure the default behavior without any loaded plugin only for one command using the --plugin=\"\" flag.\n\n"
    },
    {
      "title": "Add music",
      "level": 3,
      "content": "See Beets importing music.\n\nBy default, Beets will copy or move imported files as well as writing tags to the file. Beets support a read-only importation mode, where imported files will not be modified nor moved:\n\n```\n$ beet import -A -C -W path\n```\n\nAdditionally, one may enable the fetchart plugin using --plugin=fetchart such that Beets will look for album arts in the same directory as the imported file.\n\n"
    },
    {
      "title": "List music",
      "level": 3,
      "content": "See Beets seeing your music.\n\nBeets support custom format for listing the music. The fields name can be either a default/standard field (genre in the following example) or a custom/flexible field (mood in the following example) as long as it is used in the Beets SQLite database:\n\n```\n$ beet ls -f 'Mood: ${mood} Genre: ${genre}' query\n```\n\nHere are some corner cases when listing music:\n\n- List files without titles in their tags:\n\n```\n$ beet list -p \"title::^$\"\n```\n\n- List missing files in the library:\n\n```\n$ beet --plugin=\"badfiles\" bad 2>/dev/null | grep \"file does not exist\"\n```\n\n- Delete missing files from the library automatically:\n\n```\n$ beet --plugin=\"badfiles\" bad 2>/dev/null | grep \"file does not exist\" | cut -d \":\" -f 1 | xargs -I% beet remove -f path::%\n```\n\n"
    },
    {
      "title": "Remove music",
      "level": 3,
      "content": "See Beets remove.\n\n"
    },
    {
      "title": "Tag music",
      "level": 3,
      "content": "To run the Beets auto-tagger on already imported music, the way to go is to re-import the files directly from the music library:\n\n1. ...using a path: beet import /my/beets/library/my/album\n1. ...using a query (see #Querying)]: beet import -L query\n\nTo manually tag music, one may use the modify command or the edit command from the edit plugin (see #Plugins). Beware that the edit command will use the import configuration regarding moving (move option) and copying (copy option) for moving files after the command completion. For example, you can add two genre tags to the music using:\n\n```\n$ beet modify query genre=\"genre1;genre2\"\n```\n\nTagging modifications will be written to the database. To reflect the modifications into the file tags, use the following command:\n\n```\n$ beet write query\n```\n\n"
    },
    {
      "title": "Querying",
      "level": 3,
      "content": "Nearly all Beets commands operate on matching items (music files imported into the library) based on a query. You can list the fields available using the beet fields command. The query format is the following:\n\n"
    },
    {
      "title": "ReplayGain",
      "level": 3,
      "content": "ReplayGain support is accessible via an included plugin (see #Plugins). One can compute ReplayGain information for files matching the query using:\n\n```\n$ beet --plugin=\"replaygain\" replaygain query\n```\n\n"
    },
    {
      "title": "Album art",
      "level": 3,
      "content": "Album art is automatically fetched during the import, if the fetchart included plugin is enabled (see #Plugins). After importing, one can:\n\n- Manually add an image as an album art inside a file metadata:\n\n```\n$ beet --plugin=\"embedart\" embedart -f /path/to/image.jpg query\n```\n\nEnsure that the zero plugin is not loaded, otherwise it will delete our album art after saving it, therefore canceling our command.\n\n- Import an album art into the library:\n\n```\n$ beet --plugin=\"fetchart\" fetchart -q query\n```\n\nIt will search in priority for images on the filesystem, i.e., where the music is stored in the library.\n\n- Remove album art from files: First, include images in the fields parameter of the zero plugin inside the configuration file. Second, run:\n\n- First, include images in the fields parameter of the zero plugin inside the configuration file.\n- Second, run:\n\n```\n$ beet --plugin=\"zero\" zero query\n```\n\n"
    },
    {
      "title": "Plugins",
      "level": 2,
      "content": "Beets supports official plugins and community plugins. Here is a curated list of plugins that add major features that may be available in other music library organizer tools:\n\n"
    },
    {
      "title": "Enabling tab autocompletion",
      "level": 3,
      "content": "Autocompletion is supported for Bash and Zsh.\n\n"
    },
    {
      "title": "Bash",
      "level": 4,
      "content": "Beets includes support for Bash shell command completion. To enable completion, put the following line into your .bashrc:\n\n```\n~/.bashrc\n```\n\n```\neval \"$(beet completion)\"\n```\n\nYou will also need to install the package bash-completion for this to work.\n\n"
    },
    {
      "title": "Zsh",
      "level": 4,
      "content": "The official Arch package install the Zsh completion on the system. If using another installation method, to install the completions, make the beets/extra/_beet (from the upstream repository) file available in one of the Zsh's $fpath directories (either by a copy or symlink). Using the Zsh's Bash completion compatibility as suggested by the documentation does only work partially.\n\n"
    },
    {
      "title": "Setup the library directory (external drive, network)",
      "level": 3,
      "content": "Once imported, Beets hard code the path of each item of the library inside the SQLite's .db database file. Therefore, it is recommended to use a fixed path on the filesystem using a link redirecting to the actual directory storing the Beets library.\n\nNote: **not** \n\nIt has the following advantages:\n\n1. Having the link of the library pointing to different paths across machines, when the library is synced but not available on the same path.\n1. Allowing to dynamically change the path of the library by updating the symbolic link, for example, when switching to a synced external hard drive.\n1. Not having to deal with SQLite's database items path when the library is moved. Indeed, if you change the library location on the filesystem without any beet command, it will be cumbersome to change the path of already imported items inside the database file (see #Updating the library directory).\n\nAs an example, to use a symlink with a fixed path of /srv/beets pointing to a library mounted over network at /mnt/network/beets, execute:\n\n```\n$ ln -sfT /srv/beets /mnt/network/beets\n```\n\nYou can rexecute the same command to update the symlink to another location later. In the configuration file, one should have:\n\n```\n~/.config/beets/config.yaml\n```\n\n```\ndirectory: /srv/beets\n```\n\n"
    },
    {
      "title": "Updating the library directory",
      "level": 3,
      "content": "According to Beets' FAQ, two regular options are offered to modify the path to the library directory (containing music files) after the files have been imported:\n\n1. Make the modification in ~/.config/beets/config.yaml and use beet move. This solution has the disadvantage that the library should be moved by Beets itself, and not before by an external program.\n1. Delete the SQLite database (.db file) and re-create it from the new path using beet import -AWC. This solution has the disadvantage that the custom tags that are stored inside the SQLite database itself (instead of inside the music files' metadata/header) would be lost.\n\nThe last solution suggested by Beets developers are to manually modifying the SQLite database without further indication. This can be achieved by the following, assuming that SQLite is installed, and that the old and new paths of the library was /old/library/path and /new/library/path, respectively.\n\n1. Make a backup of the library database and open it:\n\n```\n$ cp /path/to/library.db /path/to/library.db.bak\"\n$ sqlite /path/to/library.db\n```\n\n2. List the tables to check that the scheme corresponds to the following UPDATE requests, and update it (in-place):\n\n```\nsqlite> .schema\nsqlite> UPDATE items  SET path    = REPLACE(path,    '/old/library/path', '/new/library/path');\nsqlite> UPDATE albums SET artpath = REPLACE(artpath, '/old/library/path', '/new/library/path');\n```\n\n3. Exit SQLite:\n\n```\nsqlite> .exit\n```\n\n4. Check that Beets correctly list the files of the library under the new path:\n\n```\n$ beet ls -p [QUERY]\n```\n\n"
    },
    {
      "title": "Synchronization across computers and external drives",
      "level": 3,
      "content": "Beets does not implement any syncing mechanisms on its own. However, its architecture makes it well suited to be used with other FOSS syncing software (as reported in its GitHub Issue #271):\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Website\n- GitHub\n- Documentation Command line interface Configuration guide FAQ Plugins\n- Manpages: beet(1): Command-line interface of Beets. beetsconfig(5): Configuration file of Beets.\n\n- Command line interface\n- Configuration guide\n- FAQ\n- Plugins\n\n- beet(1): Command-line interface of Beets.\n- beetsconfig(5): Configuration file of Beets.\n\n"
    }
  ]
}