{
  "title": "Suspend to ram",
  "url": "https://wiki.archlinux.org/title/Suspend_to_ram",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- systemd\n- Power management\n- Wakeup triggers\n- swap\n\nThere are multiple methods of suspending available, notably:\n\nThe kernel provides basic functionality, and some high level interfaces provide tweaks to handle problematic hardware drivers/kernel modules (e.g. video card re-initialization).\n\n"
    },
    {
      "title": "Kernel interface (swsusp)",
      "level": 2,
      "content": "It is possible to directly inform the in-kernel software suspend code (swsusp) to enter a suspended state; the exact method and state depends on the level of hardware support. On modern kernels, writing appropriate strings to /sys/power/state is the primary mechanism to trigger this suspend.\n\nSee kernel documentation for details.\n\n"
    },
    {
      "title": "High level interface (systemd)",
      "level": 2,
      "content": "systemd provides native commands for suspend, hibernate and a hybrid suspend. This is the default interface used in Arch Linux.\n\nsystemctl suspend should work out of the box. For systemctl hibernate to work on your system you might need to follow the instructions at #Hibernation.\n\nThere are also two modes combining suspend and hibernate:\n\n- systemctl hybrid-sleep suspends the system both to RAM and disk, so a complete power loss does not result in lost data. This mode is also called suspend to both.\n- systemctl suspend-then-hibernate initially suspends the system to RAM as long as possible, then wakes it with an RTC alarm and hibernates. The RTC alarm is set with HibernateDelaySec in systemd-sleep.conf(5). The default value is set by estimating the battery discharge rate to keep the system with 5% of battery, or two hours without one. Said estimation is obtained from the change in battery level after the time specified by SuspendEstimationSec in systemd-sleep.conf(5), at which the system will briefly wake up to do the measurement (a measure is also made if the system is manually woken up from suspension).\n\nSee #Sleep hooks for additional information on configuring suspend/hibernate hooks. Also see systemctl(1), systemd-sleep(8), and systemd.special(7).\n\n"
    },
    {
      "title": "Changing suspend method",
      "level": 2,
      "content": "On systems where S0ix suspension does not provide the same energy savings as the regular S3 sleep, or when conserving energy is preferred to a quick resume time, changing the default suspend method is possible.\n\nRun the following command to see all suspend methods hardware advertises support for (current method is shown in square brackets[1]):\n\n```\n$ cat /sys/power/mem_sleep\n```\n\n```\n[s2idle] shallow deep\n```\n\nTable content:\nmem_sleep string | Sleep State\ns2idle | suspend-to-idle\nshallow | standby\ndeep | suspend-to-RAM\n\nIf your hardware does not advertise the deep sleep status, check first if your UEFI advertises some settings for it, generally under Power or Sleep state or similar wording, with options named Windows 10, Windows and Linux or S3/Modern standby support for S0ix, and Legacy, Linux, Linux S3 or S3 enabled for S3 sleep. Failing that, you can keep using s2idle, consider using hibernation or try to patch the DSDT tables (or find a patched version online).\n\nConfirm that your hardware does not exhibit issues with S3 sleep by testing a few sleep cycles after changing the sleep method:\n\n```\n# echo deep > /sys/power/mem_sleep\n```\n\nIf no issues have been found, you can make the change permanent through the MemorySleepMode directive in systemd-sleep.conf(5):\n\n```\n/etc/systemd/sleep.conf.d/mem-deep.conf\n```\n\n```\n[Sleep]\nMemorySleepMode=deep\n```\n\nor through the mem_sleep_default=deep kernel parameter.\n\nIn some opposite situations, faulty firmware advertises support for deep sleep, while only s2idle is supported. In this case, an alternative method for using s2idle is available through the SuspendState setting:\n\n```\n/etc/systemd/sleep.conf.d/freeze.conf\n```\n\n```\n[Sleep]\nSuspendState=freeze\n```\n\n"
    },
    {
      "title": "Hibernation",
      "level": 2,
      "content": "In order to use hibernation, you must create a swap partition or file, configure the initramfs so that the resume process will be initiated in early userspace, and specify the location of the swap space in a way that is available to the initramfs, e.g. HibernateLocation EFI variable defined by systemd or resume= kernel parameter. These three steps are described in detail below.\n\n- See dm-crypt/Swap encryption#With suspend-to-disk support when using encryption.\n- linux-hardened does not support hibernation, see FS#63648.\n- Hibernating to swap on zram is not supported, even when zram is configured with a backing device on permanent storage. While logind will protect against attempts to hibernate into swap space on zram, as an alternative you can create multiple swap spaces. The memory will be stored into a swap file while another available swap space is reserved for zram. See details in #Maintaining swap file for hibernation with zram.\n\n"
    },
    {
      "title": "About swap partition/file size",
      "level": 3,
      "content": "Even if your swap partition is smaller than RAM, you still have a good chance of hibernating successfully. See \"image_size\" in the kernel documentation for information on the image_size sysfs(5) pseudo-file.\n\nYou may either decrease the value of /sys/power/image_size to make the suspend image as small as possible (for small swap partitions), or increase it to possibly speed up the hibernation process. For systems with a large amount of RAM, smaller values may drastically increase the speed of resuming a hibernating system. systemd#systemd-tmpfiles - temporary files can be used to make this change persistent:\n\n```\n/etc/tmpfiles.d/hibernation_image_size.conf\n```\n\n```\n#    Path                   Mode UID  GID  Age Argument\nw    /sys/power/image_size  -    -    -    -   0\n```\n\nThe suspend image cannot span multiple swap partitions and/or swap files. It must fully fit in one swap partition or one swap file.[2]\n\n"
    },
    {
      "title": "Configure the initramfs",
      "level": 3,
      "content": "- When an initramfs with the systemd hook is used, a resume mechanism is already provided, and no further hooks need to be added.\n\n- When using a busybox-based initramfs, which is the default, the resume hook is required in /etc/mkinitcpio.conf. Whether by label or by UUID, the swap partition is referred to with a udev device node, so the resume hook must go after the udev hook. This example was made starting from the default hook configuration:\n\n```\nHOOKS=(base udev autodetect microcode modconf kms keyboard keymap consolefont block filesystems resume fsck)\n```\n\n"
    },
    {
      "title": "Pass hibernate location to initramfs",
      "level": 3,
      "content": "When the system hibernates, the memory image is dumped to the swap space, which also includes the state of mounted file systems. Therefore, the hibernate location must be made available to the initramfs, i.e. before the root file system is mounted for resuming from hibernate to work.\n\nSince systemd v255 and mkinitcpio v38, when the system is running on UEFI, systemd-sleep(8) will automatically pick a suitable swap space to hibernate into, and the information of the used swap space is stored in HibernateLocation EFI variable. Upon next boot, systemd-hibernate-resume(8) reads the location off the EFI variable and the system resumes. This means the following steps are not necessary unless the system is using legacy BIOS or you want to choose a different swap space from the automatically-selected one.\n\n"
    },
    {
      "title": "Manually specify hibernate location",
      "level": 4,
      "content": "The kernel parameter resume=swap_device can be used, where swap_device follows the persistent block device naming. For example:\n\n- resume=UUID=4209c845-f495-4c43-8a03-5363dd433153\n- resume=\"PARTLABEL=Swap partition\"\n- resume=/dev/archVolumeGroup/archLogicalVolume â€“ if swap is on a LVM logical volume (UUID and Label should also work)\n\nThe kernel parameters will only take effect after rebooting. To hibernate right away, obtain the volume's major and minor device numbers from lsblk and echo them in format major:minor to /sys/power/resume.\n\nFor example, if the swap device is 8:3:\n\n```\n# echo 8:3 > /sys/power/resume\n```\n\nIf using a swap file, additionally follow the procedures in #Acquire swap file offset.\n\nWhen using a swap file for hibernation, the block device on which the file system lies should be specified in resume=, and additionally the physical offset of swap file must be specified through resume_offset= kernel parameter. [3]\n\nOn file systems other than Btrfs, the value of resume_offset= can be obtained by running filefrag -v swap_file. The output is in a table format and the required value is in the first row of the physical_offset column.\n\nFor example:\n\n```\n# filefrag -v /swapfile\n```\n\n```\nFilesystem type is: ef53\nFile size of /swapfile is 4294967296 (1048576 blocks of 4096 bytes)\n ext:     logical_offset:        physical_offset: length:   expected: flags:\n   0:        0..       0:      38912..     38912:      1:\n   1:        1..   22527:      38913..     61439:  22527:             unwritten\n   2:    22528..   53247:     899072..    929791:  30720:      61440: unwritten\n...\n```\n\nIn the example the value of resume_offset= is the first 38912.\n\nAlternatively, to directly acquire the offset value:\n\n```\n# filefrag -v swap_file | awk '$1==\"0:\" {print substr($4, 1, length($4)-2)}'\n```\n\nFor Btrfs, do not try to use the filefrag tool, since the \"physical\" offset you get from filefrag is not the real physical offset on disk; there is a virtual disk address space in order to support multiple devices.[4] Instead, use the btrfs-inspect-internal(8) command. E.g.:\n\n```\n# btrfs inspect-internal map-swapfile -r swap_file\n```\n\n```\n198122980\n```\n\nIn this example, the kernel parameter would be resume_offset=198122980.\n\nTo apply the change immediately (without rebooting), echo the resume offset to /sys/power/resume_offset. For example, if the offset is 38912:\n\n```\n# echo 38912 > /sys/power/resume_offset\n```\n\n"
    },
    {
      "title": "Change the image compression algorithm for hibernation",
      "level": 3,
      "content": "Starting with Linux 6.9[5], the image compression algorithm for hibernation can be changed. The default compression algorithm is selected based on the compile time option CONFIG_HIBERNATION_DEF_COMP, but it can be overridden at boot time and runtime.\n\nDifferent compression algorithms have different characteristics and hibernation may benefit when it uses any of these algorithms, especially when a secondary algorithm (LZ4) offers better decompression speeds over a default algorithm (LZO), which in turn reduces hibernation image restore time.\n\nYou can override the default algorithm in two ways:\n\n1) Passing hibernate.compressor as a kernel parameter:\n\n```\nhibernate.compressor=lzo\nhibernate.compressor=lz4\n```\n\n2) Specifying the algorithm at runtime:\n\n```\n# echo lzo > /sys/module/hibernate/parameters/compressor\n# echo lz4 > /sys/module/hibernate/parameters/compressor\n```\n\nCurrently lzo and lz4 are the supported algorithms with LZO being the default.\n\n"
    },
    {
      "title": "Maintaining swap file for hibernation with zram",
      "level": 3,
      "content": "It is possible to solve the hibernation problem with zram RAM-only swap by maintaining two or more swap spaces at the same time. systemd will always ignore zram block devices before triggering hibernation [6], therefore keeping both spaces enabled should work without further intervention.\n\nAfter configured the swap file, follow the zram page. Make sure zram has the higher swap priority (e.g. pri=100).\n\nNote: **Do not** \n\n- Do not create an on-demand swap unit for hibernation as it is not officially supported. See systemd issues #16708 and #30083.\n- The kernel alone is responsible for reclaiming anonymous memory of pages and swapping them; not using a swap space can actually lead to bad memory usage. The user can manage priorities in reclaiming memory for certain applications in the form of memory.low, tunable by control groups. Overall this is more effective than setting the swappiness parameter.\n- Read the Swap Management in kernel documentation and the Chris Down's article - In defence of swap: common misconceptions for more details.\n\n"
    },
    {
      "title": "Hibernation into a thinly-provisioned LVM volume",
      "level": 3,
      "content": "Hibernation into a thinly-provisioned LVM volume is possible, but you have to make sure that the volume is fully allocated. Otherwise resuming from it will fail, see FS#50703.\n\nYou can fully allocate the LVM volume by simply filling it with zeros. E.g.:\n\n```\n# dd if=/dev/zero of=/dev/vg0/swap bs=1M status=progress\n```\n\nTo verify the volume is fully allocated, you can use:\n\n```\n# lvs\n```\n\n```\nLV                   VG  Attr       LSize   Pool Origin    Data%  Meta%  Move Log Cpy%Sync Convert\n  swap                 vg0 Vwi-aot--- 10.00g  pool           100\n```\n\nA fully allocated volume will show up as having 100% data usage.\n\n"
    },
    {
      "title": "Disable zswap writeback to use the swap space only for hibernation",
      "level": 3,
      "content": "In Linux 6.8, zswap gained a per-cgroup option to disable writeback. By using systemd unit setting MemoryZSwapWriteback (see systemd.resource-control(5) Â§ Memory Accounting and Control) in all possible unit types, zswap writeback can be effectively disabled entirely. This allows to use zswap just like zram with the added benefit of supporting hibernation.\n\nTo avoid having to manually create twelve top level per-type drop-in files (for system and user scope, service, slice, socket, mount, swap units types), install zswap-disable-writebackAUR. Enable zswap and reboot for the settings to take effect.\n\nTry to perform memory intensive tasks and confirm that zswap has not written anything to disk:\n\n```\n# cat /sys/kernel/debug/zswap/written_back_pages\n```\n\n```\n0\n```\n\n"
    },
    {
      "title": "Custom systemd units",
      "level": 3,
      "content": "systemd starts suspend.target, hibernate.target, hybrid-sleep.target, or suspend-then-hibernate.target for each sleep state, respectively. All the aforementioned targets pull in sleep.target. Any of the targets can be used to invoke custom units before or after suspend/hibernate. Separate files should be created for user actions and root/system actions. Examples:\n\n```\n/etc/systemd/system/user-suspend@.service\n```\n\n```\n[Unit]\nDescription=User suspend actions\nBefore=sleep.target\n\n[Service]\nUser=%I\nType=forking\nEnvironment=DISPLAY=:0\nExecStartPre= -/usr/bin/pkill -u %u unisonÂ ; /usr/local/bin/music.sh stop\nExecStart=/usr/bin/sflock\nExecStartPost=/usr/bin/sleep 1\n\n[Install]\nWantedBy=sleep.target\n```\n\n```\n/etc/systemd/system/user-resume@.service\n```\n\n```\n[Unit]\nDescription=User resume actions\nAfter=suspend.target hibernate.target\n\n[Service]\nUser=%I\nType=simple\nExecStart=/usr/local/bin/ssh-connect.sh\n\n[Install]\nWantedBy=suspend.target hibernate.target\n```\n\nEnable user-suspend@user.service and/or user-resume@user.service for the change to take effect.\n\nFor root/system actions:\n\n```\n/etc/systemd/system/root-suspend.service\n```\n\n```\n[Unit]\nDescription=Local system suspend actions\nBefore=sleep.target\n\n[Service]\nType=simple\nExecStart=-/usr/bin/pkill sshfs\n\n[Install]\nWantedBy=sleep.target\n```\n\n```\n/etc/systemd/system/root-resume.service\n```\n\n```\n[Unit]\nDescription=Local system resume actions\nAfter=suspend.target hibernate.target\n\n[Service]\nType=simple\nExecStart=/usr/bin/systemctl restart mnt-media.automount\n\n[Install]\nWantedBy=suspend.target hibernate.target\n```\n\n"
    },
    {
      "title": "Combined sleep/resume unit",
      "level": 4,
      "content": "With the combined unit file, a single hook does all the work for different phases (sleep/resume) and for different targets.\n\nExample and explanation:\n\n```\n/etc/systemd/system/wicd-sleep.service\n```\n\n```\n[Unit]\nDescription=Wicd sleep hook\nBefore=sleep.target\nStopWhenUnneeded=yes\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=-/usr/share/wicd/daemon/suspend.py\nExecStop=-/usr/share/wicd/daemon/autoconnect.py\n\n[Install]\nWantedBy=sleep.target\n```\n\n- RemainAfterExit=yes: After started, the service is considered active until it is explicitly stopped.\n- StopWhenUnneeded=yes: When active, the service will be stopped if no other active service requires it. In this specific example, it will be stopped after sleep.target is stopped.\n- Because sleep.target has StopWhenUnneeded=yes, the hook is guaranteed to start/stop properly for different tasks.\n\n"
    },
    {
      "title": "Hooks in /usr/lib/systemd/system-sleep",
      "level": 3,
      "content": "systemd-sleep runs all executables in /usr/lib/systemd/system-sleep/, passing two arguments to each of them:\n\n1. Either pre or post, depending on whether the machine is going to sleep or waking up.\n1. suspend, hibernate, hybrid-sleep or suspend-then-hibernate, depending on which is being invoked.\n\nAn environment variable called SYSTEMD_SLEEP_ACTION will be set and contain the sleep action that is processing. This is primarily helpful for suspend-then-hibernate where the value of the variable will be suspend, hibernate, or suspend-after-failed-hibernate in cases where hibernation has failed.\n\nThe output of any custom script will be logged by systemd-suspend.service, systemd-hibernate.service or systemd-hybrid-sleep.service. You can see its output in systemd's journalctl:\n\n```\n# journalctl -b -u systemd-suspend.service\n```\n\nAn example of a custom sleep script:\n\n```\n/usr/lib/systemd/system-sleep/example.sh\n```\n\n```\n#!/bin/sh\ncase $1/$2 in\n  pre/*)\n    echo \"Going to $2...\"\n   Â ;;\n  post/*)\n    echo \"Waking up from $2...\"\n   Â ;;\nesac\n```\n\nDo not forget to make your script executable.\n\n"
    },
    {
      "title": "Unlocking automatically on resume in trusted locations",
      "level": 3,
      "content": "When resuming, you can automatically unlock your system if it is connected to certain devices or trusted Wi-Fi networks.\n\n```\n/etc/local-scripts/resume-unlock.sh\n```\n\n```\n#!/usr/bin/bash\n# Unlock session if at a trusted location\n\nfunction trusted() {\n    # Check if connected to a trusted Wi-Fi network\n    [[ $(iwgetid -r) == your_home_ssid ]] \\\n        && return 0\n\n    # Check if trusted USB device is connected.\n    #lsusb -d xxxx:xxxx && return 0\n\n    return 1 # Not trusted\n}\n\nfor (( i=0; i < 10; i++ )); do\n    if trusted; then\n        loginctl unlock-sessions\n        exit\n    fi\n    sleep 0.5\ndone\n```\n\nConfigure your desktop environment so that it locks on resume, and then create a sleep hook that runs the above script after resuming. You also need to install wireless_tools to read the connected Wi-Fi SSID. If you also want to test for connected USB devices, uncomment the lsusb -d ... line in the script and fill in the ID of your trusted device. You can get the ID of your device by running lsusb.\n\n"
    },
    {
      "title": "Disable sleep completely",
      "level": 3,
      "content": "When using a device as e.g a server, suspending/hibernating might not be needed or it could even be undesired. Each sleep state can be disabled through systemd-sleep.conf(5):\n\n```\n/etc/systemd/sleep.conf.d/disable-sleep.conf\n```\n\n```\n[Sleep]\nAllowSuspend=no\nAllowHibernation=no\nAllowHybridSleep=no\nAllowSuspendThenHibernate=no\n```\n\n"
    },
    {
      "title": "Intel Rapid Start Technology (IRST)",
      "level": 3,
      "content": "Intel Rapid Start Technology is a firmware method of hibernation that allows hibernating from sleep after a predefined interval or according to battery state. This should be faster and more reliable than regular hibernation as it is done by firmware instead of at the operating system level. Generally it must enabled in the firmware, and the firmware also provides support for setting the duration after suspend/battery event triggering hibernation. However, some devicesâ€“despite supporting IRST in the firmwareâ€“only allow it to be configured via Intel's Windows drivers. In such cases the intel-rst kernel module described below should be able to configure the events under Linux.\n\nWith Intel Rapid Start Technology (IRST) enabled, resuming from a deep sleep takes \"a few seconds longer than resuming from S3 but is far faster than resuming from hibernation\".\n\nMany Intel-based systems have firmware support for IRST but require a special partition on an SSD (rather than an HDD). OEM deployments of Windows may have a pre-existing IRST partition which can be retained during the Arch Linux installation process (rather than wiping and re-partitioning the whole SSD). It should show up as an unformatted partition equal in size to the system's RAM.\n\nIf you intend to wipe and re-partition the whole drive (or have already done so), then the IRST partition must be recreated if you also plan on using the technology. This can be done by creating an empty partition equal in size to the system's RAM and by setting its partition type to GUID D3BFE2DE-3DAF-11DF-BA40-E3A556D89593 for a GPT partition or ID 0x84 for an MBR partition. You may also need to enable support for IRST in your system's firmware settings.\n\nThe duration of the IRST hibernation process (i.e., copying the \"entire contents of RAM to a special partition\") is dependent on the system's RAM size and SSD speed and can thus take 20â€“60 seconds. Some systems may indicate the process's completion with an LED indicator, e.g., when it stops blinking.\n\nConfiguring IRST hibernation events in the Linux kernel requires CONFIG_INTEL_RST built-in or as a module. Once loaded via modprobe intel_rst, it should create the files wakeup_events and wakeup_time under /sys/bus/acpi/drivers/intel_rapid_start/*/ that can be used for further configuration. This module is tersely documented, see the source drivers/platform/x86/intel/rst.c for more details.\n\nSee also the general Q&A and user guides for Intel Rapid Start Technology.\n\n"
    },
    {
      "title": "Track laptop battery energy change during sleep states",
      "level": 3,
      "content": "To measure power consumption in suspend states use Batenergy script to log battery changes to the system journal. This allows to compare power consumption in S3 / S0x states or check after BIOS and kernel updates for regressions and fixes. The script needs bc to be installed for calculation.\n\n"
    },
    {
      "title": "ACPI_OS_NAME",
      "level": 3,
      "content": "You might want to tweak your DSDT table to make it work. See DSDT.\n\n"
    },
    {
      "title": "Suspend/hibernate does not work, or does not work consistently",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nThere have been many reports about the screen going black without easily viewable errors or the ability to do anything when going into and coming back from suspend and/or hibernate. These problems have been seen on both laptops and desktops. This is not an official solution, but switching to an older kernel, especially the LTS-kernel, will probably fix this.\n\nA problem may arise when using the hardware watchdog timer (disabled by default, see RuntimeWatchdogSec= in systemd-system.conf(5) Â§ OPTIONS). A buggy watchdog timer may reset the computer before the system finishes creating the hibernation image.\n\nSometimes the screen goes black due to device initialization from within the initramfs. Removing any modules you might have in Mkinitcpio#MODULES, removing the kms hook and rebuilding the initramfs can possibly solve this issue, in particular with graphics drivers for early KMS. Initializing such devices before resuming can cause inconsistencies that prevents the system resuming from hibernation. This does not affect resuming from RAM. Also, check the blog article best practices to debug suspend issues.\n\nMoving from the ATI video driver to the newer AMDGPU driver could also help to make the hibernation and awakening process successful.\n\nFor NVIDIA users, blacklisting the module nvidiafb might help. [8]\n\nLaptops with an Intel CPU that load the intel_lpss_pci module for a touchpad may face kernel panic on resume (blinking caps lock) [9]. The module needs to be added to initramfs as:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nMODULES=(... intel_lpss_pci ...)\n```\n\nThen regenerate the initramfs.\n\n"
    },
    {
      "title": "USB device errors",
      "level": 4,
      "content": "System may fail to suspend because of a USB device. You might see the following error:\n\n```\nPM: Some devices failed to suspend, or early wake event detected\n...\nxhci_hcd 0000:02:00.0: PM: failed to suspend async: error -16\n```\n\nlspci may give you more information on the failing device:\n\n```\n$ lspci -s 02:00.0\n```\n\n```\n02:00.0 USB controller: Advanced Micro Devices, Inc. [AMD] 500 Series Chipset USB 3.1 XHCI Controller\n```\n\nTry disconnecting devices on that port.\n\n"
    },
    {
      "title": "Wake-on-LAN",
      "level": 3,
      "content": "If Wake-on-LAN is active, the network interface card will consume power even if the computer is hibernated.\n\n"
    },
    {
      "title": "Instantaneous wakeup after suspending",
      "level": 3,
      "content": "See Wakeup triggers#Instantaneous wakeup after suspending.\n\n"
    },
    {
      "title": "System does not power off when hibernating",
      "level": 3,
      "content": "When you hibernate your system, the system should power off (after saving the state on the disk). On some firmware the S4 sleeping state does not work reliably. For example, instead of powering off, the system might reboot or stay on but unresponsive. If that happens, it might be instructive to set the HibernateMode to shutdown in sleep.conf.d(5):\n\n```\n/etc/systemd/sleep.conf.d/hibernatemode.conf\n```\n\n```\n[Sleep]\nHibernateMode=shutdown\n```\n\nWith the above configuration, if everything else is set up correctly, on invocation of a systemctl hibernate the machine will shut down, saving state to disk as it does so.\n\n"
    },
    {
      "title": "Operating system not found (or wrong OS booting) when booting after hibernation",
      "level": 3,
      "content": "This can happen when the boot disk is an external disk, and seems to be caused by a BIOS/firmware limitation. The BIOS/firmware tries to boot from an internal disk, while hibernation was done from an OS on an external (or other) disk.\n\nSet HibernateMode=shutdown as shown in #System does not power off when hibernating to solve the problem permanently. If you have already locked yourself out, you can try rebooting your system 4 times (wait for the error to appear each time), which on some BIOS'es forces a normal boot procedure.\n\n"
    },
    {
      "title": "Swap file in /home",
      "level": 3,
      "content": "If the swap file is in /home/, systemd-logind will not be able to access it, giving the Call to Hibernate failed: No such file or directory warning message and resulting in a need for authentication on systemctl hibernate. This setup should be avoided, as it is considered unsupported upstream. See systemd issue 15354 for two workarounds.\n\n"
    },
    {
      "title": "PC will not wake from sleep on A520I and B550I motherboards",
      "level": 3,
      "content": "On some motherboards with A520i and B550i chipsets, the system will not completely enter the sleep state or come out of it. Symptoms include the system entering sleep and the monitor turning off while internal LEDs on the motherboard or the power LED stay on. Subsequently, the system will not come back from this state and require a hard power off. If you have similar issues with AMD, first make sure your system is fully updated and check whether the AMD microcode package is installed.\n\nVerify the line starting with GPP0 has the enabled status:\n\n```\n$ cat /proc/acpi/wakeup\n```\n\n```\nDevice\tS-state\t  Status   Sysfs node\nGP12\t  S4\t*enabled   pci:0000:00:07.1\nGP13\t  S4\t*enabled   pci:0000:00:08.1\nXHC0\t  S4\t*enabled   pci:0000:0b:00.3\nGP30\t  S4\t*disabled\nGP31\t  S4\t*disabled\nPS2K\t  S3\t*disabled\nGPP0\t  S4\t*enabled   pci:0000:00:01.1\nGPP8\t  S4\t*enabled   pci:0000:00:03.1\nPTXH\t  S4\t*enabled   pci:0000:05:00.0\nPT20\t  S4\t*disabled\nPT24\t  S4\t*disabled\nPT26\t  S4\t*disabled\nPT27\t  S4\t*disabled\nPT28\t  S4\t*enabled   pci:0000:06:08.0\nPT29\t  S4\t*enabled   pci:0000:06:09.0\n```\n\nIf that is enabled, you can run the following command to disable it:\n\n```\n# echo GPP0 > /proc/acpi/wakeup\n```\n\nNow test by running systemctl suspend and let the system go to sleep. Then try to wake the system after a few seconds. If it works, you can make the workaround permanent. Create a systemd unit file:\n\n```\n/etc/systemd/system/toggle-gpp0-to-fix-wakeup.service\n```\n\n```\n[Unit]\nDescription=\"Disable GPP0 to fix suspend issue\"\n\n[Service]\nExecStart=/bin/sh -c \"/bin/echo GPP0 > /proc/acpi/wakeup\"\n\n[Install]\nWantedBy=multi-user.target\n```\n\nDo a daemon-reload and start/enable the newly created unit.\n\nAlternatively, you can create a udev rule. Assuming GPP0â€™s sysfs node is pci:0000:00:01.1 like in the example, run udevadm info -a -p /sys/bus/pci/devices/0000\\:00\\:01.1 to get the relevant information and create a udev rule like this one:\n\n```\n/etc/udev/rules.d/10-gpp0-acpi-fix.rules\n```\n\n```\nKERNEL==\"0000:00:01.1\", SUBSYSTEM==\"pci\", DRIVERS==\"pcieport\", ATTR{vendor}==\"0x1022\", ATTR{device}==\"0x1483\", ATTR{power/wakeup}=\"disabled\"\n```\n\nThe udev daemon is already watching for changes in your system by default. If needed you can reload the rules manually.\n\n"
    },
    {
      "title": "Suspend from corresponding laptop Fn key not working",
      "level": 3,
      "content": "If, regardless of the setting in logind.conf, the sleep button does not work (pressing it does not even produce a message in syslog), then logind is probably not watching the keyboard device. [10] Do:\n\n```\n# journalctl --grep=\"Watching system buttons\"\n```\n\nYou might see something like this:\n\n```\nMay 25 21:28:19 vmarch.lan systemd-logind[210]: Watching system buttons on /dev/input/event2 (Power Button)\nMay 25 21:28:19 vmarch.lan systemd-logind[210]: Watching system buttons on /dev/input/event3 (Sleep Button)\nMay 25 21:28:19 vmarch.lan systemd-logind[210]: Watching system buttons on /dev/input/event4 (Video Bus)\n```\n\nNotice no keyboard device. List keyboard devices as follows:\n\n```\n$ stat -c%N /dev/input/by-id/*-kbd\n```\n\n```\n...\n/dev/input/by-id/usb-SIGMACHIP_USB_Keyboard-event-kbd -> ../event6\n...\n```\n\nNow obtain ATTRS{name} for the parent keyboard device [11]. As an example, on the above list this keyboard device has event6 as device input event, it can be used to search its respective attribute name:\n\n```\n# udevadm info -a /dev/input/event6\n```\n\n```\n...\nKERNEL==\"event6\"\n...\nATTRS{name}==\"SIGMACHIP USB Keyboard\"\n```\n\nNow write a custom udev rule to add the \"power-switch\" tag:\n\n```\n/etc/udev/rules.d/70-power-switch-my.rules\n```\n\n```\nACTION==\"remove\", GOTO=\"power_switch_my_end\"\nSUBSYSTEM==\"input\", KERNEL==\"event*\", ATTRS{name}==\"SIGMACHIP USB Keyboard\", TAG+=\"power-switch\"\nLABEL=\"power_switch_my_end\"\n```\n\nAfter reloading the udev rules and restarting systemd-logind.service, you should see Watching system buttons on /dev/input/event6 in the journal of logind.\n\n"
    },
    {
      "title": "System freezes for 60 seconds and then wakes back up or hangs after waking up",
      "level": 3,
      "content": "Since systemd v256, systemd freezes user.slice before sleeping. This process can fail due to kernel bugs, particularly when KVM is in use.[12][13]\n\nMessages in the logs will contain Failed to freeze unit 'user.slice' before sleep. When such an issue occurs, trying to login (start another session) would fail with:\n\n```\npam_systemd(process:session): Failed to create session: Job 9876 for unit 'session-6.scope' failed with 'frozen'\n```\n\nTo temporarily revert back to the old behavior, edit systemd-suspend.service, systemd-hibernate.service, systemd-hybrid-sleep.service, and systemd-suspend-then-hibernate.service with the following drop-in:\n\n```\n[Service]\nEnvironment=SYSTEMD_SLEEP_FREEZE_USER_SESSIONS=false\n```\n\n"
    }
  ]
}