{
  "title": "Managing Wireless with systemd-networkd and wpa-supplicant",
  "url": "https://wiki.archlinux.org/title/Managing_Wireless_with_systemd-networkd_and_wpa-supplicant",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- systemd\n- systemd-resolved\n- systemd-nspawn\n- Network bridge\n- Network configuration\n- Wireless network configuration\n- Category:Network configuration\n\nsystemd-networkd is a system daemon that manages network configurations. It detects and configures network devices as they appear; it can also create virtual network devices. This service can be especially useful to set up complex network configurations for a container managed by systemd-nspawn or for virtual machines. It also works fine on simple connections.\n\n"
    },
    {
      "title": "Basic usage",
      "level": 2,
      "content": "The systemd package is part of the default Arch installation and contains all needed files to operate a wired network. Wireless adapters, covered later in this article, can be set up by services, such as wpa_supplicant or iwd.\n\n"
    },
    {
      "title": "Required services and setup",
      "level": 3,
      "content": "To use systemd-networkd, start/enable systemd-networkd.service.\n\nIt is optional to also configure systemd-resolved, which is a network name resolution service to local applications, considering the following points:\n\n- It is important to understand how resolv.conf and systemd-resolved interact to properly configure the DNS that will be used, some explanations are provided in systemd-resolved.\n- systemd-resolved is required if DNS entries are specified in .network files.\n- systemd-resolved is also required to obtain DNS addresses from DHCP servers or IPv6 router advertisements.(by setting (DHCP= and/or IPv6AcceptRA= in the [Network] section, and UseDNS=yes (the default) in the corresponding section(s) [DHCPv4], [DHCPv6], [IPv6AcceptRA], see systemd.network(5)).\n- Note that systemd-resolved can also be used without systemd-networkd.\n\n"
    },
    {
      "title": "systemd-networkd-wait-online",
      "level": 3,
      "content": "Enabling systemd-networkd.service also enables systemd-networkd-wait-online.service, which is a oneshot system service that waits for the network to be configured. The latter has WantedBy=network-online.target, so it will be started only when network-online.target itself is enabled or pulled in by some other unit. See also systemd#Running services after the network is up.\n\nBy default, systemd-networkd-wait-online.service waits for all links managed by systemd-networkd to be fully configured or failed, and for at least one link to be online.\n\nSee systemd-networkd-wait-online(8) for details.\n\n"
    },
    {
      "title": "Multiple interfaces that are not connected all the time",
      "level": 4,
      "content": "For system with multiple network interfaces that are not expected to be connected all the time (e.g. if a dual-port Ethernet card, but only one cable plugged in), starting systemd-networkd-wait-online.service will fail after the default timeout of 2 minutes. This may cause an unwanted delay in the startup process. To change the behaviour to wait for any interface rather than all interfaces to become online, edit the service and add the --any parameter to the ExecStart line:\n\n```\n/etc/systemd/system/systemd-networkd-wait-online.service.d/wait-for-only-one-interface.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=/usr/lib/systemd/systemd-networkd-wait-online --any\n```\n\nAlternatively, use systemd-networkd-wait-online@.service to wait for a specific interface. For example, to wait for enp1s0, disable systemd-networkd-wait-online.service and enable systemd-networkd-wait-online@enp1s0.service.\n\n"
    },
    {
      "title": "Wait until network interfaces have a routable address",
      "level": 4,
      "content": "Per systemd-networkd-wait-online.service(8), \"online means that the link's operational state is equal or higher than \"degraded\".\" (see networkctl(1) for the definition of \"degraded\" and other operational statuses).\n\nTo prevent systemd-networkd-wait-online.service from exiting before network interfaces have a routable IP address (and thus having other services that require a working network connection starting too early), add RequiredForOnline=routable to the [Link] section in .network files:\n\n```\n[Link]\nRequiredForOnline=routable\n```\n\n"
    },
    {
      "title": "Configuration examples",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nAll configurations in this section are stored as foo.network in /etc/systemd/network/. For a full listing of options and processing order, see #Configuration files and systemd.network(5).\n\nsystemd/udev automatically assigns predictable, stable network interface names for all local Ethernet, WLAN, and WWAN interfaces. Use networkctl list to list the devices on the system. If it is desired to divert from the automatic interface naming, see Network configuration#Change interface name for examples.\n\nAfter making changes to a configuration file, restart systemd-networkd.service.\n\n- The options specified in the configuration files are case sensitive.\n- In the examples below, enp1s0 is the wired adapter and wlp2s0 is the wireless adapter. These names can be different on different systems. See Network configuration#Network interfaces for checking your adapter names.\n- It is also possible to use a wildcard, e.g. Name=en* or Name=wl*.\n- Devices can also be matched by their type. E.g. Type=ether for Ethernet, Type=wlan for Wi-Fi and Type=wwan for WWAN.\n- Note that Type=ether will also match virtual Ethernet interfaces. To exclude them, use Type=ether in combination with Kind=!*.\n\n"
    },
    {
      "title": "Wired adapter using DHCP",
      "level": 4,
      "content": "```\n/etc/systemd/network/20-wired.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nDHCP=yes\n```\n\n"
    },
    {
      "title": "Wired adapter using a static IP",
      "level": 4,
      "content": "```\n/etc/systemd/network/20-wired.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Network]\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.1\n```\n\nAddress= can be used more than once to configure multiple IPv4 or IPv6 addresses. See #network files or systemd.network(5) for more options.\n\n"
    },
    {
      "title": "Wireless adapter",
      "level": 4,
      "content": "In order to connect to a wireless network with systemd-networkd, a wireless adapter configured with another application such as wpa_supplicant or iwd is required.\n\n```\n/etc/systemd/network/25-wireless.network\n```\n\n```\n[Match]\nName=wlp2s0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nDHCP=yes\nIgnoreCarrierLoss=3s\n```\n\nIf the wireless adapter has a static IP address, the configuration is the same (except for the interface name) as in a wired adapter.\n\nTo authenticate to the wireless network, use e.g. wpa_supplicant or iwd.\n\n"
    },
    {
      "title": "Wired and wireless adapters on the same machine",
      "level": 4,
      "content": "This setup will enable a DHCP IP for both a wired and wireless connection making use of the metric directive to allow the kernel to decide on-the-fly which one to use. This way, no connection downtime is observed when the wired connection is unplugged.\n\nThe kernel's route metric (same as configured with ip) decides which route to use for outgoing packets, in cases when several match. This will be the case when both wireless and wired devices on the system have active connections. To break the tie, the kernel uses the metric. If one of the connections is terminated, the other automatically wins without there being a gap with nothing configured (ongoing transfers may still not deal with this nicely but that is at a different OSI layer).\n\nsystemd-networkd does not set per-interface-type default route metrics, so it needs to be configured manually:\n\n```\n/etc/systemd/network/20-wired.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nDHCP=yes\n\n[DHCPv4]\nRouteMetric=100\n\n[IPv6AcceptRA]\nRouteMetric=100\n```\n\n```\n/etc/systemd/network/25-wireless.network\n```\n\n```\n[Match]\nName=wlp2s0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nDHCP=yes\n\n[DHCPv4]\nRouteMetric=600\n\n[IPv6AcceptRA]\nRouteMetric=600\n```\n\n"
    },
    {
      "title": "Configuration files",
      "level": 2,
      "content": "The global configuration file in /etc/systemd/networkd.conf may be used to override some defaults only. The main configuration is performed per network device. Configuration files are located in /usr/lib/systemd/network/, the volatile runtime network directory /run/systemd/network/ and the local administration network directory /etc/systemd/network/. Files in /etc/systemd/network/ have the highest priority.\n\nThere are three types of configuration files. They all use a format similar to systemd unit files.\n\n- .network files. They will apply a network configuration for a matching device\n- .netdev files. They will create a virtual network device for a matching environment\n- .link files. When a network device appears, udev will look for the first matching .link file\n\nThey all follow the same rules:\n\n- If all conditions in the [Match] section are matched, the profile will be activated\n- an empty [Match] section means the profile will apply in any case (can be compared to the * wildcard)\n- all configuration files are collectively sorted and processed in lexical order, regardless of the directory in which they live\n- files with identical name replace each other\n\n- Files in /etc/systemd/network/ override the corresponding system-supplied file in /usr/lib/systemd/network/. Optionally use a symlink to /dev/null to \"mask\" a system file.\n- systemd accepts the values 1, true, yes, on for a true boolean, and the values 0, false, no, off for a false boolean. See systemd.syntax(7).\n- systemd-networkd will alter routing tables also for other network software. If this is undesired, configure ManageForeignRoutingPolicyRules= in networkd.conf(5) accordingly. For example, see WireGuard#Connection lost after sleep using systemd-networkd.\n\n"
    },
    {
      "title": "network files",
      "level": 3,
      "content": "Note: **This article or section is being considered for removal.** This article or section is being considered for removal.\n\nThis article or section is being considered for removal.\n\nThese files are aimed at setting network configuration variables, especially for servers and containers.\n\n.network files have the following sections: [Match], [Link], [Network], [Address], [Route], and [DHCPv4]. Below are commonly configured keys for each section. See systemd.network(5) for more information and examples.\n\n"
    },
    {
      "title": "[Match]",
      "level": 4,
      "content": "Table content:\nParameter | Description | Accepted Values | Default Value\nName= | Match device names, e.g. en*. By prefixing with !, the list can be inverted. | white-space separated device names with globs, logical negation (!) | \nMACAddress= | Match MAC addresses, e.g. MACAddress=01:23:45:67:89:ab 00-11-22-33-44-55 AABB.CCDD.EEFF | whitespace-separated MAC addresses in full colon-, hyphen- or dot-delimited hexadecimal | \nHost= | Match the hostname or machine ID of the host. | hostname string with globs, machine-id(5) | \nVirtualization= | Check whether the system is executed in a virtualized environment. Virtualization=false will only match your host machine, while Virtualization=true matches any container or VM. It is possible to check for a specific virtualization type or implementation, or for a user namespace (with private-users). | boolean, logical negation (!), type (vm, container), implementation (see systemd-detect-virt(1)), private-users | \n\n"
    },
    {
      "title": "[Link]",
      "level": 4,
      "content": "Table content:\nParameter | Description | Accepted Values | Default Value\nMACAddress= | Assign a hardware address to the device. Useful for MAC address spoofing. | full colon-, hyphen- or dot-delimited hexadecimal MAC addresses | \nMTUBytes= | Maximum transmission unit in bytes to set for the device. Note that if IPv6 is enabled on the interface, and the MTU is chosen below 1280 (the minimum MTU for IPv6) it will automatically be increased to this value. Setting a larger MTU value (e.g. when using jumbo frames) can significantly speed up your network transfers | integer (usual suffixes K, M, G, are supported and are understood to the base of 1024) | \nMulticast= | allows the usage of multicast | boolean | ? not documented ?\n\n"
    },
    {
      "title": "[Network]",
      "level": 4,
      "content": "Table content:\nParameter | Description | Accepted Values | Default Value\nDHCP= | Controls DHCPv4 and/or DHCPv6 client support. | boolean, ipv4, ipv6 | no\nDHCPServer= | If enabled, a DHCPv4 server will be started. | boolean | no\nMulticastDNS= | Enables multicast DNS support. When set to resolve, only resolution is enabled, but not host or service registration and announcement. | boolean, resolve | false\nDNSSEC= | Controls DNSSEC DNS validation support on the link. When set to allow-downgrade, compatibility with non-DNSSEC capable networks is increased, by automatically turning off DNSSEC in this case. | boolean, allow-downgrade | false\nDNS= | Configure static DNS addresses. May be specified more than once. | inet_pton(3) | \nDomains= | A list of domains which should be resolved using the DNS servers on this link. systemd.network(5) § [NETWORK] SECTION OPTIONS | domain name, optionally prefixed with a tilde (~) | \nIPv4Forwarding= and IPv6Forwarding= | If enabled, incoming (IPv4 / IPv6) packets on this network interface will be forwarded to any other interfaces according to the routing table. This controls the net.ipv4/6.conf.INTERFACE.forwarding sysctl option of the network interface. See Internet sharing#Enable packet forwarding for details. | boolean | no\nIPMasquerade= | If enabled, packets forwarded from the network interface will appear as coming from the local host. Depending on the value, implies IPv6Forwarding=yes or IPv4Forwarding=yes. | ipv4, ipv6, both, no | no\nIPv6PrivacyExtensions= | Configures use of stateless temporary addresses that change over time (see RFC 4941). When prefer-public, enables the privacy extensions, but prefers public addresses over temporary addresses. When kernel, the kernel's default setting will be left in place. | boolean, prefer-public, kernel | no\n\n"
    },
    {
      "title": "[Address]",
      "level": 4,
      "content": "Table content:\nParameter | Description | Accepted Values | Default Value\nAddress= | Specify this key more than once to configure several addresses. Mandatory unless DHCP is used. If the specified address is 0.0.0.0 (for IPv4) or :: (for IPv6), a new address range of the requested size is automatically allocated from a system-wide pool of unused ranges. | static IPv4 or IPv6 address and its prefix length (see inet_pton(3)) | \n\n"
    },
    {
      "title": "[Route]",
      "level": 4,
      "content": "- Gateway= this option is mandatory unless direct routing or DHCP is used\n- Destination= the destination prefix of the route, possibly followed by a slash and the prefix length\n- Metrics= the priority of this route\n- Type= the type for the route\n- Table= the table identifier for the route\n- GatewayOnLink= if set to yes, the kernel does not have to check if the gateway is reachable directly by the current machine (i.e., attached to the local network). Can be used to solve some routing issues.\n\nIf Destination is not present in [Route] section, this section is treated as a default route.\n\n"
    },
    {
      "title": "[RoutingPolicyRule]",
      "level": 4,
      "content": "Standard routing algorithms usually take in account only the destination address when they have to choose to which gateway send a packet. But for more complex networks this is not enough.\n\nThe [RoutingPolicyRule] section allows you to specify additional rules that are applied only to those packages that match the specified conditions.\n\nHere a non-exhaustive list of these matches:\n\n- TypeOfService= (matches) the Type of Service of the packet as an integer in the range 0..255;\n- From= the source address prefix;\n- To= the destination address prefix;\n- FirewallMark= the iptables firewall mark value;\n- IncomingInterface= the incoming device;\n- OutgoingInterface= the outgoing device;\n\nOther options:\n\n- Type= the Routing Policy Database rule type;\n- Table= the routing table to use if the packet matches the rule;\n- Priority= the priority of this rule. Rules are evaluated in increasing order of priority, therefore lower priority rules are applied before others;\n- InvertRule= if set to true then the rule is inverted, that is it is applied to every package that doesn't satisfy at least one of the matches;\n- SuppressPrefixLength= the rule is suppressed if the prefix length is equal or less than the specified value;\n\n"
    },
    {
      "title": "[DHCPv4]",
      "level": 4,
      "content": "Table content:\nParameter | Description | Accepted Values | Default Value\nUseDNS= | controls whether the DNS servers advertised by the DHCP server are used | boolean | true\nAnonymize= | when true, the options sent to the DHCP server will follow the RFC:7844 (Anonymity Profiles for DHCP Clients) to minimize disclosure of identifying information | boolean | false\nUseDomains= | controls whether the domain name received from the DHCP server will be used as DNS search domain. If set to route, the domain name received from the DHCP server will be used for routing DNS queries only, but not for searching. This option can sometimes fix local name resolving when using systemd-resolved | boolean, route | false\nIPv6OnlyMode= | when true, the DHCP client will signal to the DHCP server that it supports IPv6-only operation (RFC:8925, IPv6-Only Preferred Option for DHCPv4). If the DHCPv4 server returns that option in its DHCP response, the client will abort the DHCP request, will not acquire an IPv4 address and will configure an IPv6-only network | boolean | true if IPv6 is enabled\n\n"
    },
    {
      "title": "[DHCPServer]",
      "level": 4,
      "content": "This is an example of a DHCP server configuration which works well with hostapd to create a wireless hotspot. IPMasquerade adds the firewall rules for NAT and implies IPv4Forwarding=yes to enable packet forwarding.\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\n```\n/etc/systemd/network/wlan0.network\n```\n\n```\n[Match]\nName=wlan0\n\n[Network]\nAddress=10.1.1.1/24\nDHCPServer=true\nIPMasquerade=ipv4\n\n[DHCPServer]\nPoolOffset=100\nPoolSize=20\nEmitDNS=yes\nDNS=9.9.9.9\n```\n\n"
    },
    {
      "title": "netdev files",
      "level": 3,
      "content": "Note: **This article or section is being considered for removal.** This article or section is being considered for removal.\n\nThis article or section is being considered for removal.\n\nThese files will create virtual network devices. They have two sections: [Match] and [NetDev]. Below are commonly configured keys for each section. See systemd.netdev(5) for more information and examples.\n\n"
    },
    {
      "title": "[Match] section",
      "level": 4,
      "content": "- Host= the hostname\n- Virtualization= check if the system is running in a virtualized environment\n\n"
    },
    {
      "title": "[NetDev] section",
      "level": 4,
      "content": "Most common keys are:\n\n- Name= the interface name. mandatory\n- Kind= e.g. bridge, bond, vlan, veth, sit, etc. mandatory\n\n"
    },
    {
      "title": "Usage with containers",
      "level": 2,
      "content": "systemd-networkd can provide fully automatic configuration of networking for systemd-nspawn containers using private networking when it is used on the host system as well as inside the container. See systemd-nspawn#Networking for a comprehensive overview.\n\nNote: **all that is needed** \n\nFor the examples below,\n\n- we will limit the output of the ip a command to the concerned interfaces,\n- we assume the host is the main operating system running on real hardware and the container is the guest system,\n- all interface names and IP addresses are only examples.\n\n"
    },
    {
      "title": "Bridge interface",
      "level": 4,
      "content": "First, create a virtual bridge interface with a .netdev unit file which tells systemd-networkd to create a device named br0 that functions as an Ethernet bridge.\n\n```\n/etc/systemd/network/25-br0.netdev\n```\n\n```\n[NetDev]\nName=br0\nKind=bridge\n```\n\nOptionally add MACAddress=none to the NetDev section for the bridge to inherit MAC address from one of the bridged interfaces. This also requires a creation of 25-br0.link file.\n\nRestart systemd-networkd.service to have systemd-networkd create the bridge.\n\nTo see the newly created bridge on the host and on the container, type:\n\n```\n$ ip a\n```\n\n```\n3: br0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default \n    link/ether ae:bd:35:ea:0c:c9 brd ff:ff:ff:ff:ff:ff\n```\n\nNote that the interface br0 is listed but is still DOWN at this stage.\n\n"
    },
    {
      "title": "Bind Ethernet to bridge",
      "level": 4,
      "content": "The next step is to add a network interface to the newly created bridge. The configuration file of the bridge must be loaded before those of the bridged interfaces, so its configuration file should be alphanumerically prior to those. In the example below, we add any interface that matches the name en* into the bridge br0.\n\n```\n/etc/systemd/network/25-br0-en.network\n```\n\n```\n[Match]\nName=en*\n\n[Network]\nBridge=br0\n```\n\nThe Ethernet interface must not have DHCP or an IP address associated, as the bridge requires an interface to bind to with no IP address.\n\n"
    },
    {
      "title": "Bridge network",
      "level": 4,
      "content": "Now that the bridge has been created and has been bound to an existing network interface, the IP configuration of the bridge interface must be specified. This is defined in a third .network file, the example below uses DHCP.\n\n```\n/etc/systemd/network/25-br0.network\n```\n\n```\n[Match]\nName=br0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nDHCP=yes\n```\n\n"
    },
    {
      "title": "Inherit MAC address (optional)",
      "level": 4,
      "content": "For the bridge to inhering MAC address from one of the bridged interfaces, set MACAddress=none and MACAddressPolicy=none.\n\n```\n/etc/systemd/network/25-br0.netdev\n```\n\n```\n[NetDev]\nName=br0\nKind=bridge\nMACAddress=none\n```\n\n```\n/etc/systemd/network/25-br0.link\n```\n\n```\n[Match]\nOriginalName=br0\n\n[Link]\nMACAddressPolicy=none\n```\n\n"
    },
    {
      "title": "Configure the container",
      "level": 4,
      "content": "Use the --network-bridge=br0 option when starting the container. See systemd-nspawn#Use a network bridge for details.\n\n"
    },
    {
      "title": "Result",
      "level": 4,
      "content": "- on host\n\n```\n$ ip a\n```\n\n```\n3: br0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default \n    link/ether 14:da:e9:b5:7a:88 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.87/24 brd 192.168.1.255 scope global br0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::16da:e9ff:feb5:7a88/64 scope link \n       valid_lft forever preferred_lft forever\n6: vb-MyContainer: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master br0 state UP group default qlen 1000\n    link/ether d2:7c:97:97:37:25 brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::d07c:97ff:fe97:3725/64 scope link \n       valid_lft forever preferred_lft forever\n```\n\n- on container\n\n```\n$ ip a\n```\n\n```\n2: host0: <BROADCAST,MULTICAST,ALLMULTI,AUTOMEDIA,NOTRAILERS,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 5e:96:85:83:a8:5d brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.73/24 brd 192.168.1.255 scope global host0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::5c96:85ff:fe83:a85d/64 scope link \n       valid_lft forever preferred_lft forever\n```\n\n"
    },
    {
      "title": "Notice",
      "level": 4,
      "content": "- we have now one IP address for br0 on the host, and one for host0 in the container\n- two new interfaces have appeared: vb-MyContainer in the host and host0 in the container. This comes as a result of the --network-bridge=br0 option as explained in systemd-nspawn#Use a network bridge for details.\n- the DHCP address on host0 comes from the system /usr/lib/systemd/network/80-container-host0.network file.\n- on host\n\nNote: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\n```\n$ brctl show\n```\n\n```\nbridge name\tbridge id\t\tSTP enabled\tinterfaces\nbr0\t\t8000.14dae9b57a88\tno\t\tenp7s0\n\t\t\t\t\t\t\tvb-MyContainer\n```\n\nthe above command output confirms we have a bridge with two interfaces binded to.\n\n- on host\n\n```\n$ ip route\n```\n\n```\ndefault via 192.168.1.254 dev br0 \n192.168.1.0/24 dev br0  proto kernel  scope link  src 192.168.1.87\n```\n\n- on container\n\n```\n$ ip route\n```\n\n```\ndefault via 192.168.1.254 dev host0 \n192.168.1.0/24 dev host0  proto kernel  scope link  src 192.168.1.73\n```\n\nthe above command outputs confirm we have activated br0 and host0 interfaces with an IP address and Gateway 192.168.1.254. The gateway address has been automatically grabbed by systemd-networkd.\n\n"
    },
    {
      "title": "Network bridge with static IP addresses",
      "level": 3,
      "content": "Setting a static IP address for each device can be helpful in case of deployed web services (e.g FTP, http, SSH). Each device will keep the same MAC address across reboots if your system /usr/lib/systemd/network/99-default.link file has the MACAddressPolicy=persistent option (it has by default). This setup routes any service on the gateway to the desired device.\n\nThe following configuration needs to be done for this setup:\n\n- on host\n\nThe configuration is very similar to the #Network bridge with DHCP section. First, a virtual bridge interface needs to be created and the main physical interface needs to be bound to it. This task can be accomplished with the following two files, with contents equal to those available in the DHCP section.\n\n```\n/etc/systemd/network/MyBridge.netdev\n/etc/systemd/network/MyEth.network\n```\n\nNext, you need to configure the IP and DNS of the newly created virtual bridge interface. For example:\n\n```\n/etc/systemd/network/MyBridge.network\n```\n\n```\n[Match]\nName=br0\n\n[Network]\nDNS=192.168.1.254\nAddress=192.168.1.87/24\nGateway=192.168.1.254\n```\n\n- on container\n\nTo get configure a static IP address on the container, we need to override the system /usr/lib/systemd/network/80-container-host0.network file, which provides a DHCP configuration for the host0 network interface of the container. This can be done by placing the configuration into /etc/systemd/network/80-container-host0.network. For example:\n\n```\n/etc/systemd/network/80-container-host0.network\n```\n\n```\n[Match]\nName=host0\n\n[Network]\nDNS=192.168.1.254\nAddress=192.168.1.94/24\nGateway=192.168.1.254\n```\n\nMake sure that systemd-networkd.service is enabled in the container.\n\n"
    },
    {
      "title": "MACVLAN bridge",
      "level": 3,
      "content": "For the host to be able to reach containers connected via MACVLAN, the host itself also needs to connect via MACVLAN and not directly to the underlying Ethernet network interface.\n\nOn the host, attach the underlying Ethernet network interface to MACVLAN and make sure it does not get assigned IP addresses. For example, using mv-0 as the MACVLAN interface name and with enp1s0 as the host's Ethernet interface:\n\n```\n/etc/systemd/network/30-enp1s0.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Link]\nRequiredForOnline=carrier\n\n[Network]\nMACVLAN=mv-0\nDHCP=no\nIPv6AcceptRA=false\nLinkLocalAddressing=no\nMulticastDNS=false\nLLMNR=false\n```\n\n- RequiredForOnline=carrier prevents systemd-networkd-wait-online.service from waiting (and eventually failing) for the connection to acquire an IP address, which will never happen.\n- The underlying network interface does not necessarily need to be a physical Ethernet interface. For example, a MACVLAN bridge can be attached to a bond.\n\nCreate the MACVLAN bridge mv-0:\n\n```\n/etc/systemd/network/25-mv-0.netdev\n```\n\n```\n[NetDev]\nName=mv-0\nKind=macvlan\n\n[MACVLAN]\nMode=bridge\n```\n\nConfigure the host's network connection on the MACVLAN bridge (mv-0). The following example uses DHCP, replace the options as necessary.\n\n```\n/etc/systemd/network/35-mv-0.network\n```\n\n```\n[Match]\nName=mv-0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nBindCarrier=enp1s0\nDHCP=yes\n```\n\nFor the container, attach a MACVLAN to the underlying Ethernet network interface (enp1s0 in the examples above). For example, in /etc/systemd/nspawn/container_name.nspawn specify:\n\n```\n[Network]\nMACVLAN=enp1s0\n```\n\nFor containers started from the command line, pass them the --network-macvlan=enp1s0 option.\n\nIn the container, the MACVLAN interface will have the name mv-underlying_interface_name (e.g. mv-enp1s0). Configure the network connection as necessary (just like in the host) by matching the interface name. For example, using DHCP:\n\n```\n/etc/systemd/network/30-mv-enp1s0.network\n```\n\n```\n[Match]\nName=mv-enp1s0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nDHCP=yes\n```\n\n"
    },
    {
      "title": "Interface and desktop integration",
      "level": 3,
      "content": "systemd-networkd does not have a proper interactive graphical management interface. Still, some tools are available to either display or modify the current state of the network, receive notifications or interact with the wireless configuration:\n\n- networkctl provides a command-line shell interface to query or modify the network interface states. It is worth noting that in order to change only some aspects of an interface behavior, one is required to first edit one or more configuration files in /etc/systemd/network/.\n- When networkd is configured with wpa_supplicant, both wpa_cli and wpa_gui offer the ability to associate and configure WLAN interfaces dynamically.\n- The networkd-dispatcherAUR daemon allows executing scripts in response to network interface state changes, similar to NetworkManager-dispatcher.\n- The networkd-notify-gitAUR creates simple notification messages on interface changes.\n- As for the DNS resolver systemd-resolved, information about current DNS servers can be visualized with resolvectl status.\n\n"
    },
    {
      "title": "Configuring static IP or DHCP based on SSID (location)",
      "level": 3,
      "content": "Often there is a situation where your home wireless network uses DHCP and office wireless network uses static IP. This mixed setup can be configured as follows:\n\n```\n/etc/systemd/network/24-wireless-office.network\n```\n\n```\n# special configuration for office Wi-Fi network\n[Match]\nName=wlp2s0\nSSID=office_ap_name\n#BSSID=aa:bb:cc:dd:ee:ff\n\n[Network]\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.1\n#DNS=8.8.8.8\n```\n\n```\n/etc/systemd/network/25-wireless-dhcp.network\n```\n\n```\n# use DHCP for any other Wi-Fi network\n[Match]\nName=wlp2s0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nDHCP=yes\n```\n\n"
    },
    {
      "title": "Bonding a wired and wireless interface",
      "level": 3,
      "content": "See also Wireless bonding.\n\nBonding allows connection sharing through multiple interfaces, so if e.g. the wired interface is unplugged, the wireless is still connected and the network connectivity remains up seamlessly.\n\nCreate a bond interface. In this case the mode is active-backup, which means packets are routed through a secondary interface if the primary interface goes down.\n\n```\n/etc/systemd/network/30-bond0.netdev\n```\n\n```\n[NetDev]\nName=bond0\nKind=bond\n\n[Bond]\nMode=active-backup\nPrimaryReselectPolicy=always\nMIIMonitorSec=1s\n```\n\nSet the wired interface as the primary:\n\n```\n/etc/systemd/network/30-ethernet-bond0.network\n```\n\n```\n[Match]\nName=enp0s25\n\n[Network]\nBond=bond0\nPrimarySlave=true\n```\n\nSet the wireless as the secondary:\n\n```\n/etc/systemd/network/30-wifi-bond0.network\n```\n\n```\n[Match]\nName=wlan0\n\n[Network]\nBond=bond0\n```\n\nConfigure the bond interface just like a normal interface:\n\n```\n/etc/systemd/network/30-bond0.network\n```\n\n```\n[Match]\nName=bond0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nBindCarrier=enp0s25 wlan0\nDHCP=yes\n```\n\nNow if the wired network is unplugged, the connection should remain through the wireless:\n\n```\n$ networkctl\n```\n\n```\nIDX LINK    TYPE     OPERATIONAL      SETUP     \n  1 lo      loopback carrier          unmanaged \n  2 enp0s25 ether    no-carrier       configured\n  3 bond0   bond     degraded-carrier configured\n  5 wlan0   wlan     enslaved         configured\n\n4 links listed.\n```\n\n"
    },
    {
      "title": "Speeding up TCP slow-start",
      "level": 3,
      "content": "On a higher bandwidth link with moderate latency (typically a home Internet connection that is above 10 Mbit/s) the default settings for the TCP Slow Start algorithm are somewhat conservative. This issue exhibits as downloads starting slowly and taking a number of seconds to speed up before they reach the connection's full bandwidth. It is particularly noticeable with a pacman upgrade, where each package downloaded starts off slowly and often finishes before it has reached the connection's full speed.\n\nThese settings can be adjusted to make TCP connections start with larger window sizes than the defaults, avoiding the time it takes for them to automatically increase on each new TCP connection[1]. While this will usually decrease performance on slow connections (or if the values are increased too far) due to having to retransmit a larger number of lost packets, they can substantially increase performance on connections with sufficient bandwidth.\n\nIt is important to benchmark before and after changing these values to ensure it is improving network speed and not reducing it. If you are not seeing downloads begin slowly and gradually speed up, then there is no need to change these values as they are already optimal for your connection speed. When benchmarking, be sure to test against both a high speed and low speed remote server to ensure you are not speeding up access to fast machines at the expense of making access to slow servers even slower.\n\nTo adjust these values, edit the .network file for the connection:\n\n```\n/etc/systemd/network/eth0.network\n```\n\n```\n[Match]\nName=eth0\n\n#[Network]\n#Gateway=...  <-- Remove this if you have it, and put it in the Gateway= line below\n\n[Route]\n# This will apply to the gateway supplied via DHCP.  If you manually specify\n# your gateway, put it here instead.\nGateway=_dhcp4\n\n# The defaults for these values is 10.  They are a multiple of the MSS (1460 bytes).\nInitialCongestionWindow=10\nInitialAdvertisedReceiveWindow=10\n```\n\nThe defaults of 10 work well for connections slower than 10 Mbit/s. For a 100 Mbit/s connection, a value of 30 works well. The manual page systemd.network(5) § [ROUTE] SECTION OPTIONS says a value of 100 is considered excessive.\n\nIf the sysctl setting net.ipv4.tcp_slow_start_after_idle is enabled then the connection will return to these initial settings after it has been idle for some time (and often a very small amount of time). If this setting is disabled then the connection will maintain a higher window if a larger one was negotiated during packet transfer. Regardless of the setting, each new TCP connection will begin with the Initial* settings set above.\n\nThe sysctl setting net.ipv4.tcp_congestion_control is not directly related to these values, as it controls how the congestion and receive windows are adjusted while a TCP link is active, and particularly when the path between the two hosts is congested and throughput must be reduced. The above Initial* values simply set the default window values selected for each new connection, before any congestion algorithm takes over and adjusts them as needed. Setting higher initial values simply shortcuts some negotiation while the congestion algorithm tries to find the optimum values (or, conversely, setting the wrong initial values adds additional negotiation time while the congestion algorithm works towards correcting them, slowing down each newly established TCP connection for a few seconds extra).\n\n"
    },
    {
      "title": "Prevent multiple default routes",
      "level": 3,
      "content": "systemd-networkd does not set per-interface-type default route metrics, i.e. they need to be configured manually when using multiple network devices. For example, the following ip route shows multiple default routes:\n\n```\nip route\n```\n\n```\ndefault via 10.30.1.1 dev eno2 proto dhcp src 10.30.1.15 metric 1024\ndefault via 192.168.1.254 dev eno1 proto dhcp src 172.18.105.104 metric 1024\n```\n\nSince the same default metric value 1024 is assigned, there is a race condition which of both is chosen as default route. Since the eno2 device came up first, it is preferred and thus, access available via eno1 may be ignored.\n\nTo prevent the race condition, assign different RouteMetric= values for the devices. See #Wired and wireless adapters on the same machine for a corresponding example.\n\nIf instead one device should not provide a default route, the UseRoutes=false option can be used to ignore routes provides by the DHCP server. This may be useful, for example, if the device provides a connection to a single other machine.\n\n"
    },
    {
      "title": "Configuring a second static IP with its own MAC address on an existing interface",
      "level": 3,
      "content": "To make your computer appear as two completely separate devices to your router, you can create a virtual interface not just with a different IP but also with a different MAC address.\n\nTo achieve this, create a virtual interface (macvlan) on top of your physical interface with a unique MAC address:\n\n```\n/etc/systemd/network/25-eth210.netdev\n```\n\n```\n[NetDev]\nName=eth210\nKind=macvlan\nMACAddress=00:11:22:33:44:55\n\n[MACVLAN]\nMode=bridge\n```\n\nThen add a network file as usual, using the same subnet and gateway, and avoiding the range of IP numbers used for DHCP if you configure a static IP. For example:\n\n```\n/etc/systemd/network/25-eth210.network\n```\n\n```\n[Match]\nName=eth210\n\n[Network]\nAddress=192.168.132.210/24\nGateway=192.168.132.1\n\n[Route]\nDestination=192.168.132.0/24\nMetric=2\n```\n\nThe macvlan interface route has metric 2. This ensures that traffic will prefer going through the main interface, since that (implicitly) has a default route with metric 1, unless specifically directed to use the macvlan interface.\n\nFinally, add MACVLAN=eth210 to the [Network] section of the .network file of your main interface!\n\nAt this point, a fast way to make your router aware of the new MAC (and configure it to accept that MAC) you can for example run arping -I eth210 192.168.132.1 as root. After configuring your router for the \"new device\" you can test if the new interface has internet access with for example curl --interface 192.168.132.210 ifconfig.me that should then print your public IP number.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- systemd-networkd(8)\n- Tom Gundersen posts on Core OS blog\n- How to set up systemd-networkd with wpa_supplicant (WonderWoofy's walkthrough on Arch forums)\n\n"
    }
  ]
}