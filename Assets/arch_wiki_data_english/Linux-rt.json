{
  "title": "Linux-rt",
  "url": "https://wiki.archlinux.org/title/Linux-rt",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section is a candidate for moving to Realtime kernel.** This article or section is a candidate for moving to Realtime kernel.\n\nThis article or section is a candidate for moving to Realtime kernel.\n\nThis article describes the Linux kernel realtime patch set, and some utilities useful for trouble shooting scheduling latencies.\n\n"
    },
    {
      "title": "What is realtime?",
      "level": 2,
      "content": "Realtime applications have operational deadlines between some triggering event and the application's response to that event. To meet these operational deadlines, programmers use realtime operating systems (RTOS) on which the maximum response time can be calculated or measured reliably for the given application and environment. A typical RTOS uses priorities. The highest priority task wanting the CPU always gets the CPU within a fixed amount of time after the event waking the task has taken place. On such an RTOS the latency of a task only depends on the tasks running at equal or higher priorities; tasks running at lower priorities may be ignored. On a non-realtime OS (most GNU/Linux distributions running their default kernels), since latencies depend on each process running on the system, it is obviously much harder to ensure deadlines will be met every time, and this difficulty scales nonlinearly with system complexity. Determinism in scheduling becomes yet more difficult to achieve because preemption can be switched off for an arbitrary amount of time. A high priority task wanting to run can thus be delayed indefinitely by lower priority tasks with preemption disabled.\n\n"
    },
    {
      "title": "How does the realtime patch work",
      "level": 2,
      "content": "The RT-Preempt patch converts Linux into a fully preemptible kernel. This is done through:\n\n- Making in-kernel locking-primitives (using spinlocks) preemptible by reimplementation with rtmutexes.\n- Critical sections protected by i.e. spinlock_t and rwlock_t are now preemptible. The creation of non-preemptible sections (in kernel) is still possible with raw_spinlock_t (same APIs like spinlock_t).\n- Implementing priority inheritance for in-kernel spinlocks and semaphores.\n- Converting interrupt handlers into preemptible kernel threads: The RT-Preempt patch treats soft interrupt handlers in kernel thread context, which is represented by a task_struct like a common user space process. However it is also possible to register an IRQ in kernel context.\n- Converting the old Linux timer API into separate infrastructures for high resolution kernel timers plus one for timeouts, leading to user space POSIX timers with high resolution.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "There are two realtime patched kernels available: linux-rt and linux-rt-lts, which both have a configuration based on the main linux kernel package. linux-rt follows the development branch of the -rt patch, while linux-rt-lts tracks a stable branch of the rt patchset.\n\n"
    },
    {
      "title": "Scheduling latency",
      "level": 2,
      "content": "In the context of the scheduler, latency is the time that passes from the occurrence of an event until the handling of said event. Often the delay from the firing of an interrupt until the interrupt handler starts running, but could also be from the expiration of a timer, etc.\n\nThere can be many varied causes for high scheduling latencies. Some worth mentioning (in no particular order) are: a misconfigured system, bad hardware, badly programmed kernel modules, CPU power management, faulty hardware timers, SMIs and SMT.\n\nWhen trying to determine a system's maximum scheduling latency, the system needs to be put under load. A busy system will tend to experience greater latencies than an idle one. To sufficiently characterize latencies of interest, it would be prudent to run tests for a long time and under a variety of nominal and worst-case load conditions. Further, since many subsystems such as disks, network devices, USB and graphics may be used sparsely after a system is brought online, care should be taken to characterize latency with these subsystems active as well.\n\n"
    },
    {
      "title": "Latency testing utilities",
      "level": 2,
      "content": "Understanding latency is non-intuitive. In measuring and interpreting latency, errors are common and very likely to happen even with experienced computer scientists. Popular tools are often incorrect. This talk explains some common pitfalls. There are several tools available to check kernel scheduling latencies, and to track down the causes of latency spikes. One set of tools comes in a package called rt-tests.\n\n"
    },
    {
      "title": "cyclictest",
      "level": 3,
      "content": "One of the programs in rt-tests is called cyclictest, which can be used to verify the maximum scheduling latency, and for tracking down the causes of latency spikes. cyclictest works by measuring the time between the expiration of a timer a thread sets and when the thread starts running again.\n\nHere is the result of a typical test run:\n\n```\n# cyclictest --smp -p98 -m\n```\n\n```\n# /dev/cpu_dma_latency set to 0us\npolicy: fifo: loadavg: 239.09 220.49 134.53 142/1304 23799          \n\nT: 0 (23124) P:98 I:1000 C: 645663 Min:      2 Act:    4 Avg:    4 Max:      23\nT: 1 (23125) P:98 I:1500 C: 430429 Min:      2 Act:    5 Avg:    3 Max:      23\nT: 2 (23126) P:98 I:2000 C: 322819 Min:      2 Act:    4 Avg:    3 Max:      15\nT: 3 (23127) P:98 I:2500 C: 258247 Min:      2 Act:    5 Avg:    4 Max:      32\n^C\n```\n\nIt shows a four CPU core system running one thread (SCHED_FIFO) per core at priority 98, with memory locked, the system is also under a high load due to running hackbench in a separate terminal. What is most interesting is the max schedling latency detected, in this case 32 usecs on core 3.\n\nSee cyclictest(8) man page.\n\n"
    },
    {
      "title": "hackbench",
      "level": 3,
      "content": "An idle kernel will tend to show much lower scheduling latencies, it is essential to put some load on it to get a realistic result. This can be done with another utility in the rt-tests package called hackbench. It works by creating multiple pairs of threads or processes, that pass data between themselves either over sockets or pipes. To make it run longer add the -l parameter: hackbench -l 1000000.\n\nSee hackbench(8) man page.\n\n"
    },
    {
      "title": "hwlatdetect",
      "level": 3,
      "content": "hwlatdetect can be used to detect SMIs taking an inordinate time, thus introducing latency by blocking normal kernel execution. It consists of a kernel module (present in both linux-rt and linux-rt-lts), and a python script to launch the process and report the results back to the user. To check if the system uses NMIs run the following command:\n\n```\n$ grep NMI /proc/interrupts\n```\n\n```\nNMI:       3335       3336       3335       3335   Non-maskable interrupts\n```\n\nThe hwlatdetect kernel module works by turning everything running on the CPUs off through the stop_machine() call. It then polls the TSC (Time Stamp Counter) looking for gaps in the generated data stream. Any gaps indicates that it was interrupted by a NMI, as they are the only possible mechanism (apart from a broken TSC implementation). To run the program for 120 secs, with a detection threshold of 15 usecs, execute the following:\n\n```\n# hwlatdetect --duration=120 --threshold=15\n```\n\n```\nhwlatdetect:  test duration 120 seconds\n   parameters:\n        Latency threshold: 15us\n        Sample window:     1000000us\n        Sample width:      500000us\n     Non-sampling period:  500000us\n        Output File:       None\n\nStarting test\ntest finished\nMax Latency: 21us\nSamples recorded: 16\nSamples exceeding threshold: 16\n1408928107.0286324723   18      17\n.\n.\n1408928180.0296881126   15      21\n.\n.\n1408928212.0300332889   18      18\n```\n\nThe result shows 16 NMIs detected that exceeded the 15 usecs threshold specified, the maximum latency detected was 21 usecs.\n\nSee hwlatdetect(8) man page.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- realtime:start - Linux Foundation Wiki\n- Intro to Real-Time Linux for Embedded Developers\n\n"
    }
  ]
}