{
  "title": "Syslog-ng",
  "url": "https://wiki.archlinux.org/title/Syslog-ng",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- rsyslog\n\nsyslog-ng is a syslog implementation which can take log messages from sources and forward them to destinations, based on powerful filter directives. Although its origins are syslog, it is a pretty generic log management tool, being able to consume structured and unstructured log messages, parsing and transforming them if necessary.\n\n"
    },
    {
      "title": "Overview",
      "level": 2,
      "content": "syslog-ng takes incoming log messages from defined 'sources' and forwards them to the appropriate destinations, based on powerful filter directives. In a typical simple set-up, syslog-ng will read messages from three sources:\n\n1. the default /dev/log device, where most logs are sent\n1. syslog-ng \"internal\" log messages\n1. /proc/kmsg kernel messages\n\nSources are defined using the \"source\" directive. These incoming messages are then filtered according to defined filters (\"filter\" keyword), i.e. according to originating program or log level, and sent to the appropriate \"destination\".\n\nDestinations include log files (e.g. /var/log/messages.log), printing messages on a console and remote servers.\n\nThe pivotal function is log. This function defines which filters should be applied to a certain source, and where the resulting messages should be sent to.\n\nApart from local sources, as explained above, syslog-ng is also able to work with various sources over the network. To work with these, you will have to create a network() or udp() or tcp() source as explained below.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the syslog-ng package.\n\nTo use syslog-ng, start/enable syslog-ng@default.service.\n\n"
    },
    {
      "title": "systemd/journald integration",
      "level": 3,
      "content": "syslog-ng pulls in the messages from the systemd journal by default. Keeping ForwardToSyslog=no in /etc/systemd/journald.conf is recommended in order to avoid the overhead associated with the socket and to avoid needless error messages in the log. If on the other hand you do not want to store your logs twice and turn journald's Storage=none, you will need ForwardToSyslog=yes, as syslog-ng tries to follow the 'journald' journal file.\n\nSee #syslog-ng and systemd journal for more details.\n\n"
    },
    {
      "title": "Sources",
      "level": 2,
      "content": "syslog-ng receives log messages from a source. To define a source you should follow the following syntax:\n\n```\nsource <identifier> { source-driver(params); source-driver(params); ... };\n```\n\nIn the simplest case, you will just need a single system() driver.\n\n```\nsource src { system(); };\n```\n\nThis will automatically detect the best way to collect local logs and will make sure kernel, application and internal logs from syslog-ng are all collected.\n\nYou can look at the identifiers and source-drivers in the alternative syslog-ng manuals (as the ones on syslog-ng.com were unreachable).\n\nThe system() driver is actually a higher-level construct that expands to various sources as needed for the local system. But you can acquire more control by removing the system() source and use the lower level drivers directly.\n\nThe unix-stream() source-driver opens the given AF_UNIX socket and starts listening on it for messages.\n\nThe internal() source-driver \"receives\" messages generated internally, by syslog-ng itself.\n\nTherefore, the following means: src gets messages from the /dev/log socket and syslog-ng.\n\n```\nsource src { unix-stream(\"/dev/log\"); internal(); };\n```\n\nThe kernel sends log messages to /proc/kmsg and the file() driver reads log messages from files. Therefore, the following means kernsrc gets messages from file /proc/kmsg:\n\n```\nsource kernsrc { file(\"/proc/kmsg\"); };\n```\n\nTo open a port to read data from a remote server a source must be defined with this syntax:\n\n```\nsource s_net { network(transport(tcp)); };\n```\n\nfor UDP or\n\n```\nsource s_net { network(transport(udp)); };\n```\n\nto receive log messages via TCP. Both listen on port 514, unless overridden with the port() parameter.\n\n"
    },
    {
      "title": "syslog-ng and systemd journal",
      "level": 3,
      "content": "Starting with syslog-ng version 3.6.1 the default system() source on Linux systems using systemd uses journald as its standard system() source.\n\nIf you wish to use both the journald and syslog-ng, ensure the following settings are in effect. For systemd-journald, in the /etc/systemd/journald.conf file, Storage= either set to auto or unset (which defaults to auto) and ForwardToSyslog= set to yes. For /etc/syslog-ng/syslog-ng.conf, you need the following source stanza:\n\n```\n/etc/syslog-ng/syslog-ng.conf\n```\n\n```\nsource src {\n  system();\n};\n```\n\nIf, on the other hand, you wish not to retain the journald logs, but only syslog-ng's text logs, set Storage=volatile in /etc/systemd/journald.conf. This will store journald in ram. As of syslog-ng 3.6.3, syslog-ng is using journald as the system(); source so if you set Storage=none, the systemd journal will drop all messages and not forward them to syslog-ng.\n\nAfter the change restart the systemd-journald.service and syslog-ng@default.service daemons.\n\n"
    },
    {
      "title": "Destinations",
      "level": 2,
      "content": "In syslog-ng, log messages are sent to files. The syntax is very similar to sources:\n\n```\ndestination <identifier> {destination-driver(params); destination-driver(params); ... };\n```\n\nYou will be normally logging to a file, but you could log to a different destination-driver: pipe, Unix socket, TCP-UDP ports, terminals or to specific programs. Simply declaring a destination will not cause messages to be delivered to that destination: that will only happen as soon as you connect sources and destinations using log statements. Log statements can also include filters, thereby implementing a flexible log routing functionality.\n\nThis declaration instructs syslog-ng to send messages to /var/log/auth.log:\n\n```\ndestination authlog { file(\"/var/log/auth.log\"); };\n```\n\nIf the user is logged in, usertty() sends messages to the terminal of the specified user. If you want to send console messages to root's terminal if it is logged in:\n\n```\ndestination console { usertty(\"root\"); };\n```\n\nMessages can be sent to a pipe with pipe(). The following sends xconsole messages to the pipe /dev/xconsole. This needs some more configuration, so you could look at the sub-section xconsole below.\n\n```\ndestination xconsole { pipe(\"/dev/xconsole\"); };\n```\n\nTo send messages on the network, use udp(). The following will send your log data out to another server.\n\n```\ndestination remote_server { udp(\"10.0.0.2\" port(514)); };\n```\n\nYou can also use the newer network() driver syntax for the same:\n\n```\ndestination remote_server { network(\"10.0.0.2\" port(514) transport(udp)); };\n```\n\n"
    },
    {
      "title": "Creating filters for messages",
      "level": 2,
      "content": "The syntax for the filter statement is:\n\n```\nfilter <identifier> { expression; };\n```\n\nFunctions can be used in the expression, such as the function facility() which selects messages based on the syslog facility codes (kern, mail, auth, etc). Apart from facility codes, each log message is associated with a severity value; where debug is the most verbose, and panic only shows serious errors. You can find the facilities, log levels and priority names in /usr/include/sys/syslog.h or in RFC 3164. To filter those messages coming from authorization, like su(pam_unix)[18569]: session opened for user root by (uid=1000) use the following:\n\n```\nfilter f_auth { facility(auth); };\n```\n\nThe facility expression can use the boolean operators and, or, and not, so the following filter selects those messages not coming from authorization, network news or mail:\n\n```\nfilter f_debug { not facility(auth, authpriv, news, mail); };\n```\n\nThe function severity() selects messages based on its severity level, so if you want to select informational levels:\n\n```\nfilter f_info { severity(info); };\n```\n\nFunctions and boolean operators can be combined in more complex expressions. The following line filters messages with a priority level from informational to warning not coming from auth, authpriv, mail and news facilities:\n\n```\nfilter f_messages { severity(info..warn) and not facility(auth, authpriv, mail, news); };\n```\n\nMessages can also be selected by matching a regular expression in the message with the function match(\"regex\" value(\"<macro>\")). For example this would match the main part of the message against the regexp \"failed\":\n\n```\nfilter f_failed { match(\"failed\" value(\"MESSAGE\")); };\n```\n\nIn filter expressions, you can use both pre-defined and user defined macros. These are also called \"hard\" and \"soft\" macros respectively.\n\nA list and documentation of all macros can be found in the syslog-ng documentation:\n\n```\n\"AMPM\", \"BSDTAG\", \"DATE, C_DATE, R_DATE, S_DATE\", \"DAY, C_DAY, R_DAY, S_DAY\", \"FACILITY\", \"FACILITY_NUM\", \"FULLDATE, C_FULLDATE, R_FULLDATE, S_FULLDATE\", \"FULLHOST\", \"FULLHOST_FROM\", \"HOUR, C_HOUR, R_HOUR, S_HOUR\", \"HOUR12, C_HOUR12, R_HOUR12, S_HOUR12\", \"HOST\", \"HOST_FROM\", \"ISODATE, C_ISODATE, R_ISODATE, S_ISODATE\", \"LEVEL_NUM\", \"LOGHOST\", \"MIN, C_MIN, R_MIN, S_MIN\", \"MONTH, C_MONTH, R_MONTH, S_MONTH\", \"MONTH_ABBREV, C_MONTH_ABBREV, R_MONTH_ABBREV, S_MONTH_ABBREV\", \"MONTH_NAME, C_MONTH_NAME, R_MONTH_NAME, S_MONTH_NAME\", \"MONTH_WEEK, C_MONTH_WEEK, R_MONTH_WEEK, S_MONTH_WEEK\", \"MSEC, C_MSEC, R_MSEC, S_MSEC\", \"MSG or MESSAGE\", \"MSGHDR\", \"MSGID\", \"MSGONLY\", \"PID\", \"PRI\", \"PRIORITY or LEVEL\", \"PROGRAM\", \"SDATA, .SDATA.SDID.SDNAME\", \"SEC, C_SEC, R_SEC, S_SEC\", \"SOURCEIP\", \"SEQNUM\", \"STAMP, R_STAMP, S_STAMP\", \"SYSUPTIME\", \"TAG\", \"TAGS\", \"TZ, C_TZ, R_TZ, S_TZ\", \"TZOFFSET, C_TZOFFSET, R_TZOFFSET, S_TZOFFSET\", \"UNIXTIME, C_UNIXTIME, R_UNIXTIME, S_UNIXTIME\", \"USEC, C_USEC, R_USEC, S_USEC\", \"YEAR, C_YEAR, R_YEAR, S_YEAR\", \"WEEK, C_WEEK, R_WEEK, S_WEEK\", \"WEEK_ABBREV, C_WEEK_ABBREV, R_WEEK_ABBREV, S_WEEK_ABBREV\", \"WEEK_DAY, C_WEEK_DAY, R_WEEK_DAY, S_WEEK_DAY\", \"WEEKDAY, C_WEEKDAY, R_WEEKDAY, S_WEEKDAY\", \"WEEK_DAY_NAME, C_WEEK_DAY_NAME, R_WEEK_DAY_NAME, S_WEEK_DAY_NAME\".\n```\n\nTo filter messages received from a particular remote host (as declared in the incoming message itself and not by its IP address), the host() function must be used:\n\n```\nfilter f_host { host( \"192.168.1.1\" ); };\n```\n\nIf you would rather filter on sending IP address, you can use the netmask() filter:\n\n```\nfilter f_ipaddr { netmask( \"192.168.1.1/32\" ); };\n```\n\n"
    },
    {
      "title": "Log paths",
      "level": 2,
      "content": "syslog-ng connects sources, filters and destinations with log statements. The syntax is:\n\n```\nlog {source(s1); source(s2); ...\nfilter(f1); filter(f2); ...\ndestination(d1); destination(d2); ...\nflags(flag1[, flag2...]); };\n```\n\nThe following for example sends messages from src source to mailinfo destination filtered by f_info filter:\n\n```\nlog { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };\n```\n\nA log statement describes a pipeline: it tells syslog-ng to take messages from a source (or multiple sources) and deliver them to a destination (or multiple destinations) assuming the associated filters are matching.\n\nIf you have multiple log statements that take messages from the same source, messages will be duplicated along with all of those pipelines. Of course, you can apply a different set of filters and therefore route messages selectively to multiple destinations.\n\nApart from filtering, syslog-ng can apply parsing or rewriting of messages. Parsing means the extraction of information from the message text, whereas rewriting a message means that syslog-ng can change/reformat messages as needed.\n\nThe log statement has a lot more to offer:\n\n1. You can stop processing subsequent log paths after the current one matches using flags(final).\n1. You can tell a log statement to grab messages that none of the other log statements captured using flags(fallback)\n1. You can create an arbitrary graph out of log pipelines by using embedded log statements and junctions, which help you to construct complex processing pipelines.\n\nYou can read more about log statements in a chapter of the syslog-ng documentation.\n\n"
    },
    {
      "title": "Tips and tricks",
      "level": 2,
      "content": "After understanding the logic behind syslog-ng, many possible and complex configuration are possible. Here there are some examples.\n\n"
    },
    {
      "title": "Have syslog-ng reload the configuration file",
      "level": 3,
      "content": "You can make syslog-ng re-evaluate the configuration file. You can do so manually by sending a SIGHUP to the process, or reload syslog-ng@default.service.\n\n"
    },
    {
      "title": "Failover Logging to Remote Host",
      "level": 3,
      "content": "This setup shows how to send the default unencrypted syslog packets across both TCP and UDP protocols, using the standard port (514) and an alternate port. This is sending the same output to the same machine 4 different ways to try and make sure packets make it. Mostly useful if you are debugging a remote server that fails to reboot. The different ports and protocols are to make it past any firewall filters or other network problems. Also useful for port-forwarding and using tunnels. Something like this setup is ideal to tunnel across an ssh connection that the prone-to-failover host initiates through a reverse connection.\n\n```\n#sending to a remote syslog server on TCP and UDP ports (not encrypted)\ndestination askapache_failover_loghost {\n    tcp(\"208.86.158.195\" port(25214));\n    udp(\"208.86.158.195\" port(25214));\n    udp(\"mysyslog1.dyndns.org\" port(514));\n};\nlog { \n    source(src); \n    destination(askapache_failover_loghost);\n};\n```\n\nAnd then on the loghost receiving these logs:\n\n```\n#a USB redirected console for flexible viewing\ndestination debugging_console {\n    file(\"/dev/ttyU1\");\n};\n\n# listens on IP addresses and ports, sets the incoming settings\nsource prone_to_failover_host {\n    tcp(ip(208.86.158.195),port(25214));\n    udp(ip(208.86.158.195) port(25214));\n\n    udp(default-facility(syslog) default-priority(emerg));\n    tcp(default-facility(syslog) default-priority(emerg));\n}\n\n# log it\nlog {\n    source(prone_to_failover_host); \n    destination(debugging_console);\n};\n```\n\n"
    },
    {
      "title": "Move log to another file",
      "level": 3,
      "content": "In order to move some log from /var/log/messages to another file.\n\n```\n#sshd configuration\ndestination ssh { file(\"/var/log/ssh.log\"); };\nfilter f_ssh { program(\"sshd\"); };\nlog { source(src); filter(f_ssh); destination(ssh); flags(final); };\n```\n\nMake sure you add this block above your usual log statements. Due to flags(final) in the log statement, anything that matches the \"sshd\" filter would only be sent to ssh.log and processing of the message would stop at that point.\n\n"
    },
    {
      "title": "Configuring as a loghost",
      "level": 3,
      "content": "Configuring your system to be a loghost is quite simple. Drop the following into your configuration, and create the needed directory. With this simple configuration, log filenames will be based on the FQDN of the remote host, and located in /var/log/remote/. After creating the remote directory, reload your syslog-ng configuration.\n\n```\nsource net { udp(); };\ndestination remote { file(\"/var/log/remote/${FULLHOST}-log\"); };\nlog { source(net); destination(remote); };\n```\n\nYou could also consider the default-network-drivers() source that will open multiple ports, accepting messages over multiple different syslog protocols that are usually deployed in the field.\n\n"
    },
    {
      "title": "Improve performance",
      "level": 3,
      "content": "syslog-ng's performance can be improved in different ways:\n\n"
    },
    {
      "title": "Write every so often",
      "level": 4,
      "content": "It seems that the old sync(X) option is called flush_lines(X) now, where the writing to the file is buffered for X lines. Default is 100.\n\n"
    },
    {
      "title": "Increase source batching limits",
      "level": 4,
      "content": "syslog-ng is doing message processing in parallel, as streams of messages are received using the many different source mechanisms. To avoid starving one source connection over the other, syslog-ng both uses threading and imposes limits on how much messages would it process from a single source connection at a time.\n\nThis means that even though a source application might have sent 1000 messages in a tight loop, syslog-ng would process it 100 pieces at a time (the exact limit is specified by log-fetch-limit()) and after every 100, it would re-check if other connections are also in need of processing. This has some overhead, and syslog-ng performance can be increased significantly by increasing log-fetch-limit()\n\nThe other mechanism that can use tuning based on a specific use-case is the window size setting used for backpressure propagation. This is the log-iw-size() parameter that controls how many messages can be in-flight before a destination acknowledges them. By increasing the log-iw-size() you can let it work on more messages before it would stop to allow destinations to consume messages.\n\nBy increasing log-iw-size() your memory/disk buffer use will increase, as syslog-ng will have to put the messages somewhere.\n\n"
    },
    {
      "title": "Avoid redundant processing and disk space",
      "level": 4,
      "content": "A single log message can be sent to different log files several times. For example, in the initial configuration file, we have the following definitions:\n\n```\ndestination cron { file(\"/var/log/cron.log\"); };\ndestination messages { file(\"/var/log/messages\"); };\nfilter f_cron { facility(cron); };\nfilter f_messages { level(info..warn) \n       and not facility(auth, authpriv, mail, news); };\nlog { source(src); filter(f_cron); destination(cron); };\nlog { source(src); filter(f_messages); destination(messages); };\n```\n\nThe same message from the cron facility will end up in both the cron.log and messages files. To change this behavior we can use the final flag, ending up further processing with the message. Therefore, in this example, if we want messages from the cron facility not ending up in the messages file, we should change the cron's log sentence by:\n\n```\nlog { source(src); filter(f_cron); destination(cron); flags(final); };\n```\n\nanother way is to exclude the cron facility from f_messages filter:\n\n```\nfilter f_messages { level(info..warn) and not facility(cron, auth, authpriv, mail, news); };\n```\n\n"
    },
    {
      "title": "PostgreSQL Destination",
      "level": 3,
      "content": "This section will use two roles: syslog and logwriter. syslog will be the administrator of the database syslog and logwriter will only be able to add records to the logs table.\n\nNo longer needed to create table for logs. syslog-ng will create automatically.\n\n```\npsql -U postgres\n```\n\n```\npostgres=# CREATE ROLE syslog WITH LOGIN;\npostgres=# \\password syslog    # Using the \\password function is secure because\npostgres=# CREATE ROLE logwriter WITH LOGIN;\npostgres=# \\password logwriter # the password is not saved in history.\npostgres=# CREATE DATABASE syslog OWNER syslog;\npostgres=# \\q # You are done here for the moment\n```\n\nEdit pg_hba.conf to allow syslog and logwriter to establish a connection to PostgreSQL.\n\n```\n/var/lib/postgres/data/pg_hba.conf\n```\n\n```\n# TYPE  DATABASE    USER        CIDR-ADDRESS          METHOD\n\nhost    syslog      logwriter   192.168.0.1/24        md5\nhost    syslog      syslog      192.168.0.10/32       md5\n```\n\nThen reload postgresql.service.\n\nEdit /etc/syslog-ng/syslog-ng.conf so that it knows where and how to write to PostgreSQL. syslog-ng will utilize the logwriter role.\n\n```\n...\n#\n# SQL logging support\n#\n\ndestination d_pgsql {\n  sql(type(pgsql)\n  host(\"127.0.0.1\") username(\"logwriter\") password(\"password\")\n  database(\"syslog\")\n  table(\"logs_${HOST}_${R_YEAR}${R_MONTH}${R_DAY}\") #or whatever you want, example ${HOST}\" for hosts, ${LEVEL}\" for levels.. etc\n  columns(\"datetime timestamp with time zone\", \"host varchar(32)\", \"program varchar(16)\", \"pid varchar(16)\", \"message varchar(200)\")\n  values(\"$R_ISODATE\", \"$HOST\", \"$PROGRAM\", \"$PID\", \"$MSG\")\n  indexes(\"datetime\", \"host\", \"program\", \"pid\", \"message\"));\n};\n\nlog { source(src); destination(d_pgsql); };\n```\n\nFinally, restart syslog-ng.service.\n\nAnd check to see if things are being logged.\n\n```\npsql -U logwriter -d syslog\nsyslog=> SELECT * FROM <your table name> ORDER BY datetime DESC LIMIT 10;\n```\n\n"
    },
    {
      "title": "ISO 8601 timestamps",
      "level": 3,
      "content": "Before :\n\n```\n#logger These timestamps are not optimal.\n#tail -n 1 /var/log/messages.log\nFeb 18 14:25:01 hostname logger: These timestamps are not optimal.\n#\n```\n\nAdd ts_format(iso); to /etc/syslog-ng/syslog-ng.conf in the options section. Example:\n\n```\noptions {\n  stats_freq (0);\n  flush_lines (0);\n  time_reopen (10);\n  log_fifo_size (1000);\n  long_hostnames(off); \n  use_dns (no);\n  use_fqdn (no);\n  create_dirs (no);\n  keep_hostname (yes);\n  perm(0640);\n  group(\"log\");\n  ts_format(iso);      #make ISO-8601 timestamps\n  #frac-digits(3);     #optional time to nearest millisecond \n};\n```\n\nThen reload syslog-ng.service.\n\nAfter :\n\n```\n#logger Now THAT is a timestamp!\n#tail -n 2 /var/log/messages.log\nFeb 18 14:25:01 hostname logger: These timestamps are not optimal.\n2010-02-18T20:23:58-05:00 electron logger: Now THAT is a timestamp!\n#\n```\n\n"
    },
    {
      "title": "RFC 3339 timestamps",
      "level": 3,
      "content": "Same as above, except use rfc3339 instead of iso for ts_format\n\n"
    },
    {
      "title": "Log Levels",
      "level": 3,
      "content": "Log levels are defined separately for each logged facility in syslog-ng config. Available log levels are listed in /usr/include/sys/syslog.h:\n\n```\n/usr/include/sys/syslog.h\n```\n\n```\ndefine LOG_EMERG       0       /* system is unusable */\ndefine LOG_ALERT       1       /* action must be taken immediately */\ndefine LOG_CRIT        2       /* critical conditions */\ndefine LOG_ERR         3       /* error conditions */\ndefine LOG_WARNING     4       /* warning conditions */\ndefine LOG_NOTICE      5       /* normal but significant condition */\ndefine LOG_INFO        6       /* informational */\ndefine LOG_DEBUG       7       /* debug-level messages */\n```\n\n"
    },
    {
      "title": "Macros and Variables",
      "level": 3,
      "content": "Macros can be used in both templates, and in destination file names. Macros of syslog-ng OSE.\n\nThe following code will write the log lines to /var/log/test.log in the format of macroname=value@.\n\n```\ntemplate t_test { template(\"PROGRAM=$PROGRAM@PID=$PID@BSDTAG=$BSDTAG@TAG=$TAG@TAGS=$TAGS@FACILITY=$FACILITY@FACILITY_NUM=$FACILITY_NUM@LEVEL=$LEVEL@LEVEL_NUM=$LEVEL_NUM@PRI=$PRI@PRIORITY=$PRIORITY@FULLHOST=$FULLHOST@FULLHOST_FROM=$FULLHOST_FROM@HOST=$HOST@HOST_FROM=$HOST_FROM@LOGHOST=$LOGHOST@MSGHDR=$MSGHDR@MSGID=$MSGID@MSGONLY=$MSGONLY@MSG=$MSG@MESSAGE=$MESSAGE@SOURCE=$SOURCE@SOURCEIP=$SOURCEIP@SOURCE_IP=$SOURCE_IP@SEQNUM=$SEQNUM@UNIXTIME=$UNIXTIME@FULLDATE=$FULLDATE@ISODATE=$ISODATE@DATE=$DATE@STAMP=$STAMP@TZ=$TZ@TZOFFSET=$TZOFFSET@SEC=$SEC@MIN=$MIN@HOUR=$HOUR@HOUR12=$HOUR12@DAY=$DAY@WEEK=$WEEK@WEEK_DAY=$WEEK_DAY@WEEK_DAY_ABBREV=$WEEK_DAY_ABBREV@WEEK_DAY_NAME=$WEEK_DAY_NAME@MONTH=$MONTH@MONTH_ABBREV=$MONTH_ABBREV@MONTH_NAME=$MONTH_NAME@MONTH_WEEK=$MONTH_WEEK@YEAR=$YEAR@YEAR_DAY=$YEAR_DAY\n\\n\"); template_escape(no); };\n\ndestination d_test { file(\"/var/log/test.log\" template(t_test)); };\n\nlog { source(s_local); destination(d_test); flags(final); };\n```\n\nYou can create your own value list as below once syslog-ng is restarted with: tail /var/log/test.log|tr \"@\" \"\\n\"\n\n```\nPROGRAM=kernel\nPID=\nBSDTAG=4A\nTAG=04\nTAGS=.source.s_local\nFACILITY=kern\nFACILITY_NUM=0\nLEVEL=warning\nLEVEL_NUM=4\nPRI=4\nPRIORITY=warning\nFULLHOST=www.askapache.com\nFULLHOST_FROM=www.askapache.com\nHOST=www.askapache.com\nHOST_FROM=www.askapache.com\nLOGHOST=\nMSGHDR=kernel: \nMSGID=\nMSGONLY=Firewall: *INVALID* IN=eth0 OUT= MAC=00:00 SRC=x.x.x.x DST=198.101.159.98 LEN=40 TOS=0x00 PREC=0x00 TTL=113 ID=7730 DF PROTO=TCP SPT=52369 DPT=80 WINDOW=0 RES=0x00 ACK RST URGP=0 \nMSG=Firewall: *INVALID* IN=eth0 OUT= MAC=00:00 SRC=x.x.x.x DST=198.101.159.98 LEN=40 TOS=0x00 PREC=0x00 TTL=113 ID=7730 DF PROTO=TCP SPT=52369 DPT=80 WINDOW=0 RES=0x00 ACK RST URGP=0 \nMESSAGE=Firewall: *INVALID* IN=eth0 OUT= MAC=00:00 SRC=x.x.x.x DST=198.101.159.98 LEN=40 TOS=0x00 PREC=0x00 TTL=113 ID=7730 DF PROTO=TCP SPT=52369 DPT=80 WINDOW=0 RES=0x00 ACK RST URGP=0 \nSOURCE=s_local\nSOURCEIP=127.0.0.1\nSOURCE_IP=\nUNIXTIME=1369742458\nFULLDATE=2013 May 28 08:00:58\nISODATE=2013-05-28T08:00:58-04:00\nDATE=May 28 08:00:58\nSTAMP=2013-05-28T08:00:58-04:00\nTZ=-04:00\nTZOFFSET=-04:00\nSEC=58\nMIN=00\nHOUR=08\nHOUR12=\nDAY=28\nWEEK=21\nWEEK_DAY=3\nWEEK_DAY_ABBREV=Tue\nWEEK_DAY_NAME=Tuesday\nMONTH=05\nMONTH_ABBREV=May\nMONTH_NAME=May\nMONTH_WEEK=4\nYEAR=2013\nYEAR_DAY=148\n```\n\n"
    },
    {
      "title": "Receive and parse common syslog messages",
      "level": 3,
      "content": "Starting from version 3.16 syslog-ng is capable to receive and parse messages on the most common ports with the most common parsers using the default-network-drivers() source driver.\n\n- Default listening ports: 514, both TCP and UDP, for RFC3164 (BSD-syslog) formatted traffic 601 TCP, for RFC5424 (IETF-syslog) formatted traffic 6514 TCP, for TLS-encrypted traffic\n- Automatic parsers: RFC3164 message parser RFC5424 message parser Cisco parser Structured EWMM parser Other application adapters (Splunk Common Information Model (CIM), iptables, or sudo)\n\n- 514, both TCP and UDP, for RFC3164 (BSD-syslog) formatted traffic\n- 601 TCP, for RFC5424 (IETF-syslog) formatted traffic\n- 6514 TCP, for TLS-encrypted traffic\n\n- RFC3164 message parser\n- RFC5424 message parser\n- Cisco parser\n- Structured EWMM parser\n- Other application adapters (Splunk Common Information Model (CIM), iptables, or sudo)\n\n"
    },
    {
      "title": "See Also",
      "level": 3,
      "content": "- Netconsole A kernel module that sends all kernel log messages (i.e. dmesg) over the network to another computer, without involving user space (e.g. syslogd).\n\n"
    },
    {
      "title": "External Links",
      "level": 2,
      "content": "- syslog-ng Project Page on GitHub\n- syslog-ng OSE Main Page from syslog-ng.com\n- syslog-ng Documentation\n- syslog-ng Documentation GitHub page\n- syslog-ng Blogs\n- Axoflow Blogs about syslog-ng\n- syslog-ng Project Page on Freecode\n- Gentoo:syslog-ng\n- Gentoo:Security Handbook/Logging\n- What is Syslog? Logging with PostgreSQL HOWTO\n- Wikipedia:ISO 8601\n- RFC 3164 - The BSD syslog Protocol\n- RFC 5424 - The Syslog Protocol RFC 5425 - Transport Layer Security (TLS) Transport Mapping for Syslog RFC 5426 - Transmission of Syslog Messages over UDP RFC 5427 - Textual Conventions for Syslog Management RFC 5428 - MIB for PacketCable and IPCablecom-Compliant Devices\n- RFC 3339 - Date and Time on the Internet: Timestamps\n\n- RFC 5425 - Transport Layer Security (TLS) Transport Mapping for Syslog\n- RFC 5426 - Transmission of Syslog Messages over UDP\n- RFC 5427 - Textual Conventions for Syslog Management\n- RFC 5428 - MIB for PacketCable and IPCablecom-Compliant Devices\n\n"
    }
  ]
}