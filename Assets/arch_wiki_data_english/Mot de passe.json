{
  "title": "Mot de passe",
  "url": "https://wiki.archlinux.org/title/Mot_de_passe",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- DeveloperWiki:UID / GID Database\n- Sudo (Français)\n- Polkit\n- File permissions and attributes\n- systemd-homed\n- Reset lost root password\n\nLes utilisateurs et les groupes sont utilisés sous GNU/Linux pour le contrôle d'accès-c'est-à-dire pour contrôler l'accès aux fichiers, répertoires et périphériques du système. Linux offre par défaut des mécanismes de contrôle d'accès relativement simples et bruts. Pour des options plus avancées, consultez ACL, Capabilities et PAM#Configuration How-Tos.\n\n"
    },
    {
      "title": "Vue d'ensemble",
      "level": 2,
      "content": "Un utilisateur est toute personne qui utilise un ordinateur. Dans ce cas, nous décrivons les noms qui représentent ces utilisateurs. Il peut s'agir de Pierre ou de Paul et ils peuvent utiliser les noms Reinedesneiges ou Pirate à la place de leur vrai nom. Tout ce qui compte, c'est que l'ordinateur a un nom pour chaque compte qu'il crée et c'est ce nom qui permet à une personne d'accéder à l'ordinateur. Certains services du système fonctionnent également à l'aide de comptes d'utilisateurs restreints ou privilégiés.\n\nLa gestion des utilisateurs est effectuée à des fins de sécurité en limitant l'accès de certaines manières spécifiques. Le superutilisateur («root») a un accès complet au système d'exploitation et à sa configuration ; il est destiné à un usage administratif uniquement. Les utilisateurs non privilégiés peuvent utiliser les programmes su et sudo pour contrôler l'escalade des privilèges.\n\nToute personne peut avoir plus d'un compte à condition d'utiliser un nom différent pour chaque compte qu'elle crée. En outre, il existe des noms réservés qui ne peuvent pas être utilisés, comme «root».\n\nLes utilisateurs peuvent être regroupés dans un \"groupe\", et des utilisateurs peuvent être ajoutés à un groupe existant pour utiliser les accès privilégiés qu'il accorde.\n\n"
    },
    {
      "title": "Permissions et appartenance",
      "level": 2,
      "content": "Extrait de Sous UNIX, tout est fichier :\n\nTraduit de Extending UNIX File Abstraction for General-Purpose Networking[dead link 2024-01-13 ⓘ] :\n\nChaque fichier sur un système GNU/Linux appartient à un utilisateur et à un groupe. De plus, il existe trois types de permissions d'accès : lecture, écriture et exécution. Différentes autorisations d'accès peuvent être appliquées à l'utilisateur propriétaire d'un fichier, au groupe propriétaire et aux autres (ceux qui ne sont pas propriétaires). On peut déterminer les propriétaires et les autorisations d'un fichier en consultant la liste longue de la commande ls :\n\n```\n$ ls -l /boot/\n```\n\n```\ntotal 13740\ndrwxr-xr-x 2 root root    4096 Jan 12 00:33 grub\n-rw-r--r-- 1 root root 8570335 Jan 12 00:33 initramfs-linux-fallback.img\n-rw-r--r-- 1 root root 1821573 Jan 12 00:31 initramfs-linux.img\n-rw-r--r-- 1 root root 1457315 Jan  8 08:19 System.map26\n-rw-r--r-- 1 root root 2209920 Jan  8 08:19 vmlinuz-linux\n```\n\nLa première colonne affiche les permissions du fichier (par exemple, le fichier initramfs-linux.img a les permissions -rw-r--r--). Les troisième et quatrième colonnes affichent l'utilisateur et le groupe propriétaires du fichier, respectivement. Dans l'exemple ci-dessus, tous les fichiers appartiennent à l'utilisateur root et au groupe root.\n\n```\n$ ls -l /media/\n```\n\n```\ntotal 16\ndrwxrwx--- 1 root vboxsf 16384 Jan 29 11:02 sf_Shared\n```\n\nDans cet exemple, le répertoire sf_Shared appartient à l'utilisateur root et au groupe vboxsf. Il est également possible de déterminer les propriétaires et les permissions d'un fichier à l'aide de la commande stat :\n\nUtilisateur propriétaire :\n\n```\n$ stat -c %U /media/sf_Shared/\n```\n\n```\nroot\n```\n\nGroupe propriétaire :\n\n```\n$ stat -c %G /media/sf_Shared/\n```\n\n```\nvboxsf\n```\n\nDroits d'accès :\n\n```\n$ stat -c %A /media/sf_Shared/\n```\n\n```\ndrwxrwx---\n```\n\nLes droits d'accès sont affichés en trois groupes de caractères, représentant les droits de l'utilisateur propriétaire, du groupe propriétaire et des autres, respectivement. Par exemple, les caractères -rw-r--r-- indiquent que le propriétaire du fichier a le droit de lire et d'écrire, mais pas d'exécuter (rw-), tandis que les utilisateurs appartenant au groupe propriétaire et les autres utilisateurs ont uniquement le droit de lire (r-- et r--). Les caractères drwxrwx--- indiquent que le propriétaire du fichier et les utilisateurs appartenant au groupe propriétaire ont tous les droits de lecture, d'écriture et d'exécution (rwx et rwx), tandis que les autres utilisateurs se voient refuser l'accès (---). Le premier caractère représente le type du fichier.\n\nLister les fichiers appartenant à un utilisateur ou à un groupe avec l'utilitaire find :\n\n```\n# find / -group groupname\n```\n\n```\n# find / -group groupnumber\n```\n\n```\n# find / -user user\n```\n\nL'utilisateur et le groupe propriétaires d'un fichier peuvent être modifiés à l'aide de la commande chown (changement de propriétaire). (changer le propriétaire). Les autorisations d'accès à un fichier peuvent être modifiées à l'aide de la commande chmod (changer le mode). (changer le mode).\n\nConsultez chown(1), chmod(1) et Autorisations de fichiers Linux (en) pour plus de détails.\n\n"
    },
    {
      "title": "Shadow",
      "level": 2,
      "content": "Les outils de gestion des utilisateurs, des groupes et des mots de passe sur Arch Linux proviennent du paquet shadow, qui est une dépendance du méta-paquet base.\n\n"
    },
    {
      "title": "Liste des fichiers",
      "level": 2,
      "content": "Table content:\nFichier | Objectif\n/etc/shadow | Sécuriser les informations du compte utilisateur\n/etc/passwd | Informations sur le compte utilisateur\n/etc/gshadow | Contient les informations shadowées pour les comptes de groupe\n/etc/group | Définit les groupes auxquels les utilisateurs appartiennent\n\n"
    },
    {
      "title": "Gestion des utilisateurs",
      "level": 2,
      "content": "Pour lister les utilisateurs actuellement connectés sur le système, la commande who peut être utilisée. Pour lister tous les comptes utilisateurs existants, y compris leurs propriétés stockées dans la #Base de données des utilisateurs, exécutez passwd -Sa en tant que «root». Consultez passwd(1) pour la description du format de sortie.\n\nPour ajouter un nouvel utilisateur, utilisez la commande useradd :\n\n```\n# useradd -m -G additional_groups -s login_shell nom_utilisateur\n```\n\nSi un groupe de connexion initial est spécifié par un nom ou un numéro, il doit faire référence à un groupe déjà existant. S'il n'est pas spécifié, le comportement de useradd dépendra de la variable USERGROUPS_ENAB contenue dans /etc/login.defs. Le comportement par défaut (USERGROUPS_ENAB yes) est de créer un groupe avec le même nom que le nom d'utilisateur.\n\nLorsque le shell de connexion est destiné à être non fonctionnel, par exemple lorsque le compte utilisateur est créé pour un service spécifique, /usr/bin/nologin peut être spécifié à la place d'un shell normal pour refuser poliment une connexion (consultez nologin(8)).\n\nConsultez useradd(8) pour d'autres options prises en charge.\n\n"
    },
    {
      "title": "Exemple d'ajout d'un utilisateur",
      "level": 3,
      "content": "Pour ajouter un nouvel utilisateur nommé archie, en créant son répertoire personnel et en utilisant tous les paramètres par défaut en termes de groupes, de noms de répertoires, d'interpréteur de commandes utilisé et divers autres paramètres :\n\n```\n# useradd -m archie\n```\n\nBien qu'il ne soit pas nécessaire de protéger l'utilisateur nouvellement créé archie par un mot de passe, il est fortement recommandé de le faire :\n\n```\n# passwd archie\n```\n\nLa commande useradd ci-dessus crée aussi automatiquement un groupe appelé archie et en fait le groupe par défaut de l'utilisateur archie. Faire en sorte que chaque utilisateur ait son propre groupe (avec le même nom de groupe que le nom d'utilisateur) est la meilleure façon d'ajouter des utilisateurs.\n\nVous pouvez également modifier le groupe par défaut à l'aide de l'option -g, mais notez que, dans les systèmes multi-utilisateurs, il n'est pas recommandé d'utiliser un seul groupe par défaut (par exemple users) pour chaque utilisateur. La raison en est que, typiquement, la méthode pour faciliter l'accès partagé en écriture pour des groupes spécifiques d'utilisateurs est de définir la valeur umask de l'utilisateur à 002, ce qui signifie que le groupe par défaut aura par défaut toujours accès en écriture à tout fichier que vous créez. Consultez également Groupes privés d'utilisateurs (en). Si un utilisateur doit être membre d'un groupe spécifique, spécifiez ce groupe comme groupe supplémentaire lors de la création de l'utilisateur.\n\nDans le scénario recommandé, où le groupe par défaut a le même nom que le nom de l'utilisateur, tous les fichiers sont par défaut accessibles en écriture uniquement pour l'utilisateur qui les a créés. Pour autoriser l'accès en écriture à un groupe spécifique, les fichiers/répertoires partagés peuvent être rendus accessibles en écriture par défaut pour tous les membres de ce groupe et le groupe propriétaire peut être automatiquement fixé au groupe qui possède le répertoire parent en définissant le bit setgid sur ce répertoire :\n\n```\n# chmod g+s notre_répertoire_partagé.\n```\n\nSinon, le groupe par défaut du créateur du fichier (généralement le même que le nom d'utilisateur) est utilisé.\n\nSi un changement de GID est nécessaire temporairement, vous pouvez également utiliser la commande newgrp pour changer le GID par défaut de l'utilisateur en un autre GID au moment de l'exécution. Par exemple, après l'exécution de newgrp groupname, les fichiers créés par l'utilisateur seront associés au GID groupname. sans qu'il soit nécessaire de se reconnecter. Pour revenir au GID par défaut, exécutez newgrp sans nom de groupe.\n\n"
    },
    {
      "title": "Exemple d'ajout d'un utilisateur système",
      "level": 3,
      "content": "Les utilisateurs système peuvent être utilisés pour exécuter des processus/daemons sous un autre utilisateur, protéger (par exemple avec chown) des fichiers et/ou des répertoires et d'autres exemples de renforcement de l'ordinateur.\n\nLa commande suivante permet de créer un utilisateur système sans accès au shell et sans répertoire home (en option, ajoutez le paramètre -U pour créer un groupe portant le même nom que l'utilisateur, et ajoutez l'utilisateur à ce groupe) :\n\n```\n# useradd -r -s /usr/bin/nologin nom_utilisateur.\n```\n\nSi l'utilisateur du système nécessite un ID d'utilisateur et de groupe spécifique, spécifiez-les avec les options -u/--uid et -g/--gid lors de la création de l'utilisateur :\n\n```\n# useradd -r -u 850 -g 850 -s /usr/bin/nologin nom_utilisateur.\n```\n\n"
    },
    {
      "title": "Changer le nom de connexion ou le répertoire d'origine d'un utilisateur",
      "level": 3,
      "content": "Pour changer le répertoire personnel d'un utilisateur :\n\n```\n# usermod -d /my/new/home -m nom_utilisateur.\n```\n\nL'option -m crée aussi automatiquement le nouveau répertoire et y déplace le contenu.\n\nNote: **pas** Assurez-vous qu'il n'y ait pas de / à la fin de /my/old/home.\n\n```\n# ln -s /my/new/home/ /my/old/home\n```\n\nAssurez-vous qu'il n'y ait pas de / à la fin de /my/old/home.\n\nPour changer le nom de connexion d'un utilisateur :\n\n```\n# usermod -l newname oldname\n```\n\nLe changement de nom d'utilisateur est sûr et facile lorsqu'il est effectué correctement, il suffit d'utiliser la commande usermod. Si l'utilisateur est associé à un groupe portant le même nom, vous pouvez le renommer avec la commande groupmod.\n\nAlternativement, le fichier /etc/passwd peut être édité directement, consultez #Base de données des utilisateurs pour une introduction à son format.\n\nGardez aussi à l'esprit les points suivants :\n\n- Si vous utilisez sudo, assurez-vous de mettre à jour votre /etc/sudoers pour refléter le(s) nouveau(x) nom(s) d'utilisateur (via la commande visudo en tant que root).\n- Les crontabs personnels doivent être ajustés en renommant le fichier de l'utilisateur dans /var/spool/cron de l'ancien au nouveau nom, puis en ouvrant crontab -e pour modifier les chemins pertinents et ajuster les permissions des fichiers en conséquence.\n- Le contenu des répertoires/fichiers personnels de Wine dans ~/.wine/drive_c/users, ~/.local/share/applications/wine/Programs et peut-être plus doivent être renommés/édités manuellement.\n- Certains modules complémentaires de Thunderbird, comme Enigmail, peuvent devoir être réinstallés.\n- Tout ce qui se trouve sur votre système (raccourcis de bureau, scripts shell, etc.) qui utilise un chemin absolu vers votre répertoire personnel (c'est-à-dire /home/oldname) devra être modifié pour refléter votre nouveau nom. Pour éviter ces problèmes dans les scripts shell, utilisez simplement les variables ~ ou $HOME pour les répertoires personnels.\n- N'oubliez pas non plus de modifier en conséquence les fichiers de configuration dans /etc/ qui dépendent de votre chemin absolu (par exemple Samba, CUPS, etc.). Une bonne façon de savoir quels fichiers vous devez mettre à jour consiste à utiliser la commande grep de cette manière : grep -r old_user *\n\n"
    },
    {
      "title": "Autres exemples de gestion des utilisateurs",
      "level": 3,
      "content": "Pour saisir les informations relatives aux utilisateurs pour le commentaire GECOS (par exemple le nom complet de l'utilisateur), tapez :\n\n```\n# chfn username\n```\n\n(de cette façon, chfn fonctionne en mode interactif).\n\nAlternativement, le commentaire GECOS peut être défini plus librement avec :\n\n```\n# usermod -c \"Commentaire\" username\n```\n\nPour marquer le mot de passe d'un utilisateur comme expiré, lui demandant de créer un nouveau mot de passe lors de sa première connexion, tapez :\n\n```\n# chage -d 0 username\n```\n\nLes comptes utilisateurs peuvent être supprimés avec la commande userdel :\n\n```\n# userdel -r username\n```\n\nL'option -r spécifie que le répertoire personnel de l'utilisateur et le spool de courrier doivent également être supprimés.\n\nPour changer le shell de connexion de l'utilisateur :\n\n```\n# usermod -s /bin/bash username\n```\n\n"
    },
    {
      "title": "Base de données des utilisateurs",
      "level": 2,
      "content": "Les informations sur les utilisateurs locaux sont stockées dans le fichier /etc/passwd en texte clair : chacune de ses lignes représente un compte utilisateur et comporte sept champs délimités par des deux-points.\n\n```\ncompte:mot de passe:UID:GID:GECOS:répertoire:shell.\n```\n\nOù :\n\n- account est le nom de l'utilisateur. Ce champ ne peut pas être vide. Les règles de nommage standard *NIX s'appliquent.\n- password est le mot de passe de l'utilisateur. Attention: Le fichier passwd est lisible par le monde entier, donc stocker des mots de passe (hachés ou non) dans ce fichier n'est pas sûr. Arch Linux utilise plutôt des mots de passe cachés «shadowed passwords» : le champ password contiendra un caractère de remplacement (x) indiquant que le mot de passe haché est enregistré dans le fichier à accès restreint /etc/shadow. Pour cette raison, il est recommandé de toujours changer les mots de passe en utilisant la commande passwd.\n- UID est l'identifiant numérique de l'utilisateur. Dans Arch, le premier nom de connexion (après root) pour un utilisateur dit normal, par opposition aux services, est UID 1000 par défaut ; les entrées UID suivantes pour les utilisateurs doivent être supérieures à 1000.\n- GID est l'identifiant numérique du groupe primaire pour l'utilisateur. Les valeurs numériques des GID sont listées dans /etc/group.\n- GECOS est un champ facultatif utilisé à des fins d'information ; il contient généralement le nom complet de l'utilisateur, mais il peut également être utilisé par des services tels que finger et géré avec la commande chfn. Ce champ est facultatif et peut être laissé vide.\n- directory est utilisé par la commande login pour définir la variable d'environnement $HOME. Plusieurs services ayant leurs propres utilisateurs utilisent /, mais les utilisateurs normaux définissent généralement un répertoire sous /home.\n- shell est le chemin vers le «shell» par défaut de l'utilisateur. Ce champ est facultatif et la valeur par défaut est /bin/bash.\n\nNote: **passwd** \n\nExemple :\n\n```\narchie:x:1001:1003:Archie,un commentaire ici,,:/home/archie:/bin/bash\n```\n\nEn résumé, cela signifie : utilisateur archie, dont le mot de passe se trouve dans /etc/shadow, dont l'UID est 1001 et dont le groupe principal est 1003. Archie est son nom complet et un commentaire est associé à son compte ; son répertoire personnel est /home/archie et son shell est Bash.\n\nLa commande pwck peut être utilisée pour vérifier l'intégrité de la base de données des utilisateurs. Elle peut trier la liste des utilisateurs par GID en même temps, ce qui peut être utile pour la comparaison :\n\n```\n# pwck -s\n```\n\n"
    },
    {
      "title": "Contrôles d'intégrité automatiques",
      "level": 2,
      "content": "Au lieu d'exécuter pwck/grpck manuellement, le timer de systemd shadow.timer, qui fait partie de, et est activé par, l'installation du paquet shadow, lancera shadow.service quotidiennement. shadow.service exécutera pwck(8) et grpck(8) pour vérifier l'intégrité des fichiers de mots de passe et de groupe.\n\nSi des anomalies sont signalées, le groupe peut être modifié avec la commande vigr(8) et les utilisateurs avec vipw(8). Ceci fournit une marge de protection supplémentaire dans la mesure où ces commandes verrouillent les bases de données pour l'édition. Notez que l'éditeur de texte par défaut est vi, mais un autre éditeur sera utilisé si la variable d'environnement EDITOR. Si la variable d'environnement est définie, cet éditeur sera utilisé à la place.\n\n"
    },
    {
      "title": "Gestion des groupes",
      "level": 2,
      "content": "/etc/group est le fichier qui définit les groupes sur le système (consultez group(5) pour plus de détails). Il y a aussi son compagnon gshadow qui est rarement utilisé. Ses détails se trouvent dans gshadow(5).\n\nAffichez l'appartenance à un groupe avec la commande groups :\n\n```\n$ groups user\n```\n\nSi user est omis, les noms des groupes de l'utilisateur actuel sont affichés.\n\nLa commande id fournit des détails supplémentaires, comme l'UID de l'utilisateur et les GIDs associés :\n\n```\n$ id user\n```\n\nPour lister tous les groupes du système :\n\n```\n$ cat /etc/group\n```\n\nCréer de nouveaux groupes avec la commande groupadd :\n\n```\n# groupadd groupe\n```\n\nAjouter des utilisateurs à un groupe avec la commande gpasswd (consultez FS#58262 concernant les erreurs) :\n\n```\n# gpasswd -a user group\n```\n\nVous pouvez également ajouter un utilisateur à des groupes supplémentaires avec la commande usermod (remplacez additional_groups par une liste séparée par des virgules) :\n\n```\n# usermod -aG groupes_supplémentaires nom_d_utilisateur\n```\n\nModifier un groupe existant avec la commande groupmod, par exemple pour renommer le groupe old_group en new_group :\n\n```\n# groupmod -n new_group old_group\n```\n\nPour supprimer des groupes existants :\n\n```\n# groupdel group\n```\n\nPour supprimer les utilisateurs d'un groupe :\n\n```\n# gpasswd -d user group\n```\n\nLa commande grpck peut être utilisée pour vérifier l'intégrité des fichiers de groupe du système.\n\n"
    },
    {
      "title": "Liste des groupes",
      "level": 2,
      "content": "Cette section explique le but des groupes essentiels du paquet filesystem. Il existe de nombreux autres groupes, qui seront créés avec le GID correct lorsque le paquet correspondant sera installé. Consultez la page principale du logiciel pour plus de détails.\n\n"
    },
    {
      "title": "Groupes d'utilisateurs",
      "level": 3,
      "content": "Les utilisateurs non «root» doivent souvent être ajoutés à certains des groupes suivants pour permettre l'accès aux périphériques matériels et faciliter l'administration du système :\n\nTable content:\nGroupe | Fichiers affectés | Objectif\nadm |  | Groupe d'administration, couramment utilisé pour donner un accès en lecture aux journaux protégés. Il a un accès complet en lecture aux fichiers du journal.\nftp | /srv/ftp/ | Accès aux fichiers servis par Serveurs FTP.\ngames | /var/games | Accès à certains logiciels de jeux.\nhttp | /srv/http/ | Accès aux fichiers servis par Serveurs HTTP.\nlog |  | Accès aux fichiers journaux dans /var/log/ créés par syslog-ng.\nrfkill | /dev/rfkill}. | Droit de contrôler l'état d'alimentation des périphériques sans fil (utilisé par rfkill).\nsys |  | Droit de gérer les imprimantes dans CUPS.\nsystemd-journal | /var/log/journal/* | Peut être utilisé pour fournir un accès en lecture seule aux journaux de systemd, comme alternative à adm et wheel. [1]. Sinon, seuls les messages générés par l'utilisateur sont affichés.\nuucp | /dev/ttyS[0-9]+, /dev/tts/[0-9]+, /dev/ttyUSB[0-9]+, /dev/ttyACM[0-9]+, /dev/rfcomm[0-9]+ | RS-232 ports série et périphériques qui y sont connectés.\nwheel |  | Groupe d'administration, couramment utilisé pour donner des privilèges permettant d'effectuer des actions administratives. Il a un accès complet en lecture aux fichiers du journal et le droit d'administrer les imprimantes dans CUPS. Il peut également être utilisé pour donner accès aux utilitaires sudo et su (aucun des deux ne l'utilise par défaut).\n\n"
    },
    {
      "title": "Groupes du système",
      "level": 3,
      "content": "Les groupes suivants sont utilisés à des fins d’administration, une affectation aux utilisateurs n'est nécessaire que pour des objectifs spécifiques :\n\nTable content:\nGroupe | Fichiers affectés | Objectif\ndbus |  | utilisé en interne par dbus\nkmem | /dev/port, /dev/mem, /dev/kmem} | \nlocate | /usr/bin/locate, /var/lib/locate, /var/lib/mlocate, /var/lib/slocate | Consulter Locate.\nlp | /dev/lp[0-9]*, /dev/parport[0-9]* | Accès aux périphériques du port parallèle (imprimantes et autres).\nmail | /usr/bin/mail | \nnobody |  | Groupe non privilégié.\nproc | /proc/pid/ | Un groupe autorisé à prendre connaissance des informations sur les processus, autrement interdites par l'option de montage hidepid= du système de fichiers proc. Le groupe doit être explicitement défini avec l'option de montage gid=.\nroot | /* | Administration et contrôle complets du système (root, admin).\nsmmsp |  | Groupe sendmail.\ntty | /dev/tty, /dev/vcc, /dev/vc, /dev/ptmx | \nutmp | /run/utmp, /var/log/btmp, /var/log/wtmp | \n\n"
    },
    {
      "title": "Groupes pré-systemd",
      "level": 3,
      "content": "Avant la migration de Arch vers systemd, les utilisateurs devaient être ajoutés manuellement à ces groupes afin de pouvoir accéder aux périphériques correspondants. Cette méthode a été abandonnée en faveur de udev qui marque les périphériques avec un tag uaccess et logind assignant les permissions aux utilisateurs dynamiquement via des ACLs en fonction de la session actuellement active. Notez que la session ne doit pas être interrompue pour que cela fonctionne (consultez General troubleshooting#Session permissions pour le vérifier).\n\nIl existe quelques exceptions notables qui nécessitent l'ajout d'un utilisateur à certains de ces groupes : par exemple, si vous souhaitez autoriser les utilisateurs à accéder à l'appareil même lorsqu'ils ne sont pas connectés. Cependant, notez que l'ajout d'utilisateurs à ces groupes peut même entraîner la rupture de certaines fonctionnalités (par exemple, le groupe audio empêchera le changement rapide d'utilisateur et permettra aux applications de bloquer le mixage logiciel).\n\nTable content:\nGroupe | Fichiers affectés | Objectif\naudio | /dev/audio, /dev/snd/*, /dev/rtc0 | Accès direct au matériel de sonorisation, pour toutes les sessions. Il est toujours nécessaire pour faire fonctionner ALSA et OSS dans les sessions distantes, consultez ALSA#User privileges. Également utilisé dans JACK pour donner aux utilisateurs des droits de traitement en temps réel.\ndisk | /dev/sd[a-zA-Z]*[1-9]* | Accès aux périphériques blocs non affectés par d'autres groupes tels que optical, floppy et storage.\nfloppy | /dev/fd[0-9]* | Accès aux lecteurs de disquettes.\ninput | /dev/input/event[0-9]*, /dev/input/mouse[0-9]* | Accès aux périphériques d'entrée. Introduit dans systemd 215 [2].\nkvm | /dev/kvm | Accès aux machines virtuelles utilisant KVM.\noptical | /dev/sr[0-9], /dev/sg[0-9] | Accès aux périphériques optiques tels que les lecteurs de CD et de DVD.\nscanner | /var/lock/sane | Accès au matériel du scanner.\nstorage | /dev/st[0-9]*[lma]*, /dev/nst[0-9]*[lma]* | Utilisé pour accéder aux disques amovibles tels que les disques durs USB, les lecteurs flash/jump, les lecteurs MP3 ; permet à l'utilisateur de monter les périphériques de stockage. [3] Maintenant uniquement pour l'accès direct aux bandes si aucune règle udev personnalisée n'est impliquée. [4] [5] [6] [7] Également requis pour la manipulation de certains périphériques via udisks/udisksctl.\nvideo | /dev/fb/0, /dev/misc/agpgart | Accès aux périphériques de capture vidéo, accélération matérielle 2D/3D, framebuffer (X peut être utilisé sans appartenir à ce groupe).\n\nÉgalement requis pour la manipulation de certains périphériques via udisks/udisksctl.\n\n"
    },
    {
      "title": "Groupes non utilisés",
      "level": 3,
      "content": "Les groupes suivants ne sont actuellement utilisés à aucune fin :\n\nTable content:\nGroupe | Fichiers concernés | Objectif\nbin | aucun | Historique\ndaemon |  | \nlock |  | Utilisé pour l'accès au fichier de verrouillage. Requis par exemple par gnokiiAUR.\nmem |  | \nnetwork |  | Inutilisé par défaut. Peut être utilisé, par exemple, pour accorder l'accès à NetworkManager (consultez NetworkManager#Set up PolicyKit permissions).\npower |  | \nuuidd |  | \nusers |  | Le groupe principal des utilisateurs lorsque les groupes privés d'utilisateurs ne sont pas utilisés (généralement non recommandé), par exemple lors de la création d'utilisateurs avec USERGROUPS_ENAB no dans /etc/login.defs ou l'option -N/--no-user-group de useradd.\n\n"
    },
    {
      "title": "Autres outils liés à ces bases de données",
      "level": 2,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\ngetent(1) peut être utilisé pour lire un enregistrement particulier.\n\n```\n% getent groupe tty\n```\n\nComme indiqué dans #Base de données des utilisateurs, l'utilisation d'utilitaires spécifiques tels que passwd et chfn, est une meilleure façon de modifier les bases de données. Néanmoins, il y a des moments où les modifier directement est préférable. Pour ces cas, vipw, vigr sont fournis. Il est fortement recommandé d'utiliser ces éditeurs personnalisés plutôt qu'un éditeur de texte général, car ils verrouillent les bases de données contre les modifications simultanées. Ils permettent également d'éviter les entrées invalides et/ou les erreurs de syntaxe. Notez qu'Arch Linux préfère l'utilisation d'outils spécifiques, comme chage, pour modifier la base de données fantôme plutôt que d'utiliser vipw -s et vigr -s de util-linux. Consultez également FS#31414.\n\n"
    }
  ]
}