{
  "title": "Alias",
  "url": "https://wiki.archlinux.org/title/Alias",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- /Functions\n- /Prompt customization\n- Command-line shell\n- Environment variables\n- Fortune\n- Pkgfile\n- Readline\n\nBash (Bourne-Again SHell) is a command-line shell/programming language by the GNU Project. Its name alludes to its predecessor, the long-deprecated Bourne shell. Bash can be run on most Unix-like operating systems, including GNU/Linux.\n\nBash is the default command-line shell on Arch Linux.\n\n"
    },
    {
      "title": "Invocation",
      "level": 2,
      "content": "Bash behaviour can be altered depending on how it is invoked. Some descriptions of different modes follow.\n\nIf Bash is spawned by login in a TTY, by an SSH daemon, or similar means, it is considered a login shell. This mode can also be engaged using the -l/--login command line option.\n\nBash is considered an interactive shell when its standard input, output and error are connected to a terminal (for example, when run in a terminal emulator), and it is not started with the -c option or non-option arguments (for example, bash script). All interactive shells source /etc/bash.bashrc and ~/.bashrc, while interactive login shells also source /etc/profile and ~/.bash_profile.\n\n"
    },
    {
      "title": "Configuration files",
      "level": 3,
      "content": "Bash will attempt to execute a set of startup files depending on how it was invoked. See the Bash Startup Files section of the GNU Bash manual for a complete description.\n\nTable content:\nFile | Description | Login shells (see note) | Interactive, non-login shells\n/etc/profile | Sources application settings in /etc/profile.d/*.sh and /etc/bash.bashrc. | Yes | No\n~/.bash_profile | Per-user, after /etc/profile. If this file does not exist, ~/.bash_login and ~/.profile are checked in that order. The skeleton file /etc/skel/.bash_profile also sources ~/.bashrc. | Yes | No\n~/.bash_logout | Per-user, after exit of a login shell. | Yes | No\n/etc/bash.bash_logout | Depends on the -DSYS_BASH_LOGOUT=\"/etc/bash.bash_logout\" compilation flag. After exit of a login shell. | Yes | No\n/etc/bash.bashrc | Depends on the -DSYS_BASHRC=\"/etc/bash.bashrc\" compilation flag. Sources /usr/share/bash-completion/bash_completion. | No | Yes\n~/.bashrc | Per-user, after /etc/bash.bashrc. | No | Yes\n\nNote: **not** \n\n- Login shells can be non-interactive when called with the --login argument.\n- While interactive, non-login shells do not source ~/.bash_profile, they still inherit the environment from their parent process (which may be a login shell). See GregsWiki:ProcessManagement#On processes, environments and inheritance for details.\n\n"
    },
    {
      "title": "Shell and environment variables",
      "level": 3,
      "content": "The behavior of Bash and programs run by it can be influenced by a number of environment variables. Environment variables are used to store useful values such as command search directories, or which browser to use. When a new shell or script is launched it inherits its parent's variables, thus starting with an internal set of shell variables[1].\n\nThese shell variables in Bash can be exported in order to become environment variables:\n\n```\nVARIABLE=content\nexport VARIABLE\n```\n\nor with a shortcut\n\n```\nexport VARIABLE=content\n```\n\nEnvironment variables are conventionally placed in ~/.profile or /etc/profile so that other Bourne-compatible shells can use them.\n\nSee Environment variables for more general information.\n\n"
    },
    {
      "title": "Command line",
      "level": 2,
      "content": "Bash command line is managed by the separate library called Readline. Readline provides emacs and vi styles of shortcuts for interacting with the command line, i.e. moving back and forth on the word basis, deleting words etc. It is also Readline's responsibility to manage history of input commands. Last, but not least, it allows you to create macros.\n\n"
    },
    {
      "title": "Tab completion",
      "level": 3,
      "content": "Tab completion is the option to auto-complete typed commands by pressing Tab (enabled by default).\n\n"
    },
    {
      "title": "Single-tab",
      "level": 4,
      "content": "It may require up to three tab-presses to show all possible completions for a command. To reduce the needed number of tab-presses, see Readline#Faster completion.\n\n"
    },
    {
      "title": "Common programs and options",
      "level": 4,
      "content": "By default, Bash only tab-completes commands, filenames, and variables. The package bash-completion extends this by adding more specialized tab completions for common commands and their options, which can be enabled by sourcing /usr/share/bash-completion/bash_completion (which has been already sourced in Arch's /etc/bash.bashrc). With bash-completion, normal completions (such as ls file.* Tab Tab) will behave differently; however, they can be re-enabled with compopt -o bashdefault program (see [2] and [3] for more detail).\n\n"
    },
    {
      "title": "Customize per-command",
      "level": 4,
      "content": "By default, Bash only tab-completes file names following a command. You can change it to complete command names using complete -c:\n\n```\n~/.bashrc\n```\n\n```\ncomplete -c man which\n```\n\nor complete command names and file names with -cf:\n\n```\ncomplete -cf sudo\n```\n\nSee bash(1) ยง Programmable Completion for more completion options.\n\n"
    },
    {
      "title": "History completion",
      "level": 4,
      "content": "You can bind the up and down arrow keys to search through Bash's history (see: Readline#History and Readline Init File Syntax):\n\n```\n~/.bashrc\n```\n\n```\nbind '\"\\e[A\": history-search-backward'\nbind '\"\\e[B\": history-search-forward'\n```\n\nor to affect all readline programs:\n\n```\n~/.inputrc\n```\n\n```\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n```\n\n"
    },
    {
      "title": "History customization",
      "level": 4,
      "content": "The HISTCONTROL variable can prevent certain commands from being logged to the history.\n\nTo stop logging of consecutive identical commands:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=ignoredups\n```\n\nTo remove all but the last identical command:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=erasedups\n```\n\nTo avoid saving commands that start with a space:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=ignorespace\n```\n\nTo avoid saving consecutive identical commands, and commands that start with a space:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=ignoreboth\n```\n\nTo remove all but the last identical command, and commands that start with a space:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=\"erasedups:ignorespace\"\n```\n\nSee bash(1) ยง HISTCONTROL for details.\n\n"
    },
    {
      "title": "Disable history",
      "level": 4,
      "content": "To disable the bash history only temporarily:\n\n```\n$ set +o history\n```\n\nThe commands entered now are not logged to the $HISTFILE.\n\nFor example, now you can hash passwords with printf secret | sha256sum, or hide GPG usage like gpg -eaF secret-pubkey.asc and your secret is not written to disk.\n\nTo enable history:\n\n```\n$ set -o history\n```\n\nTo disable all bash history:\n\n```\n~/.bashrc or /etc/profile\n```\n\n```\nexport HISTSIZE=0\n```\n\n... and just to make sure, destroy your old histfile forever:\n\n```\n$ wipe -i -l2 -x4 -p4 \"$HISTFILE\"\n$ ln -sv /dev/null \"$HISTFILE\"\n```\n\n"
    },
    {
      "title": "Mimic Zsh run-help ability",
      "level": 3,
      "content": "Zsh can invoke the manual for the command preceding the cursor by pressing Alt+h. A similar behaviour is obtained in Bash using this Readline bind:\n\n```\n~/.bashrc\n```\n\n```\nrun-help() { help \"$READLINE_LINE\" 2>/dev/null || man \"$READLINE_LINE\"; }\nbind -m vi-insert -x '\"\\eh\": run-help'\nbind -m emacs -x     '\"\\eh\": run-help'\n```\n\nThis assumes are you using the (default) Emacs editing mode.\n\n"
    },
    {
      "title": "Share bash history across machines",
      "level": 3,
      "content": "atuin replaces your existing shell history with an SQLite database, and records additional context for your commands. Additionally, it provides optional and fully encrypted synchronization of your history between machines, via an Atuin server.\n\nEnable bash history timestamps (export HISTTIMEFORMAT=\"%F %T \") before syncing. Atuin works well with tools like blesh-gitAUR and cmd-wrapped to provide an enhanced terminal experience across machines.\n\n"
    },
    {
      "title": "Aliases",
      "level": 2,
      "content": "alias is a command, which enables a replacement of a word with another string. It is often used for abbreviating a system command, or for adding default arguments to a regularly used command.\n\nPersonal aliases can be stored in ~/.bashrc or any separate file sourced from ~/.bashrc. System-wide aliases (which affect all users) belong in /etc/bash.bashrc. See [4] for example aliases.\n\nFor functions, see Bash/Functions.\n\n"
    },
    {
      "title": "Prompt customization",
      "level": 3,
      "content": "See Bash/Prompt customization.\n\n"
    },
    {
      "title": "Syntax highlighting and autosuggestions",
      "level": 3,
      "content": "ble.sh (Bash Line Editor), packed as blesh-gitAUR, is a command line editor written in pure Bash, which is an alternative to GNU Readline. It has many enhanced features like syntax highlighting, autosuggestions, menu-completion, abbreviations, Vim editing mode, and hook functions. Other interesting features include status line, history share, right prompt, transient prompt, and xterm title.\n\nAfter installing it, source it in an interactive session.\n\n```\n~/.bashrc\n```\n\n```\nsource /usr/share/blesh/ble.sh\n```\n\nConfigurations are explained in depth in the ~/.blerc file and at the wiki. The stable bleshAUR package is also available.\n\n"
    },
    {
      "title": "Command not found",
      "level": 3,
      "content": "pkgfile includes a \"command not found\" hook that will automatically search the official repositories, when entering an unrecognized command.\n\nYou need to source the hook to enable it, for example:\n\n```\n~/.bashrc\n```\n\n```\nsource /usr/share/doc/pkgfile/command-not-found.bash\n```\n\nThen attempting to run an unavailable command will show the following info:\n\n```\n$ abiword\n```\n\n```\nabiword may be found in the following packages:\n  extra/abiword 3.0.1-2\t/usr/bin/abiword\n```\n\n"
    },
    {
      "title": "Disable Ctrl+z in terminal",
      "level": 3,
      "content": "You can disable the Ctrl+z feature (pauses/closes your application) by wrapping your command like this:\n\n```\n#!/bin/bash\ntrap \"\" 20\nadom\n```\n\nNow, when you accidentally press Ctrl+z in adomAUR instead of Shift+z, nothing will happen because Ctrl+z will be ignored.\n\n"
    },
    {
      "title": "Clear the screen after logging out",
      "level": 3,
      "content": "To clear the screen after logging out on a virtual terminal:\n\n```\n~/.bash_logout\n```\n\n```\nclear\nreset\n```\n\n"
    },
    {
      "title": "Auto \"cd\" when entering just a path",
      "level": 3,
      "content": "Bash can automatically prepend cd when entering just a path in the shell. For example:\n\n```\n$ /etc\n```\n\n```\nbash: /etc: Is a directory\n```\n\nBut after adding one line into .bashrc file:\n\n```\n~/.bashrc\n```\n\n```\n...\nshopt -s autocd\n...\n```\n\nYou get:\n\n```\n[user@host ~]$ /etc\ncd /etc\n[user@host etc]$\n```\n\n"
    },
    {
      "title": "Autojump",
      "level": 3,
      "content": "autojump-gitAUR is a python script which allows navigating the file system by searching for strings in a database with the user's most-visited paths.\n\nzoxide is an alternative which has additional features and performance improvements compared to the original autojump and can serve as a drop-in replacement for autojump.\n\n"
    },
    {
      "title": "Prevent overwrite of files",
      "level": 3,
      "content": "For the current session, to disallow existing regular files to be overwritten by redirection of shell output:\n\n```\n$ set -o noclobber\n```\n\nThis is identical to set -C.\n\nTo make the changes persistent for your user:\n\n```\n~/.bashrc\n```\n\n```\n...\nset -o noclobber\n```\n\nTo manually overwrite a file while noclobber is set:\n\n```\n$ echo \"output\" >| file.txt\n```\n\n"
    },
    {
      "title": "Use directory stack to navigate",
      "level": 3,
      "content": "pushd and popd can be used to push or pop directories to a stack while switching to them. This can be useful for \"replaying\" your navigation history.\n\n```\n[user@host ~] pushd /tmp/dir1\n[user@host /tmp/dir1] pushd /var/lib\n[user@host /var/lib] popd\n[user@host /tmp/dir1] popd\n[user@host ~]\n```\n\nSee bash(1) ยง DIRSTACK.\n\n"
    },
    {
      "title": "Line wrap on window resize",
      "level": 3,
      "content": "When resizing a terminal emulator, Bash may not receive the resize signal. This will cause typed text to not wrap correctly and overlap the prompt. The checkwinsize shell option checks the window size after each command and, if necessary, updates the values of LINES and COLUMNS.\n\n```\n~/.bashrc\n```\n\n```\nshopt -s checkwinsize\n```\n\n"
    },
    {
      "title": "Shell exits even if ignoreeof set",
      "level": 3,
      "content": "If you have set the ignoreeof option and you find that repeatedly hitting ctrl-d causes the shell to exit, it is because this option only allows 10 consecutive invocations of this keybinding (or 10 consecutive EOF characters, to be precise), before exiting the shell.\n\nTo allow higher values, you have to use the IGNOREEOF variable.\n\nFor example:\n\n```\nexport IGNOREEOF=100\n```\n\n"
    },
    {
      "title": "Checking errors by analyzing scripts",
      "level": 3,
      "content": "The package shellcheck analyzes bash (and other shell) scripts, prints possible errors, and suggests better coding.\n\nThere is also the web site shellcheck.net of the same purpose, based on this program.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Bash Reference Manual, or /usr/share/doc/bash/bashref.html\n- Readline Init File Syntax\n- The Bourne-Again Shell - The third chapter of The Architecture of Open Source Applications\n- PS1 generator - generate your .bashrc/PS1 bash prompt using an intuitive UI\n- Even more useful .bashrc commands\n\n"
    },
    {
      "title": "Tutorials",
      "level": 3,
      "content": "- Greg's Wiki\n- GregsWiki:BashGuide\n- GregsWiki:BashFAQ\n- Quote Tutorial\n\n"
    },
    {
      "title": "Community",
      "level": 3,
      "content": "- An active and friendly IRC channel for Bash\n\n"
    },
    {
      "title": "Examples",
      "level": 3,
      "content": "- How to change the title of an xterm\n\n"
    }
  ]
}