{
  "title": "Diretrizes de pacotes Python",
  "url": "https://wiki.archlinux.org/title/Diretrizes_de_pacotes_Python",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Fonte – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust – Shell – VCS – Web – Wine\n\nEsse documento cobre padrões e diretrizes na escrita de PKGBUILDs para softwares Python.\n\n"
    },
    {
      "title": "Nome do pacote",
      "level": 2,
      "content": "Para módulos de biblioteca do Python 3, use python-nomemódulo. Também use o prefixo se o pacote fornece um programa fortemente atrelado ao ecossistema do Python (p. ex. pip or tox). Para outros aplicativos, use apenas o nome do programa.\n\n"
    },
    {
      "title": "Arquitetura",
      "level": 2,
      "content": "Veja PKGBUILD (Português)#arch.\n\nUm pacote Python que contenha extensões C é dependente de arquitetura. Do contrário, muito provavelmente terá nenhuma dependência de arquitetura.\n\nPacotes compilados usando setuptools definem suas extensões C usando a palavra-chave ext_modules no setup.py.\n\n"
    },
    {
      "title": "Fonte",
      "level": 2,
      "content": "As URLs de download vinculadas do site do PyPI incluem um hash imprevisível que precisa ser obtido no site do PyPI sempre que um pacote precisar ser atualizado. Isso os torna inadequados para uso em um PKGBUILD. PyPI fornece um esquema estável alternativo: array PKGBUILD (Português)#source source=() deve usar os seguintes modelos de URL:\n\nNote que uma variável personalizada $_name é usada em vez de pkgname já que nomes de pacotes python são geralmente prefixados com python-. Essa variável pode ser definida genericamente da seguinte forma:\n\n```\n_name=${pkgname#python-}\n```\n\n"
    },
    {
      "title": "Métodos de instalação",
      "level": 2,
      "content": "Os pacotes Python geralmente são instalados usando um gerenciador de pacotes específico da linguagem, como o pip, o qual busca pacotes de um repositório online (geralmente PyPI, o Python Package Index) e rastreia os arquivos relevantes.\n\nNo entanto, para gerenciar pacotes Python de dentro de PKGBUILDs, é necessário \"instalar\" o pacote Python no local temporário $pkgdir/usr/lib/python<versão do Python>/site-packages/$pkgname.\n\nPara pacotes Python usando metadados padrão para especificar seu back-end de compilação em pyproject.toml, isso pode ser alcançado mais facilmente usando python-build e python-installer. Pacotes antigos podem não especificar que usam setuptools e oferecer apenas um setup.py que deve ser invocado manualmente.\n\n"
    },
    {
      "title": "Baseado em padrões (PEP 517)",
      "level": 3,
      "content": "- python-setuptools-scm and python-hatch-vcs: SETUPTOOLS_SCM_PRETEND_VERSION\n- python-pbr: PBR_VERSION\n- python-pdm-backend: PDM_BUILD_SCM_VERSION\n\nUm fluxo de trabalho baseado em padrões é simples: gere um wheel usando python-build e instale-o em $pkgdir usando python-installer:\n\n```\nmakedepends=(python-build python-installer python-wheel)\n\nbuild() {\n    cd \"$_name-$pkgver\"\n    python -m build --wheel --no-isolation\n}\n\npackage() {\n    cd \"$_name-$pkgver\"\n    python -m installer --destdir=\"$pkgdir\" dist/*.whl\n}\n```\n\nsendo:\n\n- --wheel resulta em apenas um arquivo wheel a ser construído, sem distribuição de código-fonte.\n- --no-isolation significa que o pacote é compilado usando o que está instalado em seu sistema (que inclui pacotes que você especificou em depends), por padrão a ferramenta cria um pacote isolado ambiente virtual e executa a construção lá.\n- --destdir=\"$pkgdir\" evita a tentativa de instalar diretamente no sistema hospedeiro em vez do arquivo de pacote, que resultaria em um erro de permissão\n- --compile-bytecode=... ou --no-compile-bytecode pode ser passado para installer, mas o padrão é escolhido com sensatez, então isso não deve ser necessário.\n\nNote: **apenas** \n\n"
    },
    {
      "title": "setuptools ou distutils",
      "level": 3,
      "content": "Se nenhum pyproject.toml puder ser encontrado ou não contiver uma tabela [build-system], significa que o projeto está usando o antigo formato legado, que usa um setup.py arquivo que invoca setuptools ou distutils. Observe que embora distutils esteja incluído na biblioteca padrão do Python, ter setuptools instalado significa que você usa uma versão corrigida de distutils.\n\n```\nmakedepends=('python-setuptools')  # a menos que exiga somente distutils\n\nbuild() {\n    cd \"$_name-$pkgver\"\n    python setup.py build\n}\n\npackage() {\n    cd \"$_name-$pkgver\"\n    python setup.py install --root=\"$pkgdir\" --optimize=1\n}\n```\n\nsendo:\n\n- --root=\"$pkgdir\" funciona igual ao --destdir acima\n- --optimize=1 compila arquivos de bytecode otimizados (.opt-1.pyc) para que possam ser rastreados pelo pacman em vez de serem criados no sistema host em demanda.\n- Adicionar --skip-build otimiza a tentativa desnecessária de executar novamente as etapas de construção já executadas na função build(), se for esse o caso.\n\nAlguns pacotes tentam usar setuptools e voltam para distutils se setuptools não puder ser importado. Neste caso, setuptools deve ser adicionado como makedepends, para que os metadados Python resultantes sejam melhores.\n\nSe um pacote precisar que setuptools seja compilado devido à inclusão de executáveis (o que não é suportado por distutils), mas apenas importa distutils, então a compilação gerará um aviso, e o pacote resultante estará quebrado (não conterá os executáveis):\n\n```\n/usr/lib/python3.8/distutils/dist.py:274: UserWarning: Unknown distribution option: 'entry_points'\n  warnings.warn(msg)\n```\n\nNeste caso, deve-se relatar um bug no upstream. Para contornar o problema, um recurso de ferramentas de configuração não documentado pode ser usado:\n\n```\n# fails because of distutils\npython setup.py build\n\n# works by using a setuptools shim\npython -m setuptools.launch setup.py build\n```\n\nSe um pacote usar python-setuptools-scm, o pacote provavelmente não será compilado com um erro como:\n\n```\nLookupError: setuptools-scm was unable to detect version for /build/python-jsonschema/src/jsonschema-3.2.0.\n\nMake sure you're either building from a fully intact git repository or PyPI tarballs. Most other sources (such as GitHub's tarballs, a git checkout without the .git folder) don't contain the necessary metadata and will not work.\n```\n\nPara corrigir a compilação, SETUPTOOLS_SCM_PRETEND_VERSION deve ser exportado como uma variável de ambiente com $pkgver como valor:\n\n```\nexport SETUPTOOLS_SCM_PRETEND_VERSION=$pkgver\n```\n\n"
    },
    {
      "title": "Verificação",
      "level": 2,
      "content": "A maioria dos projetos Python que fornecem testsuites (que são conjunto ou coleção de testes) usam nosetests ou pytest para executar os testes com test no nome do arquivo ou diretório contendo a testsuite. Em geral, só executar nosetests ou pytest é o suficiente para executar a testsuite.\n\n```\ncheck(){\n    cd \"$srcdir/foo-$pkgver\"\n\n    # Para nosetests\n    nosetests\n\n    # Para pytest\n    pytest\n}\n```\n\nSe houver uma extensão C compilada, os testes precisam ser executados usando um $PYTHONPATH, que reflete a versão maior e menor do Python, para localizá-la e carregá-la.\n\n```\ncheck(){\n  cd \"$pkgname-$pkgver\"\n  local python_version=$(python -c 'import sys; print(\"\".join(map(str, sys.version_info[:2])))')\n  # Para nosetests\n  PYTHONPATH=\"$PWD/build/lib.linux-$CARCH-cpython-${python_version}\" nosetests\n\n  # Para pytest\n  PYTHONPATH=\"$PWD/build/lib.linux-$CARCH-cpython-${python_version}\" pytest\n}\n```\n\nAlguns projetos fornecem pontos de entrada no setup.py para executar o teste. Isso funciona para pytest e nosetests.\n\n```\ncheck(){\n    cd \"$srcdir/foo-$pkgver\"\n\n    # para nosetests\n    python setup.py nosetests\n\n    # Para pytest - precisa de python-pytest-runner\n    python setup.py pytest\n}\n```\n\n"
    },
    {
      "title": "Descobrindo assinaturas PGP desanexadas no PyPI",
      "level": 3,
      "content": "Se existirem assinaturas PGP desanexadas para um determinado tarball sdist do Python, elas deverão ser usadas para verificar o tarball. No entanto, os arquivos de assinatura não aparecem diretamente na seção de download de arquivos de qualquer projeto em pypi.org. Para descobrir os tarballs sdist e seus possíveis arquivos de assinatura, é possível usar este serviço para obter uma visão geral por projeto: https://pypi.debian.net/\n\nPara python-requests, seria https://pypi.debian.net/requests.\n\n"
    },
    {
      "title": "Usando versão do Python",
      "level": 3,
      "content": "Às vezes, durante a preparação, compilação, teste ou instalação, é necessário consultar a versão principal e secundária do Python do sistema. Não codifique isso (por exemplo, 3.9 ou 3.10) e, em vez disso, use uma chamada ao interpretador Python para recuperar as informações e armazená-las em uma variável local:\n\n```\ncheck(){\n  local python_version=$(python -c 'import sys; print(\".\".join(map(str, sys.version_info[:2])))')\n  ...\n}\n```\n\n"
    },
    {
      "title": "Usando site-packages",
      "level": 3,
      "content": "Às vezes, durante a compilação, o teste ou a instalação, é necessário consultar o diretório site-packages do sistema. Não adicione este diretório literalmente (hardcoded) e, em vez disso, use uma chamada para o interpretador Python para recuperar o caminho e armazená-lo em uma variável local:\n\n```\ncheck(){\n  local site_packages=$(python -c \"import site; print(site.getsitepackages()[0])\")\n  ...\n}\n```\n\n"
    },
    {
      "title": "Diretório de teste em site-package",
      "level": 3,
      "content": "Certifique-se de não instalar um diretório de nome tests ao site-packages (ou seja, /usr/lib/pythonX.Y/site-packages/tests/). Projetos de pacotes Python que usam setuptools às vezes são configurados incorretamente para incluir o diretório que contém seus testes como um pacote Python de nível superior. Se você encontrar isso, você pode ajudar registrando um problema no projeto do pacote e pedindo que eles corrijam isso. Por exemplo, assim.\n\n"
    }
  ]
}