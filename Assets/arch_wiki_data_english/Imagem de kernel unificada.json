{
  "title": "Imagem de kernel unificada",
  "url": "https://wiki.archlinux.org/title/Imagem_de_kernel_unificada",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Uma imagem de kernel unificada (em inglês, unified kernel image – UKI) é um único executável que pode ser inicializado diretamente do firmware UEFI, ou automaticamente originado por gerenciador de boot com pouca ou nenhuma configuração.\n\nEmbora os próprios kernels suportados pelo Arch podem ser carregados pelo firmware UEFI, uma imagem unificada permite incorporar todos ou um subconjunto dos seguintes:\n\n- um carregador de stub UEFI como systemd-stub(7),\n- a linha de comando do kernel,\n- microcódigo,\n- uma imagem initramfs,\n- a imagem do kernel,\n- uma tela inicial.\n\nO executável resultante e, portanto, todos esses elementos podem ser facilmente assinado para uso com Secure Boot.\n\n"
    },
    {
      "title": "mkinitcpio",
      "level": 3,
      "content": "Pode-se testar o recurso executando como exemplo\n\n```\n# mkdir -p esp/EFI/Linux\n# mkinitcpio -p linux -- --uefi esp/EFI/Linux/test-systemd.efi\n```\n\nIsso produziria uma imagem do kernel para a predefinição linux.\n\n"
    },
    {
      "title": "Linha de comando do kernel",
      "level": 4,
      "content": "Primeiro, crie /etc/kernel/cmdline com seus parâmetros do kernel, tomando cuidado para remover entradas apontando para microcódigo e initramfs, por exemplo:\n\n```\n/etc/kernel/cmdline\n```\n\n```\nrw quiet bgrt_disable\n```\n\n"
    },
    {
      "title": "Arquivo .preset",
      "level": 4,
      "content": "Em seguida, modifique /etc/mkinitcpio.d/linux.preset, ou a predefinição que você está usando, como segue, com o ponto de montagem apropriado da partição de sistema EFI :\n\n- Se o seu sistema requer microcódigo, adicione ALL_microcode=(/boot/*-ucode.img),\n- Adicione um parâmetro PRESET_uki= para cada item em PRESETS=,\n- Opcionalmente, anexe um parâmetro --splash a cada linha PRESET_options= para a qual você deseja adicionar uma imagem inicial.\n\nAqui está um exemplo funcional de linux.preset para o kernel linux e a tela inicial do Arch.\n\n```\n/etc/mkinitcpio.d/linux.preset\n```\n\n```\n# mkinitcpio preset file for the 'linux' package\n\nALL_config=\"/etc/mkinitcpio.conf\"\nALL_kver=\"/boot/vmlinuz-linux\"\nALL_microcode=\"/boot/*-ucode.img\"\n\nPRESETS=('default' 'fallback')\n\ndefault_image=\"/boot/initramfs-linux.img\"\ndefault_uki=\"esp/EFI/Linux/archlinux-linux.efi\"\ndefault_options=\"--splash /usr/share/systemd/bootctl/splash-arch.bmp\"\n\nfallback_image=\"/boot/initramfs-linux-fallback.img\"\nfallback_uki=\"esp/EFI/Linux/archlinux-linux-fallback.efi\"\nfallback_options=\"-S autodetect\"\n```\n\nEste segundo exemplo cria uma imagem padrão para linux e uma imagem fallback para linux-lts:\n\n```\n/etc/mkinitcpio.d/linux.preset\n```\n\n```\nALL_config=\"/etc/mkinitcpio.conf\"\nALL_microcode=\"/boot/*-ucode.img\"\n\nPRESETS=('default' 'fallback')\n\ndefault_kver=\"/boot/vmlinuz-linux\"\ndefault_image=\"/boot/initramfs-linux.img\"\ndefault_uki=\"esp/EFI/Linux/archlinux-linux.efi\"\ndefault_options=\"--splash /usr/share/systemd/bootctl/splash-arch.bmp\"\n\nfallback_kver=\"/boot/vmlinuz-linux-lts\"\nfallback_image=\"/boot/initramfs-linux-lts-fallback.img\"\nfallback_uki=\"esp/EFI/Linux/archlinux-linux-lts-fallback.efi\"\nfallback_options=\"-S autodetect\"\n```\n\n- Se a ESP estiver montada em /boot, certifique-se de que tenha espaço suficiente, pois mkinitcpio atualmente compila tanto o initramfs-*.img quanto o *.efi executáveis, dobrando assim o espaço usado (consulte [1]).\n- Se tudo o que você quer fazer é inicializar a partir das imagens de kernel unificadas, você pode EFI system partition (Português)#Pontos de montagem comuns\n\nFinalmente, gere novamente o initramfs.\n\n"
    },
    {
      "title": "dracut",
      "level": 3,
      "content": "Veja dracut#Unified kernel image e dracut#Generate a new initramfs on kernel upgrade.\n\n"
    },
    {
      "title": "sbctl",
      "level": 3,
      "content": "Instale o pacote sbctl. Armazene a linha de comando do kernel em /etc/kernel/cmdline. Use o comando sbctl bundle com o parâmetro --save para criar um bundle e regerá-lo com um hook do pacman em momentos apropriados:\n\n```\n# sbctl bundle --save esp/archlinux.efi\n```\n\nPara criar mais binários EFI para outros kernels e imagens initramfs, repita o comando acima com os parâmetros --kernel-img e --initramfs, veja sbctl(8) § EFI BINARY COMMANDS. Os binários EFI podem ser gerados novamente a qualquer momento com sbctl generate-bundles.\n\n"
    },
    {
      "title": "Manualmente",
      "level": 3,
      "content": "Coloque a linha de comando do kernel que você deseja usar em um arquivo e crie o arquivo de pacote usando objcopy(1).\n\nPara microcódigo, primeiro concatene o arquivo de microcódigo e seu initrd, da seguinte forma:\n\n```\n$ cat esp/fabricante_cpu-ucode.img esp/initramfs-linux.img > /tmp/combined_initrd.img\n```\n\nAo construir a imagem unificada do kernel, passe /tmp/combined_initrd.img como o initrd. Este arquivo pode ser removido posteriormente.\n\n```\n$ stub_line=$(objdump -h \"/usr/lib/systemd/boot/efi/linuxx64.efi.stub\" | tail -2 | head -1)\n$ stub_size=0x$(echo \"$stub_line\" | awk '{print $3}')\n$ stub_offs=0x$(echo \"$stub_line\" | awk '{print $4}')\n$ osrel_offs=$((stub_size + stub_offs))\n$ cmdline_offs=$((osrel_offs + $(stat -c%s \"/usr/lib/os-release\")))\n$ splash_offs=$((cmdline_offs + $(stat -c%s \"/etc/kernel/cmdline\")))\n$ linux_offs=$((splash_offs + $(stat -c%s \"/usr/share/systemd/bootctl/splash-arch.bmp\")))\n$ initrd_offs=$((linux_offs + $(stat -c%s \"arquivo-vmlinuz\")))\n$ objcopy \\\n    --add-section .osrel=\"/usr/lib/os-release\" --change-section-vma .osrel=$(printf 0x%x $osrel_offs) \\\n    --add-section .cmdline=\"/etc/kernel/cmdline\" \\\n    --change-section-vma .cmdline=$(printf 0x%x $cmdline_offs) \\\n    --add-section .splash=\"/usr/share/systemd/bootctl/splash-arch.bmp\" \\\n    --change-section-vma .splash=$(printf 0x%x $splash_offs) \\\n    --add-section .linux=\"arquivo-vmlinuz\" \\\n    --change-section-vma .linux=$(printf 0x%x $linux_offs) \\\n    --add-section .initrd=\"arquivo-initrd\" \\\n    --change-section-vma .initrd=$(printf 0x%x $initrd_offs) \\\n    \"/usr/lib/systemd/boot/efi/linuxx64.efi.stub\" \"linux.efi\"\n```\n\nOs \"offsets\" são simplesmente calculados para que nenhuma seção se sobreponha, conforme recomendado em [2].\n\nDepois de criar a imagem, copie-a para a partição do sistema EFI:\n\n```\n# cp linux.efi esp/EFI/Linux/\n```\n\n"
    },
    {
      "title": "systemd-boot",
      "level": 3,
      "content": "systemd-boot pesquisa em esp/EFI/Linux/ por imagens de kernel unificadas e não há necessidade de configuração adicional. Veja sd-boot(7) § FILES\n\n"
    },
    {
      "title": "rEFInd",
      "level": 3,
      "content": "rEFInd detectará automaticamente imagens de kernel unificadas na partição do sistema EFI e será capaz de carregá-las. Eles também podem ser especificados manualmente em refind.conf, por padrão localizado em:\n\n```\n/boot/EFI/refind/refind.conf\n```\n\n```\nmenuentry Linux {\n    loader esp/EFI/Linux/archlinux-linux.efi\n}\n```\n\nSe a imagem estiver na raiz da ESP, o rEFInd requer apenas seu nome, como segue: loader archlinux-linux.efi. Lembre-se de que nenhum parâmetro do kernel de esp/EFI/refind_linux.conf será passado ao inicializar desta forma.\n\n"
    },
    {
      "title": "Diretamente do UEFI",
      "level": 3,
      "content": "efibootmgr pode ser usado para criar uma entrada de inicialização UEFI para o arquivo .efi:\n\n```\n# efibootmgr --create --disk /dev/sdX --part número_da_partição --label \"rótulo\" --loader 'EFI\\Linux\\arquivo.efi' --unicode\n```\n\nVeja efibootmgr(8) para uma explicação das opções.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- Especificação de imagem de kernel unificada (inglês)\n- mkinitcpio v31 and UEFI stubs\n\n"
    }
  ]
}