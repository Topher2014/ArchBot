{
  "title": "Fichier de substitution",
  "url": "https://wiki.archlinux.org/title/Fichier_de_substitution",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- /User (Français)\n- /Timers (Français)\n- /Journal (Français)\n- systemd FAQ\n- init\n- udev (Français)\n- Improving performance (Français)/Boot process (Français)\n- Allow users to shutdown\n\nComme indiqué sur la page web du projet :\n\nHistoriquement, ce que systemd appelle un service était nommé daemon: tout processus qui tourne en arrière-plan (c'est-à-dire sans interface graphique ni sortie sur un terminal), pour gérer une boucle d'événements ou fournir certains services. Un bon exemple est le cas d'un serveur web qui scrute les requêtes afin de délivrer les pages ou d'un serveur ssh attendant que quelqu'un s'y connecte. Les daemons ne sont pas tous des applications complètes et certains fournissent un travail invisible. Ils sont ainsi utilisés pour des tâches comme l'écriture de messages dans un fichier-journal (par ex. syslog, metalog), ou pour la synchronisation de l'horloge du système (par exemple Network Time Protocol). Voir daemon(7) pour de plus amples informations.\n\n"
    },
    {
      "title": "Utilisation basique de systemctl",
      "level": 2,
      "content": "La commande principale utilisée pour surveiller et contrôler systemd est systemctl. Certaines de ses utilisations sont l'examen de l'état du système et la gestion du système et des services. Consultez systemctl(1) pour plus de détails.\n\n- Vous pouvez utiliser toutes les commandes systemctl suivantes avec le paramètre -H user@host pour contrôler une instance de systemd sur une machine distante. Ceci utilisera SSH pour se connecter à l'instance systemd distante.\n- Les utilisateurs de Plasma peuvent installer systemd-kcmAUR[broken link: package not found] comme interface graphique pour systemctl. Après l'installation, le module sera ajouté dans System administration.\n\n"
    },
    {
      "title": "Utilisation des unités",
      "level": 3,
      "content": "Les unités comprennent généralement, mais sans s'y limiter, les services (.service), les points de montage (.mount), les périphériques (.device) et les sockets (.socket).\n\nLorsque vous utilisez systemctl, vous devez généralement spécifier le nom complet du fichier d'unité, y compris son suffixe, par exemple sshd.socket. Il existe cependant quelques formes courtes pour spécifier l'unité dans les commandes systemctl suivantes :\n\n- Si vous ne spécifiez pas le suffixe, systemctl supposera .service. Par exemple, netctl et netctl.service sont équivalents.\n- Les points de montage seront automatiquement traduits dans l'unité .mount appropriée. Par exemple, spécifier /home est équivalent à home.mount.\n- De la même manière que pour les points de montage, les périphériques sont automatiquement traduits dans l'unité .device appropriée, donc spécifier /dev/sda2 est équivalent à dev-sda2.device.\n\nConsultez systemd.unit(5) pour plus de détails.\n\nLes commandes du tableau ci-dessous opèrent sur des unités système puisque --system est le défaut implicite de systemctl. Pour opérer sur les unités utilisateur (pour l'utilisateur appelant), utilisez systemctl --user sans les privilèges «root». Consultez également systemd (Français)/User (Français) pour activer/désactiver les unités utilisateur pour tous les utilisateurs.\n\n- La plupart des commandes fonctionnent également si plusieurs unités sont spécifiées, consultez systemctl(1) pour plus d'informations.\n- Le paramètre --now peut être utilisé conjointement avec enable, disable et mask pour respectivement démarrer, arrêter ou masquer l'unité immédiatement plutôt qu'après le redémarrage.\n- Un paquet peut proposer des unités pour différents usages. Si vous venez d'installer un paquet, pacman -Qql paquet | grep -Fe .service -e .socket peut être utilisé pour les vérifier et les trouver.\n\nTable content:\nAction | Commande | Note\nAnalyser l'état du système\nMontrer l'état du système | systemctl status | \nLister les units en cours d'exécution | systemctl ousystemctl list-units | \nLister les units en échec | systemctl --failed | \nLister les fichiers d'units installés1 | systemctl list-unit-files | \nAfficher l'état du processus pour un PID | systemctl status pid | cgroup slice, mémoire et parent\nVérifier l'état de l'unité\nAfficher une page de manuel associée à une unité | systemctl help unit | tel que pris en charge par l'unité\nÉtat d'une unité | systemctl status unit | y compris si elle est en cours d'exécution ou non\nVérifier si une unité est activée | systemctl is-enabled unit | \nDémarrer, redémarrer, recharger d'une unité\nDémarrer une unité immédiatement | systemctl start unit en root | \nArrêter une unité immédiatement | systemctl stop unit en root | \nRedémarrer une unité | systemctl restart unit en root | \nRecharger une unité et sa configuration | systemctl reload unit en root | \nRecharger la configuration du gestionnaire systemd2 | systemctl daemon-reload en root | rechercher les unités nouvelles ou modifiées\nActiver une unité\nActiver une unité pour s'exécuter automatiquement au démarrage | systemctl enable unit en root | \nActiver une unité pour s'exécuter automatiquement au démarrage et la Démarrer immédiatement | systemctl enable --now unit en root | \nDésactiver une unité pour ne plus s'exécuter automatiquement au démarrage | systemctl disable unit en root | \nRéactiver une unité3 | systemctl reenable unit en root | c'est-à-dire désactiver et réactiver\nMasquer une unité\nMasquer une unité pour rendre impossible son exécution4 | systemctl mask unit en root | \nDémasquer une unité | systemctl unmask unit en root | \n\n1. Consultez systemd.unit(5) § UNIT FILE LOAD PATH pour connaître les répertoires où se trouvent les fichiers d'unités disponibles.\n1. Ceci ne demande pas aux unités modifiées de recharger leurs propres configurations (consultez l'action Recharger).\n1. Par exemple, si sa section [Install] a été modifiée depuis sa dernière activation.\n1. À la fois manuellement et en tant que dépendance, ce qui rend le masquage dangereux. Vérifiez si des unités masquées existent avec : $ systemctl list-unit-files --state=masked\n\n```\n$ systemctl list-unit-files --state=masked\n```\n\n"
    },
    {
      "title": "Gestion de l'énergie",
      "level": 3,
      "content": "Polkit est nécessaire pour la gestion de l'alimentation en tant qu'utilisateur non privilégié. Si vous êtes dans une session locale d'utilisateur systemd-logind et qu'aucune autre session n'est active, les commandes suivantes fonctionneront sans les privilèges de root. Dans le cas contraire (par exemple, parce qu'un autre utilisateur est connecté à un tty), systemd vous demandera automatiquement le mot de passe root.\n\nTable content:\nAction | Commande\nArrêter et redémarrer le système | systemctl reboot\nArrêter et mettre le système hors tension | systemctl poweroff\nSuspendre le système | systemctl suspend\nMettre le système en hibernation (écrire la RAM sur le disque) | systemctl hibernate\nMettre le système en état de sommeil hybride (également appelé suspendre à la fois, il sauvegarde la RAM sur le disque et suspend ensuite)) | systemctl hybrid-sleep\nSuspendre d'abord le système, puis le réveiller après une durée configurée afin de le mettre en hibernation. | systemctl suspend-then-hibernate\nEffectuer un redémarrage de l'espace utilisateur uniquement avec un #Soft reboot. | systemctl soft-reboot\n\n"
    },
    {
      "title": "Soft reboot",
      "level": 4,
      "content": "Le soft reboot, ou redémarrage à chaud, est un type particulier d'opération de redémarrage de l'espace utilisateur qui n'implique pas le noyau. Il est implémenté par systemd-soft-reboot.service(8) et peut être invoqué par systemctl soft-reboot. Comme avec kexec, il saute la réinitialisation du firmware, mais en plus le système ne passe pas par l'initialisation du noyau et initramfs, et les périphériques dm-crypt déverrouillés restent connectés.\n\nLorsque /run/nextroot/ contient une structure de système de fichiers racine valide (par exemple, le montage racine d'une autre distribution ou d'un autre snapshot), le soft-reboot fait basculer la racine du système dans cette structure, ce qui permet de passer à une autre installation sans perdre les états gérés par le noyau, par exemple le réseau (en).\n\n"
    },
    {
      "title": "Écrire des unités",
      "level": 2,
      "content": "La syntaxe des fichiers «unités» de systemd (systemd.unit(5)) s'inspire des spécifications des fichiers .desktop XDG, qui sont à leur tour inspirés de fichiers .ini de Microsoft Windows. Les fichiers «unités» sont chargés à partir de plusieurs emplacements (pour consulter la liste complète, exécutez systemctl show --property=UnitPath), mais les principaux sont (classés de la plus basse à la plus haute priorité) :\n\n- /usr/lib/systemd/system/ : unités fournies par les paquets installés\n- /etc/systemd/system/ : unités installées par l'administrateur système\n\n- Les chemins de chargement sont complètement différents lorsque vous exécutez systemd en mode utilisateur.\n- Les noms des unités systemd ne peuvent contenir que des caractères alphanumériques ASCII, des traits de soulignement et des points. Tous les autres caractères doivent être remplacés par des échappements de type C \"\\x2d\", ou utiliser leur sémantique prédéfinie ('@', '-'). Consultez systemd.unit(5) et systemd-escape(1) pour plus d'informations.\n\nConsultez les unités installées par vos paquets pour des exemples, ainsi que systemd.service(5) § EXAMPLES.\n\n"
    },
    {
      "title": "Gérer les dépendances",
      "level": 3,
      "content": "Avec systemd, les dépendances peuvent être résolues en concevant correctement les fichiers d'unité. Le cas le plus typique est que l'unité A nécessite que l'unité B fonctionne avant que A ne soit lancée. Dans ce cas, ajoutez Requires=B et After=B à la section [Unit] de A. Si la dépendance est facultative, ajoutez Wants=B et After=B à la place. Notez que Wants= et Requires= n'impliquent pas After=, ce qui signifie que si After= n'est pas spécifié, les deux unités seront démarrées en parallèle.\n\nLes dépendances sont généralement placées sur les services et non sur les #Cibles. Par exemple, network.target est tirée par le service qui configure vos interfaces réseau, donc commander votre unité personnalisée après lui est suffisant puisque network.target est démarrée de toute façon.\n\n"
    },
    {
      "title": "Types de service",
      "level": 3,
      "content": "Il existe plusieurs types de démarrage différents à considérer lors de l'écriture d'un fichier de service personnalisé. Ceci est défini avec le paramètre Type= dans la section [Service] :\n\n- Type=simple (par défaut) : systemd considère que le service doit être démarré immédiatement. Le processus ne doit pas forker. N'utilisez pas ce type si d'autres services doivent être commandés sur ce service, à moins qu'il ne soit activé par socket.\n- Type=forking : systemd considère que le service est démarré une fois que le processus a forké et que le parent est sorti. Pour les daemons classiques, utilisez ce type sauf si vous savez que ce n'est pas nécessaire. Vous devez également spécifier PIDFile= pour que systemd puisse garder la trace du processus principal.\n- Type=oneshot : cette option est utile pour les scripts qui effectuent une seule tâche puis se terminent. Vous pouvez également définir RemainAfterExit=yes pour que systemd considère toujours le service comme actif après la sortie du processus.\n- Type=notify : identique à Type=simple, mais avec la stipulation que le daemon enverra un signal à systemd quand il sera prêt. L'implémentation de référence pour cette notification est fournie par libsystemd-daemon.so.\n- Type=dbus : le service est considéré comme prêt lorsque le BusName spécifié apparaît sur le bus système de DBus.\n- Type=idle : systemd retardera l'exécution du binaire du service jusqu'à ce que tous les travaux soient distribués. A part cela, le comportement est très similaire à Type=simple.\n\nConsultez la page de manuel systemd.service(5) § OPTIONS pour une explication plus détaillée des valeurs Type\n\n"
    },
    {
      "title": "Modifier les unités fournies",
      "level": 3,
      "content": "Pour éviter les conflits avec pacman, les fichiers d'unités fournis par les paquets ne doivent pas être modifiés directement. Il existe deux façons sûres de modifier une unité sans toucher au fichier d'origine : créer un nouveau fichier d'unité qui remplace l'unité d'origine ou créer des #Fichiers de substitution qui sont appliqués par-dessus l'unité d'origine. Pour les deux méthodes, vous devez recharger l'unité après coup pour appliquer vos modifications. Vous pouvez le faire en éditant l'unité avec systemctl edit. (qui recharge l'unité automatiquement) ou en rechargeant toutes les unités avec :\n\n```\n# systemctl daemon-reload\n```\n\n- Vous pouvez utiliser systemd-delta pour consulter les fichiers de l'unité qui ont été remplacés ou étendus et ce qui a été modifié exactement.\n- Utilisez systemctl cat unit pour voir le contenu d'un fichier unité et tous les snippets drop-in associés.\n\n"
    },
    {
      "title": "Remplacer des fichiers d'unités",
      "level": 4,
      "content": "Pour remplacer le fichier d'unité /usr/lib/systemd/system/unit, créez le fichier /etc/systemd/system/unit et réactivez l'unité pour mettre à jour les liens symboliques.\n\nAlternativement, exécutez :\n\n```\n# systemctl edit --full unit\n```\n\nCeci ouvre /etc/systemd/system/unit dans votre éditeur (en copiant la version installée si elle n'existe pas encore) et la recharge automatiquement lorsque vous terminez l'édition.\n\n"
    },
    {
      "title": "Fichiers de substitution",
      "level": 4,
      "content": "Pour créer des fichiers de substitution («drop-in files») pour le fichier d'unités /usr/lib/systemd/system/unit, créez le répertoire /etc/systemd/system/unit'.d/ et placez-y des fichiers .conf pour substituer ou ajouter de nouvelles options. systemd analysera et appliquera ces fichiers par dessus l'unité originale.\n\nLa manière la plus simple de faire est de lancer :\n\n```\n# systemctl edit unit --drop-in=drop_in_name\n```\n\nCela ouvre le fichier /etc/systemd/system/unit.d/drop_in_name.conf dans votre éditeur de texte (en le créant si nécessaire) et recharge automatiquement l'unité lorsque vous avez terminé l'édition. En omettant l'option --drop-in=, systemd utilisera le nom de fichier par défaut override.conf .\n\n- La clé doit toujours être placée dans la section appropriée du fichier de remplacement.\n- Toutes les clés ne peuvent pas être remplacées par des fichiers drop-in. Par exemple, pour modifier Conflicts= un fichier de remplacement est nécessaire.\n\n"
    },
    {
      "title": "Retour à la version d'origine",
      "level": 4,
      "content": "Pour rétablir les modifications apportées à une unité à l'aide de systemctl edit, faites :\n\n```\n# systemctl revert unit (unité)\n```\n\n"
    },
    {
      "title": "Exemples",
      "level": 4,
      "content": "Par exemple, si vous souhaitez simplement ajouter une dépendance supplémentaire à une unité, vous pouvez créer le fichier suivant :\n\n```\n/etc/systemd/system/unit.d/customdependency.conf\n```\n\n```\n[Unit]\nRequires=new dependency (nouvelle dépendance)\nAfter=new dependency (après la nouvelle dépendance)\n```\n\nAutre exemple, afin de remplacer la directive ExecStart, créez le fichier suivant :\n\n```\n/etc/systemd/system/unit.d/customexec.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart= nouvelle commande.\n```\n\nNotez comment ExecStart doit être effacé avant d'être réassigné [1]. Il en va de même pour tous les éléments qui peuvent être spécifiés plusieurs fois, par exemple OnCalendar pour les minuteries.\n\nEncore un exemple pour redémarrer automatiquement un service :\n\n```\n/etc/systemd/system/unit.d/restart.conf\n```\n\n```\n[Service]\nRestart=toujours\nRestartSec=30\n```\n\n"
    },
    {
      "title": "Cibles",
      "level": 2,
      "content": "systemd utilise des cibles pour regrouper des unités via des dépendances et comme points de synchronisation standardisés. Elles ont un but similaire à celui de runlevels mais agissent un peu différemment. Chaque cible est nommée au lieu d'être numérotée et est destinée à servir un objectif spécifique avec la possibilité d'en avoir plusieurs actives en même temps. Certaines cibles sont implémentées en héritant de tous les services d'une autre cible et en lui ajoutant des services supplémentaires. Il existe des cibles systemd qui imitent les niveaux d'exécution courants de SystemVinit, vous pouvez donc toujours changer de cible en utilisant la commande familière telinit RUNLEVEL.\n\n"
    },
    {
      "title": "Obtenir les cibles actuelles",
      "level": 3,
      "content": "La commande suivante doit être utilisée sous systemd au lieu d'exécuter runlevel :\n\n```\n$ systemctl list-units --type=target\n```\n\n"
    },
    {
      "title": "Créer une cible personnalisée",
      "level": 3,
      "content": "Les runlevels qui avaient une signification définie sous sysvinit (c'est-à-dire 0, 1, 3, 5 et 6) ont une correspondance 1:1 avec une cible spécifique de systemd. Malheureusement, il n'y a pas de bon moyen de faire la même chose pour les niveaux d'exécution définis par l'utilisateur comme 2 et 4. Si vous les utilisez, il est suggéré de créer une nouvelle cible systemd nommée /etc/systemd/system/votre cible qui prend l'un des niveaux d'exécution existants comme base (vous pouvez regarder /usr/lib/systemd/system/graphical. target comme exemple), crée un répertoire /etc/systemd/system/votre cible.wants, puis établit un lien symbolique avec les services supplémentaires de /usr/lib/systemd/system/ que vous souhaitez activer.\n\n"
    },
    {
      "title": "Correspondance entre les niveaux d'exécution de SysV et les cibles systemd",
      "level": 3,
      "content": "Table content:\nNiveau d'exécution SysV ! ! cible systemd ! ! Notes\n0 | runlevel0.target, poweroff.target | Arrêter le système.\n1, s, single | runlevel1.target, rescue.target | Mode utilisateur unique.\n2, 4 | runlevel2.target, runlevel4.target, multi-user.target | Niveaux d'exécution définis par l'utilisateur/par site. Par défaut, identique à 3.\n3 | runlevel3.target, multi-user.target | Multi-utilisateur, non-graphique. Les utilisateurs peuvent généralement se connecter via plusieurs consoles ou via le réseau.\n5 | runlevel5.target, graphical.target | Multi-utilisateur, graphique. Offre généralement tous les services du runlevel 3 plus une connexion graphique.\n6 | runlevel6.target, reboot.target | Redémarrage.\nemergency | emergency.target | Shell d'urgence\n\n"
    },
    {
      "title": "Changer la cible actuelle",
      "level": 3,
      "content": "Dans systemd, les cibles sont exposées via les target units. Vous pouvez les changer comme suit :\n\n```\n# systemctl isolate graphical.target\n```\n\nCela ne changera que la cible actuelle, et n'aura aucun effet sur le prochain démarrage. Ceci est équivalent à des commandes telles que telinit 3 ou telinit 5 dans Sysvinit.\n\n"
    },
    {
      "title": "Changer la cible par défaut pour le démarrage",
      "level": 3,
      "content": "La cible standard est default.target, qui est un lien symbolique vers graphical.target. Cela correspond à peu près à l'ancien niveau d'exécution 5.\n\nPour vérifier la cible actuelle avec systemctl :\n\n```\n$ systemctl get-default\n```\n\nPour changer la cible par défaut sur laquelle démarrer, modifiez le lien symbolique default.target. Avec systemctl :\n\n```\n# systemctl set-default multi-user.target\n```\n\n```\nSuppression de /etc/systemd/system/default.target.\nCréé un lien symbolique /etc/systemd/system/default.target -> /usr/lib/systemd/system/multi-user.target.\n```\n\nVous pouvez également ajouter l'un des paramètres du noyau suivants à votre chargeur d'amorçage :\n\n- systemd.unit=multi-user.target (ce qui correspond à peu près à l'ancien niveau d'exécution 3),\n- systemd.unit=rescue.target (qui correspond en gros à l'ancien niveau d'exécution 3) (ce qui correspond à peu près à l'ancien niveau d'exécution 1).\n\n"
    },
    {
      "title": "Ordre des cibles par défaut",
      "level": 3,
      "content": "systemd choisit la default.target selon l'ordre suivant :\n\n1. Paramètre du noyau indiqué ci-dessus\n1. Symlink de /etc/systemd/system/default.target\n1. Lien symbolique de /usr/lib/systemd/system/default.target\n\n"
    },
    {
      "title": "Composants de systemd",
      "level": 2,
      "content": "Quelques composants (non exhaustifs) de systemd sont :\n\n- kernel-install — a script used to automatically move kernels and their respective initramfs images to the boot partition;\n- systemd-boot - simple gestionnaire d'amorçage UEFI ;\n- systemd-creds — to securely store and retrieve credentials used by systemd units;\n- systemd-cryptenroll — Enroll PKCS#11, FIDO2, TPM2 token/devices to LUKS2 encrypted volumes;\n- systemd-firstboot - initialisation des paramètres de base du système avant le premier démarrage ;\n- systemd-homed - comptes utilisateurs humains portables ;\n- systemd-logind(8) - gestion de session ;\n- systemd-networkd - gestion de la configuration réseau ;\n- systemd-nspawn - conteneurs léger ;\n- systemd-resolved (Français) - résolution de nom de domaine ;\n- systemd-sysusers(8) - crée les utilisateurs et les groupes du système et ajoute les utilisateurs aux groupes à l'installation du paquet ou au démarrage ;\n- systemd-timesyncd - synchronisation du temps système à travers le réseau ;\n- systemd/Journal - journalisation du système ;\n- systemd/Timers - minuteries monotones ou en temps réel pour contrôler les fichiers .service ou les événements, alternative raisonnable à Cron.\n- systemd-stub(7) - Un «stub» de démarrage UEFI utilisé pour créer des images de noyau unifiées.\n\n"
    },
    {
      "title": "systemd.mount - montage",
      "level": 3,
      "content": "systemd est chargé de monter les partitions et les systèmes de fichiers spécifiés dans /etc/fstab. Le systemd-fstab-generator(8) traduit toutes les entrées de /etc/fstab en unités systemd ; ceci est effectué au démarrage et chaque fois que la configuration du gestionnaire de système est rechargée.\n\nsystemd étend les capacités habituelles de fstab et offre des options de montage supplémentaires. Celles-ci affectent les dépendances de l'unité de montage. Elles peuvent, par exemple, garantir qu'un montage ne sera effectué qu'une fois que le réseau sera en place ou qu'une autre partition sera montée. La liste complète des options de montage spécifiques à systemd, généralement préfixées par x-systemd., est détaillée dans systemd.mount(5) § FSTAB.\n\nUn exemple de ces options de montage est le montage automatique, qui signifie monter seulement lorsque la ressource est requise plutôt qu'automatiquement au démarrage. Ceci est fourni dans Fstab (Français)#Montage automatique avec systemd.\n\n"
    },
    {
      "title": "Montage automatique d'une partition GPT",
      "level": 4,
      "content": "Sur les systèmes amorcés par UEFI, si des conditions spécifiques sont réunies, systemd-gpt-auto-generator(8) montera automatiquement les partitions GPT conformément à la Specification de Partitions Découvrables et elles peuvent donc être omises de fstab.\n\nLes conditions préalables sont :\n\n- Le chargeur d'amorçage doit définir la variable EFI LoaderDevicePartUUID, afin que la partition système EFI utilisée puisse être identifiée. Ceci est pris en charge par systemd-boot, systemd-stub(7) et rEFInd (non activé par défaut). Cela peut être vérifié en exécutant bootctl et en vérifiant l'état de Boot loader sets ESP information.\n- La partition racine doit se trouver sur le même disque physique que la partition système EFI utilisée. Les autres partitions qui seront montées automatiquement doivent se trouver sur le même disque physique que la partition racine. Cela signifie essentiellement que toutes les partitions montées automatiquement doivent partager le même disque physique avec l'ESP.\n- Le point de montage /efi doit être créé manuellement (si besoin), sinon systemd-gpt-auto-generator utilisera /boot.\n\nPour que le montage automatique de /var fonctionne, le PARTUUID doit correspondre au hachage SHA256 HMAC de l'UUID du type de partition (4d21b016-b534-45c2-a9fb-5c16e091fd2d) avec l'ID de la machine comme clé. Le PARTUUID requis peut être obtenu en utilisant :\n\n```\n$ systemd-id128 -u --app-specific=4d21b016-b534-45c2-a9fb-5c16e091fd2d machine-id\n```\n\n"
    },
    {
      "title": "systemd-sysvcompat",
      "level": 3,
      "content": "Le rôle principal de systemd-sysvcompat (requis par base) est de fournir le traditionnel binaire linux init. Pour les systèmes contrôlés par systemd, init est juste un lien symbolique vers son exécutable systemd.\n\nEn outre, il fournit quatre raccourcis pratiques auxquels les utilisateurs de SysVinit peuvent être habitués. Ces raccourcis sont halt(8), poweroff(8), reboot(8) et shutdown(8). Chacune de ces quatre commandes est un lien symbolique vers systemctl, et est régie par le comportement de systemd. Par conséquent, la discussion à #Gestion de l'énergie s'applique.\n\nLes systèmes basés sur systemd peuvent abandonner ces méthodes de compatibilité System V en ajoutant init= aux paramètre de démarrage (consultez, par exemple, /bin/init est dans systemd-sysvcompat ?) et les arguments de la commande systemctl native de systemd.\n\n"
    },
    {
      "title": "systemd-tmpfiles - fichiers temporaires",
      "level": 3,
      "content": "systemd-tmpfiles crée, supprime et nettoie les fichiers et répertoires volatiles et temporaires. Il lit les fichiers de configuration dans /etc/tmpfiles.d/ et /usr/lib/tmpfiles.d/ pour découvrir les actions à effectuer. Les fichiers de configuration du premier répertoire sont prioritaires sur ceux du second.\n\nLes fichiers de configuration sont généralement fournis avec les fichiers de service, et ils sont nommés dans le style de /usr/lib/tmpfiles.d/'program.conf. Par exemple, le daemon Samba s'attend à ce que le répertoire /run/samba existe et ait les bonnes permissions. Par conséquent, le paquet samba est livré avec cette configuration :\n\n```\n/usr/lib/tmpfiles.d/samba.conf\n```\n\n```\nD /run/samba 0755 root root\n```\n\nLes fichiers de configuration peuvent également être utilisés pour écrire des valeurs dans certains fichiers au démarrage. Par exemple, si vous avez utilisé /etc/rc.local pour désactiver le réveil à partir de périphériques USB avec echo USBE > /proc/acpi/wakeup, vous pouvez utiliser le fichier tmp suivant à la place :\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Chemin               Mode UID  GID  Age Argument\nw    /proc/acpi/wakeup     -    -    -    -   USBE\n```\n\nIl est possible d'écrire plusieurs lignes dans le même fichier, soit avec \\n en argument, soit en utilisant le type w+ sur plusieurs lignes (y compris la première) pour l'appending :\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Chemin               Mode UID  GID  Age Argument\nw+   /proc/acpi/wakeup     -    -    -    -   USBE\nw+   /proc/acpi/wakeup     -    -    -    -   LID0\n```\n\nConsultez les pages de manuel systemd-tmpfiles(8) et tmpfiles.d(5) pour plus de détails.\n\n"
    },
    {
      "title": "Trucs et astuces",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n"
    },
    {
      "title": "Outils de configuration de l'interface graphique",
      "level": 3,
      "content": "- systemadm — Explorateur graphique pour les unités de systemd. Il peut afficher la liste des unités, éventuellement filtrée par type.\n\n- SystemdGenie — Utilitaire de gestion de systemd basé sur les technologies KDE.\n\n"
    },
    {
      "title": "Exécution des services après le démarrage du réseau",
      "level": 3,
      "content": "Pour retarder un service jusqu'à ce que le réseau soit en place, incluez les dépendances suivantes dans le fichier .service :\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target\n...\n```\n\nLe service d'attente réseau de l'application particulière qui gère le réseau doit également être activé pour que network-online.target reflète correctement l'état du réseau.\n\n- Si vous utilisez NetworkManager, NetworkManager-wait-online.service est activé en même temps que NetworkManager.service. Vérifiez si c'est le cas avec systemctl is-enabled NetworkManager-wait-online.service S'il n'est pas activé, alors réactivez NetworkManager.service.\n- Dans le cas de netctl, activez netctl-wait-online.service.(Sauf si vous utilisez netctl-auto; voir FS#75836).\n- Si vous utilisez systemd-networkd, systemd-networkd-wait-online.service est activé en même temps que systemd-networkd.service. Vérifiez si c'est le cas avec systemctl is-enabled systemd-networkd-wait-online.service. S'il n'est pas activé, alors réactivez systemd-networkd.service.\n\nPour des explications plus détaillées, voir la discussion dans Network configuration synchronization points.\n\nSi un service doit effectuer des requêtes DNS, il doit en outre être ordonnancé après nss-lookup.target :\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target nss-lookup.target\n...\n```\n\nConsultez systemd.special(7) § Special Passive System Units.\n\nPour que nss-lookup.target ait un quelconque effet, il faut un service qui l'attire via Wants=nss-lookup.target et qui se place avant lui avec Before=nss-lookup.target. Cette opération est généralement effectuée par des résolveurs DNSs locaux.\n\nVérifiez quel service actif, s'il y en a un, tire dans nss-lookup.target avec :\n\n```\n$ systemctl list-dependencies --reverse nss-lookup.target\n```\n\n"
    },
    {
      "title": "Activer les unités installées par défaut",
      "level": 3,
      "content": "Arch Linux est livré avec /usr/lib/systemd/system-preset/99-default.preset contenant disable *. Ceci amène systemctl preset à désactiver toutes les unités par défaut, de sorte que lorsqu'un nouveau paquet est installé, l'utilisateur doit activer manuellement l'unité.\n\nSi ce comportement n'est pas souhaité, créez simplement un lien symbolique de /etc/systemd/system-preset/99-default.preset vers /dev/null afin de remplacer le fichier de configuration. Ainsi, systemctl preset activera toutes les unités installées, quel que soit le type d'unité, à moins que cela ne soit spécifié dans un autre fichier dans l'un des répertoires de configuration de systemctl preset. Les unités utilisateur ne sont pas affectées. Consultez systemd.preset(5) pour plus d'informations.\n\n"
    },
    {
      "title": "Mise en sandbox (bac à sable) des environnements d'application",
      "level": 3,
      "content": "Un fichier d'unité peut être créé comme un bac à sable pour isoler les applications et leurs processus dans un environnement virtuel durci. systemd utilise namespaces, une liste de capacités autorisées/refusées, et les groupes de contrôle pour conteneuriser les processus à travers une configuration étendue de l'environnement d'exécution-systemd.exec(5).\n\nL'amélioration d'un fichier d'unité systemd existant avec le sandboxing des applications nécessite généralement des essais et des erreurs accompagnés d'une utilisation généreuse de strace, stderr et journalctl(1). Vous pouvez d'abord rechercher dans la documentation en amont des tests déjà effectués sur lesquels baser vos essais. Pour obtenir un point de départ pour les options de durcissement possibles, exécutez\n\n```\n$ systemd-analyze security unit (unité)\n```\n\nQuelques exemples de la façon dont le sandboxing avec systemd peut être déployé :\n\n- CapabilityBoundingSet définit une liste de capabilities(7) qui sont autorisées ou refusées pour une unité. Consultez systemd.exec(5) § CAPABILITIES. La capacité CAP_SYS_ADM, par exemple, qui devrait être l'un des objectifs d'un bac à sable sécurisé : CapabilityBoundingSet=~ CAP_SYS_ADM.\n\n- La capacité CAP_SYS_ADM, par exemple, qui devrait être l'un des objectifs d'un bac à sable sécurisé : CapabilityBoundingSet=~ CAP_SYS_ADM.\n\n"
    },
    {
      "title": "Notification de l'échec d'un service",
      "level": 3,
      "content": "Note: **This article or section is a candidate for merging with systemd/Timers#MAILTO.** This article or section is a candidate for merging with systemd/Timers#MAILTO.\n\nThis article or section is a candidate for merging with systemd/Timers#MAILTO.\n\nAfin de notifier les échecs de service, une directive OnFailure= doit être ajoutée au fichier de service correspondant, par exemple en utilisant un #Fichiers de substitution. L'ajout de cette directive à chaque unité de service peut être réalisé à l'aide d'un fichier de configuration drop-in de haut niveau. Pour plus de détails sur les fichiers de dépôt de haut niveau, consultez systemd.unit(5).\n\nCréez un fichier de dépôt de premier niveau pour les services :\n\n```\n/etc/systemd/system/service.d/toplevel-override.conf\n```\n\n```\n[Unit]\nOnFailure=failure-notification@%n\n```\n\nCeci ajoute OnFailure=failure-notification@%n à chaque fichier de service. Si une unité_service échoue, failure-notification@une_unité_service sera lancée pour gérer la livraison de la notification (ou toute autre tâche pour laquelle elle est configurée).\n\nCréez l'unité de modèle failure-notification@ :\n\n```\n/etc/systemd/system/failure-notification@.service\n```\n\n```\n[Unit]\nDescription=Send a notification about a failed systemd unit\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=/path/to/failure-notification.sh %i\n```\n\nVous pouvez créer le script failure-notification.sh et définir ce qu'il faut faire ou comment notifier (mail, gotify, xmpp, etc.). Le %i sera le nom de l'unité de service défaillante et sera passé comme argument au script.\n\nAfin d'éviter la récurrence du démarrage des instances de failure-notification@.service en cas d'échec du démarrage, créez un fichier de configuration de dépôt vide portant le même nom que le dépôt de niveau supérieur (le fichier de configuration de dépôt de niveau service vide est prioritaire sur le dépôt de niveau supérieur et remplace ce dernier) :\n\n```\n# mkdir -p /etc/systemd/system/failure-notification@.service.d\n# touch /etc/systemd/system/failure-notification@.service.d/toplevel-override.conf\n```\n\n"
    },
    {
      "title": "Désactiver automatiquement un disque dur externe à la mise hors tension",
      "level": 3,
      "content": "Note: **This article or section is a candidate for merging with Udisks#Troubleshooting.** This article or section is a candidate for merging with Udisks#Troubleshooting.\n\nThis article or section is a candidate for merging with Udisks#Troubleshooting.\n\nSi un disque dur externe n'est pas correctement mis hors tension lors de l'arrêt du système, il peut être souhaitable de résoudre le problème. La manière la plus pratique de le faire est d'utiliser udisks\n\nActiver udisks2.service.\n\nUn service permettant de lancer notre script pourrait ressembler à ceci :\n\n```\n/etc/systemd/system/handle_external_hdds.service\n```\n\n```\n[Unit]\nRequires=udisks2.service\nRequires=graphical.target\nAfter=graphical.target\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStop=/usr/local/bin/handle_external_hdds.sh\n\n[Installation]\nWantedBy=graphical.target\n```\n\nActiver handle_external_hdds.service\n\nFaites un daemon-reload systemd pour appliquer le nouveau paramètre.\n\nRedémarrez graphical.target pour vérifier si cela fonctionne.\n\nUn exemple de script pour gérer un nombre arbitraire de partitions sur un seul disque ressemble à ceci :\n\n```\n/usr/local/bin/handle_external_hdds.sh\n```\n\n```\n#!/bin/bash -u\n\ndeclare -a uuids=(uuid_list)\n\n# Ne procéder que si le lecteur est présent.\n\nif [[ ! -L \"/dev/disk/by-uuid/${uuids[0]}\" ]]; then\n  exit 0\nfi\nfor uuid in \"${uuids[@]}\"; do\n  if findmnt \"/dev/disk/by-uuid/$uuid\"; then\n    umount \"/dev/disk/by-uuid/$uuid\"\n  fi\ndone\n\n# udisksctl éteint le lecteur approprié même si sa partition est alimentée\n\nudisksctl power-off -b \"/dev/disk/by-uuid/${uuids[0]}\"\n```\n\nuuid_list est une liste d'UUIDs délimités par des espaces correspondant aux partitions du périphérique à vérifier, par exemple \"uuid_1\" \"uuid_2\".\n\n"
    },
    {
      "title": "Recherche des services ayant échoué",
      "level": 3,
      "content": "Pour trouver les services systemd qui n'ont pas réussi à démarrer :\n\n```\n$ systemctl --state=failed\n```\n\nPour savoir pourquoi ils ont échoué, examinez leur sortie de journal. Consultez systemd/Journal#Filtering output pour plus de détails.\n\n"
    },
    {
      "title": "Diagnostic des problèmes de démarrage",
      "level": 3,
      "content": "systemd a plusieurs options pour diagnostiquer les problèmes avec le processus de démarrage. Consultez General troubleshooting (Français)#Problèmes de démarrage pour des instructions plus générales et des options pour capturer les messages de démarrage avant que systemd ne prenne en charge le processus de démarrage. Consultez également la documentation sur le débogage de systemd de freedesktop.org [2].\n\n"
    },
    {
      "title": "Diagnostic d'un service",
      "level": 3,
      "content": "Si un service systemd se comporte mal ou si vous souhaitez obtenir plus d'informations sur ce qui se passe, définissez la SYSTEMD_LOG_LEVEL {[variable d'environnement]] à SYSTEMD_LOG_LEVEL. [à debug. Par exemple, pour exécuter le daemon systemd-networkd en mode débogage :\n\nAjoutez un #Fichiers de substitution pour le service en ajoutant les deux lignes :\n\n```\n[Service]\nEnvironment=SYSTEMD_LOG_LEVEL=debug\n```\n\nOu comme équivalent, définissez la variable d'environnement manuellement :\n\n```\n# SYSTEMD_LOG_LEVEL=debug /lib/systemd/systemd-networkd\n```\n\npuis redémarrer systemd-networkd et regarder le journal du service avec l'option -f/--follow.\n\n"
    },
    {
      "title": "L'arrêt/le redémarrage prend très longtemps",
      "level": 3,
      "content": "Si le processus d'arrêt prend beaucoup de temps (ou semble se figer), il est probable qu'un service qui ne se termine pas est à blâmer. systemd attend un certain temps que chaque service se termine avant d'essayer de le tuer. Pour savoir si vous êtes concerné, consultez l’extinction finit par se terminer dans le wiki systemd.\n\nUn problème courant est un processus d'arrêt ou de suspension bloqué. Pour vérifier si c'est le cas, vous pouvez exécuter l'une ou l'autre de ces commandes et vérifier les sorties\n\n```\n# systemctl poweroff\n```\n\n```\nFailed to power off system via logind: There's already a shutdown or sleep operation in progress\n```\n\n```\n# systemctl list-jobs\n```\n\n```\nJOB UNIT                      TYPE  STATE  \n...\n21593 systemd-suspend.service start running\n21592 suspend.target          start waiting\n..\n```\n\nLa solution à ce problème serait d'annuler ces tâches en exécutant\n\n```\n# systemctl cancel\n# systemctl stop systemd-suspend.service\n```\n\npuis de réessayer l'arrêt ou le redémarrage.\n\n"
    },
    {
      "title": "Les processus à courte durée de vie ne semblent pas alimenter le journal",
      "level": 3,
      "content": "Si l'exécution de journalctl -u foounit en tant que root ne montre aucune sortie pour un service de courte durée, regardez plutôt le PID. Par exemple, si systemd-modules-load.service échoue et que systemctl status systemd-modules-load indique qu'il a été exécuté sous le PID 123, vous pouvez consulter la sortie dans le journal pour ce PID, c'est-à-dire en exécutant journalctl -b _PID=123 en tant que root. Les champs de métadonnées du journal tels que _SYSTEMD_UNIT et _COMM sont collectés de manière asynchrone et dépendent du répertoire /proc du processus existant. Pour résoudre ce problème, il faut corriger le noyau pour qu'il fournisse ces données via une connexion socket, comme pour SCM_CREDENTIALS. En bref, il s'agit d'un bug. Gardez à l'esprit que les services qui échouent immédiatement peuvent ne rien imprimer dans le journal, conformément à la conception de systemd.\n\n"
    },
    {
      "title": "Le temps de démarrage augmente avec le temps",
      "level": 3,
      "content": "Après avoir utilisé systemd-analyze, un certain nombre d'utilisateurs ont remarqué que leur temps de démarrage avait considérablement augmenté par rapport à ce qu'il était auparavant. Après avoir utilisé systemd-analyze blame NetworkManager (Français) est signalé comme prenant un temps anormalement long pour démarrer.\n\nPour certains utilisateurs, le problème est dû au fait que /var/log/journal devient trop volumineux. Ceci peut avoir d'autres impacts sur les performances, comme pour systemctl status ou journalctl. En tant que telle, la solution est de supprimer tous les fichiers du dossier (idéalement en faisant une sauvegarde quelque part, au moins temporairement) et ensuite de définir une taille limite pour les fichiers du journal comme décrit dans Systemd/Journal#Journal size limit.\n\n"
    },
    {
      "title": "systemd-tmpfiles-setup.service ne démarre pas au démarrage",
      "level": 3,
      "content": "À partir de systemd 219, /usr/lib/tmpfiles.d/systemd.conf spécifie les attributs ACL pour les répertoires sous /var/log/journal et, par conséquent, exige que la prise en charge des ACL soit activé pour le système de fichiers sur lequel le journal réside.\n\nConsultez Access Control Lists#Enable ACL pour savoir comment activer ACL sur le système de fichiers qui abrite /var/log/journal.\n\n"
    },
    {
      "title": "Désactiver le mode d'urgence sur la machine distante",
      "level": 3,
      "content": "Vous pouvez souhaiter désactiver le mode d'urgence sur une machine distante, par exemple, une machine virtuelle hébergée sur Azure ou Google Cloud. En effet, si le mode d'urgence est déclenché, la machine sera bloquée pour se connecter au réseau.\n\nPour le désactiver, masquez emergency.service et emergency.target.\n\n"
    },
    {
      "title": "Voir aussi",
      "level": 2,
      "content": "- Wikipedia:systemd\n- Site web officiel optimisations de systemd FAQ de systemd Trucs et astuces de systemd\n- systemd(1)\n- Autres distributions Gentoo:Systemd Fedora:Systemd Fedora:Comment déboguer les problèmes de Systemd Fedora:SysVinit à Systemd Cheatsheet Debian:systemd\n- L'histoire sur le blog de Lennart, mise à jour 1, mise à jour 2, mise à jour 3, Sommaire\n- Debugger les Services Systemd\n- systemd pour les administrateurs (PDF)\n- Comment utiliser Systemctl pour gérer les services et unités Systemd\n- Gestion des sessions avec systemd-logind\n- Coloration syntaxique pour les fichiers systemd avec Emacs\n- Deux parties d'un article d'introduction dans le magazine The H Open.\n\n- optimisations de systemd\n- FAQ de systemd\n- Trucs et astuces de systemd\n\n- Gentoo:Systemd\n- Fedora:Systemd\n- Fedora:Comment déboguer les problèmes de Systemd\n- Fedora:SysVinit à Systemd Cheatsheet\n- Debian:systemd\n\n"
    }
  ]
}