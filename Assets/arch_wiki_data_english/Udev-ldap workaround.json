{
  "title": "Udev-ldap workaround",
  "url": "https://wiki.archlinux.org/title/Udev-ldap_workaround",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- udisks\n\nudev is a userspace system that enables the operating system administrator to register userspace handlers for events. The events received by udev's daemon are mainly generated by the (Linux) kernel in response to physical events relating to peripheral devices. As such, udev's main purpose is to act upon peripheral detection and hot-plugging, including actions that return control to the kernel, e.g., loading kernel modules or device firmware. Another component of this detection is adjusting the permissions of the device to be accessible to non-root users and groups.\n\nAs the successor of devfsd and hotplug, udev also manages device nodes in the /dev directory by adding, symlinking and renaming them. udev replaces the functionality of both hotplug and hwdetect.\n\nudev handles separate events concurrently (in parallel), leading to a potential performance improvement over older systems. At the same time, this can complicate system administration, because, for example, the kernel module loading order is not preserved across boots. If the machine has multiple block devices, this may manifest itself in the form of device nodes changing designations after reboot. For example, if the machine has two hard drives, /dev/sda may on next boot become /dev/sdb. See below for more info on this.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "udev is part of systemd and thus installed by default. See systemd-udevd.service(8) for information.\n\n"
    },
    {
      "title": "About udev rules",
      "level": 2,
      "content": "udev rules written by the administrator go in /etc/udev/rules.d/, their file name has to end with .rules. The udev rules shipped with various packages are found in /usr/lib/udev/rules.d/. If there are two files by the same name under /usr/lib and /etc, the ones in /etc take precedence.\n\nTo learn about udev rules, refer to the udev(7) manual. Also see Writing udev rules and some practical examples are provided within the guide: Writing udev rules - Examples.\n\n"
    },
    {
      "title": "udev rule example",
      "level": 3,
      "content": "Below is an example of a rule that creates a symlink /dev/video-cam when a webcamera is connected.\n\nLet say this camera is currently connected and has loaded with the device name /dev/video2. The reason for writing this rule is that at the next boot, the device could show up under a different name, like /dev/video0.\n\n```\n$ udevadm info --attribute-walk --path=$(udevadm info --query=path --name=/dev/video2)\n```\n\n```\nUdevadm info starts with the device specified by the devpath and then walks up the chain of parent devices.\nIt prints for every device found, all possible attributes in the udev rules key format.\nA rule to match, can be composed by the attributes of the device and the attributes from one single parent device.\n\nlooking at device '/devices/pci0000:00/0000:00:04.1/usb3/3-2/3-2:1.0/video4linux/video2':\n  KERNEL==\"video2\"\n  SUBSYSTEM==\"video4linux\"\n   ...\nlooking at parent device '/devices/pci0000:00/0000:00:04.1/usb3/3-2/3-2:1.0':\n  KERNELS==\"3-2:1.0\"\n  SUBSYSTEMS==\"usb\"\n  ...\nlooking at parent device '/devices/pci0000:00/0000:00:04.1/usb3/3-2':\n  KERNELS==\"3-2\"\n  SUBSYSTEMS==\"usb\"\n  ATTRS{idVendor}==\"05a9\"\n  ATTRS{manufacturer}==\"OmniVision Technologies, Inc.\"\n  ATTRS{removable}==\"unknown\"\n  ATTRS{idProduct}==\"4519\"\n  ATTRS{bDeviceClass}==\"00\"\n  ATTRS{product}==\"USB Camera\"\n  ...\n```\n\nTo identify the webcamera, from the video4linux device we use KERNEL==\"video2\" and SUBSYSTEM==\"video4linux\", then walking up two levels above, we match the webcamera using vendor and product ID's from the usb parent SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"05a9\" and ATTRS{idProduct}==\"4519\". Note that this matching is case sensitive, so \"05A9\" can not be used to match the idVendor in this example.\n\nWe are now able to create a rule match for this device as follows:\n\n```\n/etc/udev/rules.d/83-webcam.rules\n```\n\n```\nKERNEL==\"video[0-9]*\", SUBSYSTEM==\"video4linux\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"05a9\", ATTRS{idProduct}==\"4519\", SYMLINK+=\"video-cam\"\n```\n\nHere we create a symlink using SYMLINK+=\"video-cam\" but we could easily set user OWNER=\"john\" or group using GROUP=\"video\" or set the permissions using MODE=\"0660\".\n\nIf you intend to write a rule to do something when a device is being removed, be aware that device attributes may not be accessible. In this case, you will have to work with preset device environment variables. To monitor those environment variables, execute the following command while unplugging your device:\n\n```\n$ udevadm monitor --property --udev\n```\n\nIn this command's output, you will see value pairs such as ID_VENDOR_ID and ID_MODEL_ID, which match the previously used attributes idVendor and idProduct. A rule that uses device environment variables instead of device attributes may look like this:\n\n```\n/etc/udev/rules.d/83-webcam-removed.rules\n```\n\n```\nACTION==\"remove\", SUBSYSTEM==\"usb\", ENV{ID_VENDOR_ID}==\"05a9\", ENV{ID_MODEL_ID}==\"4519\", RUN+=\"/path/to/your/script\"\n```\n\n"
    },
    {
      "title": "List the attributes of a device",
      "level": 3,
      "content": "To get a list of all of the attributes of a device you can use to write rules, run this command:\n\n```\n$ udevadm info --attribute-walk --name=device_name\n```\n\nReplace device_name with the device present in the system, such as /dev/sda or /dev/ttyUSB0.\n\nIf you do not know the device name you can also list all attributes of a specific system path:\n\n```\n$ udevadm info --attribute-walk --path=/sys/class/backlight/acpi_video0\n```\n\nTo narrow down the search for a device, figure out the class and run:\n\n```\n$ ls /dev/class/by-id\n```\n\nYou can use the symlink outright or what it points as the input to --name. For example:\n\n```\n$ udevadm info --attribute-walk --name=/dev/input/by-id/usb-foostan_Corne-event-kbd\n```\n\nTo get the path of a bare USB device which does not populate any subordinate device you have to use the full USB device path. Start monitor mode and then plug in the USB device to get it:\n\n```\n$ udevadm monitor\n```\n\n```\n...\nKERNEL[26652.638931] add      /devices/pci0000:00/0000:00:01.2/0000:02:00.0/0000:03:05.0/0000:05:00.0/usb1/1-3 (usb)\nKERNEL[26652.639153] add      /devices/pci0000:00/0000:00:01.2/0000:02:00.0/0000:03:05.0/0000:05:00.0/usb1/1-3/1-3:1.0 (usb)\n...\n```\n\nYou can just choose the deepest path and --attribute-walk will show all parent's attributes anyway:\n\n```\n$ udevadm info --attribute-walk --path=/devices/pci0000:00/0000:00:01.2/0000:02:00.0/0000:03:05.0/0000:05:00.0/usb1/1-3/1-3:1.0\n```\n\n"
    },
    {
      "title": "Testing rules before loading",
      "level": 3,
      "content": "```\n# udevadm test $(udevadm info --query=path --name=device_name) 2>&1\n```\n\nThis will not perform all actions in your new rules but it will however process symlink rules on existing devices which might come in handy if you are unable to load them otherwise. You can also directly provide the path to the device you want to test the udev rule for:\n\n```\n# udevadm test /sys/class/backlight/acpi_video0/\n```\n\n"
    },
    {
      "title": "Loading new rules",
      "level": 3,
      "content": "udev automatically detects changes to rules files, so changes take effect immediately without requiring udev to be restarted. However, the rules are not re-triggered automatically on already existing devices. Hot-pluggable devices, such as USB devices, will probably have to be reconnected for the new rules to take effect, or at least unloading and reloading the ohci-hcd and ehci-hcd kernel modules and thereby reloading all USB drivers.\n\nIf rules fail to reload automatically:\n\n```\n# udevadm control --reload\n```\n\nTo manually force udev to trigger your rules:\n\n```\n# udevadm trigger\n```\n\n"
    },
    {
      "title": "udisks",
      "level": 2,
      "content": "See udisks.\n\n"
    },
    {
      "title": "Mounting drives in rules",
      "level": 3,
      "content": "To mount removable drives, do not call mount from udev rules. This is ill-advised for two reasons:\n\n1. systemd by default runs systemd-udevd.service with a separate \"mount namespace\" (see namespaces(7)), which means that mounts will not be visible to the rest of the system.\n1. Even if you change the service parameters to fix this (commenting out the PrivateMounts and MountFlags lines), there is another problem which is that processes started from Udev are killed after a few seconds. In case of FUSE filesystems, such as NTFS-3G, mount starts a user-space process to handle the filesystem internals; when this is killed you will get Transport endpoint not connected errors if you try to access the filesystem.\n\nThere are some options that work:\n\n- Start a custom systemd service from the Udev rule; the systemd service can invoke a script which can start any number of long-running processes (like FUSE). A concise example which automatically mounts USB disks under /media is udev-media-automount. A variant of the same idea is explained in this blog post.\n- Use systemd-mount instead of mount in your Udev rule. This is recommended by systemd developers. For example this Udev rule should mount USB disks under /media:\n\n```\nACTION==\"add\", SUBSYSTEMS==\"usb\", SUBSYSTEM==\"block\", ENV{ID_FS_USAGE}==\"filesystem\", RUN{program}+=\"/usr/bin/systemd-mount --no-block --automount=yes --collect $devnode /media\"\n```\n\n- Use a package like udisks or udiskie. These are very powerful, but difficult to set up. Also, they are meant to be used in single user sessions, since they make some filesystems available under the ownership of the unprivileged user whose session is currently active.\n\n"
    },
    {
      "title": "Spawning long-running processes",
      "level": 3,
      "content": "Programs started by udev will block further events from that device, and any tasks spawned from a udev rule will be killed after event handling is completed. If you need to spawn a long-running process with udev, the intended way is to have a systemd unit which handles running the actual command, and a udev rule that merely signals that this unit should run. However, using systemctl in a udev rule is discouraged, since it is meant for user interaction and may block, among other things.\n\nThe correct way of doing this is to have the rule tag the device as needing a systemd device unit (see systemd.device(5)) using TAG+=\"systemd\" and adding an device property of either ENV{SYSTEMD_WANTS}= for services that would run with systemctl --system or ENV{SYSTEMD_USER_WANTS}= for services that should run with systemctl --user. For example:\n\n```\nSUBSYSTEM==\"tty\" ACTION==\"add\" ATTRS{manufacturer}==\"Pulse-Eight\" ATTRS{product}==\"CEC Adapter\" TAG+=\"systemd\" ENV{SYSTEMD_WANTS}=\"inputattach-cec@$devnode.service\"\n```\n\n```\n/etc/systemd/system/inputattach-cec@.service\n```\n\n```\n[Unit]\nDescription=Configure USB serial device at %I\n\n[Service]\nType=simple\nExecStart=/usr/bin/inputattach --pulse8-cec %I\n```\n\nSYSTEMD_WANTS is equivalent to the Wants= directive elsewhere in systemd, meaning the device will not be affected if the service fails, does not exists, or completes successfully at any point.\n\n"
    },
    {
      "title": "Allowing regular users to use devices",
      "level": 3,
      "content": "When a kernel driver initializes a device, the default state of the device node is to be owned by root:root, with permissions 600. [1] This makes devices inaccessible to regular users unless the driver changes the default, or a udev rule in userspace changes the permissions.\n\nThe OWNER, GROUP, and MODE udev values can be used to provide access, though one encounters the issue of how to make a device usable to all users without an overly permissive mode. Ubuntu's approach is to create a plugdev group that devices are added to, but this practice is not only discouraged by the systemd developers, [2] but considered a bug when shipped in udev rules on Arch (FS#35602). Another approach historically employed, as described in Users and groups#Pre-systemd groups, is to have different groups corresponding to categories of devices.\n\nThe modern recommended approach for systemd systems is to use a MODE of 660 to let the group use the device, and then attach a TAG named uaccess [3]. This special tag makes udev apply a dynamic user ACL to the device node, which coordinates with systemd-logind(8) to make the device usable to logged-in users. For an example of a udev rule implementing this:\n\n```\n/etc/udev/rules.d/71-device-name.rules\n```\n\n```\nSUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"vendor_id\", ATTRS{idProduct}==\"product_id\", MODE=\"0660\", TAG+=\"uaccess\"\n```\n\n"
    },
    {
      "title": "Execute when HDMI cable is plugged in or unplugged",
      "level": 3,
      "content": "Create the rule /etc/udev/rules.d/95-hdmi-plug.rules with the following content:\n\n```\nACTION==\"change\", SUBSYSTEM==\"drm\", ENV{DISPLAY}=\":0\", ENV{XAUTHORITY}=\"/home/username/.Xauthority\", RUN+=\"/path/to/script.sh\"\n```\n\n"
    },
    {
      "title": "Execute on VGA cable plug in",
      "level": 3,
      "content": "Create the rule /etc/udev/rules.d/95-monitor-hotplug.rules with the following content to launch arandr on plug in of a VGA monitor cable:\n\n```\nKERNEL==\"card0\", SUBSYSTEM==\"drm\", ENV{DISPLAY}=\":0\", ENV{XAUTHORITY}=\"/home/username/.Xauthority\", RUN+=\"/usr/bin/arandr\"\n```\n\nSome display managers store the .Xauthority outside the user home directory. You will need to update the ENV{XAUTHORITY} accordingly. As an example GNOME Display Manager looks as follows:\n\n```\n$ printenv XAUTHORITY\n```\n\n```\n/run/user/1000/gdm/Xauthority\n```\n\n"
    },
    {
      "title": "Detect new eSATA drives",
      "level": 3,
      "content": "If your eSATA drive is not detected when you plug it in, there are a few things you can try. You can reboot with the eSATA plugged in. Or you could try:\n\n```\n# echo 0 0 0 | tee /sys/class/scsi_host/host*/scan\n```\n\nOr you could install scsiaddAUR (from the AUR) and try:\n\n```\n# scsiadd -s\n```\n\nHopefully, your drive is now in /dev. If it is not, you could try the above commands while running:\n\n```\n# udevadm monitor\n```\n\nto see if anything is actually happening.\n\n"
    },
    {
      "title": "Mark internal SATA ports as eSATA",
      "level": 3,
      "content": "If you connected an eSATA bay or another eSATA adapter, the system will still recognize this disk as an internal SATA drive. GNOME and KDE will ask you for your root password all the time. The following rule will mark the specified SATA-Port as an external eSATA-Port. With that, a normal GNOME user can connect their eSATA drives to that port like a USB drive, without any root password and so on.\n\n```\n/etc/udev/rules.d/10-esata.rules\n```\n\n```\nDEVPATH==\"/devices/pci0000:00/0000:00:1f.2/host4/*\", ENV{UDISKS_SYSTEM}=\"0\"\n```\n\n```\n$ udevadm info --query=path /dev/sdb\n```\n\n```\n/devices/pci0000:00/0000:00:1f.2/host4/target4:0:0/4:0:0:0/block/sdb\n```\n\n```\n$ find /sys/devices/ -name sdb\n```\n\n```\n/sys/devices/pci0000:00/0000:00:1f.2/host4/target4:0:0/4:0:0:0/block/sdb\n```\n\n"
    },
    {
      "title": "Setting static device names",
      "level": 3,
      "content": "Because udev loads all modules asynchronously, they are initialized in a different order. This can result in devices randomly switching names. A udev rule can be added to use static device names. See also Persistent block device naming for block devices and Network configuration#Change interface name for network devices.\n\n"
    },
    {
      "title": "Video device",
      "level": 4,
      "content": "For setting up the webcam in the first place, refer to Webcam setup.\n\nUsing multiple webcams will assign video devices as /dev/video* randomly on boot. The recommended solution is to create symlinks using a udev rule as in the #udev rule example:\n\n```\n/etc/udev/rules.d/83-webcam.rules\n```\n\n```\nKERNEL==\"video[0-9]*\", SUBSYSTEM==\"video4linux\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"05a9\", ATTRS{idProduct}==\"4519\", SYMLINK+=\"video-cam1\"\nKERNEL==\"video[0-9]*\", SUBSYSTEM==\"video4linux\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"046d\", ATTRS{idProduct}==\"08f6\", SYMLINK+=\"video-cam2\"\n```\n\n"
    },
    {
      "title": "Printer",
      "level": 4,
      "content": "If you use multiple printers, /dev/lp[0-9] devices will be assigned randomly on boot, which will break e.g. CUPS configuration.\n\nYou can create the following rule, which will create symlinks under /dev/lp/by-id and /dev/lp/by-path, similar to Persistent block device naming scheme:\n\n```\n/etc/udev/rules.d/60-persistent-printer.rules\n```\n\n```\nACTION==\"remove\", GOTO=\"persistent_printer_end\"\n# This should not be necessary\n#KERNEL!=\"lp*\", GOTO=\"persistent_printer_end\"\n\nSUBSYSTEMS==\"usb\", IMPORT{builtin}=\"usb_id\"\nENV{ID_TYPE}!=\"printer\", GOTO=\"persistent_printer_end\"\n\nENV{ID_SERIAL}==\"?*\", SYMLINK+=\"lp/by-id/$env{ID_BUS}-$env{ID_SERIAL}\"\n\nIMPORT{builtin}=\"path_id\"\nENV{ID_PATH}==\"?*\", SYMLINK+=\"lp/by-path/$env{ID_PATH}\"\n\nLABEL=\"persistent_printer_end\"\n```\n\n"
    },
    {
      "title": "Identifying a disk by its serial",
      "level": 3,
      "content": "To perform some action on a specific disk device /dev/sdX identified permanently by its unique serial ID_SERIAL_SHORT as displayed with udevadm info /dev/sdX, one can use the below rule. It is passing as a parameter the device name found if any to illustrate:\n\n```\n/etc/udev/rules.d/69-disk.rules\n```\n\n```\nACTION==\"add\", KERNEL==\"sd[a-z]\", ENV{ID_SERIAL_SHORT}==\"X5ER1ALX\", RUN+=\"/path/to/script /dev/%k\"\n```\n\n"
    },
    {
      "title": "Waking from suspend with USB device",
      "level": 3,
      "content": "A udev rule can be useful to enable the wakeup triggers of a USB device, like a mouse or a keyboard, so that it can be used to wake the system from sleep.\n\nFirst, identify the vendor and product identifiers of the USB device. They will be used to recognize it in the udev rule. For example:\n\n```\n$ lsusb | grep Logitech\n```\n\n```\nBus 007 Device 002: ID 046d:c52b Logitech, Inc. Unifying Receiver\n```\n\nThen, find where the device is connected to using:\n\n```\n$ grep c52b /sys/bus/usb/devices/*/idProduct\n```\n\n```\n/sys/bus/usb/devices/1-1.1.1.4/idProduct:c52b\n```\n\nNow create the rule to change the power/wakeup attribute of both the device and the USB controller it is connected to whenever it is added:\n\n```\n/etc/udev/rules.d/50-wake-on-device.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"usb\", DRIVERS==\"usb\", ATTRS{idVendor}==\"046d\", ATTRS{idProduct}==\"c52b\", ATTR{power/wakeup}=\"enabled\", ATTR{driver/1-1.1.1.4/power/wakeup}=\"enabled\"\n```\n\n"
    },
    {
      "title": "Triggering events",
      "level": 3,
      "content": "Note: **This article or section is a candidate for merging with #Testing rules before loading.** This article or section is a candidate for merging with #Testing rules before loading.\n\nThis article or section is a candidate for merging with #Testing rules before loading.\n\nIt can be useful to trigger various udev events. For example, you might want to simulate a USB device disconnect on a remote machine. In such cases, use udevadm trigger:\n\n```\n# udevadm trigger --verbose --type=subsystems --action=remove --subsystem-match=usb --attr-match=\"idVendor=abcd\"\n```\n\nThis command will trigger a USB remove event on all USB devices with vendor ID abcd.\n\n"
    },
    {
      "title": "Triggering desktop notifications from a udev rule",
      "level": 3,
      "content": "To trigger a desktop notification from a udev rule, use systemd-run(1) as explained in Desktop notifications#Send notifications to another user:\n\nCreate the file:\n\n```\n/etc/udev/rules.d/99-powersupply_notification.rules\n```\n\n```\n# Rule for when switching to battery\nACTION==\"change\", SUBSYSTEM==\"power_supply\", ATTRS{type}==\"Mains\", ATTRS{online}==\"0\", RUN+=\"/usr/bin/systemd-run --machine=target_user@.host --user notify-send 'Changing Power States' 'Using battery power'\"\n# Rule for when switching to AC\nACTION==\"change\", SUBSYSTEM==\"power_supply\", ATTRS{type}==\"Mains\", ATTRS{online}==\"1\", RUN+=\"/usr/bin/systemd-run --machine=target_user@.host --user notify-send 'Changing Power States' 'Using AC power'\"\n```\n\nTo launch multiple or long commands, an executable script can be given to systemd-run:\n\n```\n/usr/local/bin/from_battery.sh\n```\n\n```\n#!/bin/sh\n\npaplay /usr/share/sounds/freedesktop/stereo/power-unplug.oga\nnotify-send --icon=/usr/share/icons/Adwaita/symbolic/legacy/battery-good-symbolic.svg 'Changing Power States' 'Using battery power' --expire-time=4000\n```\n\n"
    },
    {
      "title": "Blacklisting modules",
      "level": 3,
      "content": "In rare cases, udev can make mistakes and load the wrong modules. To prevent it from doing this, you can blacklist modules. Once blacklisted, udev will never load that module – not at boot-time and not even later on when a hot-plug event is received (e.g., you plug in your USB flash drive).\n\n"
    },
    {
      "title": "Debug output",
      "level": 3,
      "content": "To get hardware debug info, use the kernel parameter udev.log-priority=debug. Alternatively you can set\n\n```\n/etc/udev/udev.conf\n```\n\n```\nudev_log=\"debug\"\n```\n\nThis option can also be compiled into your initramfs by adding the configuration file to your FILES array:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nFILES=(... /etc/udev/udev.conf)\n```\n\nand then regenerate the initramfs.\n\n"
    },
    {
      "title": "udevd hangs at boot",
      "level": 3,
      "content": "After migrating to LDAP or updating an LDAP-backed system, udevd can hang at boot at the message \"Starting UDev Daemon\". This is usually caused by udevd trying to look up a name from LDAP but failing, because the network is not up yet. The solution is to ensure that all system group names are present locally.\n\nExtract the group names referenced in udev rules and the group names actually present on the system:\n\n```\n# grep -Fr GROUP /etc/udev/rules.d/ /usr/lib/udev/rules.d/ | sed 's:.*GROUP=\"\\([-a-z_]\\{1,\\}\\)\".*:\\1:' | sort -u >udev_groups\n# cut -d: -f1 /etc/gshadow /etc/group | sort -u >present_groups\n```\n\nTo see the differences, do a side-by-side diff:\n\n```\n# diff -y present_groups udev_groups\n...\nnetwork\t\t\t\t\t\t\t      <\nnobody\t\t\t\t\t\t\t      <\nntp\t\t\t\t\t\t\t      <\noptical\t\t\t\t\t\t\t\toptical\npower\t\t\t\t\t\t\t      |\tpcscd\nrfkill\t\t\t\t\t\t\t      <\nroot\t\t\t\t\t\t\t\troot\nscanner\t\t\t\t\t\t\t\tscanner\nsmmsp\t\t\t\t\t\t\t      <\nstorage\t\t\t\t\t\t\t\tstorage\n...\n```\n\nIn this case, the pcscd group is for some reason not present in the system. Add the missing groups. Also, make sure that local resources are looked up before resorting to LDAP. /etc/nsswitch.conf should contain the following line:\n\n```\ngroup: files ldap\n```\n\n"
    },
    {
      "title": "Some devices, that should be treated as removable, are not",
      "level": 3,
      "content": "You need to create a custom udev rule for that particular device. To get definitive information of the device you can use either ID_SERIAL or ID_SERIAL_SHORT (remember to change /dev/sdb if needed):\n\n```\n$ udevadm info /dev/sdb | grep ID_SERIAL\n```\n\nThen we set UDISKS_AUTO=\"1\" to mark the device for automounting and UDISKS_SYSTEM=\"0\" to mark the device as \"removable\". See udisks(8) for details.\n\n```\n/etc/udev/rules.d/99-removable.rules\n```\n\n```\nENV{ID_SERIAL_SHORT}==\"serial_number\", ENV{UDISKS_AUTO}=\"1\", ENV{UDISKS_SYSTEM}=\"0\"\n```\n\nRemember to reload udev rules with udevadm control --reload. Next time you plug your device in, it will be treated as an external drive.\n\n"
    },
    {
      "title": "Sound problems with some modules not loaded automatically",
      "level": 3,
      "content": "Some users have traced this problem to old entries in /etc/modprobe.d/sound.conf. Try cleaning that file out and trying again.\n\n"
    },
    {
      "title": "Optical drives have group ID set to \"disk\"",
      "level": 3,
      "content": "If the group ID of your optical drive is set to disk and you want to have it set to optical, you have to create a custom udev rule:\n\n```\n/etc/udev/rules.d\n```\n\n```\n# permissions for SCSI CD devices\nSUBSYSTEMS==\"scsi\", KERNEL==\"s[rg][0-9]*\", ATTRS{type}==\"5\", GROUP=\"optical\"\n```\n\n"
    },
    {
      "title": "X programs in RUN rules hang when no X server is present",
      "level": 3,
      "content": "When xrandr or another X-based program tries to connect to an X server, it falls back to a TCP connection on failure. However, due to IPAddressDeny in the systemd-udev service configuration, this hangs. Eventually the program will be killed and event processing will resume.\n\nIf the rule is for a drm device and the hang causes event processing to complete once the X server has started, this can cause 3D acceleration to stop working with a failed to authenticate magic error.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- udev(7)\n- An Introduction to udev\n- udev mailing list information\n- Scripting with udev\n- Writing udev rules\n- Device and Module Handling on an LFS System\n- Running GUI or accessing display variables from udev rules\n- openSUSE udev documentation\n\n"
    }
  ]
}