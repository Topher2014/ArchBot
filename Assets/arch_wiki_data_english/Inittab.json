{
  "title": "Inittab",
  "url": "https://wiki.archlinux.org/title/Inittab",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nRelated articles\n\n- init\n\nOn systems based on SysVinit, init is the first process that is executed once the Linux kernel loads. The default init program used by the kernel is /sbin/init provided by systemd-sysvcompat (by default on new installs, see systemd) or sysvinitAUR. The word init will always refer to sysvinit in this article.\n\ninittab is the startup configuration file for init located in /etc. It contains directions for init on what programs and scripts to run when entering a specific runlevel.\n\nAlthough a SysVinit-based Arch system does use init, most of the work is delegated to the #Main boot scripts. This article concentrates on init and inittab.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install sysvinitAUR initscripts-forkAUR from the AUR. This step will remove systemd-sysvcompat, and you will use sysvinit on reboot. To restore systemd, append init=/usr/lib/systemd/systemd to the kernel command line.\n\nA snapshot of init scripts as packaged in Arch Linux before migration to systemd is available at arch-rcscripts. For support with newer packages, see #Writing rc.d scripts.\n\nSee Init#Configuration for generic configuration steps.\n\n"
    },
    {
      "title": "Overview of init and inittab",
      "level": 2,
      "content": "init is always process 1 and, other than managing some swap space, is the parent process to all other processes. You can get an idea of where init lies in the process hierarchy of your system with pstree:\n\n```\n$ pstree -Ap\n```\n\n```\ninit(1)-+-acpid(3432)\n        |-crond(3423)\n        |-dbus-daemon(3469)\n        |-gpm(3485)\n        |-mylogin(3536)\n        |-ngetty(3535)---login(3954)---zsh(4043)---pstree(4326)\n        |-polkitd(4033)---{polkitd}(4035)\n        |-syslog-ng(3413)---syslog-ng(3414)\n        `-udevd(643)-+-udevd(3194)\n                     `-udevd(3218)\n```\n\nBesides usual initialization of system (as the name suggests), init also handles rebooting, shutdown and booting into recovery mode (single-user mode). To support these, inittab groups entries into different runlevels. The runlevels Arch uses are 0 for halt, 1 (aliased as S) for single-user mode, 3 for normal booting (multi-user mode), 5 for X and 6 for reboot. Other distributions may adopt other conventions, but the meanings of 0, 1 and 6 are universal.\n\nUpon execution, init scans inittab and carry out appropriate actions. An entry in inittab takes the form\n\n```\nid:runlevels:action:process\n```\n\nWhere id is a unique identifier for the entry (just a name, no real impact on init), and runlevels is a (not delimited) string of runlevels. If the runlevel init is entering appears in runlevels, action is carried out, executing process if appropriate. Some special actions would cause init to ignore runlevels and adopt a special matching method. More explanation follows in the next section.\n\nSee also man 5 inittab and man 8 init.\n\n"
    },
    {
      "title": "Through bootloader",
      "level": 3,
      "content": "To change the runlevel the system boots into, simply add the desired runlevel n to the respective bootloader's configuration line. A common application of this is Xinit#Autostart X at login. To boot to the desired runlevel, add its number to the kernel parameters (e.g. 3 for runlevel 3).\n\nThe run-level was appended to the end so the kernel knows what run-level to start with. To use another init program (e.g. systemd), add init=/usr/lib/systemd/systemd or similar.\n\n"
    },
    {
      "title": "After boot up",
      "level": 3,
      "content": "After the system has booted up, you may issue telinit n to inform init to change the runlevel to n. init then reads inittab and \"diffs\" runlevel n and current runlevel - killing processes not present in the new runlevel and carrying out actions not present in the old runlevel. Processes present in both runlevels are left untouched. The killing procedure is actually a little complex; again, technical details can be found in the init manpage.\n\ninit does not watch inittab. You need to call telinit explicitly to apply modifications to inittab. The command telinit q causes init to re-examine inittab but not switch runlevel.\n\n"
    },
    {
      "title": "inittab",
      "level": 2,
      "content": "In this section we examine common entries in inittab, in the same order as they appear in the default inittab used by Arch. After that there are a few examples to help you create your own inittab entry.\n\n"
    },
    {
      "title": "Default runlevel",
      "level": 3,
      "content": "The default runlevel is 3. Uncomment or add this if you prefer to boot into runlevel 5 (which is used for X conventionally) by default:\n\n```\nid:5:initdefault:\n```\n\n"
    },
    {
      "title": "Main boot scripts",
      "level": 3,
      "content": "These are the main Arch init scripts.\n\n```\nrc::sysinit:/etc/rc.sysinit\nrs:S1:wait:/etc/rc.single\nrm:2345:wait:/etc/rc.multi\nrh:06:wait:/etc/rc.shutdown\n```\n\n"
    },
    {
      "title": "Single-user boot",
      "level": 3,
      "content": "Sometimes your kernel may fail to boot up all the way, due to a corrupted or dead hard drive or filesystem, missing key files, etc. In that case your init image may automatically enter into single-user mode which only allows root login and uses /sbin/sulogin instead of /sbin/login to control the login process. You can also boot into single-user mode by appending the letter S to your kernel command line in your GRUB, LILO, or syslinux configuration. If you would like something other than sulogin to run, specify it here.\n\n```\nsu:S:wait:/sbin/sulogin -p\n```\n\n"
    },
    {
      "title": "Gettys and login",
      "level": 3,
      "content": "These are crucial entries that run the gettys on your terminals. Most default configurations will have several gettys running on ttys1-6 which is what pops up on your screen with the login prompt. Also see openvt, chvt, stty, and ioctl.\n\n```\nc1:234:respawn:/sbin/agetty 9600 tty1 xterm-color\nc5:5:respawn:/sbin/agetty 57600 tty2 xterm-256color\n```\n\n"
    },
    {
      "title": "Ctrl+Alt+Del",
      "level": 3,
      "content": "When the special key sequence Ctrl+Alt+Del is pressed, this determines what to do.\n\n```\nca::ctrlaltdel:/sbin/shutdown -t3 -r now\n```\n\n"
    },
    {
      "title": "X programs",
      "level": 3,
      "content": "If you are not afraid to debug, you can figure out how to start all sorts of programs from inittab. One useful type of program is to start your login manager when the runlevel is 5, multi-user-x-mode. In the following example you can see how to start SLiM when entering runlevel 5.\n\n```\nx:5:respawn:/usr/bin/slim >/dev/null 2>&1\n#x:5:respawn:/usr/bin/xdm -nodaemon -confi /etc/X11/xdm/archlinux/xdm-config\n```\n\n"
    },
    {
      "title": "Power-sensing scripts",
      "level": 3,
      "content": "Init can communicate with your UPS device and execute processes based on the status of the UPS. Here are some examples:\n\n```\npf::powerfail:/sbin/shutdown -f -h +2 \"Power Failure; System Shutting Down\"\npr:12345:powerokwait:/sbin/shutdown -c \"Power Restored; Shutdown Cancelled\"\n```\n\n"
    },
    {
      "title": "Custom keyboard request",
      "level": 3,
      "content": "The following line adds a custom function for when a special key sequence is pressed. You can modify this special key sequence to be anything you like, similar to a Ctrl+Alt+Del.\n\n```\nkb::kbrequest:/usr/bin/wall \"Keyboard Request -- edit /etc/inittab to customize\"\n```\n\n"
    },
    {
      "title": "Trigger the kbrequest",
      "level": 4,
      "content": "You can trigger the special key sequence kbrequest by sending the WINCH signal to the init process (i.e. PID 1) as root. In this example, the command:\n\n```\n# kill -WINCH 1\n```\n\nCauses wall to write to all ttys:\n\n```\nBroadcast message from root@askapachehost (console) (Wed Oct 27 14:02:26 2010):\nKeyboard Request -- edit /etc/inittab to customize\n```\n\n"
    },
    {
      "title": "Writing rc.d scripts",
      "level": 2,
      "content": "Initscripts uses rc.d scripts to used to control the starting, stopping and restarting of daemons.\n\n"
    },
    {
      "title": "Guideline",
      "level": 3,
      "content": "- Source /etc/rc.conf, /etc/rc.d/functions, and optionally /etc/conf.d/DAEMON_NAME.\n- Arguments and other daemon options should be placed in /etc/conf.d/DAEMON_NAME. This is done to separate configuration from logic and to keep a consistent style among daemon scripts.\n- Use functions in /etc/rc.d/functions instead of duplicating their functionality.\n- Include at least start, stop and restart as arguments to the script.\n\n"
    },
    {
      "title": "Available functions",
      "level": 3,
      "content": "- There are some functions provided by /etc/rc.d/functions: stat_busy \"message\": set status busy for printed message (e.g. Starting daemon [BUSY]) stat_done: set status done (e.g. Starting daemon [DONE]) stat_fail: set status failed (e.g. Starting daemon [FAILED]) get_pid program: get PID of the program ck_pidfile PID-file program: check whether PID-file is still valid for the program (e.g. ck_pidfile /var/run/daemon.pid daemon || rm -f /var/run/daemon.pid) [add|rm]_daemon program: add/remove program to running daemons (stored in /run/daemons/)\n\n- stat_busy \"message\": set status busy for printed message (e.g. Starting daemon [BUSY])\n- stat_done: set status done (e.g. Starting daemon [DONE])\n- stat_fail: set status failed (e.g. Starting daemon [FAILED])\n- get_pid program: get PID of the program\n- ck_pidfile PID-file program: check whether PID-file is still valid for the program (e.g. ck_pidfile /var/run/daemon.pid daemon || rm -f /var/run/daemon.pid)\n- [add|rm]_daemon program: add/remove program to running daemons (stored in /run/daemons/)\n\nFull list of functions is much longer and most possibilities (like way to control whether or not non-root users can launch daemon) are still undocumented and can be learned only from /etc/rc.d/functions source. See also man rc.d.\n\n"
    },
    {
      "title": "Example",
      "level": 3,
      "content": "The following is an example for crond. Look in /etc/rc.d for greater variety.\n\nThe configuration file:\n\n```\n/etc/conf.d/crond\n```\n\n```\nARGS=\"-S -l info\"\n```\n\nThe actual script:\n\n```\n/etc/rc.d/crond\n```\n\n```\n#!/bin/bash\n\n. /etc/rc.conf\n. /etc/rc.d/functions\n\nDAEMON=crond\nARGS=\n\n[ -r /etc/conf.d/$DAEMON ] && . /etc/conf.d/$DAEMON\n\nPID=$(get_pid $DAEMON)\n\ncase \"$1\" in\n start)\n   stat_busy \"Starting $DAEMON\"\n   [ -z \"$PID\" ] && $DAEMON $ARGS &>/dev/null\n   if [ $? = 0 ]; then\n     add_daemon $DAEMON\n     stat_done\n   else\n     stat_fail\n     exit 1\n   fi\n   ;;\n stop)\n   stat_busy \"Stopping $DAEMON\"\n   [ -n \"$PID\" ] && kill $PID &>/dev/null\n   if [ $? = 0 ]; then\n     rm_daemon $DAEMON\n     stat_done\n   else\n     stat_fail\n     exit 1\n   fi\n   ;;\n restart)\n   $0 stop\n   sleep 1\n   $0 start\n   ;;\n *)\n   echo \"usage: $0 {start|stop|restart}\"  \nesac\n```\n\n"
    },
    {
      "title": "Runlevels",
      "level": 2,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nFrom init(8):\n\nIf something goes wrong with your Arch setup in such way that you are completely helpless when the system boots up, you may need this.\n\nFor example, if you use some deffective display drivers, the system may freeze when the X server starts. If you have a display manager in your startup daemons list, you need to take full control of your system before that daemon starts.\n\nAnd how do you do that?\n\nWhat you need is called \"booting to another runlevel\". This basically determines in what state the system will be when the boot sequence terminates. Normally you finish in the multi-user mode with all daemons started (=runlevel 3).\n\n"
    },
    {
      "title": "Comparison to systemd targets",
      "level": 3,
      "content": "Table content:\nsystemd Target | SysV Runlevel | Notes\nrunlevel0.target, poweroff.target | 0 | Shut down the system.\nrunlevel1.target, rescue.target | 1, s, single | Single user mode.\nrunlevel2.target, runlevel4.target, multi-user.target | 2, 4 | User-defined/Site-specific runlevels. By default, identical to 3.\nrunlevel3.target, multi-user.target | 3 | Multi-user, non-graphical. Users can usually login via multiple consoles or via the network.\nrunlevel5.target, graphical.target | 5 | Multi-user, graphical. Usually has all the services of runlevel 3 plus a graphical login.\nrunlevel6.target, reboot.target | 6 | Reboot\nemergency.target | emergency | Emergency shell\n\n"
    },
    {
      "title": "List of initscripts runlevels",
      "level": 3,
      "content": "And what are the possible runlevels?\n\n- 1: Single user (maintainance mode): You want to use this one if you have problems.\n- 3: Multi user: Normal mode\n- 5: Multi user with X11: The same as 3 but with X11 loaded in virtual terminal 8 by default\n- 0: Halt\n- 6: Reboot\n- 2, 4: Not used\n\nTake a look to /etc/inittab to see how it works.\n\n"
    },
    {
      "title": "Runlevel invocation",
      "level": 3,
      "content": "You specify what runlevel you would like to enter on the kernel commandline. You just have to pass the number of the desired runlevel as an option on that commandline, so it may look like this if you are in trouble and you want to use single user mode (only the last number is important here)\n\n```\nkernel /vmlinuz-linux ... root=/dev/sda2 ro 1\n```\n\nAnd yes, in a case when you can not boot, you will have to append the runlevel number to the kernel command line in the boot manager during bootup.\n\n"
    },
    {
      "title": "First method",
      "level": 4,
      "content": "Throughout this page, 4 will be used for an example since it is not used by default in Arch. To create another runlevel:\n\n```\n# cd /etc\n# cp rc.multi rc.multi4\n# sed -i \"s/DAEMONS/DAEMONS4/g\" /etc/rc.multi4\n```\n\nThe execution of sed will change /etc/rc.multi4 to look at the new DAEMONS array that will be defined in a couple of steps.\n\nNext, we will add our new /etc/rc.multi4 script to /etc/inittab by changing this line:\n\n```\nrm:2345:wait:/etc/rc.multi\n```\n\nto:\n\n```\nrm:235:wait:/etc/rc.multi\nra:4:wait:/etc/rc.multi4\n```\n\nYou can also add a new line to /etc/inittab to execute another script or program to do anything you would like.\n\nExample: Log into X as a single user for a special purpose:\n\n```\nxa:4:respawn:/bin/su - $USER -c \"/usr/bin/startx\"\n```\n\nThe next step will be to add a new DAEMONS array to your /etc/rc.conf file, call it DAEMONS4=(...) and populate this array with any daemons you would like to run for the new runlevel.\n\nThe /etc/rc.conf gives the suggestion to put a ! in front of daemons you want to disable. How this is handled in the default /etc/rc.multi, is that anything prefaced with the ! is skipped. A downside to this is if you use the above method to define a different set of daemons for your new runlevel (i.e, want to stop some, keep others going, and/or start new ones) any daemon prefaced with ! will not be stopped when switching to or from your new runlevel. The following /etc/rc.multi changes this behavior.\n\nExample:\n\n```\n/etc/rc.multi\n```\n\n```\n#!/bin/bash\n #\n # /etc/rc.multi\n #\n  \n . /etc/rc.conf\n . /etc/rc.d/functions\n \n run_hook multi_start\n \n # Load sysctl variables if sysctl.conf is present\n [ -r /etc/sysctl.conf ] && /sbin/sysctl -q -p &>/dev/null\n \n # Start daemons\n # _remember to change DAEMONS in next line for the file /etc/rc.multi4\n for daemon in \"${DAEMONS[@]}\"; do\n         if [ \"$daemon\" = \"${daemon#!}\" ]; then\n                 # check to see if daemon is running.\n                 ck_daemon $daemon\n                 if [ $? -eq 1 ]; then\n                         # daemon is running, skip it.\n                         status_started\n                 else\n                         # daemon is not running, start it.\n                         if [ \"$daemon\" = \"${daemon#@}\" ]; then\n                                 start_daemon $daemon\n                         else\n                                 start_daemon_bkgd ${daemon:1}\n                         fi\n                 fi\n         else\n                 # check previous runlevel. if it's N, then we've just booted\n                 #   and do not need to stop any daemons. otherwise, stop daemons\n                 #   when runlevel changes as requested in DAEMONS array.\n                 if [ `/sbin/runlevel | cut -d ' ' -f 1` != \"N\" ] ; then\n                         ck_daemon ${daemon:1}\n                         if [ $? -eq 1 ] ; then\n                                  # daemon is running, let's stop it.\n                                  stop_daemon ${daemon:1}\n                         fi\n                 fi\n         fi\n done\n \n if [ -x /etc/rc.local ]; then\n         /etc/rc.local\n fi\n \n run_hook multi_end\n \n # vim: set ts=2 noet:\n```\n\nHere is what this does:\n\n```\nDAEMONS=(syslog-ng network netfs sshd alsa !jack !gpm)      # runlevel 3\nDAEMONS4=(syslog-ng network netfs !sshd alsa jack gpm)      # runlevel 4\n```\n\nIn runlevel 3, jack and gpm are disabled, and in runlevel 4 sshd is not needed, but jack and gpm are. The above /etc/rc.multi script will scan the daemons array and check for:\n\n1. if a daemon is running (without !). if it is, skip it. if not, start it.\n1. if a daemon is disabled (!), stop it. (this is skipped on boot-up)\n1. it still honors starting daemons in the background (@)\n\nIn the above example, when going from runlevel 3 to runlevel 4, syslog-ng, network, netfs, and alsa are checked and found to be running so they will be skipped. sshd will be disabled then jack and gpm will be started. And when going from runlevel 4 to runlevel 3, syslog-ng, network, netfs, and alsa are still running, so will be skipped again, but jack and gpm will be stopped, while sshd will be started again.\n\nIn summary:\n\n1. copy /etc/rc.multi to /etc/rc.multi4\n1. add DAEMONS4 to the end of your /etc/rc.conf and add daemons to it\n1. be sure to change /etc/rc.multi4 by changing DAEMONS to DAEMONS4\n1. edit /etc/inittab to add the runlevel and take appropriate actions\n\nIf you do use the above /etc/rc.multi, proper operation is for it to be both your main /etc/rc.multi and your new /etc/rc.multi4 to ensure that all daemons are processed as you desire. It will not break your system to have two different versions of /etc/rc.multi.\n\nWhile your new runlevel setup should not be written over by any system updates, it is always handy to have backups on hand in the event that something unforeseen happens.\n\n"
    },
    {
      "title": "Another way, without adding any symlink",
      "level": 4,
      "content": "With a simple modification on /etc/rc.multi, runlevels can be simply added by adding a new DAEMONS line in /etc/rc.conf.\n\nHere is the patch:\n\n```\n--- rc.multi\t2008-06-22 23:58:29.000000000 +0200\n+++ rc.multi.new\t2008-06-23 00:14:05.000000000 +0200\n@@ -11,8 +11,25 @@\n # Load sysctl variables if sysctl.conf is present\n [ -r /etc/sysctl.conf ] && /sbin/sysctl -q -p &>/dev/null\n \n+# Load the appropriate DAEMONS array according to runlevel specified in the kernel boot cmdline\n+RUNLEVEL=\"\"\n+FINAL_DAEMONS=()\n+ \n+for param in `cat /proc/cmdline`; do\n+  param_rl=`echo $param | grep ^runlevel`\n+  if [ ! \"$param_rl\" = \"\" ]; then\n+    RUNLEVEL=`echo $param_rl | sed -r -e \"s#runlevel=(.+)#\\1#\"`\n+  fi\n+done;\n+\n+if [ \"${RUNLEVEL}\" = \"\" ]; then\n+\teval FINAL_DAEMONS=(${DAEMONS[@]})\n+else\n+\teval FINAL_DAEMONS=(\\${DAEMONS_${RUNLEVEL}[@]})\n+\tif [ \"${#FINAL_DAEMONS[@]}\" = \"0\" ]; then\n+\t\teval FINAL_DAEMONS=(${DAEMONS[@]})\n+\tfi\t\n+fi\n+\n # Start daemons\n-for daemon in \"${DAEMONS[@]}\"; do\n+for daemon in \"${FINAL_DAEMONS[@]}\"; do\n \tif [ \"$daemon\" = \"${daemon#!}\" ]; then\n \t\tif [ \"$daemon\" = \"${daemon#@}\" ]; then\n \t\t\t/etc/rc.d/$daemon start\n```\n\nNow, to add a runlevel, add a new array in /etc/rc.conf (in this example I named it FOO):\n\n```\nDAEMONS_FOO=( ...whatever... )\n```\n\nand to run the system with this runlevel, simply add runlevel=FOO to your boot arguments in LILO or GRUB.\n\n"
    },
    {
      "title": "Other distributions",
      "level": 3,
      "content": "Runlevels exist in all Linux distributions and while runlevel 1 is usually single-user \"emergency mode\", 0 means halt and 6 mean reboot, the meaning of other runlevels varies from one distribution to another.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Wikipedia:Init\n- Linux Knowledge Base and Tutorial. Run Levels.\n\n"
    }
  ]
}