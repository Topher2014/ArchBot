{
  "title": "Senha",
  "url": "https://wiki.archlinux.org/title/Senha",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- DeveloperWiki:UID / GID Database\n- sudo\n- Polkit\n- Permissões e atributos de arquivo\n- systemd-homed\n\nUsuários e grupos são usados no GNU/Linux para controle de acesso — isto é, para controlar o acesso aos arquivos, diretórios e periféricos do sistema. O Linux oferece mecanismos de controle de acesso relativamente simples/grosseiros por padrão. Para opções mais avançadas, veja ACL, Capacidades e PAM#Configuration How-Tos.\n\n"
    },
    {
      "title": "Visão geral",
      "level": 2,
      "content": "Um usuário é qualquer pessoa que use um computador. Nesse caso, estamos descrevendo os nomes que representam esses usuários. Pode ser Maria ou Guilherme, e eles podem usar os nomes SraDragao ou Pirata no lugar de seu nome real. Tudo o que importa é que o computador possui um nome para cada conta que ele cria, e é esse o nome pelo qual uma pessoa ganha acesso para usar o computador. Alguns serviços do sistema também são executados usando contas de usuários restritas ou privilegiadas.\n\nO gerenciamento de usuários é feito com a finalidade de segurança, limitando o acesso de determinadas formas específicas. O superusuário (root) possui acesso completo ao sistema operacional e sua configuração; destina-se apenas a uso administrativo. Usuários não privilegiados podem usar os programas su e sudo para a escalação de privilégios controlados.\n\nQualquer indivíduo pode ter mais de uma conta, desde que eles usem um nome diferente para cada conta que eles criem. Além disso, existem alguns nomes reservados que não podem ser usados como \"root\".\n\nOs usuários podem ser agrupados em um \"grupo\", e os usuários podem ser adicionados a um grupo existente para utilizar o acesso privilegiado que ele concede.\n\n"
    },
    {
      "title": "Permissões e propriedade",
      "level": 2,
      "content": "De In UNIX Everything is a File:\n\nDe Extending UNIX File Abstraction for General-Purpose Networking[link inativo 2024-01-13 ⓘ]:\n\nTodo arquivo em um sistema GNU/Linux pertence a um usuário e a um grupo. Além disso, existem três tipos de permissões de acesso: ler, escrever e executar. Permissões de acesso diferentes podem ser aplicadas ao usuário dono de um arquivo, grupo dono e outros (aqueles que não são usuários nem do grupo dono). Pode-se determinar os donos e permissões de um arquivo ao visualizar o formato de listagem longa do comando ls:\n\n```\n$ ls -l /boot/\n```\n\n```\ntotal 13740\ndrwxr-xr-x 2 root root    4096 Jan 12 00:33 grub\n-rw-r--r-- 1 root root 8570335 Jan 12 00:33 initramfs-linux-fallback.img\n-rw-r--r-- 1 root root 1821573 Jan 12 00:31 initramfs-linux.img\n-rw-r--r-- 1 root root 1457315 Jan  8 08:19 System.map26\n-rw-r--r-- 1 root root 2209920 Jan  8 08:19 vmlinuz-linux\n```\n\nA primeira coluna exibe as permissões do arquivo (por exemplo, o arquivo initramfs-linux.img possui permissões -rw-r-r--). As terceira e quarta colunas exibem o usuário e o grupo que possuem o arquivo, respectivamente. Neste exemplo, todos os arquivos pertencem ao usuário root e do grupo root.\n\n```\n$ ls -l /media/\n```\n\n```\ntotal 16\ndrwxrwx--- 1 root vboxsf 16384 Jan 29 11:02 sf_Shared\n```\n\nNeste exemplo, o diretório sf_Shared pertence ao usuário root e do grupo vboxsf. Também é possível determinar os donos e as permissões do arquivo usando o comando stat:\n\nUsuário dono:\n\n```\n$ stat -c %U /media/sf_Shared/\n```\n\n```\nroot\n```\n\nGrupo dono:\n\n```\n$ stat -c %G /media/sf_Shared/\n```\n\n```\nvboxsf\n```\n\nDireitos de acesso:\n\n```\n$ stat -c %A /media/sf_Shared/\n```\n\n```\ndrwxrwx---\n```\n\nAs permissões de acesso são exibidas em três grupos de caracteres, representando as permissões do usuário dono, grupo dono e outros, respectivamente. Por exemplo, os caracteres -rw-r-r-- indicam que o dono do arquivo tem permissão de leitura e gravação, mas não de execução (rw-), enquanto os usuários pertencem ao grupo dono e outros usuários só têm permissão de leitura (r-- e r--). Enquanto isso, os caracteres drwxrwx--- indicam que o dono do arquivo e os usuários pertencentes ao grupo dono possuem permissões de leitura, gravação e execução (rwx e rwx), enquanto outros usuários têm acesso negado (---). O primeiro caractere representa o tipo do arquivo.\n\nListe arquivos que pertencem a um usuário ou grupo com o utilitário find:\n\n```\n# find / -group grupo\n```\n\n```\n# find / -group númerogrupo\n```\n\n```\n# find / -user usuário\n```\n\nO usuário e o grupo donos de um arquivo podem ser alterados com o comando chown (change owner ou mudar o dono). As permissões de acesso a um arquivo podem ser alteradas com o comando chmod (change mode ou mudar o modo).\n\nVeja chown(1), chmod(1) e Permissões de acesso a arquivos e diretórios para detalhes adicionais.\n\n"
    },
    {
      "title": "Shadow",
      "level": 2,
      "content": "As ferramentas de gerenciamento de usuários, grupos e senhas no Arch Linux vem com o pacote shadow, que é uma dependência do metapacote base.\n\n"
    },
    {
      "title": "Lista de arquivos",
      "level": 2,
      "content": "Table content:\nArquivo | Propósito\n/etc/shadow | Informações da conta do usuário seguras\n/etc/passwd | Informações da conta do usuário\n/etc/gshadow | Contém a \"sombra\" da informação para contas de grupo\n/etc/group | Define os grupos para aos quais os usuários pertencem\n\n"
    },
    {
      "title": "Gerenciamento de usuário",
      "level": 2,
      "content": "Para listar os usuários conectados no sistema, o comando who pode ser usado. Para listar todas as contas de usuários existentes, incluindo suas propriedades armazenadas na base de dados de usuário, execute passwd -Sa como root. Veja passwd(1) para a descrição do formato de saída.\n\nPara adicionar um novo usuário, use o comando useradd:\n\n```\n# useradd -m -G grupos_adicionais -s shell_de_login nome_de_usuário\n```\n\nSe um grupo inicial do usuário for especificado por nome e número, deve se referir a um grupo já existente. Se não especificado, o comportamento de useradd vai depender da variável USERGROUPS_ENAB contida em /etc/login.defs. O comportamento padrão (USERGROUPS_ENAB yes) é criar um grupo com o nome igual ao nome de usuário.\n\nQuando o shell de login destina-se a ser não funcional, por exemplo quando a conta de usuário é criada para um serviço específico, /usr/bin/nologin pode ser especificado no lugar de uma shell comum para educadamente recusar um login (veja nologin(8)).\n\nVeja useradd(8) para outras opções suportadas.\n\n"
    },
    {
      "title": "Exemplo de adicionar um usuário",
      "level": 3,
      "content": "Para adicionar um novo usuário chamado archie, crar seu diretório pessoal e, do contrário, usando todos os padrões nos termos de grupos, nomes de pastas, shell usado e vários outros parâmetros:\n\n```\n# useradd -m archie\n```\n\nApesar de ser obrigatório proteger o recém criado usuário archie com uma senha, é altamente recomendado fazê-lo:\n\n```\n# passwd archie\n```\n\nO comando useradd acima pode também criar automaticamente um grupo chamado archie e torna este o grupo padrão para o usuário archie. Fazer com que cada usuário tenha seu próprio grupo (com o nome do grupo igual ao nome do usuário) é a maneira preferida de adicionar usuários.\n\nVocê poderia fazer o grupo padrão alguma outra coisa usando a opção -g, mas note que, em sistemas multiusuários, o uso de um único grupo padrão (por exemplo, users) para cada usuário não é recomendado. A razão é que, tipicamente, o método para facilitar o acesso de gravação compartilhada para grupos específicos de usuários é definir o valor umask do usuário para 002, o que significa que o grupo padrão sempre terá, por padrão, acesso de gravação a qualquer arquivo que você crie. Veja também User Private Groups. Se um usuário deve ser um membro de um grupo específico, especifique aquele grupo como um grupo suplementar ao criar o usuário.\n\nNo cenário recomendado, onde o grupo padrão tem o mesmo nome que o nome do usuário, todos os arquivos são somente graváveis para o usuário que os criou. Para permitir o acesso de gravação a um grupo específico, os arquivos/pastas compartilhados podem ser gravados por padrão para todos neste grupo e o grupo dono pode ser fixado automaticamente no grupo que possui o diretório pai configurando o bit setgid neste diretório:\n\n```\n# chmod g+s nosso_diretório_compartilhado\n```\n\nCaso contrário, o grupo padrão do criador do arquivo (geralmente o mesmo que o nome do usuário) é usado.\n\nSe uma mudança de GID for necessária temporariamente, você também pode usar o comando newgrp para alterar o GID padrão do usuário para outro GID em tempo de execução. Por exemplo, depois de executar newgrp nomegrupo, os arquivos criados pelo usuário serão associados ao GID nomegrupo, sem requerer um novo login. Para voltar ao GID padrão, execute newgrp sem um nome de grupo.\n\n"
    },
    {
      "title": "Exemplo de adicionar um usuário do sistema",
      "level": 3,
      "content": "Os usuários do sistema podem ser usados para executar processos/daemons em um usuário diferente, protegendo (por exemplo, com chown) arquivos e/ou diretórios e mais exemplos de hardening do computador.\n\nCom o seguinte comando, um usuário do sistema sem acesso ao shell e sem um diretório home é criado (opcionalmente, anexe o parâmetro -U para criar um grupo com o mesmo nome que o usuário e adicione o usuário para este grupo):\n\n```\n# useradd -r -s /usr/bin/nologin nome_de_usuário\n```\n\nSe o usuário do sistema exige um ID de usuário e grupo específico, especifique-os com as opções -u/--uid e -g/--gid ao criar o usuário:\n\n```\n# useradd -r -u 850 -g 850 -s /usr/bin/nologin nome_de_usuário\n```\n\n"
    },
    {
      "title": "Alterar um nome de login ou diretório home do usuário",
      "level": 3,
      "content": "Para alterar o diretório home do usuário:\n\n```\n# usermod -d /meu/novo/home -m nome_de_usuário\n```\n\nA opção -m também cria automaticamente o novo diretório e move o conteúdo para lá.\n\nNote: **não** Certifique-se de que não haja / ao final de /meu/novo/home.\n\n```\n# ln -s /meu/novo/home/ /meu/antigo/home\n```\n\nCertifique-se de que não haja / ao final de /meu/novo/home.\n\nPara alterar o nome de login de um usuário:\n\n```\n# usermod -l novo_nome antigo_nome\n```\n\nAlterar um nome de usuário é seguro e fácil quando feito corretamente, basta usar o comando usermod. Se o usuário estiver associado a um grupo com o mesmo nome, você pode renomear isso com o comando groupmod.\n\nAlternativamente, o arquivo /etc/passwd pode ser editado diretamente, veja #Base de dados de usuários para uma introdução ao seu formato.\n\nTambém tenha em mente as notas a seguir:\n\n- Se você estiver usando sudo, certifique-se de atualizar o /etc/sudoers para refletir o(s) novo(s) usuário(s) (via o comando visudo como root).\n- Os crontabs pessoais precisam ser ajustados renomeando o arquivo do usuário em /var/spool/cron do nome antigo para o novo, e depois abrindo com crontab -e para alterar os caminhos relevantes e fazê-lo ajustar as permissões do arquivo.\n- O conteúdo das pastas e dos arquivos pessoais do wine em ~/.wine/drive_c/users, ~/.local/share/applications/wine/Programs e possivelmente mais, precisam ser renomeados/editados manualmente.\n- Certos complementos do Thunderbird, como o Enigmail, podem precisar ser reinstalados.\n- Qualquer coisa no seu sistema (atalhos da área de trabalho, scripts de shell, etc.) que usa um caminho absoluto para seu diretório home (ou seja, /home/antigo_nome) precisará ser alterado para refletir seu novo nome. Para evitar esses problemas em scripts de shell, use as variáveis ~ ou $HOME para diretórios home.\n- Além disso, não se esqueça de editar adequadamente os arquivos de configuração em /etc que dependem de seu caminho absoluto (p.ex., Samba, CUPS, etc.). Uma boa maneira de aprender quais arquivos você precisa atualizar envolve o uso do comando grep desta maneira: grep -r antigo_usuário *\n\n"
    },
    {
      "title": "Outros exemplos de gerenciamento de usuário",
      "level": 3,
      "content": "Para adicionar um usuário a outros grupos, use (grupos_adicionais é uma lista separada por vírgula):\n\n```\n# usermod -aG grupos_adicionais nome_de_usuário\n```\n\nPara inserir informações do usuário para o comentário GECOS (ex. o nome completo do usuário), digite:\n\n```\n# chfn nome_de_usuário\n```\n\n(dessa forma, chfn é executado em modo interativo).\n\nAlternativamente, o comentário GECOS pode ser definido mais livremente com:\n\n```\n# usermod -c \"Comentário\" nome_de_usuário\n```\n\nPara marcar a senha de um usuário como expirada, exigindo que ele crie uma nova senha na primeira vez que fizerem login, digite:\n\n```\n# chage -d 0 nome_de_usuário\n```\n\nContas de usuário podem ser excluídas com o comando userdel:\n\n```\n# userdel -r nome_de_usuário\n```\n\nA opção -r especifica que o diretório home do usuário e o spool de correios também devem ser excluídos.\n\nPara alterar o shell de login do usuário:\n\n```\n# usermod -s /bin/bash nome_de_usuário\n```\n\n"
    },
    {
      "title": "Base de dados de usuários",
      "level": 2,
      "content": "As informações do usuário local são armazenadas no arquivo de texto simples /etc/passwd: cada uma das suas linhas representa uma conta de usuário e tem sete campos delimitados por caracteres de dois pontos.\n\n```\nconta:senha:UID:GID:GECOS:diretório:shell\n```\n\nSendo que:\n\n- conta é o nome de usuário. Esse campo não pode estar vazio. Padrão regras de nomeação *NIX aplicam-se.\n- senha é a senha do usuário. Atenção: O arquivo passwd é legível por todos, então armazenar senhas (em hash ou de outra forma) neste arquivo é inseguro. Em vez disso, o Arch Linux usa senhas em shadow: o campo senha conterá um caractere reservado (x) indicando que a senha em hash está salva no arquivo de acesso restrito /etc/shadow. Por esse motivo, é recomendado sempre alterar senhas usando o comando passwd.\n- UID é a identificação numérica de usuário. No Arch, o nome do primeiro login (após o root) para o chamado usuário normal, em oposição a serviços, tem UID 1000, por padrão; entradas subsequentes de UID para usuários devem ser maiores que 1000.\n- GID é a identificação numérica de grupo primário para o usuário. Valores numéricos para GIDs são listados em /etc/group.\n- GECOS é um campo opcional com propósitos informacionais; geralmente, ele contém o nome completo do usuário, mas também pode ser usado por serviços, como o finger, e gerenciado com o comando chfn. Esse campo é opcional e pode ser deixado em branco.\n- diretório é usado pelo comando de login para definir a variável de ambiente $HOME. Vários serviços com seus próprios usuários usam /, mas os usuários normais costumam definir uma pasta em /home.\n- shell é o caminho para o shell de comandos padrão do usuário. Esse campo é opcional e tem como padrão /bin/bash.\n\nNote: **passwd** \n\nExemplo:\n\n```\njoao:x:1001:1003:João da Silva,algum comentário aqui,,:/home/joao:/bin/bash\n```\n\nExpandindo, isso significa: usuário joao, cuja senha está em /etc/shadow, cujo UID é 1001 e cujo grupo primário é 1003. João da Silva é o nome completo dele e existe um comentário associado a sua conta; Seu diretório inicial é /home/joao e ele está usando Bash.\n\nO comando pwck pode ser usado para verificar a integridade da base de dados de usuário. Ele pode ordenar a lista de usuários por GID ao mesmo tempo, o que pode ser útil para comparação:\n\n```\n# pwck -s\n```\n\n"
    },
    {
      "title": "Gerenciamento de grupo",
      "level": 2,
      "content": "/etc/group é o arquivo que define os grupos no sistema (veja group(5) para detalhes). Há também seu companheiro gshadow que raramente é usado. Seus detalhes estão em gshadow(5).\n\nMostre associação a grupos com o comando groups:\n\n```\n$ groups usuário\n```\n\nSe usuário for omitido, os nomes de grupos do usuário atual são exibidos.\n\nO comando id fornece detalhes adicionais, tal como o UID do usuário e GIDs associados:\n\n```\n$ id usuário\n```\n\nPara listar todos os grupos no sistema:\n\n```\n$ cat /etc/group\n```\n\nCrie novos grupos com o comando groupadd:\n\n```\n# groupadd grupo\n```\n\nAdicione usuários a um grupo com o comando gpasswd (veja FS#58262 a cerca de erros; alternativamente, o comando usermod pode ser usado):\n\n```\n# gpasswd -a usuário grupo\n```\n\nModifique um grupo existente com groupmod; por exemplo, para renomear o grupo antigo_grupo para novo_grupo enquanto preserva o gid (todos os arquivos previamente pertencentes ao antigo_grupo serão do novo_grupo):\n\n```\n# groupmod -n novo_grupo antigo_grupo\n```\n\nPara excluir grupos existentes:\n\n```\n# groupdel grupo\n```\n\nPara remover usuários de um grupo antigo:\n\n```\n# gpasswd -d usuário grupo\n```\n\nO comando grpck pode ser usado para verificar a integridade dos arquivos de grupo do sistema.\n\nAtualizações ao pacote filesystem criam arquivos .pacnew. Ao contrário dos arquivos .pacnew para o #Gerenciamento de usuário, essas alterações podem ser ignoradas/removidas, porque o script de instalação adiciona quaisquer novos grupos exigidos.\n\n"
    },
    {
      "title": "Lista de grupos",
      "level": 2,
      "content": "Essa seção explica o propósito dos grupos essenciais do pacote core/filesystem. Há muitos outros grupos, que serão criados com o GID correto quando o pacote relevante for instalado. Veja a página principal do software para detalhe.\n\n"
    },
    {
      "title": "Grupos de usuário",
      "level": 3,
      "content": "Usuários não root de estação de trabalho ou desktop frequentemente precisam ser adicionados a alguns dos grupos a seguir para permitir acesso a periféricos de hardware e facilitar administração de sistema:\n\nTable content:\nGrupo | Arquivos afetados | Propósito\nadm |  | Grupo administrativo, geralmente usado para fornecer acesso de leitura a logs protegidos. Tem acesso total de leitura aos arquivos de journal.\nftp | /srv/ftp/ | Acesso a arquivos servidos por servidores FTP.\ngames | /var/games | Acesso a alguns softwares de jogos.\nhttp | /srv/http/ | Acesso a arquivos servidos por servidores HTTP.\nlog |  | Acesso a arquivos de registros de log em /var/log/ criados pelo syslog-ng.\nrfkill | /dev/rfkill | Direito para controlar estado de energia de dispositivos sem fio (usado pelo rfkill).\nsys |  | Direito para administrar impressoras no CUPS.\nsystemd-journal | /var/log/journal/* | Pode ser usado para fornecer acesso somente leitura aos logs do systemd, como uma alternativa ao adm e ao wheel [1]. Do contrário, apenas mensagens geradas pelo usuário são exibidas.\nuucp | /dev/ttyS[0-9]+, /dev/tts/[0-9]+, /dev/ttyUSB[0-9]+, /dev/ttyACM[0-9]+, /dev/rfcomm[0-9]+ | Portas seriais RS-232 e dispositivos conectados a elas.\nwheel |  | Grupo administrativo, comumente usado a dar privilégios para realizar ações administrativas. Também tem acesso total de leitura aos arquivos de journal. Pode também ser usado para dar acesso aos utilitários sudo e su (nenhum deles usa-o por padrão, sendo configurável em /etc/pam.d/su e /etc/pam.d/su-l).\n\n"
    },
    {
      "title": "Grupos de sistema",
      "level": 3,
      "content": "Os seguintes grupos são usados para propósitos de sistema, uma atriubuição para usuários é necessária apenas para propósitos dedicados:\n\nTable content:\nGrupo | Arquivos afetados | Propósito\ndbus |  | Usado internamente pelo dbus\nkmem | /dev/port, /dev/mem, /dev/kmem | \nlocate | /usr/bin/locate, /var/lib/locate, /var/lib/mlocate, /var/lib/slocate | Veja Locate.\nlp | /dev/lp[0-9]*, /dev/parport[0-9]* | Acesso a dispositivos de porta paralela (impressoras e outros).\nmail | /usr/bin/mail | \nnobody |  | Grupo sem privilégios.\nproc | /proc/pid/ | Um grupo autorizado a aprender informação de processo que, do contrário, seria proibido pela opção de montagem hidepid= do sistema de arquivos proc. O grupo deve ser definido explicitamente com a opção de montagem gid=.\nroot | /* | Administração e controle total do sistema (root, admin).\nsmmsp |  | Grupo do sendmail.\ntty | /dev/tty, /dev/vcc, /dev/vc, /dev/ptmx | \nutmp | /run/utmp, /var/log/btmp, /var/log/wtmp | \n\n"
    },
    {
      "title": "Grupos pré-systemd",
      "level": 3,
      "content": "Antes do Arch migrar para o systemd, os usuários tinham que ser adicionados manualmente a esses grupos para poder acessar os dispositivos correspondentes. Essa forma se tornou obsoleta em favor do udev marcar os dispositivos com uma etiqueta uaccess e logind atribuindo as permissões aos usuários de forma dinâmica via ACLs de acordo com qual sessão está atualmente ativa. Observe que a sessão não deve ser quebrada para que isso funcione (consulte Solução de problemas gerais#Permissões de sessão).\n\nExistem algumas exceções notáveis que exigem a adição de um usuário a alguns desses grupos: por exemplo, se você quiser permitir que os usuários acessem o dispositivo mesmo quando não estiverem logados. No entanto, observe que adicionar usuários aos grupos pode até fazer alguma funcionalidade quebrar (por exemplo, o grupo audio irá quebrar a troca rápida de usuários e permite que os aplicativos bloqueiem o mixer de software).\n\nTable content:\nGrupo | Arquivos afetados | Propósito\naudio | /dev/audio, /dev/snd/*, /dev/rtc0 | Acesso direto ao hardware de som, para todas as sessões. Ainda é necessário fazer ALSA (Português) e OSS funcionar nas sessões remotas, veja ALSA#User privileges. Também é usado no JACK para fornecer aos usuários permissões de processamento em tempo real.\ndisk | /dev/sd[a-zA-Z]*[1-9]* | Acesso para bloquear dispositivos não afetados por outros grupos, como optical, floppy e storage.\nfloppy | /dev/fd[0-9]* | Acesso a unidades de disquete.\ninput | /dev/input/event[0-9]*, /dev/input/mouse[0-9]* | Acesso a dispositivos de entrada. Introduzido no systemd 215 [2].\nkvm | /dev/kvm | Aceso a máquinas virtuais usando KVM.\noptical | /dev/sr[0-9], /dev/sg[0-9] | Acesso a dispositivos óticos, como unidades de CD e DVD.\nscanner | /var/lock/sane | Acesso a hardware de scanner.\nstorage | /dev/st[0-9]*[lma]*, /dev/nst[0-9]*[lma]* | Usado para ganhar acesso a unidades removíveis, como as unidades de HD externo USB, pendrives, MP3 players; permite ao usuário montar dispositivos de armazenamento.[3] Agora, apenas para acesso direto às fitas, se nenhuma regra personalizada do udev estiver envolvida.[4][5][6][7]\nvideo | /dev/fb/0, /dev/misc/agpgart | Acesso a dispositivos de captura de vídeo, aceleração hardware 2D/3D, framebuffer (X pode ser usado sem pertencer a este grupo).\n\n"
    },
    {
      "title": "Grupos sem uso",
      "level": 3,
      "content": "Os seguintes grupos estão atualmente sem uso para qualquer propósito:\n\nTable content:\nGrupo | Arquivos afetados | Propósito\nbin | nenhum | Histórico\ndaemon |  | \nlock |  | Usado para acesso a arquivo de trava. Necessário para, por exemplo, gnokiiAUR.\nmem |  | \nnetwork |  | Sem uso por padrão. Pode ser usado, por exemplo, para conceder acesso ao NetworkManager (veja NetworkManager (Português)#Configurar as permissões de PolicyKit).\npower |  | \nuuidd |  | \nusers |  | O grupo primário para usuários quando os grupos privados de usuários não são usados (geralmente não recomendado), por exemplo, ao criar usuários com USERGROUPS_ENAB no em /etc/login.defs ou a opção -N/--no-user-group de useradd.\n\n"
    },
    {
      "title": "Outras ferramentas relacionadas para esses banco de dados",
      "level": 2,
      "content": "getent(1) pode ser usado para ler um registro em particular.\n\n```\n% getent group tty\n```\n\nConforme avisado em #Base de dados de usuários, o uso de utilitários específicos, como passwd e chfn, é uma maneira melhor de alterar os bancos de dados. Mesmo assim, há momentos em que editá-los diretamente é cuidada. Para aqueles momentos, vipw, vigr são fornecidos. É altamente recomendável usar esses editores sob medida usando um editor de texto geral, pois eles bloqueiam os bancos de dados em relação à edição simultânea. Eles também ajudam a evitar entradas inválidas e/ou erros de sintaxe. Observe que o Arch Linux prefere o uso de ferramentas específicas, como chage, para modificar o banco de dados shadow usando vipw -s e vigr -s do util-linux. Veja também FS#31414.\n\n"
    }
  ]
}