{
  "title": "ZFS Installation",
  "url": "https://wiki.archlinux.org/title/ZFS_Installation",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- File systems\n- ZFS/Virtual disks\n- Install Arch Linux on ZFS\n\nZFS is an advanced filesystem, originally developed and released by Sun Microsystems for the solaris operating system. Nowadays ZFS usually refers to the fork OpenZFS, which ports the original implementation to other operating systems, including Linux, while continuing the development of solaris ZFS. This article will treat ZFS as synonmous with OpenZFS.\n\nZFS is featureful. Features of ZFS include: an improved page cache algorithm: ARC, deduplication, pooled storage, snapshots, replication, data integrity verification and automatic repair (scrubbing), RAID-Z and much more.\n\n"
    },
    {
      "title": "Concepts",
      "level": 2,
      "content": "Unlike regular filesystems where a filesystem reside on a single block device, ZFS stores data in storage pools. Pools are composed of vdevs (virtual devices) which are themselves composed of block devices. Pools always write data to the vdev with most percentage of free space (so data are naturally striped across vdevs). Vdevs on the other hand can use more complex configurations such as RAIDZ and mirror. In the simplest configuration a pool can be created on a single vdev composed of a single partition, which behaves similar to regular filesystems.\n\nOnce created, storage resources can be allocated from the pool. Such resources are groupd into units of what called datasets. There are 4 types of datasets:\n\n1. file system: File systems are basically a directory tree and can be mounted like regular filesystems into the system namespace.\n1. volume (zvol): A volume represented as a block device\n1. snapshot: A snapshot of a file system or a volume\n1. bookmark: A snapshot that does not hold data, used for incremental replication.\n\nDataset are identified by a unique path with the following syntax:\n\n```\npool(/segment)+((#|@)bookmark/snapshot name)?\n```\n\nwhere # is used for bookmarks and @ is used for snapshots.\n\n"
    },
    {
      "title": "Complications of being out-of-tree",
      "level": 2,
      "content": "Due to complex legal reasons, the Linux kernel maintainers refuse to accept ZFS into the linux kernel. As such, ZFS is developed as an out-of-tree module. A consequence of this arrangement is that kernel updates will break the kernel API that ZFS uses from time to time. Whenever this happens, ZFS would have to change their code to adapt to this new API. This means there will be a time period where ZFS does not work on the latest mainline kernel release.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "As an out-of-tree module, there are 2 types of packages you can choose to install. Either installing it as a binary kernel module built against a specific kernel version or installing its source as a DKMS module that gets automatically rebuilt anytime the kernel updates.\n\nIn addition to the kernel modules, users would also need to install userspaces tools such as zpool(8) and zfs(8). These userspace tools are usually packaged as a single package called zfs-utils*.\n\nAll of the kernel module packages mentioned below correctly specified their dependency on their corresponding zfs-utils* packages so when installing you just need to satisfy their dependency.\n\n"
    },
    {
      "title": "Binary kernel module",
      "level": 3,
      "content": "Table content:\nPackage | Repository | ZFS release type | Targeting kernel | Binary package | Notes\nzfs-linux-ltsAUR | AUR | Stable | linux-lts | No | Highly recommended to use devtools when building newer versions of the ZFS package as otherwise you'd have to uninstall your current ZFS package to upgrade the kernel.\nzfs-linuxAUR | AUR | Stable | linux | No\nzfs-linux-lts-poscat | archlinuxcn | Stable | linux-lts | Yes | Automatically updated and rebuilt against new kernel versions by a build bot every few hours, additionally provides a mkinitcpio hook for systemd based initrds\nzfs-linux-lts-rc-poscat | archlinuxcn | Release candidate | linux-lts | Yes\nzfs-linux | archzfs | Stable | linux | Yes | \nzfs-linux-lts | archzfs | Stable | linux-lts | Yes | \n\n"
    },
    {
      "title": "DKMS",
      "level": 3,
      "content": "- zfs-dkmsAUR: stable release\n- zfs-dkms-staging-gitAUR: stable release with cherry picked patches for compatibility with latest linux kernel\n\n"
    },
    {
      "title": "Root on ZFS",
      "level": 3,
      "content": "See Install Arch Linux on ZFS.\n\n"
    },
    {
      "title": "Importing pools at startup",
      "level": 3,
      "content": "ZFS provides systemd services for automatically importing pools and targets for other units to determine the state of ZFS initialization. These are:\n\n- zfs.target which is reached when all ZFS services completes\n- zfs-import.target which is reached when ZFS pools finish importing\n- zfs-volumes.target which is reached when zvols all appear under /dev\n- zfs-import-scan.service which imports pools by scanning for devices using libblkid\n- zfs-import-cache.service which imports pools by consulting a zpool.cache file\n- zfs-volume-wait.service which waits for all zvols to be available.\n\nYou should choose one between zfs-import-scan.service and zfs-import-cache.service and enable the rest.\n\n"
    },
    {
      "title": "zfs-import-scan",
      "level": 4,
      "content": "zfs-import-scan.service uses zpool import's default logic of scanning devices using blkid, this means no zpool.cache files are needed. This is the recommended method since zpool.cache is deprecated.\n\nIt is important to make sure none of your pools are imported with the cachefile option enabled since zfs-import-scan.service will not start if zpool.cache exists and is not empty. You can achieve this by enabling the zfs_autoimport_disable option of the zfs module. You should also either remove the existing zpool.cache or setting cachefile to none for all imported pools when booting.\n\n"
    },
    {
      "title": "zfs-import-cache",
      "level": 4,
      "content": "zfs-import-cache.service uses zpool import -c <zpool.cache> when importing pools which reads device paths from the zpool.cache.\n\nUsing this method means you need to be conscious about the device paths while creating ZFS pools, since some device paths may change between boots or hardware modifications, which would lead to stale cache and failure of pool imports. See Persistent block device naming on how to choose devices paths that are persistent.\n\n"
    },
    {
      "title": "Automatically mounting filesystems",
      "level": 3,
      "content": "The services zfs-import-scan.service and zfs-import-cache.service will import the pools without mounting any filesystems. To also mount filesystems on startup there are 2 methods, depending on if your filesystems are configured using mountpoint=legacy or not. If your filesystems are configured with a mix of legacy mount and non-legacy mount you'll need to use both methods.\n\n"
    },
    {
      "title": "zfs-mount-generator",
      "level": 4,
      "content": "If your filesystems use non-legacy mount, it is recommended to use zfs-mount-generator, which is a systemd.generator(7) that generates systemd mount units for all filesystems of imported zfs pools with the property canmount=on to mount filesystems on boot. By default though zfs-mount-generator won't do anything since it requires zfs list caches. You need to:\n\n1. Enable and start zfs-zed.service.\n1. Create the /etc/zfs/zfs-list.cache directory. # mkdir -p /etc/zfs/zfs-list.cache\n1. Enable tracking for individual pools by creating empty files named after your pools in /etc/zfs/zfs-list.cache/. Zed will only update the list of filesystems if the file for the pool already exists and is writable. # touch /etc/zfs/zfs-list.cache/pool-name\n1. Check the contents of /etc/zfs/zfs-list.cache/pool-name. If it is empty, zed has not detected any events and therefore has not refreshed the cache file. Change a monitored property somewhere on the pool to emit a new ZFS event which will trigger the ZEDLET and refresh the cache file. The first example below assumes relatime is enabled on the pool zroot and that it is inherited by the child filesystem fs1. Trigger an event by changing a property and then reverting it: # zfs set relatime=off zroot/fs1 # zfs inherit relatime zroot/fs1 If inherit is not available (e.g. you are working with the root pool) simply make the change on the pool itself and revert it manually rather than using inherit:# zfs set relatime=off zroot # zfs set relatime=on zroot\n1. You can check the file from step 3 to make sure it is populated. The pool will now be mounted on boot. Reboot to see it mounted, or restart zfs-zed.service.\n\n```\n# mkdir -p /etc/zfs/zfs-list.cache\n```\n\n```\n# touch /etc/zfs/zfs-list.cache/pool-name\n```\n\n```\n# zfs set relatime=off zroot/fs1\n# zfs inherit relatime zroot/fs1\n```\n\n```\n# zfs set relatime=off zroot\n# zfs set relatime=on zroot\n```\n\n"
    },
    {
      "title": "fstab",
      "level": 4,
      "content": "If your filesystem uses legacy mount, then you should specify the mountpoint in the fstab file. The device field should be the name (full path) of your filesystem and the dump and fsck fields should be left as 0.\n\n"
    },
    {
      "title": "Creating a hostid file",
      "level": 3,
      "content": "While not strictly necessary, it is usually a good idea to create a /etc/hostid file:\n\n```\n# zgenhostid $(hostid)\n```\n\n"
    },
    {
      "title": "Experimenting with ZFS",
      "level": 3,
      "content": "Users wishing to experiment with ZFS with no possibility of real data loss can refer to ZFS/Virtual disks.\n\n"
    },
    {
      "title": "Creating ZFS pools",
      "level": 3,
      "content": "To create a ZFS pool:\n\n```\n# zpool create -R <root> -o <poolopts> -O <dsetprops> <pool> <vdevs>\n```\n\nWhere each vdev is either a device or has the format:\n\n```\n<vdev type> <device> ... <device>\n```\n\n- -R: Mounts all filesystems under this directory, useful for not interfering with existing system\n- -o: Specifies the properties of the pool, can be used multiple times. Some properties such as ashift cannot be changed once created. (technically ashift is per vdev but to configure it per vdev you'll need to use zpool add)\n- -O: Specifies the properties of the root dataset of the pool, can be used multiple times. Some properties such as normalization cannot be changed once created.\n- pool: This is the name of the pool.\n- vdev type: See zpoolconcepts(7) for a list of supported vdev types.\n- device: A block device, can be either a full path or the file name part of the path\n\nFor example, to create a pool on a single partition:\n\n```\n# zpool create -R /mnt pool /dev/sda\n```\n\nTo create a pool with a single raidz1 vdev:\n\n```\n# zpool create -R /mnt pool \\\n               raidz1 \\\n                  ata-ST3000DM001-9YN166_S1F0KDGY \\\n                  ata-ST3000DM001-9YN166_S1F0JKRR \\\n                  ata-ST3000DM001-9YN166_S1F0KBP8 \\\n                  ata-ST3000DM001-9YN166_S1F0JTM1\n```\n\nTo create a pool with two mirror vdevs:\n\n```\n# zpool create -R /mnt pool \\\n               mirror \\\n                  ata-ST3000DM001-9YN166_S1F0KDGY \\\n                  ata-ST3000DM001-9YN166_S1F0JKRR \\\n               mirror \\\n                  ata-ST3000DM001-9YN166_S1F0KBP8 \\\n                  ata-ST3000DM001-9YN166_S1F0JTM1\n```\n\n"
    },
    {
      "title": "The ashift property",
      "level": 4,
      "content": "ashift is an immutable per-vdev property that determines the (logical) sector size, which is 2^ashift bytes. For optimal performance, the logical sector size should always be greater than or equal to the physical sector size of the disks.\n\nBy default, zpool create should be able to correctly determine the physical sector size of the device. This should suffice in a single disk setup.\n\nHowever, if you are (or intend to) using vdev setups that can replace failed disks, such as mirror or raidzX, it is usually a good idea to always use ashift=12, since using 4kb logical sector size on a 512b physical disk won't have a performance penalty while the converse will. (unless your devices are the few rare SSDs that uses an 8kb sector size)\n\nNote: to check the physical sector sizes of your disks.\n\n```\n$ lsblk --filter 'TYPE==\"DISK\"' -o NAME,PHY-SEC\n```\n\nto check the physical sector sizes of your disks.\n\nAdditionally, if you are using NVMe drives, it might be possible to format it using a more performant LBA format than the factory default (see nvme-format(1)).\n\n"
    },
    {
      "title": "GRUB-compatible pool creation",
      "level": 4,
      "content": "By default, zpool create enables all features on a pool. If /boot resides on ZFS when using GRUB you must only enable features supported by GRUB otherwise GRUB will not be able to read the pool. ZFS includes compatibility files (see /usr/share/zfs/compatibility.d) to assist in creating pools at specific feature sets, of which grub2 is an option.\n\nYou can create a pool with only the compatible features enabled:\n\n```\n# zpool create -o compatibility=grub2 $POOL_NAME $VDEVS\n```\n\n"
    },
    {
      "title": "Verifying pool status",
      "level": 3,
      "content": "If the command is successful, there will be no output. Using the mount command will show that the pool is mounted. Using zpool status will show that the pool has been created:\n\n```\n# zpool status\n```\n\n```\npool: bigdata\n state: ONLINE\n scan: none requested\nconfig:\n\n        NAME                                       STATE     READ WRITE CKSUM\n        bigdata                                    ONLINE       0     0     0\n          -0                                       ONLINE       0     0     0\n            ata-ST3000DM001-9YN166_S1F0KDGY-part1  ONLINE       0     0     0\n            ata-ST3000DM001-9YN166_S1F0JKRR-part1  ONLINE       0     0     0\n            ata-ST3000DM001-9YN166_S1F0KBP8-part1  ONLINE       0     0     0\n            ata-ST3000DM001-9YN166_S1F0JTM1-part1  ONLINE       0     0     0\n\nerrors: No known data errors\n```\n\n"
    },
    {
      "title": "Importing a pool created by id",
      "level": 3,
      "content": "In accordance with the zpool-import.8 manual, to import an existing pool you need to use flags:\n\n- -c cachefile Reads configuration from the given cachefile that was created with the cachefile pool property. This cachefile is used instead of searching for devices.\n\n- -d dir/device Uses device or searches for devices or files in dir. The -d option can be specified multiple times.\n\nTo import an existing pool to run a chroot on it consult Export/Import dei pool(Italiano)\n\n"
    },
    {
      "title": "Destroying a storage pool",
      "level": 3,
      "content": "To destroy a whole pool:\n\n```\n# zpool destroy <pool>\n```\n\nAnd now when checking the status:\n\n```\n# zpool status\n```\n\n```\nno pools available\n```\n\n"
    },
    {
      "title": "Exporting a storage pool",
      "level": 3,
      "content": "To export a pool:\n\n```\n# zpool export <pool>\n```\n\n"
    },
    {
      "title": "Extending an existing pool",
      "level": 3,
      "content": "A device (a partition or a disk) can be added to an existing zpool:\n\n```\n# zpool add <pool> <device-id>\n```\n\n"
    },
    {
      "title": "Attaching a device to (create) a mirror",
      "level": 3,
      "content": "A device (a partition or a disk) can be attached aside an existing device to be its mirror (similar to RAID 1):\n\n```\n# zpool attach <pool> <device-id|mirror> <new-device-id>\n```\n\nYou can attach the new device to an already existing mirror vdev (e.g. to upgrade from a 2-device to a 3-device mirror) or attach it to single device to create a new mirror vdev.\n\n"
    },
    {
      "title": "Renaming a pool",
      "level": 3,
      "content": "Renaming a pool that is already created is accomplished in 2 steps:\n\n```\n# zpool export oldname\n# zpool import oldname newname\n```\n\n"
    },
    {
      "title": "Setting a different mount point",
      "level": 3,
      "content": "The mount point for a given zpool can be moved at will with one command:\n\n```\n# zfs set mountpoint=/foo/bar poolname\n```\n\n"
    },
    {
      "title": "Upgrading pools",
      "level": 3,
      "content": "When upgrading ZFS to a new version, new feature might be available. However for compatibility reasons ZFS won't automatically enable new features on previously created pools. Instead they need to be manually turned on for each pool.\n\nTo check for upgrade availability:\n\n```\n$ zpool upgrade\n```\n\n```\nThis system supports ZFS pool feature flags.\n\nAll pools are formatted using feature flags.\n\nEvery feature flags pool has all supported and requested features enabled.\n```\n\nAn example output with upgradable pools:\n\n```\nThis system supports ZFS pool feature flags.\n\nAll pools are formatted using feature flags.\n\n\nSome supported features are not enabled on the following pools. Once a\nfeature is enabled the pool may become incompatible with software\nthat does not support the feature. See zpool-features(7) for details.\n\nNote that the pool 'compatibility' feature can be used to inhibit\nfeature upgrades.\n\nPOOL  FEATURE\n\nrpool\n      redaction_list_spill\n      raidz_expansion\n      fast_dedup\n      longname\n      large_microzap\n```\n\nTo upgrade a single pool:\n\n```\n# zpool upgrade <pool>\n```\n\nTo upgrade all pools:\n\n```\n# zpool upgrade -a\n```\n\n"
    },
    {
      "title": "Creating datasets",
      "level": 2,
      "content": "Users can optionally create a dataset under the zpool as opposed to manually creating directories under the zpool. Datasets allow for an increased level of control (quotas for example) in addition to snapshots. To be able to create and mount a dataset, a directory of the same name must not pre-exist in the zpool. To create a dataset, use:\n\n```\n# zfs create <nameofzpool>/<nameofdataset>\n```\n\nIt is then possible to apply ZFS specific attributes to the dataset. For example, one could assign a quota limit to a specific directory within a dataset:\n\n```\n# zfs set quota=20G <nameofzpool>/<nameofdataset>/<directory>\n```\n\nTo see all the commands available in ZFS, see zfs(8) or zpool(8).\n\n"
    },
    {
      "title": "Native encryption",
      "level": 3,
      "content": "ZFS offers the following supported encryption options: aes-128-ccm, aes-192-ccm, aes-256-ccm, aes-128-gcm, aes-192-gcm and aes-256-gcm. When encryption is set to on, aes-256-gcm will be used. See zfs-change-key(8) for a description of the native encryption, including limitations.\n\nThe following keyformats are supported: passphrase, raw, hex.\n\nOne can also specify/increase the default iterations of PBKDF2 when using passphrase with -o pbkdf2iters <n>, although it may increase the decryption time.\n\n- To import a pool with keys, one needs to specify the -l flag, without this flag encrypted datasets will be left unavailable until the keys are loaded. See #Importing a pool created by id.\n- Native ZFS encryption has been made available in the stable 0.8.0 release or newer. Previously it was only available in development versions provided by packages like zfs-linux-gitAUR, zfs-dkms-gitAUR or other development builds. Users who were only using the development versions for the native encryption, may now switch to the stable releases if they wish.\n- The default encryption suite was changed from aes-256-ccm to aes-256-gcm in the 0.8.4 release.\n\nTo create a dataset including native encryption with a passphrase, use:\n\n```\n# zfs create -o encryption=on -o keyformat=passphrase <nameofzpool>/<nameofdataset>\n```\n\nTo use a key instead of using a passphrase:\n\n```\n# dd if=/dev/random of=/path/to/key bs=32 count=1 iflag=fullblock\n# zfs create -o encryption=on -o keyformat=raw -o keylocation=file:///path/to/key <nameofzpool>/<nameofdataset>\n```\n\nThe easy way to make a key in human-readable form (keyformat=hex):\n\n```\n# od -Anone -x -N 32 -w64 /dev/random | tr -d [:blank:] > /path/to/hex.key\n```\n\nTo verify the key location:\n\n```\n# zfs get keylocation <nameofzpool>/<nameofdataset>\n```\n\nTo change the key location:\n\n```\n# zfs set keylocation=file:///path/to/key <nameofzpool>/<nameofdataset>\n```\n\nYou can also manually load the keys by using one of the following commands:\n\n```\n# zfs load-key <nameofzpool>/<nameofdataset> # load key for a specific dataset\n# zfs load-key -a # load all keys\n# zfs load-key -r zpool/dataset # load all keys in a dataset\n```\n\nTo mount the created encrypted dataset:\n\n```\n# zfs mount <nameofzpool>/<nameofdataset>\n```\n\n"
    },
    {
      "title": "Unlock/Mount at boot time: systemd",
      "level": 4,
      "content": "It is possible to automatically unlock a pool dataset on boot time by using a systemd unit. For example create the following service to unlock any specific dataset:\n\n```\n/etc/systemd/system/zfs-load-key@.service\n```\n\n```\n[Unit]\nDescription=Load %I encryption keys\nBefore=systemd-user-sessions.service zfs-mount.service\nAfter=zfs-import.target\nRequires=zfs-import.target\nDefaultDependencies=no\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=/usr/bin/bash -c 'until (systemd-ask-password \"Encrypted ZFS password for %I\" --no-tty | zfs load-key %I); do echo \"Try again!\"; done'\n\n[Install]\nWantedBy=zfs-mount.service\n```\n\nEnable/start the service for each encrypted dataset, (e.g. zfs-load-key@pool0-dataset0.service). Note the use of -, which is an escaped / in systemd unit definitions. See systemd-escape(1) for more info.\n\nAn alternative is to load all possible keys:\n\n```\n/etc/systemd/system/zfs-load-key.service\n```\n\n```\n[Unit]\nDescription=Load encryption keys\nDefaultDependencies=no\nAfter=zfs-import.target\nBefore=zfs-mount.service\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=/usr/bin/zfs load-key -a\nStandardInput=tty-force\n\n[Install]\nWantedBy=zfs-mount.service\n```\n\nEnable/start zfs-load-key.service.\n\n"
    },
    {
      "title": "Unlock at login time: PAM",
      "level": 4,
      "content": "If you are not encrypting the root volume, but only the home volume or a user-specific volume, another idea is to wait until login to decrypt it. The advantages of this method are that the system boots uninterrupted, and that when the user logs in, the same password can be used both to authenticate and to decrypt the home volume, so that the password is only entered once.\n\nThere are two methods for unlocking the home dataset: #PAM module or #Custom script. Both methods assume your datasets are structured similar to:\n\n```\n$ zfs list -o name,mountpoint,canmount,encryption\n```\n\n```\nNAME                   MOUNTPOINT        CANMOUNT  ENCRYPTION\nrpool                  /                 on        off\nrpool/home             /home             off       off\nrpool/home/user        /home/user        on        aes-256-gcm\nrpool/home/user/child  /home/user/child  on        aes-256-gcm\n```\n\nReplace rpool/home, user, and child with the values from your setup.\n\nOpenZFS includes a PAM module since 2.0.0. It supports child datasets since 2.3.1.\n\nFirst, use the following:\n\n```\n# zfs set org.openzfs.systemd:ignore=on rpool/home\n```\n\nThis stops systemd from automatically mounting rpool/home. This property will be inherited by all child datasets.\n\nThen create the following file:\n\n```\n/etc/pam.d/zfs-key\n```\n\n```\nauth       optional                    pam_zfs_key.so homes=rpool/home runstatedir=/run/pam_zfs_key mount_recursively\nsession    [success=1 default=ignore]  pam_succeed_if.so service = systemd-user quiet\nsession    optional                    pam_zfs_key.so homes=rpool/home runstatedir=/run/pam_zfs_key mount_recursively\npassword   optional                    pam_zfs_key.so homes=rpool/home runstatedir=/run/pam_zfs_key mount_recursively\n```\n\nmount_recursively may be ommited if there are no child datasets in any of the users' datasets.\n\nFinally, add the following to the beginning of /etc/pam.d/system-auth and /etc/pam.d/su-l:\n\n```\nauth       include      zfs-key\nsession    include      zfs-key\npassword   include      zfs-key\n```\n\nFirst set the mountpoint to legacy to avoid having it mounted by zfs mount -a:\n\n```\n# zfs set mountpoint=legacy rpool/home\n```\n\nEnsure that it is in /etc/fstab so that mount /home will work:\n\n```\n/etc/fstab\n```\n\n```\nrpool/home         /home           zfs             rw,xattr,posixacl,noauto        0 0\n```\n\nAlternatively, you can keep using ZFS mounts if you use both:\n\n```\n# zfs set canmount=noauto rpool/home\n# zfs set org.openzfs.systemd:ignore=on rpool/home\n```\n\nThe first will stop ZFS automatically mounting it, and the second systemd, but you will still be able to manually (or through the following scripts) mount it. If you have child datasets, org.openzfs.systemd:ignore=on will be inherited, but you will need to set canmount=noauto on each as it is not inheritable, otherwise they will try to mount without a mountpoint.\n\nOn a single-user system, with only one /home volume having the same encryption password as the user's password, it can be decrypted at login as follows: first create /usr/local/bin/mount-zfs-homedir\n\n```\n/usr/local/bin/mount-zfs-homedir\n```\n\n```\n#!/bin/bash\nset -eu\n\n# $PAM_USER will be the username of the user, you can use it for per-user home volumes.\nHOME_VOLUME=\"rpool/home\" \n\nif [ \"$(zfs get keystatus \"${HOME_VOLUME}\" -Ho value)\" != \"available\" ]; then\n  PASSWORD=$(cat -)\n  zfs load-key \"${HOME_VOLUME}\" <<< \"$PASSWORD\" || continue\nfi\n\n# This will also mount any child datasets, unless they use a different key.\necho \"$(zfs list -rHo name,keystatus,mounted \"${HOME_VOLUME}\")\" | while IFS=$'\\t' read -r NAME KEYSTATUS MOUNTED; do\n  if [ \"${MOUNTED}\" != \"yes\" ] && [ \"${KEYSTATUS}\" == \"available\" ]; then\n    zfs mount \"${NAME}\" || true\n  fi\ndone\n```\n\ndo not forget to make it executable; then get PAM to run it by adding the following line to /etc/pam.d/system-auth:\n\n```\n/etc/pam.d/system-auth\n```\n\n```\nauth       optional                    pam_exec.so          expose_authtok /usr/local/bin/mount-zfs-homedir\n```\n\nNow it will transparently decrypt and mount the /home volume when you log in anywhere: on the console, via ssh, etc.\n\nA caveat is that since your ~/.ssh directory is not mounted, if you log in via ssh, you must use password authentication the first time rather than relying on ~/.ssh/authorized_keys.\n\nIf you do not wish to enable (insecure) password authentication, you can instead move ~/.ssh/authorized_keys to a new location. Make /etc/ssh/user_config/ and inside it a folder for each user, owned by that user and with 700 permissions. Then move each user's authorized_keys into their respective folders, and edit the system sshd configuration:\n\n```\n/etc/ssh/sshd_config\n```\n\n```\nAuthorizedKeysFile /etc/ssh/user_config/%u/authorized_keys\n```\n\nThen restart sshd.service. You can also optionally make a link for each user from ~/.ssh/authorized_keys to the new location so users can still edit it as they are used to.\n\nThis will let you log in, but your home partition will not be mounted, and you will need to do so manually. There are multiple options to work around this:\n\nIt is possible to set up PAM to only prompt for a password via SSH when it is necessary to decrypt your home partition. You will need to enable both publickey and keyboard-interactive authentication methods:\n\n```\n/etc/ssh/sshd_config\n```\n\n```\nPubkeyAuthentication yes\nKbdInteractiveAuthentication yes\nAuthenticationMethods publickey,keyboard-interactive\n\n## Example of excluding a certain user who does not have an encrypted home directory.\n#Match User nohome\n#  KbdInteractiveAuthentication no\n#  AuthenticationMethods publickey\n```\n\nNote: **either** \n\nThis will mean it asks for the password after validating the key, but using PAM we can stop it asking for the password when not needed. We make a script that will fail when the key is not available to us:\n\n```\n/usr/local/bin/require-encrypted-homedir\n```\n\n```\n#!/bin/bash\nset -eu\n\nHOME_VOLUME=\"zroot/data/home\" # You can use $PAM_USER to use the username in the volume for a per-user solution.\n\nif [ \"$(zfs get keystatus \"${HOME_VOLUME}\" -Ho value)\" != \"available\" ]; then\n  exit 27 # PAM_TRY_AGAIN\nelif [[ \"${SSH_AUTH_INFO_0:-\"\"}\" =~ ^\"publickey \" ]]; then\n  exit 0\nelse\n  # If this happens, it implies a configuration error: either you are allowing auth without a public \n  # key, or have enabled this in a non-SSH PAM service. Both are dangerous and this should block it, \n  # but if you see it, fix your configuration.\n  exit 3 # PAM_SERVICE_ERR\nfi\n```\n\nAnd make it executable.\n\nNow we want to configure PAM to call this, and skip asking for the password if the script succeeds because we already have the key available. Add this line above the existing auth line(s) you want to skip (all of them unless you have something else set up) for the SSH service:\n\n```\n/etc/pam.d/sshd\n```\n\n```\nauth sufficient pam_exec.so /usr/local/bin/require-encrypted-homedir\n```\n\nNote: **not** \n\nWith this, you will be prompted for a password only when the key is not loaded.\n\nA simpler option is to just enable both methods, meaning your key still gets checked, but then you have to type the password too, which will decrypt your home partition.\n\n```\n/etc/ssh/sshd_config\n```\n\n```\nPubkeyAuthentication yes\nPasswordAuthentication yes\nAuthenticationMethods publickey,password\n```\n\nNote: **either** \n\nThis works (and will not let anyone authenticate with just a password), but has the downside of requiring your password every time.\n\nYou can also specify something like:\n\n```\nAuthenticationMethods publickey password,publickey\n```\n\nThis allows clients to either use either just a public key, or one and a password. Which the client will do will be based on the PreferredAuthentications option. -o PreferredAuthentications=password,publickey will ask for the password, while -o PreferredAuthentications=publickey will not. This is more manual than automated fallback, but has less moving parts, and avoids asking you every time if you prefer publickey by default (you can use host-specific options on clients to simplify setting these options).\n\n"
    },
    {
      "title": "Swap volume",
      "level": 3,
      "content": "- On systems with extremely high memory pressure, using a zvol for swap can result in lockup, regardless of how much swap is still available. This issue is currently being investigated in OpenZFS issue #7734\n- Swap on zvol does not support resume from hibernation, attempt to resume will result in pool corruption. Possible workaround: https://github.com/openzfs/zfs/issues/260#issuecomment-758782144\n\nZFS does not allow to use swapfiles, but users can use a ZFS volume (ZVOL) as swap. It is important to set the ZVOL block size to match the system page size, which can be obtained by the getconf PAGESIZE command (default on x86_64 is 4KiB). Another option useful for keeping the system running well in low-memory situations is not caching the ZVOL data.\n\nCreate a 8 GiB zfs volume:\n\n```\n# zfs create -V 8G -b $(getconf PAGESIZE) -o compression=zle \\\n              -o logbias=throughput -o sync=always\\\n              -o primarycache=metadata -o secondarycache=none \\\n              -o com.sun:auto-snapshot=false <pool>/swap\n```\n\nPrepare it as swap partition:\n\n```\n# mkswap -f /dev/zvol/<pool>/swap\n# swapon /dev/zvol/<pool>/swap\n```\n\nTo make it permanent, edit /etc/fstab. ZVOLs support discard, which can potentially help ZFS's block allocator and reduce fragmentation for all other datasets when/if swap is not full.\n\nAdd a line to /etc/fstab:\n\n```\n/dev/zvol/<pool>/swap none swap discard 0 0\n```\n\n"
    },
    {
      "title": "Access Control Lists",
      "level": 3,
      "content": "To use ACL on a dataset:\n\n```\n# zfs set acltype=posixacl <nameofzpool>/<nameofdataset>\n# zfs set xattr=sa <nameofzpool>/<nameofdataset>\n```\n\nSetting xattr is recommended for performance reasons [1].\n\nIt may be preferable to enable ACL on the zpool as datasets will inherit the ACL parameters. Setting aclinherit=passthrough may be wanted as the default mode is restricted [2]; however, it is worth noting that aclinherit does not affect POSIX ACLs [3]:\n\n```\n# zfs set aclinherit=passthrough <nameofzpool>\n# zfs set acltype=posixacl <nameofzpool>\n# zfs set xattr=sa <nameofzpool>\n```\n\n"
    },
    {
      "title": "Databases",
      "level": 3,
      "content": "ZFS, unlike most other file systems, has a variable record size, or what is commonly referred to as a block size. By default, the recordsize on ZFS is 128KiB, which means it will dynamically allocate blocks of any size from 512B to 128KiB depending on the size of file being written. This can often help fragmentation and file access, at the cost that ZFS would have to allocate new 128KiB blocks each time only a few bytes are written to.\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nMost RDBMSes work in 8KiB-sized blocks by default. Although the block size is tunable for MySQL/MariaDB, PostgreSQL, and Oracle database, all three of them use an 8KiB block size by default. For both performance concerns and keeping snapshot differences to a minimum (for backup purposes, this is helpful), it is usually desirable to tune ZFS instead to accommodate the databases, using a command such as:\n\n```\n# zfs set recordsize=8K <pool>/postgres\n```\n\nThese RDBMSes also tend to implement their own caching algorithm, often similar to ZFS's own ARC. In the interest of saving memory, it is best to simply disable ZFS's caching of the database's file data and let the database do its own job:\n\n```\n# zfs set primarycache=metadata <pool>/postgres\n```\n\nZFS uses the ZIL for crash recovery, but databases are often syncing their data files to the file system on their own transaction commits anyway. The end result of this is that ZFS will be committing data twice to the data disks, and it can severely impact performance. You can tell ZFS to prefer to not use the ZIL, and in which case, data is only committed to the file system once. However, doing so on non-solid state storage (e.g. HDDs) can result in decreased read performance due to fragmentation (OpenZFS Wiki) -- with mechanical hard drives, please consider using a dedicated SSD as ZIL rather than setting the option below. In addition, setting this for non-database file systems, or for pools with configured log devices, can also negatively impact the performance, so beware:\n\n```\n# zfs set logbias=throughput <pool>/postgres\n```\n\nThese can also be done at file system creation time, for example:\n\n```\n# zfs create -o recordsize=8K \\\n             -o primarycache=metadata \\\n             -o mountpoint=/var/lib/postgres \\\n             -o logbias=throughput \\\n              <pool>/postgres\n```\n\nPlease note: these kinds of tuning parameters are ideal for specialized applications like RDBMSes. You can easily hurt ZFS's performance by setting these on a general-purpose file system such as your /home directory.\n\n"
    },
    {
      "title": "/tmp",
      "level": 3,
      "content": "If you would like to use ZFS to store your /tmp directory, which may be useful for storing arbitrarily-large sets of files or simply keeping your RAM free of idle data, you can generally improve performance of certain applications writing to /tmp by disabling file system sync. This causes ZFS to ignore an application's sync requests (eg, with fsync or O_SYNC) and return immediately. While this has severe application-side data consistency consequences (never disable sync for a database!), files in /tmp are less likely to be important and affected. Please note this does not affect the integrity of ZFS itself, only the possibility that data an application expects on-disk may not have actually been written out following a crash.\n\n```\n# zfs set sync=disabled <pool>/tmp\n```\n\nAdditionally, for security purposes, you may want to disable setuid and devices on the /tmp file system, which prevents some kinds of privilege-escalation attacks or the use of device nodes:\n\n```\n# zfs set setuid=off <pool>/tmp\n# zfs set devices=off <pool>/tmp\n```\n\nCombining all of these for a create command would be as follows:\n\n```\n# zfs create -o setuid=off -o devices=off -o sync=disabled -o mountpoint=/tmp <pool>/tmp\n```\n\nPlease note, also, that if you want /tmp on ZFS, you will need to mask (disable) systemd's automatic tmpfs-backed /tmp (tmp.mount), else ZFS will be unable to mount your dataset at boot-time or import-time.\n\n"
    },
    {
      "title": "Transmitting snapshots with ZFS Send and ZFS Recv",
      "level": 3,
      "content": "It is possible to pipe ZFS snapshots to an arbitrary target by pairing zfs send and zfs recv. This is done through standard output, which allows the data to be sent to any file, device, across the network, or manipulated mid-stream by incorporating additional programs in the pipe.\n\nBelow are examples of common scenarios:\n\n"
    },
    {
      "title": "Basic ZFS Send",
      "level": 4,
      "content": "First, create a snapshot of some ZFS filesystem:\n\n```\n# zfs snapshot zpool0/archive/books@snap\n```\n\nNow send the snapshot to a new location on a different zpool:\n\n```\n# zfs send -v zpool0/archive/books@snap | zfs recv zpool4/library\n```\n\nThe contents of zpool0/archive/books@snap are now live at zpool4/library\n\nFirst, create a snapshot of some ZFS filesystem:\n\n```\n# zfs snapshot zpool0/archive/books@snap\n```\n\nWrite the snapshot to a gzip file:\n\n```\n# zfs send zpool0/archive/books@snap > /tmp/mybooks.gz\n```\n\nNow restore the snapshot from the file:\n\n```\n# gzcat /tmp/mybooks.gz | zfs recv -F zpool0/archive/books\n```\n\n"
    },
    {
      "title": "Send over ssh",
      "level": 4,
      "content": "First, create a snapshot of some ZFS filesystem:\n\n```\n# zfs snapshot zpool1/filestore@snap\n```\n\nNext we pipe our \"send\" traffic over an ssh session running \"recv\":\n\n```\n# zfs send -v zpool1/filestore@snap | ssh $HOST zfs recv coldstore/backups\n```\n\nThe -v flag prints information about the datastream being generated. If you are using a passphrase or passkey, you will be prompted to enter it.\n\n"
    },
    {
      "title": "Incremental Backups",
      "level": 4,
      "content": "You may wish update a previously sent ZFS filesystem without retransmitting all of the data over again. Alternatively, it may be necessary to keep a filesystem online during a lengthy transfer and it is now time to send writes that were made since the initial snapshot.\n\nFirst, create a snapshot of some ZFS filesystem:\n\n```\n# zfs snapshot zpool1/filestore@initial\n```\n\nNext we pipe our \"send\" traffic over an ssh session running \"recv\":\n\n```\n# zfs send -v -R zpool1/filestore@initial | ssh $HOST zfs recv coldstore/backups\n```\n\nOnce changes are written, make another snapshot:\n\n```\n# zfs snapshot zpool1/filestore@snap2\n```\n\nThe following will send the differences that exist locally between zpool1/filestore@initial and zpool1/filestore@snap2 and create an additional snapshot for the remote filesystem coldstore/backups:\n\n```\n# zfs send -v -i -R zpool1/filestore@initial | ssh $HOST zfs recv coldstore/backups\n```\n\nNow both zpool1/filestore and coldstore/backups have the @initial and @snap2 snapshots.\n\nOn the remote host, you may now promote the latest snapshot to become the active filesystem:\n\n```\n# rollback coldstore/backups@snap2\n```\n\n"
    },
    {
      "title": "General",
      "level": 3,
      "content": "ZFS pools and datasets can be further adjusted using parameters.\n\nTo retrieve the current pool parameter status:\n\n```\n# zfs get all <pool>\n```\n\nTo retrieve the current dataset parameter status:\n\n```\n# zfs get all <pool>/<dataset>\n```\n\nTo disable access time (atime), which is enabled by default:\n\n```\n# zfs set atime=off <pool>\n```\n\nTo disable access time (atime) on a particular dataset:\n\n```\n# zfs set atime=off <pool>/<dataset>\n```\n\nAn alternative to turning off atime completely, relatime is available. This brings the default ext4/XFS atime semantics to ZFS, where access time is only updated if the modified time or changed time changes, or if the existing access time has not been updated within the past 24 hours. It is a compromise between atime=off and atime=on. This property only takes effect if atime is on:\n\n```\n# zfs set atime=on <pool>\n# zfs set relatime=on <pool>\n```\n\nCompression is just that, transparent compression of data. ZFS supports a few different algorithms, presently lz4 is the default, gzip is also available for seldom-written yet highly-compressible data; consult the OpenZFS Wiki for more details.\n\nTo enable compression:\n\n```\n# zfs set compression=on <pool>\n```\n\nTo reset a property of a pool and/or dataset to its default state, use zfs inherit:\n\n```\n# zfs inherit -rS atime <pool>\n# zfs inherit -rS atime <pool>/<dataset>\n```\n\n"
    },
    {
      "title": "Scrubbing",
      "level": 3,
      "content": "Whenever data is read and ZFS encounters an error, it is silently repaired when possible, rewritten back to disk and logged so you can obtain an overview of errors on your pools. There is no fsck or equivalent tool for ZFS. Instead, ZFS supports a feature known as scrubbing. This traverses through all the data in a pool and verifies that all blocks can be read.\n\nTo scrub a pool:\n\n```\n# zpool scrub <pool>\n```\n\nTo cancel a running scrub:\n\n```\n# zpool scrub -s <pool>\n```\n\n"
    },
    {
      "title": "How often should I do this?",
      "level": 4,
      "content": "From the Oracle blog post Disk Scrub - Why and When?:\n\n- What is the expiration of your oldest backup? You should probably scrub your data at least as often as your oldest tapes expire so that you have a known-good restore point.\n- How often are you experiencing disk failures? While the recruitment of a hot-spare disk invokes a \"resilver\" -- a targeted scrub of just the VDEV which lost a disk -- you should probably scrub at least as often as you experience disk failures on average in your specific environment.\n- How often is the oldest piece of data on your disk read? You should scrub occasionally to prevent very old, very stale data from experiencing bit-rot and dying without you knowing it.\n\nIn the ZFS Administration Guide by Aaron Toponce, he advises to scrub consumer disks once a week.\n\n"
    },
    {
      "title": "Start with a service or timer",
      "level": 4,
      "content": "Using a systemd timer/service it is possible to automatically scrub pools.\n\nTo perform scrubbing monthly on a particular pool:\n\n```\n/etc/systemd/system/zfs-scrub@.timer\n```\n\n```\n[Unit]\nDescription=Monthly zpool scrub on %i\n\n[Timer]\nOnCalendar=monthly\nAccuracySec=1h\nPersistent=true\n\n[Install]\nWantedBy=multi-user.target\n```\n\n```\n/etc/systemd/system/zfs-scrub@.service\n```\n\n```\n[Unit]\nDescription=zpool scrub on %i\n\n[Service]\nNice=19\nIOSchedulingClass=idle\nKillSignal=SIGINT\nExecStart=/usr/bin/zpool scrub %i\n\n[Install]\nWantedBy=multi-user.target\n```\n\nEnable/start zfs-scrub@pool-to-scrub.timer unit for monthly scrubbing the specified zpool.\n\n"
    },
    {
      "title": "Enabling TRIM",
      "level": 3,
      "content": "To quickly query your vdevs TRIM support, you can include trimming information in zpool status with -t.\n\n```\n$ zpool status -t tank\n```\n\n```\npool: tank\n state: ONLINE\n  scan: none requested\n config:\n\n\tNAME                                     STATE     READ WRITE CKSUM\n\ttank                                     ONLINE       0     0     0\n\t  ata-ST31000524AS_5RP4SSNR-part1        ONLINE       0     0     0  (trim unsupported)\n\t  ata-CT480BX500SSD1_2134A59B933D-part1  ONLINE       0     0     0  (untrimmed)\n\nerrors: No known data errors\n```\n\nZFS is capable of trimming supported vdevs either on-demand or periodically via the autotrim property.\n\nManually performing a TRIM operation on a zpool:\n\n```\n# zpool trim <zpool>\n```\n\nEnabling periodic trimming on all supported vdevs in a pool:\n\n```\n# zpool set autotrim=on <zpool>\n```\n\nTo perform a full zpool trim monthly on a particular pool using a systemd timer/service:\n\n```\n/etc/systemd/system/zfs-trim@.timer\n```\n\n```\n[Unit]\nDescription=Monthly zpool trim on %i\n\n[Timer]\nOnCalendar=monthly\nAccuracySec=1h\nPersistent=true\n\n[Install]\nWantedBy=multi-user.target\n```\n\n```\n/etc/systemd/system/zfs-trim@.service\n```\n\n```\n[Unit]\nDescription=zpool trim on %i\nDocumentation=man:zpool-trim(8)\nRequires=zfs.target\nAfter=zfs.target\nConditionACPower=true\nConditionPathIsDirectory=/sys/module/zfs\n\n[Service]\nNice=19\nIOSchedulingClass=idle\nKillSignal=SIGINT\nExecStart=/bin/sh -c '\\\nif /usr/bin/zpool status %i | grep \"trimming\"; then\\\nexec /usr/bin/zpool wait -t trim %i;\\\nelse exec /usr/bin/zpool trim -w %i; fi'\nExecStop=-/bin/sh -c '/usr/bin/zpool trim -s %i 2>/dev/null || true'\n\n[Install]\nWantedBy=multi-user.target\n```\n\nEnable/start zfs-trim@pool-to-trim.timer unit for monthly trimming of the specified zpool.\n\n"
    },
    {
      "title": "SSD Caching",
      "level": 3,
      "content": "If your pool has no configured log devices, ZFS reserves space on the pool's data disks for its intent log (the ZIL, also called SLOG). If your data disks are slow (e.g. HDD) it is highly recommended to configure the ZIL on solid state drives for better write performance and also to consider a layer 2 adaptive replacement cache (L2ARC). The process to add them is very similar to adding a new VDEV.\n\nAll of the below references to device-id are the IDs from /dev/disk/by-id/*.\n\n"
    },
    {
      "title": "ZIL",
      "level": 4,
      "content": "To add a mirrored ZIL:\n\n```\n# zpool add <pool> log mirror <device-id-1> <device-id-2>\n```\n\nOr to add a single device ZIL:\n\n```\n# zpool add <pool> log <device-id>\n```\n\nBecause the ZIL device stores data that has not been written to the pool, it is important to use devices that can finish writes when power is lost. It is also important to use redundancy, since a device failure can cause data loss. In addition, the ZIL is only used for sync writes, so may not provide any performance improvement when your data drives are as fast as your ZIL drive(s).\n\n"
    },
    {
      "title": "L2ARC",
      "level": 4,
      "content": "To add L2ARC:\n\n```\n# zpool add <pool> cache <device-id>\n```\n\nL2ARC is only a read cache, so redundancy is unnecessary. Since ZFS version 2.0.0, L2ARC is persisted across reboots.[4]\n\nL2ARC is generally only useful in workloads where the amount of hot data is bigger than system memory, but small enough to fit into L2ARC. The L2ARC is indexed by the ARC in system memory, consuming 70 bytes per record (default 128KiB). Thus, the equation for RAM usage is:\n\n```\n(L2ARC size) / (recordsize) * 70 bytes\n```\n\nBecause of this, L2ARC can, in certain workloads, harm performance as it takes memory away from ARC.\n\n"
    },
    {
      "title": "ZVOLs",
      "level": 3,
      "content": "ZFS volumes (ZVOLs) can suffer from the same block size-related issues as RDBMSes, but it is worth noting that the default recordsize for ZVOLs is 8 KiB already. If possible, it is best to align any partitions contained in a ZVOL to your recordsize (current versions of fdisk and gdisk by default automatically align at 1MiB segments, which works), and file system block sizes to the same size. Other than this, you might tweak the recordsize to accommodate the data inside the ZVOL as necessary (though 8 KiB tends to be a good value for most file systems, even when using 4 KiB blocks on that level).\n\n"
    },
    {
      "title": "RAIDZ and Advanced Format physical disks",
      "level": 4,
      "content": "Each block of a ZVOL gets its own parity disks, and if you have physical media with logical block sizes of 4096B, 8192B, or so on, the parity needs to be stored in whole physical blocks, and this can drastically increase the space requirements of a ZVOL, requiring 2× or more physical storage capacity than the ZVOL's logical capacity. Setting the recordsize to 16k or 32k can help reduce this footprint drastically.\n\nSee OpenZFS issue #1807 for details.\n\n"
    },
    {
      "title": "I/O Scheduler",
      "level": 3,
      "content": "While ZFS is expected to work well with modern schedulers including, mq-deadline, and none, experimenting with manually setting the I/O scheduler on ZFS disks may yield performance gains. The ZFS recomendation is \"[...] users leave the default scheduler “unless you’re encountering a specific problem, or have clearly measured a performance improvement for your workload”\"[5]\n\n"
    },
    {
      "title": "Creating a zpool fails",
      "level": 3,
      "content": "If the following error occurs then it can be fixed.\n\n```\n# the kernel failed to rescan the partition table: 16\n# cannot label 'sdc': try using parted(8) and then provide a specific slice: -1\n```\n\nOne reason this can occur is because ZFS expects pool creation to take less than 1 second[6][7]. This is a reasonable assumption under ordinary conditions, but in many situations it may take longer. Each drive will need to be cleared again before another attempt can be made.\n\n```\n# parted /dev/sda rm 1\n# parted /dev/sda rm 1\n# dd if=/dev/zero of=/dev/sdb bs=512 count=1\n# zpool labelclear /dev/sda\n```\n\nA brute force creation can be attempted over and over again, and with some luck the ZPool creation will take less than 1 second. One cause for creation slowdown can be slow burst read writes on a drive. By reading from the disk in parallel to ZPool creation, it may be possible to increase burst speeds.\n\n```\n# dd if=/dev/sda of=/dev/null\n```\n\nThis can be done with multiple drives by saving the above command for each drive to a file on separate lines and running\n\n```\n# cat $FILE | parallel\n```\n\nThen run ZPool creation at the same time.\n\n"
    },
    {
      "title": "ZFS is using too much RAM",
      "level": 3,
      "content": "By default, ZFS caches file operations (ARC) using up to half of available system memory on the host. To adjust the ARC size, add the following to the Kernel parameters list:\n\n```\nzfs.zfs_arc_max=536870912 # (for 512MiB)\n```\n\nIn case that the default value of zfs_arc_min (1/32 of system memory) is higher than the specified zfs_arc_max it is needed to add also the following to the Kernel parameters list:\n\n```\nzfs.zfs_arc_min=268435456 # (for 256MiB, needs to be lower than zfs.zfs_arc_max)\n```\n\nYou may also want to increase zfs_arc_sys_free instead (in this example to 8GiB):\n\n```\n# echo $((8*1024**3)) > /sys/module/zfs/parameters/zfs_arc_sys_free\n```\n\nFor a more detailed description, as well as other configuration options, see Gentoo:ZFS#ARC.\n\nZFS should release ARC as applications reserve more RAM, but some applications still get confused, and reported free RAM is always wrong. But in case all your applications work as intended and you have no problems, there is no need to change ARC settings.\n\n"
    },
    {
      "title": "No hostid found",
      "level": 3,
      "content": "An error that occurs at boot with the following lines appearing before initscript output:\n\n```\nZFS: No hostid found on kernel command line or /etc/hostid.\n```\n\nThis warning occurs because the ZFS module does not have access to the spl hosted. There are two solutions, for this. Either place the spl hostid in the kernel parameters in the boot loader. For example, adding spl.spl_hostid=0x00bab10c.\n\nThe other solution is to make sure that there is a hostid in /etc/hostid, and then regenerate the initramfs image. Which will copy the hostid into the initramfs image.\n\n"
    },
    {
      "title": "Pool cannot be found while booting from SAS/SCSI devices",
      "level": 3,
      "content": "In case you are booting a SAS/SCSI based, you might occassionally get boot problems where the pool you are trying to boot from cannot be found. A likely reason for this is that your devices are initialized too late into the process. That means that zfs cannot find any devices at the time when it tries to assemble your pool.\n\nIn this case you should force the scsi driver to wait for devices to come online before continuing. You can do this by putting this into /etc/modprobe.d/zfs.conf:\n\n```\n/etc/modprobe.d/zfs.conf\n```\n\n```\noptions scsi_mod scan=sync\n```\n\nAfterwards, regenerate the initramfs.\n\nThis works because the zfs hook will copy the file at /etc/modprobe.d/zfs.conf into the initcpio which will then be used at build time.\n\n"
    },
    {
      "title": "Unexported pool",
      "level": 4,
      "content": "If the new installation does not boot because the zpool cannot be imported, chroot into the installation and properly export the zpool. See #Emergency chroot repair with archzfs.\n\nOnce inside the chroot environment, load the ZFS module and force import the zpool,\n\n```\n# zpool import -a -f\n```\n\nnow export the pool:\n\n```\n# zpool export <pool>\n```\n\nTo see the available pools, use,\n\n```\n# zpool status\n```\n\nIt is necessary to export a pool because of the way ZFS uses the hostid to track the system the zpool was created on. The hostid is generated partly based on the network setup. During the installation in the archiso the network configuration could be different generating a different hostid than the one contained in the new installation. Once the zfs filesystem is exported and then re-imported in the new installation, the hostid is reset. See Re: Howto zpool import/export automatically? - msg#00227.\n\nIf ZFS complains about \"pool may be in use\" after every reboot, properly export pool as described above, and then regenerate the initramfs in normally booted system.\n\n"
    },
    {
      "title": "Incorrect hostid",
      "level": 4,
      "content": "Double check that the pool is properly exported. Exporting the zpool clears the hostid marking the ownership. So during the first boot the zpool should mount correctly. If it does not there is some other problem.\n\nReboot again, if the zfs pool refuses to mount it means the hostid is not yet correctly set in the early boot phase and it confuses zfs. Manually tell zfs the correct number, once the hostid is coherent across the reboots the zpool will mount correctly.\n\nBoot using zfs_force and write down the hostid. This one is just an example.\n\n```\n$ hostid\n```\n\n```\n0a0af0f8\n```\n\nThis number have to be added to the kernel parameters as spl.spl_hostid=0x0a0af0f8. Another solution is writing the hostid inside the initram image, see the installation guide[broken link: invalid section] explanation about this.\n\nUsers can always ignore the check adding zfs_force=1 in the kernel parameters, but it is not advisable as a permanent solution.\n\n"
    },
    {
      "title": "Devices have different sector alignment",
      "level": 3,
      "content": "Once a drive has become faulted it should be replaced A.S.A.P. with an identical drive.\n\n```\n# zpool replace bigdata ata-ST3000DM001-9YN166_S1F0KDGY ata-ST3000DM001-1CH166_W1F478BD -f\n```\n\nbut in this instance, the following error is produced:\n\n```\ncannot replace ata-ST3000DM001-9YN166_S1F0KDGY with ata-ST3000DM001-1CH166_W1F478BD: devices have different sector alignment\n```\n\nZFS uses the ashift option to adjust for physical block size. When replacing the faulted disk, ZFS is attempting to use ashift=12, but the faulted disk is using a different ashift (probably ashift=9) and this causes the resulting error.\n\nFor Advanced Format disks with 4 KiB block size, an ashift of 12 is recommended for best performance. See OpenZFS FAQ: Performance Considerations and ZFS and Advanced Format disks.\n\nUse zdb to find the ashift of the zpool: zdb , then use the -o argument to set the ashift of the replacement drive:\n\n```\n# zpool replace bigdata ata-ST3000DM001-9YN166_S1F0KDGY ata-ST3000DM001-1CH166_W1F478BD -o ashift=9 -f\n```\n\nCheck the zpool status for confirmation:\n\n```\n# zpool status -v\n```\n\n```\npool: bigdata\nstate: DEGRADED\nstatus: One or more devices is currently being resilvered.  The pool will\n        continue to function, possibly in a degraded state.\naction: Wait for the resilver to complete.\nscan: resilver in progress since Mon Jun 16 11:16:28 2014\n    10.3G scanned out of 5.90T at 81.7M/s, 20h59m to go\n    2.57G resilvered, 0.17% done\nconfig:\n\n        NAME                                   STATE     READ WRITE CKSUM\n        bigdata                                DEGRADED     0     0     0\n        raidz1-0                               DEGRADED     0     0     0\n            replacing-0                        OFFLINE      0     0     0\n            ata-ST3000DM001-9YN166_S1F0KDGY    OFFLINE      0     0     0\n            ata-ST3000DM001-1CH166_W1F478BD    ONLINE       0     0     0  (resilvering)\n            ata-ST3000DM001-9YN166_S1F0JKRR    ONLINE       0     0     0\n            ata-ST3000DM001-9YN166_S1F0KBP8    ONLINE       0     0     0\n            ata-ST3000DM001-9YN166_S1F0JTM1    ONLINE       0     0     0\n\nerrors: No known data errors\n```\n\n"
    },
    {
      "title": "Pool resilvering stuck/restarting/slow?",
      "level": 3,
      "content": "According to ZFS issue #840, this is a known issue since 2012 with ZFS-ZED which causes the resilvering process to constantly restart, sometimes get stuck and be generally slow for some hardware. The simplest mitigation is to stop zfs-zed.service until the resilver completes.\n\n"
    },
    {
      "title": "Fix slow boot caused by failed import of unavailable pools in the initramfs zpool.cache",
      "level": 3,
      "content": "Your boot time can be significantly impacted if you update your intitramfs (eg when doing a kernel update) when you have additional but non-permanently attached pools imported because these pools will get added to your initramfs zpool.cache and ZFS will attempt to import these extra pools on every boot, regardless of whether you have exported it and removed it from your regular zpool.cache.\n\nIf you notice ZFS trying to import unavailable pools at boot, first run:\n\n```\n$ zdb -C\n```\n\nTo check your zpool.cache for pools you do not want imported at boot. If this command is showing (an) additional, currently unavailable pool(s), run:\n\n```\n# zpool set cachefile=/etc/zfs/zpool.cache zroot\n```\n\nTo clear the zpool.cache of any pools other than the pool named zroot. Sometimes there is no need to refresh your zpool.cache, but instead all you need to do is regenerate the initramfs.\n\n"
    },
    {
      "title": "ZFS Command History",
      "level": 3,
      "content": "ZFS logs changes to a pool's structure natively as a log of executed commands in a ring buffer (which cannot be turned off). The log may be helpful when restoring a degraded or failed pool.\n\n```\n# zpool history zpool\n```\n\n```\nHistory for 'zpool':\n2023-02-19.16:28:44 zpool create zpool raidz1 /scratch/disk_1.img /scratch/disk_2.img /scratch/disk_3.img\n2023-02-19.16:31:29 zfs set compression=lz4 zpool\n2023-02-19.16:41:45 zpool scrub zpool\n2023-02-19.17:00:57 zpool replace zpool /scratch/disk_1.img /scratch/bigger_disk_1.img\n2023-02-19.17:01:34 zpool scrub zpool\n2023-02-19.17:01:42 zpool replace zpool /scratch/disk_2.img /scratch/bigger_disk_2.img\n2023-02-19.17:01:46 zpool replace zpool /scratch/disk_3.img /scratch/bigger_disk_3.img\n```\n\n"
    },
    {
      "title": "Create an Archiso image with ZFS support",
      "level": 3,
      "content": "See Install Arch Linux on ZFS#Embedding ZFS module into custom archiso.\n\n"
    },
    {
      "title": "zrepl",
      "level": 4,
      "content": "The zreplAUR package provides a ZFS automatic replication service, which could also be used as a snapshotting service much like snapper.\n\nFor details on how to configure the zrepl daemon, see the zrepl documentation. The configuration file should be located at /etc/zrepl/zrepl.yml. Then, run zrepl configcheck to make sure that the syntax of the config file is correct. Finally, enable zrepl.service.\n\n"
    },
    {
      "title": "sanoid",
      "level": 4,
      "content": "sanoidAUR is a policy-driven tool for taking snapshots. Sanoid also includes syncoid, which is for replicating snapshots. It comes with systemd services and a timer.\n\nSanoid only prunes snapshots on the local system. To prune snapshots on the remote system, run sanoid there as well with prune options. Either use the --prune-snapshots command line option or use the --cron command line option together with the autoprune = yes and autosnap = no configuration options.\n\n"
    },
    {
      "title": "ZFS Automatic Snapshot Service for Linux",
      "level": 4,
      "content": "The zfs-auto-snapshot-gitAUR package provides a shell script to automate the management of snapshots, with each named by date and label (hourly, daily, etc), giving quick and convenient snapshotting of all ZFS datasets. The package also installs cron tasks for quarter-hourly, hourly, daily, weekly, and monthly snapshots. Optionally adjust the --keep parameter from the defaults depending on how far back the snapshots are to go (the monthly script by default keeps data for up to a year).\n\nTo prevent a dataset from being snapshotted at all, set com.sun:auto-snapshot=false on it. Likewise, set more fine-grained control as well by label, if, for example, no monthlies are to be kept on a snapshot, for example, set com.sun:auto-snapshot:monthly=false.\n\nOnce the package has been installed, enable and start the selected timers (zfs-auto-snapshot-{frequent,daily,weekly,monthly}.timer).\n\n"
    },
    {
      "title": "Creating a share",
      "level": 3,
      "content": "ZFS has support for creating shares by NFS or SMB.\n\n"
    },
    {
      "title": "NFS",
      "level": 4,
      "content": "Make sure NFS has been installed/configured, note there is no need to edit the /etc/exports file. For sharing over NFS the services nfs-server.service and zfs-share.service should be started.\n\nTo make a pool available on the network:\n\n```\n# zfs set sharenfs=on nameofzpool\n```\n\nTo make a dataset available on the network:\n\n```\n# zfs set sharenfs=on nameofzpool/nameofdataset\n```\n\nTo enable read/write access for a specific ip-range(s):\n\n```\n# zfs set sharenfs=\"rw=@192.168.1.100/24,rw=@10.0.0.0/24\" nameofzpool/nameofdataset\n```\n\nTo check if the dataset is exported successfully:\n\n```\n# showmount -e `hostname`\n```\n\n```\nExport list for hostname:\n/path/of/dataset 192.168.1.100/24\n```\n\nTo view the current loaded exports state in more detail, use:\n\n```\n# exportfs -v\n```\n\n```\n/path/of/dataset\n    192.168.1.100/24(sync,wdelay,hide,no_subtree_check,mountpoint,sec=sys,rw,secure,no_root_squash,no_all_squash)\n```\n\nTo view the current NFS share list by ZFS:\n\n```\n# zfs get sharenfs\n```\n\n"
    },
    {
      "title": "SMB",
      "level": 4,
      "content": "When sharing through SMB, using usershares in /etc/samba/smb.conf will allow ZFS to setup and create the shares. See Samba#Enable Usershares for details.\n\n```\n/etc/samba/smb.conf\n```\n\n```\n[global]\n    usershare path = /var/lib/samba/usershares\n    usershare max shares = 100\n    usershare allow guests = yes\n    usershare owner only = no\n```\n\nCreate and set permissions on the user directory as root\n\n```\n# mkdir /var/lib/samba/usershares\n# chmod +t /var/lib/samba/usershares\n```\n\nTo make a pool available on the network:\n\n```\n# zfs set sharesmb=on nameofzpool\n```\n\nTo make a dataset available on the network:\n\n```\n# zfs set sharesmb=on nameofzpool/nameofdataset\n```\n\nTo check if the dataset is exported successfully:\n\n```\n# smbclient -L localhost -U%\n```\n\n```\nSharename       Type      Comment\n        ---------       ----      -------\n        IPC$            IPC       IPC Service (SMB Server Name)\n        nameofzpool_nameofdataset        Disk      Comment: path/of/dataset\nSMB1 disabled -- no workgroup available\n```\n\nTo view the current SMB share list by ZFS:\n\n```\n# zfs get sharesmb\n```\n\n"
    },
    {
      "title": "Encryption in ZFS using dm-crypt",
      "level": 3,
      "content": "Before OpenZFS version 0.8.0, ZFS did not support encryption directly (See #Native encryption). Instead, zpools can be created on dm-crypt block devices. Since the zpool is created on the plain-text abstraction, it is possible to have the data encrypted while having all the advantages of ZFS like deduplication, compression, and data robustness. Furthermore, utilizing dm-crypt will encrypt the zpools metadata, which the native encryption can inherently not provide.[8]\n\ndm-crypt, possibly via LUKS, creates devices in /dev/mapper and their name is fixed. So you just need to change zpool create commands to point to that names. The idea is configuring the system to create the /dev/mapper block devices and import the zpools from there. Since zpools can be created in multiple devices (raid, mirroring, striping, ...), it is important all the devices are encrypted otherwise the protection might be partially lost.\n\nFor example, an encrypted zpool can be created using plain dm-crypt (without LUKS) with:\n\n```\n# cryptsetup open --type=plain --hash=sha256 --cipher=aes-xts-plain64 --offset=0 \\\n             --key-file=/dev/sdZ --key-size=512 /dev/sdX enc\n# zpool create zroot /dev/mapper/enc\n```\n\nIn the case of a root filesystem pool, the mkinitcpio.conf HOOKS line will enable the keyboard for the password, create the devices, and load the pools. It will contain something like:\n\n```\nHOOKS=(... keyboard encrypt zfs ...)\n```\n\nSince the /dev/mapper/enc name is fixed no import errors will occur.\n\nCreating encrypted zpools works fine. But if you need encrypted directories, for example to protect your users' homes, ZFS loses some functionality.\n\nZFS will see the encrypted data, not the plain-text abstraction, so compression and deduplication will not work. The reason is that encrypted data has always high entropy making compression ineffective and even from the same input you get different output (thanks to salting) making deduplication impossible. To reduce the unnecessary overhead it is possible to create a sub-filesystem for each encrypted directory and use eCryptfs on it.\n\nFor example to have an encrypted home: (the two passwords, encryption and login, must be the same)\n\n```\n# zfs create -o compression=off -o dedup=off -o mountpoint=/home/<username> <zpool>/<username>\n# useradd -m <username>\n# passwd <username>\n# ecryptfs-migrate-home -u <username>\n<log in user and complete the procedure with ecryptfs-unwrap-passphrase>\n```\n\n"
    },
    {
      "title": "Emergency chroot repair with archzfs",
      "level": 3,
      "content": "To get into the ZFS filesystem from live system for maintenance, there are two options:\n\n1. Build custom archiso with ZFS as described in #Create an Archiso image with ZFS support.\n1. Boot the latest official archiso and bring up the network. Then enable archzfs repository inside the live system as usual, sync the pacman package database and install the archzfs-archiso-linux package.\n\nTo start the recovery, load the ZFS kernel modules:\n\n```\n# modprobe zfs\n```\n\nImport the pool:\n\n```\n# zpool import -a -R /mnt\n```\n\nMount the boot partition and EFI system partition (if any):\n\n```\n# mount /dev/sda2 /mnt/boot\n# mount /dev/sda1 /mnt/efi\n```\n\nChroot into the ZFS filesystem:\n\n```\n# arch-chroot /mnt /bin/bash\n```\n\nCheck the kernel version:\n\n```\n# pacman -Qi linux\n# uname -r\n```\n\nuname will show the kernel version of the archiso. If they are different, run depmod (in the chroot) with the correct kernel version of the chroot installation:\n\n```\n# depmod -a 3.6.9-1-ARCH (version gathered from pacman -Qi linux but using the matching kernel modules directory name under the chroot's /lib/modules)\n```\n\nThis will load the correct kernel modules for the kernel version installed in the chroot installation.\n\nRegenerate the initramfs. There should be no errors.\n\n"
    },
    {
      "title": "Bind mount",
      "level": 3,
      "content": "Here a bind mount from /mnt/zfspool to /srv/nfs4/music is created. The configuration ensures that the zfs pool is ready before the bind mount is created.\n\n"
    },
    {
      "title": "fstab",
      "level": 4,
      "content": "See systemd.mount(5) for more information on how systemd converts fstab into mount unit files with systemd-fstab-generator(8).\n\n```\n/etc/fstab\n```\n\n```\n/mnt/zfspool\t\t/srv/nfs4/music\t\tnone\tbind,defaults,nofail,x-systemd.requires=zfs-mount.service\t0 0\n```\n\n"
    },
    {
      "title": "Monitoring / Mailing on Events",
      "level": 3,
      "content": "See ZED: The ZFS Event Daemon for more information.\n\nAn email forwarder, such as S-nail, is required to accomplish this. Test it to be sure it is working correctly.\n\nUncomment the following in the configuration file:\n\n```\n/etc/zfs/zed.d/zed.rc\n```\n\n```\nZED_EMAIL_ADDR=\"root\"\n ZED_EMAIL_PROG=\"mailx\"\n ZED_NOTIFY_VERBOSE=0\n ZED_EMAIL_OPTS=\"-s '@SUBJECT@' @ADDRESS@\"\n```\n\nUpdate 'root' in ZED_EMAIL_ADDR=\"root\" to the email address you want to receive notifications at.\n\nIf you are keeping your mailrc in your home directory, you can tell mail to get it from there by setting MAILRC:\n\n```\n/etc/zfs/zed.d/zed.rc\n```\n\n```\nexport MAILRC=/home/<user>/.mailrc\n```\n\nThis works because ZED sources this file, so mailx sees this environment variable.\n\nIf you want to receive an email no matter the state of your pool, you will want to set ZED_NOTIFY_VERBOSE=1. You will need to do this temporary to test.\n\nStart and enable zfs-zed.service.\n\nWith ZED_NOTIFY_VERBOSE=1, you can test by running a scrub as root: zpool scrub <pool-name>.\n\n"
    },
    {
      "title": "Wrap shell commands in pre & post snapshots",
      "level": 3,
      "content": "Since it is so cheap to make a snapshot, we can use this as a measure of security for sensitive commands such as system and package upgrades. If we make a snapshot before, and one after, we can later diff these snapshots to find out what changed on the filesystem after the command executed. Furthermore we can also rollback in case the outcome was not desired.\n\n"
    },
    {
      "title": "znp",
      "level": 4,
      "content": "E.g.:\n\n```\n# zfs snapshot -r zroot@pre\n# pacman -Syu\n# zfs snapshot -r zroot@post\n# zfs diff zroot@pre zroot@post \n# zfs rollback zroot@pre\n```\n\nA utility that automates the creation of pre and post snapshots around a shell command is znp.\n\nE.g.:\n\n```\n# znp pacman -Syu\n# znp find / -name \"something*\" -delete\n```\n\nand you would get snapshots created before and after the supplied command, and also output of the commands logged to file for future reference so we know what command created the diff seen in a pair of pre/post snapshots.\n\n"
    },
    {
      "title": "Remote unlocking of ZFS encrypted root",
      "level": 3,
      "content": "As of PR #261, archzfs supports SSH unlocking of natively-encrypted ZFS datasets. This section describes how to use this feature, and is largely based on dm-crypt/Specialties#Busybox based initramfs (built with mkinitcpio).\n\n1. Install mkinitcpio-netconf to provide hooks for setting up early user space networking.\n1. Choose an SSH server to use in early user space. The options are mkinitcpio-tinyssh or mkinitcpio-dropbear, and are mutually exclusive. If using mkinitcpio-tinyssh, it is also recommended to install tinyssh or tinyssh-convert-gitAUR. This tool converts an existing OpenSSH hostkey to the TinySSH key format, preserving the key fingerprint and avoiding connection warnings. The TinySSH and Dropbear mkinitcpio install scripts will automatically convert existing hostkeys when generating a new initcpio image.\n1. Decide whether to use an existing OpenSSH key or generate a new one (recommended) for the host that will be connecting to and unlocking the encrypted ZFS machine. Copy the public key into /etc/tinyssh/root_key or /etc/dropbear/root_key. When generating the initcpio image, this file will be added to authorized_keys for the root user and is only valid in the initrd environment.\n1. Add the ip= kernel parameter to your boot loader configuration. The ip string is highly configurable. A simple DHCP example is shown below.ip=:::::eth0:dhcp\n1. Edit /etc/mkinitcpio.conf to include the netconf, dropbear or tinyssh, and zfsencryptssh hooks before the zfs hook:HOOKS=(... netconf <tinyssh>|<dropbear> zfsencryptssh zfs ...)\n1. Regenerate the initramfs.\n1. Reboot and try it out!\n\n1. If using mkinitcpio-tinyssh, it is also recommended to install tinyssh or tinyssh-convert-gitAUR. This tool converts an existing OpenSSH hostkey to the TinySSH key format, preserving the key fingerprint and avoiding connection warnings. The TinySSH and Dropbear mkinitcpio install scripts will automatically convert existing hostkeys when generating a new initcpio image.\n\n```\nip=:::::eth0:dhcp\n```\n\n```\nHOOKS=(... netconf <tinyssh>|<dropbear> zfsencryptssh zfs ...)\n```\n\n"
    },
    {
      "title": "Changing the SSH server port",
      "level": 4,
      "content": "By default, mkinitcpio-tinyssh and mkinitcpio-dropbear listen on port 22. You may wish to change this.\n\nFor TinySSH, copy /usr/lib/initcpio/hooks/tinyssh to /etc/initcpio/hooks/tinyssh, and find/modify the following line in the run_hook() function:\n\n```\n/etc/initcpio/hooks/tinyssh\n```\n\n```\n/usr/bin/tcpserver -HRDl0 0.0.0.0 <new_port> /usr/sbin/tinysshd -v /etc/tinyssh/sshkeydir &\n```\n\nFor Dropbear, copy /usr/lib/initcpio/hooks/dropbear to /etc/initcpio/hooks/dropbear, and find/modify the following line in the run_hook() function:\n\n```\n/etc/initcpio/hooks/tinyssh\n```\n\n```\n/usr/sbin/dropbear -E -s -j -k -p <new_port>\n```\n\nRegenerate the initramfs.\n\n"
    },
    {
      "title": "Unlocking from a Windows machine using PuTTY/Plink",
      "level": 4,
      "content": "First, we need to use puttygen.exe to import and convert the OpenSSH key generated earlier into PuTTY's .ppk private key format. We will call it zfs_unlock.ppk for this example.\n\nThe mkinitcpio-netconf process above does not setup a shell (nor do we need need one). However, because there is no shell, PuTTY will immediately close after a successful connection. This can be disabled in the PuTTY SSH configuration (Connection > SSH > [X] Do not start a shell or command at all), but it still does not allow us to see stdout or enter the encryption passphrase. Instead, we use plink.exe with the following parameters:\n\n```\nplink.exe -ssh -l root -i c:\\path\\to\\zfs_unlock.ppk <hostname>\n```\n\nThe plink command can be put into a batch script for ease of use.\n\n"
    },
    {
      "title": "Enabling bclone support",
      "level": 3,
      "content": "To use cp --reflink and other commands needing bclone support, it is necessary to upgrade the feature flags if coming from a version prior to 2.2.2. This will allow the pool to have support for bclone. This is done with zpool upgrade, if the status of the pool show this is possible.\n\nIt is also required to enable a module parameter, otherwise userspace apps will not be able to use this feature. You can do this by putting this into /etc/modprobe.d/zfs.conf:\n\n```\n/etc/modprobe.d/zfs.conf\n```\n\n```\noptions zfs zfs_bclone_enabled=1\n```\n\nCheck that is working, and how much space is being saved with the command: zpool get all POOLNAME | grep clon\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Aaron Toponce's 17-part blog on ZFS\n- OpenZFS releases\n- OpenZFS FAQ\n- FreeBSD Handbook - The Z File System\n- Oracle Solaris ZFS Administration Guide\n- ZFS Best Practices Guide\n- ZFS Troubleshooting Guide\n- How Pingdom uses ZFS to back up 5TB of MySQL data every day\n- Tutorial on adding the modules to a custom kernel\n- How to create cross platform ZFS disks under Linux\n- How-To: Using ZFS Encryption at Rest in OpenZFS (ZFS on Linux, ZFS on FreeBSD, …)\n- Archzfs iso download page: Frequently updated and downloadable archzfs linux iso with full OpenZFS support since 2016\n- reddit: pam_zfs_key\n\n"
    }
  ]
}