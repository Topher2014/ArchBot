{
  "title": "EFI System Partition",
  "url": "https://wiki.archlinux.org/title/EFI_System_Partition",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Unified Extensible Firmware Interface\n- Boot loader\n\nThe EFI system partition (also called ESP) is an OS independent partition that acts as the storage place for the UEFI boot loaders, applications and drivers to be launched by the UEFI firmware. It is mandatory for UEFI boot.\n\n"
    },
    {
      "title": "Check for an existing partition",
      "level": 2,
      "content": "If you are installing Arch Linux on an UEFI-capable computer with an installed operating system, like Windows 10 for example, it is very likely that you already have an EFI system partition.\n\nTo find out the disk partition scheme and the system partition, use fdisk as root on the disk you want to boot from:\n\n```\n# fdisk -l /dev/sdx\n```\n\nThe command returns:\n\n- The disk's partition table: it indicates Disklabel type: gpt if the partition table is GPT or Disklabel type: dos if it is MBR.\n- The list of partitions on the disk: Look for the EFI system partition in the list, it is usually at least 100 MiB in size and has the type EFI System or EFI (FAT-12/16/32). To confirm this is the ESP, mount it and check whether it contains a directory named EFI, if it does this is definitely the ESP.\n\nIf you found an acceptable existing EFI system partition, simply proceed to #Mount the partition. If you did not find one, you will need to create it, proceed to #Create the partition.\n\n"
    },
    {
      "title": "Create the partition",
      "level": 2,
      "content": "The following two sections show how to create an EFI system partition (ESP).\n\nThe partition size should provide adequate space for storing boot loaders and other files required for booting.\n\nIt is recommended to make the partition 1 GiB in size to ensure it has adequate space for multiple kernels or unified kernel images, a boot loader, firmware updates files and any other operating system or OEM files. If still in doubt, 4 GiB ought to be enough for anybody, e.g., for tools like Limine boot loader with Snapper integration for Btrfs, which supports creating multiple bootable snapshots.\n\n- For early and/or buggy UEFI implementations the size of at least 512 MiB might be needed.[1]\n- If you plan to mount the partition to /boot and will not install more than one kernel, then 400 MiB will be sufficient.\n- When dual booting with Windows, the size should be at least 300 MiB for drives with a 4096 logical sector size (Advanced Format 4Kn drives)[2] or at least 100 MiB otherwise.[3]\n- To ensure the partition can be formatted to FAT32, it should be at least 36 MiB on drives with 512 byte logical sector size and 260 MiB on drives with 4096 logical sector size.[4]\n- If none of these are relevant issues, the partition size can be as small as 2 MiB, in which case it could house nothing more than a boot loader.\n\n"
    },
    {
      "title": "GPT partitioned disks",
      "level": 3,
      "content": "EFI system partition on a GUID Partition Table is identified by the partition type GUID C12A7328-F81F-11D2-BA4B-00A0C93EC93B.\n\nChoose one of the following methods to create an ESP for a GPT partitioned disk:\n\n- fdisk: Create a partition and use the t command to change its partition type to EFI System using the alias uefi.\n- gdisk: Create a partition with partition type EF00.\n- GNU Parted: Create a partition with fat32 as the file system type and set the esp flag on it.\n\nAfter creating the partition, it should be formatted with a file system. Proceed to the #Format the partition section below.\n\n"
    },
    {
      "title": "MBR partitioned disks",
      "level": 3,
      "content": "Note: See also Partitioning#Choosing between GPT and MBR for the limits of MBR and the advantages of GPT in general.\n\n- Some firmware might not support UEFI/MBR booting due to it not being supported by Windows Setup.\n- bootctl does not support installing systemd-boot to an MBR partitioned disk; see systemd issue 1125.\n\nSee also Partitioning#Choosing between GPT and MBR for the limits of MBR and the advantages of GPT in general.\n\nEFI system partition on a Master Boot Record partition table is identified by the partition type ID EF.\n\nChoose one of the following methods to create an ESP for a MBR partitioned disk:\n\n- fdisk: Create a primary partition and and use the t command to change its partition type to EFI (FAT-12/16/32).\n- GNU Parted: Create a primary partition with fat32 as the file system type and set the esp flag on it.\n\nAfter creating the partition, it should be formatted with a file system. Proceed to the #Format the partition section below.\n\n"
    },
    {
      "title": "Format the partition",
      "level": 2,
      "content": "The UEFI specification mandates support for the FAT12, FAT16, and FAT32 file systems (see UEFI specification version 2.10, section 13.3.1.1), but any conformant vendor can optionally add support for additional file systems; for example, the firmware in Apple Macs supports the HFS+ file system.\n\nTo prevent potential issues with other operating systems and since the UEFI specification says that UEFI \"encompasses the use of FAT32 for a system partition, and FAT12 or FAT16 for removable media\"[5], it is recommended to use FAT32. Use the mkfs.fat(8) utility from dosfstools:\n\n```\n# mkfs.fat -F 32 /dev/sdxY\n```\n\nIf you get the message WARNING: Not enough clusters for a 32 bit FAT! and you cannot create a larger ESP, reduce cluster size with mkfs.fat -s2 -F32 ... or -s1; otherwise the partition may be unreadable by UEFI. See mkfs.fat(8) for supported cluster sizes.\n\nFor partitions smaller than 32 MiB using FAT32 may not be possible. In which case, format it to FAT16 or even FAT12. For example, a 2 MiB ESP will only be able to support FAT12:\n\n```\n# mkfs.fat -F 12 /dev/sdxY\n```\n\n"
    },
    {
      "title": "Mount the partition",
      "level": 2,
      "content": "The kernels, initramfs files, and, in most cases, the processor's microcode, need to be accessible by the boot loader or UEFI itself to successfully boot the system. Thus if you want to keep the setup simple, your boot loader choice limits the available mount points for EFI system partition.\n\nNote: Alternatively preload the required kernel modules on boot, e.g.:\n\nAlternatively preload the required kernel modules on boot, e.g.:\n\n```\n/etc/modules-load.d/vfat.conf\n```\n\n```\nvfat\nnls_cp437\nnls_ascii\n```\n\n"
    },
    {
      "title": "Typical mount points",
      "level": 3,
      "content": "The three typical scenarios for mounting the EFI system partition are:\n\n- mount the ESP to /boot: This facilitates system maintenance and administration, as /boot is the default path where microcode packages place the CPU microcode initramfs files and where mkinitcpio places kernels and initramfs images. This ensures that the above files are accessible to most boot loaders, as not all of them can access files on other volumes. This prevents setting file-specific permissions and/or extended attributes, as FAT sets global permissions at mount time This increases the size requirement for the ESP, as files normally installed in /boot will join the EFI-related ones. In the case of dual-booting, this exposes the OS-specific boot files to potentially hazardous manipulation from other OSes. This makes encrypting /boot impossible, as EFI-related files have to be accessible by the firmware.\n- mount the ESP to /efi: It ensures a separation of concerns between OS- and EFI-related files, which may include other OSes' files better left alone. It avoids increasing the size requirement of the ESP by not placing the files installed to /boot in it: only the EFI binaries (the boot loader (and optionally drivers) and/or the unified kernel image) will be stored on the ESP, which saves storage space. It allows to preserve Linux-specific filesystem permissions for files residing in /boot, avoiding FAT limitations. It allows to mount separately the ESP according to the need, e.g. only when upgrading the boot loader. If using system encryption with the appropriate setup, it allows to leave only a few required files unencrypted while /boot remains protected: this can be useful for unified kernel images or boot loaders that have file system drivers capable of accessing the kernel(s) and files that are stored elsewhere.\n- mount the ESP to /efi and additionally mount an \"Extended Boot Loader Partition\" (XBOOTLDR) to /boot. This can be useful when a previously created ESP is too small to hold multiple boot loaders and/or kernels but the ESP cannot be easily resized (such as when installing Linux after Windows to dual boot). This method is supported by at least systemd-boot.\n\n- This facilitates system maintenance and administration, as /boot is the default path where microcode packages place the CPU microcode initramfs files and where mkinitcpio places kernels and initramfs images.\n- This ensures that the above files are accessible to most boot loaders, as not all of them can access files on other volumes.\n- This prevents setting file-specific permissions and/or extended attributes, as FAT sets global permissions at mount time\n- This increases the size requirement for the ESP, as files normally installed in /boot will join the EFI-related ones.\n- In the case of dual-booting, this exposes the OS-specific boot files to potentially hazardous manipulation from other OSes.\n- This makes encrypting /boot impossible, as EFI-related files have to be accessible by the firmware.\n\n- It ensures a separation of concerns between OS- and EFI-related files, which may include other OSes' files better left alone.\n- It avoids increasing the size requirement of the ESP by not placing the files installed to /boot in it: only the EFI binaries (the boot loader (and optionally drivers) and/or the unified kernel image) will be stored on the ESP, which saves storage space.\n- It allows to preserve Linux-specific filesystem permissions for files residing in /boot, avoiding FAT limitations.\n- It allows to mount separately the ESP according to the need, e.g. only when upgrading the boot loader.\n- If using system encryption with the appropriate setup, it allows to leave only a few required files unencrypted while /boot remains protected: this can be useful for unified kernel images or boot loaders that have file system drivers capable of accessing the kernel(s) and files that are stored elsewhere.\n\n- /efi is a replacement[6][7] for the historical and now discouraged ESP mountpoint /boot/efi.\n- The /efi directory is not available by default, you will need to first create it before mounting the ESP to it.\n\n"
    },
    {
      "title": "Alternative mount points",
      "level": 3,
      "content": "If you do not use one of the #Typical mount points, you will need to copy your boot files to ESP (referred to hereafter as esp).\n\n```\n# mkdir -p esp/EFI/arch\n# cp -a /boot/vmlinuz-linux esp/EFI/arch/\n# cp -a /boot/initramfs-linux.img esp/EFI/arch/\n# cp -a /boot/initramfs-linux-fallback.img esp/EFI/arch/\n```\n\nFurthermore, you will need to keep the files on the ESP up-to-date with later kernel updates. Failure to do so could result in an unbootable system. The following sections discuss several mechanisms for automating it.\n\n"
    },
    {
      "title": "Using bind mount",
      "level": 4,
      "content": "Instead of mounting the ESP itself to /boot, you can mount a directory of the ESP to /boot using a bind mount (see mount(8)). This allows pacman to update the kernel directly while keeping the ESP organized to your liking.\n\nJust like in #Alternative mount points, copy all boot files to a directory on your ESP, but mount the ESP outside /boot. Then bind mount the directory:\n\n```\n# mount --bind esp/EFI/arch /boot\n```\n\nAfter verifying success, edit your Fstab to make the changes persistent:\n\n```\n/etc/fstab\n```\n\n```\nesp/EFI/arch /boot none defaults,bind 0 0\n```\n\n"
    },
    {
      "title": "Using systemd",
      "level": 4,
      "content": "Systemd features event triggered tasks. In this particular case, the ability to detect a change in path is used to sync the EFISTUB kernel and initramfs files when they are updated in /boot/. The file watched for changes is initramfs-linux-fallback.img since this is the last file built by mkinitcpio, to make sure all files have been built before starting the copy. The systemd path and service files to be created are:\n\n```\n/etc/systemd/system/efistub-update.path\n```\n\n```\n[Unit]\nDescription=Copy EFISTUB Kernel to EFI system partition\n\n[Path]\nPathChanged=/boot/initramfs-linux-fallback.img\n\n[Install]\nWantedBy=multi-user.target\nWantedBy=system-update.target\n```\n\n```\n/etc/systemd/system/efistub-update.service\n```\n\n```\n[Unit]\nDescription=Copy EFISTUB Kernel to EFI system partition\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/cp -af /boot/vmlinuz-linux esp/EFI/arch/\nExecStart=/usr/bin/cp -af /boot/initramfs-linux.img esp/EFI/arch/\nExecStart=/usr/bin/cp -af /boot/initramfs-linux-fallback.img esp/EFI/arch/\n```\n\nThen enable and start efistub-update.path.\n\n```\nExecStart=/usr/bin/sbsign --key /path/to/db.key --cert /path/to/db.crt --output esp/EFI/arch/vmlinuz-linux /boot/vmlinuz-linux\n```\n\n"
    },
    {
      "title": "Using filesystem events",
      "level": 4,
      "content": "Filesystem events can be used to run a script syncing the EFISTUB Kernel after kernel updates. An example with incron follows.\n\n```\n/usr/local/bin/efistub-update\n```\n\n```\n#!/bin/sh\ncp -af /boot/vmlinuz-linux esp/EFI/arch/\ncp -af /boot/initramfs-linux.img esp/EFI/arch/\ncp -af /boot/initramfs-linux-fallback.img esp/EFI/arch/\n```\n\n```\n/etc/incron.d/efistub-update.conf\n```\n\n```\n/boot/initramfs-linux-fallback.img IN_CLOSE_WRITE /usr/local/bin/efistub-update\n```\n\nIn order to use this method, enable the incrond.service.\n\n"
    },
    {
      "title": "Using mkinitcpio preset",
      "level": 4,
      "content": "As the presets in /etc/mkinitcpio.d/ support shell scripting, the kernel and initramfs can be copied by just editing the presets.\n\nEdit the file /etc/mkinitcpio.d/linux.preset:\n\n```\n/etc/mkinitcpio.d/linux.preset\n```\n\n```\n# mkinitcpio preset file for the 'linux' package\n\n# Directory to install the kernel, the initramfs...\nESP_DIR=\"esp/EFI/arch\"\n\n#ALL_config=\"/etc/mkinitcpio.conf\"\nALL_kver=\"${ESP_DIR}/vmlinuz-linux\"\n\nPRESETS=('default' 'fallback')\n\n#default_config=\"/etc/mkinitcpio.conf\"\ndefault_image=\"${ESP_DIR}/initramfs-linux.img\"\ndefault_options=\"\"\n\n#fallback_config=\"/etc/mkinitcpio.conf\"\nfallback_image=\"${ESP_DIR}/initramfs-linux-fallback.img\"\nfallback_options=\"-S autodetect\"\n```\n\nTo test that, just run:\n\n```\n# rm /boot/initramfs-linux-fallback.img /boot/initramfs-linux.img\n# mv /boot/vmlinuz-linux esp/EFI/arch/\n# mkinitcpio -p linux\n```\n\n```\n/etc/mkinitcpio.d/linux.preset\n```\n\n```\nESP_DIR=\"esp/EFI/arch\"\n#ALL_config=\"/etc/mkinitcpio.conf\"\nALL_kver=\"$ESP_DIR/vmlinuz-linux$suffix\"\nPRESETS=('default')\ndefault_config=\"/etc/mkinitcpio.conf\"\ndefault_image=\"$ESP_DIR/initramfs-linux$suffix.img\"\n```\n\n```\n/etc/mkinitcpio.d/linux-zen.preset\n```\n\n```\nsuffix='-zen'\nsource /etc/mkinitcpio.d/linux.preset\n```\n\n"
    },
    {
      "title": "Using a mkinitcpio post hook",
      "level": 4,
      "content": "A mkinitcpio post hook can be used to copy kernels and initramfs images to a desired directory after the initramfs is generated.\n\nCreate the following file and make it executable:\n\n```\n/etc/initcpio/post/copy-kernel-and-initramfs\n```\n\n```\n#!/usr/bin/env bash\n\nkernel=\"$1\"\ninitrd=\"$2\"\ntarget_dir=\"esp/EFI/arch\"\nfiles_to_copy=()\n\nfor file in \"$kernel\" \"$initrd\"; do\n\tif [[ -n \"$file\" ]] && ! cmp -s -- \"$file\" \"${target_dir}/${file##*/}\"; then\n\t\tfiles_to_copy+=(\"$file\")\n\tfi\ndone\n\n(( ! ${#files_to_copy[@]} )) && exit 0\n\ncp -af -- \"${files_to_copy[@]}\" \"${target_dir}/\"\n```\n\n"
    },
    {
      "title": "Using pacman hook",
      "level": 4,
      "content": "A last option relies on the pacman hooks that are run at the end of the transaction.\n\nThe first file is a hook that monitors the relevant files, and it is run if they were modified in the former transaction.\n\n```\n/etc/pacman.d/hooks/999-kernel-efi-copy.hook\n```\n\n```\n[Trigger]\nType = Path\nOperation = Install\nOperation = Upgrade\nTarget = usr/lib/modules/*/vmlinuz\nTarget = usr/lib/initcpio/*\nTarget = boot/*-ucode.img\n\n[Action]\nDescription = Copying linux and initramfs to EFI directory...\nWhen = PostTransaction\nExec = /usr/local/bin/kernel-efi-copy.sh\n```\n\nThe second file is the script itself. Create the file and make it executable:\n\n```\n/usr/local/bin/kernel-efi-copy.sh\n```\n\n```\n#!/bin/sh\n#\n# Copy kernel and initramfs images to EFI directory\n#\n\nESP_DIR=\"esp/EFI/arch\"\n\nfor file in /boot/vmlinuz*\ndo\n        cp -af \"$file\" \"$ESP_DIR/$(basename \"$file\").efi\"\n        [ $? -ne 0 ] && exit 1\ndone\n\nfor file in /boot/initramfs*\ndo\n        cp -af \"$file\" \"$ESP_DIR/\"\n        [ $? -ne 0 ] && exit 1\ndone\n\n[ -e /boot/intel-ucode.img ] && cp -af /boot/intel-ucode.img \"$ESP_DIR/\"\n[ -e /boot/amd-ucode.img ] && cp -af /boot/amd-ucode.img \"$ESP_DIR/\"\n\nexit 0\n```\n\n"
    },
    {
      "title": "Replace the partition with a larger one",
      "level": 3,
      "content": "On a disk with a preexisting operating system, the EFI system partition may be smaller than recommended in #Create the partition. E.g. Windows Setup creates a measly 100 MiB EFI system partition on non-4Kn drives.\n\nIn such cases, it may be a good idea to create a new, larger EFI system partition to prevent running out of space on it.\n\n"
    },
    {
      "title": "Free up space for a new partition in Windows",
      "level": 4,
      "content": "In Windows, partitions can be either managed graphically with Disk Management (diskmgmt.msc) or from the command line with the diskpart.exe utility.\n\nRun diskmgmt.msc as Administrator.\n\n1. Right click on the \"(C:)\" partition (the only one of the default Windows-created partitions which can be resized online) and select Shrink Volume....\n1. Enter 4096 as the amount to shrink and click Shrink.\n\nThere should now be a 4 GiB unallocated space after the \"(C:)\" partition.\n\nBoot into Arch Linux or the Arch Linux installation medium to proceed to creating a new partition.\n\n"
    },
    {
      "title": "Delete the old partition and create a new one",
      "level": 4,
      "content": "First, make sure to backup the contents of the EFI system partition. For example, with esp being its mountpoint:\n\n```\n# cp -a esp /esp_backup\n```\n\nUnmount the EFI system partition:\n\n```\n# umount esp\n```\n\nRun blkid and take note of the UUID and PARTUUID values. They will later be reused for the new partition.\n\n```\n# blkid\n```\n\n```\n/dev/sdxY: UUID=\"XXXX-XXXX\" BLOCK_SIZE=\"512\" TYPE=\"vfat\" PARTLABEL=\"EFI system partition\" PARTUUID=\"YYYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY\"\n```\n\nDelete the old partition using sgdisk from gptfdisk:\n\n```\n# sgdisk --delete=Y /dev/sdx\n```\n\nCreate a new partition in the largest unallocated space while reusing the old PARTUUID and PARTLABEL:\n\n```\n# sgdisk --align-end --largest-new=0 --typecode=0:ef00 --change-name=0:'EFI system partition' --partition-guid=0:YYYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY /dev/sdx\n```\n\nConfirm the new, 4 GiB in size, EFI system partition is created by listing the partitions with fdisk:\n\n```\n# fdisk -l /dev/sdx\n```\n\n```\n...\nDevice         Start       End   Sectors  Size Type\n/dev/sdx1  158099456 166488063   8388608    4G EFI System\n/dev/sdx2     206848    239615     32768   16M Microsoft reserved\n/dev/sdx3     239616 158099455 157859840 75.3G Microsoft basic data\n/dev/sdx4  166488064 167768063   1280000  625M Windows recovery environment\n/dev/sdx5  167768064 176156671   8388608    4G Linux swap\n/dev/sdx6  176156672 243265535  67108864   32G Linux root (x86-64)\n\nPartition table entries are not in disk order.\n```\n\nPartition numbers are not resorted when deleting and creating partitions, so the EFI system partition number on the disk will likely be the same as before.\n\nFormat the partition to FAT32 reusing the old UUID (while removing the dash from it):\n\n```\n# mkfs.fat -F 32 -i XXXXXXXX /dev/sdxY\n```\n\nFinally, mount the new partition and restore its contents from backup:\n\n```\n# mount /dev/sdxY esp\n# cp -a /esp_backup/. esp/\n```\n\nIf you previously stopped esp.automount, start it again.\n\n"
    },
    {
      "title": "Sacrifice an adjacent swap partition to enlarge the ESP",
      "level": 4,
      "content": "If there is a swap partition right after the EFI system partition, you can sacrifice it to give space for enlarging the EFI system partition. E.g. with a layout similar to:\n\n```\n# fdisk -l /dev/sdx\n```\n\n```\n...\nDevice       Start       End   Sectors  Size Type\n/dev/sdx1     2048    616447    614400  300M EFI System\n/dev/sdx2   616448   9005055   8388608    4G Linux swap\n/dev/sdx3  9005056 125827071 116822016 55.7G Linux root (x86-64)\n```\n\nFirst, deactivate the swap partition and remove it from fstab.\n\nUse fdisk to delete the swap partition and enlarge the EFI system partition.\n\n1. Run: # fdisk -l /dev/sdx\n1. Use the d command to delete the swap partition (partition number 2 in the example layout above).\n1. Use the e command to enlarge the EFI system partition (partition number 1 in the example layout above). Use the suggested default value for the new size and press Enter.\n1. Write changes to disk and exit via the w command.\n\n```\n# fdisk -l /dev/sdx\n```\n\nAfter the partition is resized, you need to resize the file system in it. Since fatresize(1) does not work and libparted cannot resize FAT volumes of certain sizes, the only option is to backup the files from the existing file system and create a new one that takes up all space of the partition.\n\nTake note of the file system UUID to allow reusing it for the new file system:\n\n```\n$ lsblk -dno UUID /dev/sdxY\n```\n\n```\nXXXX-XXXX\n```\n\nBackup the contents of the EFI system partition. For example, with esp being its mountpoint:\n\n```\n# cp -a esp /esp_backup\n```\n\nUnmount the EFI system partition:\n\n```\n# umount esp\n```\n\nWipe the file system signature from the partition to avoid any artifacts from the old file system:\n\n```\n# wipefs -af /dev/sdxY\n```\n\nFormat the partition to FAT32 reusing the old UUID (while removing the dash from it):\n\n```\n# mkfs.fat -F 32 -i XXXXXXXX /dev/sdxY\n```\n\nFinally, mount the new partition and restore its contents from backup:\n\n```\n# mount /dev/sdxY esp\n# cp -a /esp_backup/. esp/\n```\n\nIf you previously stopped esp.automount, start it again.\n\nNow that the swap partition is gone, set up swap on a swap file.\n\n"
    },
    {
      "title": "ESP on software RAID1",
      "level": 3,
      "content": "It is possible to make the ESP part of a RAID1 array, but doing so brings the risk of data corruption, and further considerations need to be taken when creating the ESP. See [9] and [10] for details and UEFI booting and RAID1 for an in-depth guide with a solution.\n\nThe key part is to use --metadata 1.0 in order to keep the RAID metadata at the end of the partition, otherwise the firmware will not be able to access it:\n\n```\n# mdadm --create --verbose --level=1 --metadata=1.0 --raid-devices=2 /dev/md/ESP /dev/sdaX /dev/sdbY\n```\n\nAlternatively, as the ESP is not often updated, a secondary ESP can be managed by copying the primary ESP to the secondary one on a different disk during relevant updates. A boot entry for the secondary ESP can then be added manually using efibootmgr. See the debian wiki for an implementation example. Note that while this avoids some risks of the RAID approach, it only works when using a single OS.\n\n"
    },
    {
      "title": "Firmware does not see the EFI directory",
      "level": 3,
      "content": "If you give the FAT file system a volume name (i.e. file system label), be sure to name it something other than EFI. That can trigger a bug in some firmwares (due to the volume name matching the EFI directory name) that will cause the firmware to act like the EFI directory does not exist.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- The EFI system partition and the default boot behavior\n- Multi Boot Linux With One Boot Partition | John Ramsden\n\n"
    }
  ]
}