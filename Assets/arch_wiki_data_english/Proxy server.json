{
  "title": "Proxy server",
  "url": "https://wiki.archlinux.org/title/Proxy_server",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- HTTP tunneling\n\nAccording to Wikipedia:\n\nProxying can be applied in common Internet protocols such as HTTP or SOCKS.\n\n"
    },
    {
      "title": "HTTPS MITM proxies",
      "level": 2,
      "content": "When debugging HTTPS connections it is sometimes useful to intercept them outside of the browser. In order for the TLS MITM to work you need to trust a certificate authority of the proxy either in your browser or system-wide.\n\n- Charles — Graphical trialware written in Java.\n\n- Fiddler — Proprietary and graphical, running on Mono.\n\n- microsocks — Plain simple SOCKS5 proxy server, written in C.\n\n- mitmproxy — Command-line and web interface, written in Python, also has API.\n\n- sslsplit — Works with any TLS connections but cannot act as a HTTP proxy in a browser, written in C.\n\n"
    },
    {
      "title": "Environment variables",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nSome programs, such as wget and (used by pacman) CURL, use environment variables of the form protocol_proxy to determine the proxy for a given protocol (e.g. HTTP, FTP, ...).\n\nBelow is an example on how to set these variables in a shell:\n\n```\nexport http_proxy=http://10.203.0.1:5187/\nexport https_proxy=$http_proxy\nexport ftp_proxy=$http_proxy\nexport rsync_proxy=$http_proxy\nexport no_proxy=\"localhost,127.0.0.1,localaddress,.localdomain.com\"\n```\n\nSome programs look for the all caps version of the environment variables.\n\nIf the proxy environment variables are to be made available to all users and all applications, the above mentioned export commands may be added to a script, say proxy.sh inside /etc/profile.d/. The script has to be then made executable. This method is helpful while using a desktop environment like Xfce which does not provide an option for proxy configuration. For example, Chromium browser will make use of the variables set using this method while running XFCE.\n\nAlternatively, there is a tool named proxyman-gitAUR which claims to configure system-wide proxy settings easily. It also handles proxy configurations of other software like git, npm, Dropbox, etc.\n\nAlternatively you can automate the toggling of the variables by adding a function to your .bashrc:\n\n```\nfunction proxy_on() {\n    export no_proxy=\"localhost,127.0.0.1,localaddress,.localdomain.com\"\n\n    if (( $# > 0 )); then\n        valid=$(echo $@ | sed -n 's/\\([0-9]\\{1,3\\}.\\?\\)\\{4\\}:\\([0-9]\\+\\)/&/p')\n        if [[ $valid != $@ ]]; then\n            >&2 echo \"Invalid address\"\n            return 1\n        fi\n        local proxy=$1\n        export http_proxy=\"$proxy\" \\\n               https_proxy=$proxy \\\n               ftp_proxy=$proxy \\\n               rsync_proxy=$proxy\n        echo \"Proxy environment variable set.\"\n        return 0\n    fi\n\n    echo -n \"username: \"; read username\n    if [[ $username != \"\" ]]; then\n        echo -n \"password: \"\n        read -es password\n        local pre=\"$username:$password@\"\n    fi\n\n    echo -n \"server: \"; read server\n    echo -n \"port: \"; read port\n    local proxy=$pre$server:$port\n    export http_proxy=\"$proxy\" \\\n           https_proxy=$proxy \\\n           ftp_proxy=$proxy \\\n           rsync_proxy=$proxy \\\n           HTTP_PROXY=$proxy \\\n           HTTPS_PROXY=$proxy \\\n           FTP_PROXY=$proxy \\\n           RSYNC_PROXY=$proxy\n}\n\nfunction proxy_off(){\n    unset http_proxy https_proxy ftp_proxy rsync_proxy \\\n          HTTP_PROXY HTTPS_PROXY FTP_PROXY RSYNC_PROXY\n    echo -e \"Proxy environment variable removed.\"\n}\n```\n\nOmit username or password if they are not needed.\n\nAs an alternative, you may want to use the following script. Change the strings YourUserName, ProxyServerAddress:Port, LocalAddress and LocalDomain to match your own data, then edit your ~/.bashrc to include the edited functions. Any new bash window will have the new functions. In existing bash windows, type source ~/.bashrc. You may prefer to put function definitions in a separate file like functions then add source functions to .bashrc instead of putting everything in .bashrc. You may also want to change the name \"myProxy\" into something short and easy to write.\n\n```\n#!/bin/bash\n\nassignProxy(){\n   PROXY_ENV=\"http_proxy ftp_proxy https_proxy all_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY\"\n   for envar in $PROXY_ENV\n   do\n      export $envar=$1\n   done\n   for envar in \"no_proxy NO_PROXY\"\n   do\n      export $envar=$2\n   done\n}\n\nclrProxy(){\n    PROXY_ENV=\"http_proxy ftp_proxy https_proxy all_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY\"\n    for envar in $PROXY_ENV\n    do\n       unset $envar\n    done\n}\n\nmyProxy(){\n   user=YourUserName\n   read -p \"Password: \" -s pass &&  echo -e \" \"\n   proxy_value=\"http://$user:$pass@ProxyServerAddress:Port\"\n   no_proxy_value=\"localhost,127.0.0.1,LocalAddress,LocalDomain.com\"\n   assignProxy $proxy_value $no_proxy_value\n}\n```\n\n"
    },
    {
      "title": "Keep proxy through sudo",
      "level": 3,
      "content": "If the proxy environment variables are set for the user only they will get lost when running commands with sudo (or when programs use sudo internally).\n\nA way to prevent that is to add the following line to a sudo configuration file:\n\n```\n/etc/sudoers.d/05_proxy\n```\n\n```\nDefaults env_keep += \"*_proxy *_PROXY\"\n```\n\n"
    },
    {
      "title": "Automation with network managers",
      "level": 3,
      "content": "- NetworkManager cannot change the environment variables.\n- netctl could set-up these environment variables but they would not be seen by other applications as they are not child of netctl.\n\n"
    },
    {
      "title": "About libproxy",
      "level": 2,
      "content": "libproxy is an abstraction library which should be used by all applications that want to access a network resource. It still is in development but could lead to a unified and automated handling of proxies in GNU/Linux if widely adopted.\n\nThe role of libproxy is to read the proxy settings from different sources and make them available to applications which use the library. The interesting part with libproxy is that it offers an implementation of the Web Proxy Autodiscovery Protocol and an implementation of Proxy Auto-Config that goes with it.\n\nThe /usr/bin/proxy binary takes URL(s) as argument(s) and returns the proxy/proxies that could be used to fetch this/these network resource(s).\n\n"
    },
    {
      "title": "Web proxy options",
      "level": 2,
      "content": "- Squid is a very popular caching/optimizing proxy.\n- Privoxy is an anonymizing and ad-blocking proxy.\n- tinyproxy is a small, efficient HTTP/SSL proxy daemon.\n- For a simple proxy, ssh with port forwarding can be used.\n\n"
    },
    {
      "title": "Simple Proxy with SSH",
      "level": 3,
      "content": "Connect to a server (HOST) on which you have an account (USER) as follows\n\n```\n$ ssh -D PORT USER@HOST\n```\n\nFor PORT, choose some number which is not an IANA registered port. This specifies that traffic on the local PORT will be forwarded to the remote HOST. ssh will act as a SOCKS server. Software supporting SOCKS proxy servers can simply be configured to connect to PORT on localhost. See OpenSSH#Forwarding other ports.\n\n"
    },
    {
      "title": "Using a SOCKS proxy",
      "level": 2,
      "content": "There are two cases:\n\n- the application you want to use handles SOCKS5 proxies (for example Firefox), then you just have to configure it to use the proxy.\n- the application you want to use does not handle SOCKS proxies, then you can try to use proxychains-ng, proxy-nsAUR, or torsocks.\n\nIn Firefox, you can use the SOCKS proxy in the menu Preferences > Network > Settings. Choose Manual Proxy Configuration, and set the SOCKS Host (and only this one, make sure the other fields, such as HTTP Proxy or SSL Proxy are left empty). For example, if a SOCKS5 proxy is running on localhost port 8080, put 127.0.0.1 in the SOCKS Host field, 8080 in the Port field, and validate.\n\nIf using proxychains-ng, the configuration takes place in /etc/proxychains.conf. You may have to uncomment the last line (set by default to use Tor), and replace it with the parameters of the SOCKS proxy. For example, if you are using the same SOCKS5 proxy as above, you will have to replace the last line by:\n\n```\nsocks5 127.0.0.1 8080\n```\n\nThen, proxychains-ng can be launched with\n\n```\n$ proxychains program\n```\n\nWhere program can be any program already installed on your system (e.g. xterm, gnome-terminal, etc).\n\nIf using proxy-ns, the configuration takes place in /etc/proxy-ns/config.json. You may have to change the socks5_address. An example configuration using SOCKS5 proxy as above looks like this:\n\n```\n/etc/proxy-ns/config.json\n```\n\n```\n{\n  \"tun_name\": \"tun0\",\n  \"tun_ip\": \"10.0.0.1/24\",\n  \"socks5_address\": \"127.0.0.1:8080\",\n  \"fake_dns\": true,\n  \"fake_network\": \"240.0.0.0/4\",\n  \"dns_server\": \"9.9.9.9\"\n}\n```\n\nThen, proxy-ns can be launched with:\n\n```\n$ proxy-ns program\n```\n\nThe usage is the same as proxychains.\n\nIf using tsocks, the configuration takes place in /etc/tsocks.conf. See tsocks.conf(5) for the options. An example minimum configuration looks like this:\n\n```\n/etc/tsocks.conf\n```\n\n```\nserver = 127.0.0.1\nserver_port = 8080\nserver_type = 5\ndefault_user = \"\"\ndefault_pass = \"\"\n```\n\n"
    },
    {
      "title": "curl and pacman",
      "level": 3,
      "content": "You may set the all_proxy environment variable to let curl and pacman (which uses curl) use your socks5 proxy:\n\n```\n$ export all_proxy=\"socks5://your.proxy:1080\"\n```\n\n"
    },
    {
      "title": "Proxy settings on GNOME",
      "level": 2,
      "content": "Some programs like Chromium and Firefox can use the settings stored by GNOME. These settings can be modified through the gnome-control-center front end and also through gsettings.\n\n```\ngsettings set org.gnome.system.proxy mode 'manual' \ngsettings set org.gnome.system.proxy.http host 'proxy.localdomain.com'\ngsettings set org.gnome.system.proxy.http port 8080\ngsettings set org.gnome.system.proxy.ftp host 'proxy.localdomain.com'\ngsettings set org.gnome.system.proxy.ftp port 8080\ngsettings set org.gnome.system.proxy.https host 'proxy.localdomain.com'\ngsettings set org.gnome.system.proxy.https port 8080\ngsettings set org.gnome.system.proxy.socks host 'proxy.localdomain.com'\ngsettings set org.gnome.system.proxy.socks port 8080\ngsettings set org.gnome.system.proxy ignore-hosts \"['localhost', '127.0.0.0/8', '10.0.0.0/8', '192.168.0.0/16', '172.16.0.0/12' , '*.localdomain.com' ]\"\n```\n\nAs GNOME is often used with NetworkManager, see also NetworkManager#Proxy settings. It does not appear that NetworkManager supports fetching the configuration from the GNOME settings above without a GNOME desktop.\n\n"
    },
    {
      "title": "Microsoft NTLM proxy",
      "level": 2,
      "content": "In a Windows network, NT LAN Manager (NTLM) is a suite of Microsoft security protocols which provides authentication, integrity, and confidentiality to users.\n\nA local proxy stands between your applications and the NTLM proxy, adding NTLM authentication on-the-fly.\n\n```\n(NTLM PROXY IP:PORT + CREDENTIALS + OTHER INFO) -----> (127.0.0.1:PORT)\n```\n\nTwo options are available from AUR:\n\n- alpaca-proxyAUR\n- cntlmAUR\n\n"
    },
    {
      "title": "Alpaca",
      "level": 3,
      "content": "alpaca-proxyAUR from AUR is a local HTTP proxy for command-line tools. It supports proxy auto-configuration (PAC) files and NTLM authentication.\n\n"
    },
    {
      "title": "Usage",
      "level": 4,
      "content": "Alpaca can be launched interactively, which requires entering a password:\n\n```\n$ alpaca -d MYDOMAIN -u me\nPassword (for MYDOMAIN\\me):\n```\n\nTo launch alpaca non-interactively, a NTLM hash needs to be generated and exported as a variable:\n\n```\n$ ./alpaca -d MYDOMAIN -u me -H\nPassword (for MYDOMAIN\\me):\nNTLM_CREDENTIALS=\"me@DOMAIN:00000000000000000000000000000000\"; export NTLM_CREDENTIALS\n```\n\nAlpaca will by default listen on localhost:3128, this can be overridden using the -l and -p options.\n\nFurthermore a proxy PAC url should be provided as a parameter of the -C option.\n\n"
    },
    {
      "title": "Running as a service",
      "level": 4,
      "content": "alpaca-proxyAUR includes the alpaca.service systemd user service, which can be used to start alpaca automatically in a non-interactive way.\n\nIt requires the following environment variables to be set in ~/.config/alpaca.environment:\n\n```\nLISTEN_ADDRESS=localhost\nLISTEN_PORT=3128\nNTLM_CREDENTIALS=\"me@DOMAIN:00000000000000000000000000000000\"\nPAC_URL=\"http://some.url/to/some-file.pac\"\n```\n\n"
    },
    {
      "title": "Cntlm",
      "level": 3,
      "content": "cntlmAUR from the AUR can be configured with several \"parent\" proxies and Cntlm will try one after another until one works. All authenticated connections are cached and reused to achieve high efficiency.\n\n"
    },
    {
      "title": "Configuration",
      "level": 4,
      "content": "Change settings in /etc/cntlm.conf as needed, except for the password. Then run:\n\n```\n$ cntlm -H\n```\n\nThis will generate encrypted password hashes according to your proxy hostname, username and password.\n\nEdit /etc/cntlm.conf again and include all three generated hashes, then enable cntlm.service.\n\nTo test settings, run:\n\n```\n$ cntlm -v\n```\n\n"
    },
    {
      "title": "Usage",
      "level": 4,
      "content": "Use 127.0.0.1:port or localhost:port as a proxy adress. port matches the Listen parameter in /etc/cntlm.conf, which by default is 3128.\n\n"
    }
  ]
}