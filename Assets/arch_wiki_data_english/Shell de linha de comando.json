{
  "title": "Shell de linha de comando",
  "url": "https://wiki.archlinux.org/title/Shell_de_linha_de_comando",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- dotfiles\n- Utilitários principais\n\nDo Wikipédia:\n\n"
    },
    {
      "title": "Lista de shells",
      "level": 2,
      "content": "Shells que são mais ou menos compatíveis com POSIX são listados sob #Compatíveis com POSIX, enquanto shells que têm uma sintaxe diferente estão sob #Shells alternativos.\n\n"
    },
    {
      "title": "Compatíveis com POSIX",
      "level": 3,
      "content": "Esses shells podem todos serem vinculados a /usr/bin/sh. Quando Bash, mkshAUR e zsh são chamados com o nome sh, eles se tornam mais compatíveis com POSIX.\n\n- Bash — O Bash estende o shell Bourne com histórico e conclusão de linha de comando, arrays indexados e associativos, aritmética de inteiros, substituição de processos, strings here, correspondência de expressões regulares e expansão de chaves.\n\n- DASH — Descendente da versão do NetBSD do Almquist SHell (ash). Um shell rápido compatível com POSIX que pretende ser o menor possível.\n\n- Korn shell — O KornShell possui uma linguagem de programação completa, poderosa e de alto nível para escrever aplicativos, muitas vezes mais fácil e rápido do que com outras linguagens de alto nível. Isso o torna especialmente adequado para prototipagem. O ksh tem as melhores características do Bourne shell e do C shell, além de muitos novos recursos próprios. Assim, o ksh pode fazer muito para melhorar sua produtividade e a qualidade do seu trabalho, tanto na interação com o sistema quanto na programação. Os programas ksh são mais fáceis de escrever e são mais concisos e legíveis do que os programas escritos em linguagem de nível inferior, como C.\n\n- Zsh — Shell projetado para uso interativo, embora também seja uma poderosa linguagem de script. Muitos dos recursos úteis de Bash, ksh e tcsh foram incorporados no Zsh; vários recursos originais foram adicionados. O documento introdutório detalha alguns dos recursos exclusivos do Zsh.\n\n"
    },
    {
      "title": "Shells alternativos",
      "level": 3,
      "content": "- C shell — Interpretador de linguagem de comando que pode ser usado tanto como um shell de login interativo quanto como um processador de comando de script de shell. Inclui um editor de linha de comando, completação de palavra programável, correção ortográfica, mecanismo de histórico, controle de trabalho e uma sintaxe tipo C.\n\n- Elvish — Elvish é um shell moderno e expressivo, que pode carregar valores internos estruturados por meio de pipelines. Esse recurso torna possível evitar um monte de código complexo de processamento de texto. Isso permite uma linguagem de programação mais efetiva, com recursos como exceções, espaço de nome e funções anônimas. Ele também possui um readline poderoso que verifica a sintaxe enquanto digita, e realce de sintaxe por padrão.\n\n- fish — Shell de linha de comando inteligente e amigável. O fish executa o realce da sintaxe da linha de comando em cores, bem como o realce e a completação dos comandos e dos argumentos, da existência do arquivo e do histórico. Ele oferece suporte à completação na medida em que você escreve para o histórico e os comandos. O fish é capaz de analisar as páginas man do sistema para determinar argumentos válidos para comandos, permitindo que ele realce e complete os comandos. Uma revisão fácil do último comando pode ser feita usando Alt+Up. O daemon de fish (fishd) facilita ter um histórico sincronizado em todas as instâncias do fish, bem como variáveis de ambiente universais e persistentes. Além disso, fish possui sintaxe de programação significativamente simplificada e fluxo de controle (similar ao ruby). Para mais informações, veja o tutorial.\n\n- Oh — Shell de Unix escrito em Go. É semelhante em espírito, mas diferente em detalhes de outros shells de Unix. Oh, estende os recursos da linguagem de programação do shell sem sacrificar os recursos interativos do shell.\n\n- PowerShell — O PowerShell é uma linguagem de programação orientada a objetos e um shell de linha de comando interativo, originalmente escrito para e exclusivo para o Windows. Mais tarde, foi aberto e portado para Mac OS X e Linux.\n\n- rc — Interpretador de comando para o Plan9 que fornece recursos semelhantes ao Bourne shell do UNIX, com algumas pequenas adições e menos sintaxe idiossincrática.\n\n- xonsh — AUm shell retrocompatível com base no interpretador python.\n\n"
    },
    {
      "title": "Alterando seu shell padrão",
      "level": 2,
      "content": "Depois de instalar um dos shells acima, você pode executar esse shell dentro do seu shell atual, apenas executando o executável. Se você quiser ser servido nesse shell quando você fizer login no entanto, você precisará alterar seu shell padrão.\n\nPara listar todos os shells instalados, execute:\n\n```\n$ chsh -l\n```\n\nE para definir um como padrão para seu usuário, faça:\n\n```\n$ chsh -s caminho-completo-do-shell\n```\n\nsendo caminho-completo-do-shell é o caminho completo como fornecido em chsh -l.\n\nSe você agora você encerrar a sessão e iniciá-la novamente, você será saudado pelo outro shell.\n\n"
    },
    {
      "title": "Arquivos de configuração",
      "level": 2,
      "content": "Para iniciar automaticamente programas no console ou no login, você pode usar os arquivos/diretórios de inicialização do shell. Leia a documentação do seu shell, ou seu artigo do ArchWiki, p. ex., Bash#Configuration files ou Zsh#Startup/Shutdown files.\n\nVeja também arquivos de configuração.\n\n"
    },
    {
      "title": "/etc/profile",
      "level": 3,
      "content": "Após o login, todas os shells compatíveis com Bourne usam /etc/profile, o que, por sua vez, origina qualquer arquivo *.sh legível em /etc/profile.d/: estes scripts não requerem uma diretiva de interpretador, nem precisam ser executáveis. Eles são usados para configurar um ambiente e definir configurações específicas do aplicativo.\n\n"
    },
    {
      "title": "Padronização",
      "level": 3,
      "content": "É possível fazer com que os arquivos de configuração de shells (alguns) sigam a mesma convenção de nomenclatura, além de ter suporte a alguma configuração comum entre os shells.\n\nVeja o artigo sobre isso e o repositório relacionado.\n\n"
    },
    {
      "title": "Entrada e saída",
      "level": 2,
      "content": "Veja também GregsWiki e Redirecionamento de E/S.\n\n- Redirecionamentos truncam arquivos antes que os comandos sejam executados: comando arquivo > arquivo não funcionará como esperado. Enquanto alguns comandos (sed, por exemplo) fornecem uma opção para editar arquivos no local, isso não acontece para muitos outros. Nesses casos, você pode usar o comando sponge(1) do pacote moreutils.\n- Como o cat não está embutido no shell, em muitas ocasiões você pode achar mais conveniente usar um redirecionamento, por exemplo, em scripts, ou se você se importa muito com desempenho. De fato, < arquivo faz o mesmo que cat arquivo.\n- Shells compatíveis com POSIX possuem suporte a Here Documents:\n\n```\ncomando arquivo > arquivo\n```\n\n```\n$ cat << EOF\num\ndois\ntrês\nEOF\n```\n\n- Pipelines de shells operam no stdout por padrão. Para operar no stderr(3), você pode redirecionar stderr para stdout com comando 2>&1 | outrocomando ou, para Bash 4, comando |& outrocomando.\n- Lembre-se que muitos utilitários principais do GNU aceitam arquivos como argumentos, então, por exemplo, grep padrão < arquivo pode ser substituído por grep padrão arquivo.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- Evolução de shells no Linux no IBM developerWorks\n- terminal.sexy — Designer de esquema de cores de terminal\n- Hyperpolyglot — Comparação lado a lado das sintaxes do shell\n- UNIX Power Tools — Uso geral da ferramenta de linha de comando\n- commandlinefu.com — Compartilhamento de trechos de linha de comando\n- List of applications/Utilities#Terminal emulators\n\n"
    }
  ]
}