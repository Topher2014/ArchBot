{
  "title": "Arch package guidelines/Security",
  "url": "https://wiki.archlinux.org/title/Arch_package_guidelines/Security",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Font – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel modules – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust - Security – Shell – VCS – Web – Wine\n\nThis page describes security packaging guidelines for Arch Linux packages. For C/C++ projects the compiler and linker can apply security hardening options. Arch Linux applies PIE, FORTIFY_SOURCE, stack protector, nx and relro by default.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "Hardening protections can be reviewed by running checksec.\n\n```\n$ checksec --file=/usr/bin/cat\n```\n\n"
    },
    {
      "title": "RELRO",
      "level": 2,
      "content": "RELRO is a generic mitigation technique to harden the data sections of an ELF binary/process. When a program is loaded several ELF memory sections need to be written to by the linker but can be turned read-only before turning control over to the program. This prevents attackers of overriding some ELF sections. There are two different RELRO modes:\n\n- Partial RELRO (-Wl,-z,relro) some sections are marked as read-only after program load except the GOT (.got.plt) is still writeable.\n- Full RELRO (-Wl,-z,now) during program load all dynamic symbols are resolved, allowing for the complete GOT to be marked read-only.\n\nIf an application reports partial relro, investigate if the build toolchain passes our LDFLAGS or allows overriding LDFLAGS. For Go packages investigate if the build method uses build.go as pure golang Makefile replacement which does not allow passing of LDFLAGS.\n\n"
    },
    {
      "title": "Haskell",
      "level": 3,
      "content": "For Haskell it is not clear how to achieve Full RELRO at the moment.\n\n"
    },
    {
      "title": "Go",
      "level": 3,
      "content": "See Go package guidelines#Flags and build options.\n\n"
    },
    {
      "title": "Stack canary",
      "level": 2,
      "content": "A stack canary is added by the compiler between the buffer and control data on the stack. If this well known value is corrupted, a buffer overflow occurred and the running program segfaults to prevent possible arbitrary code execution.\n\nThe gcc package has it enabled stack protection by default with the --enable-default-ssp compile option.\n\n"
    },
    {
      "title": "C/C++",
      "level": 3,
      "content": "Executable-space protection marks memory regions as non-executable, such that an attempt to execute machine code in these regions will cause an exception. It makes use of hardware features such as the NX bit (no-execute bit), or in some cases software emulation of those features.\n\n"
    },
    {
      "title": "C/C++",
      "level": 3,
      "content": "The gcc package has it enabled by default for C/C++ with --enable-default-pie.\n\n"
    },
    {
      "title": "Golang",
      "level": 3,
      "content": "Pass the following flags to go build:\n\n```\nexport GOFLAGS='-buildmode=pie'\nexport CGO_CPPFLAGS=\"-D_FORTIFY_SOURCE=3\"\nexport CGO_LDFLAGS=\"-Wl,-z,relro,-z,now\"\n```\n\n"
    },
    {
      "title": "Haskell",
      "level": 3,
      "content": "Pass the following flag to runhaskell Setup.hs configure:\n\n```\n--ghc-option='-pie'\n```\n\n"
    },
    {
      "title": "RPATH/RUNPATH",
      "level": 2,
      "content": "RUNPATH/RPATH provides further search paths for the object it is listed in (it can be used both for executable and for shared objects).\n\n```\n$ objdump -x /usr/bin/perl | grep -E 'RPATH|RUNPATH'\n```\n\nIf the RPATH value contains a path within an attackers control it can possibly execute code by installing a malicious library in that directory for example CVE-2006-1566 CVE-2005-4280. See Debian:RpathIssue.\n\nThe RPATH entry is set by the linker by passing for example the following string to LDFLAGS -Wl,-rpath -Wl,/usr/local/lib. To make an RUNPATH entry append --enable-new-dtags to the linker flags.\n\n"
    },
    {
      "title": "FORTIFY",
      "level": 2,
      "content": "Fortify source is a macro that adds buffer overflow protection in various functions that perform operations on memory and strings. It checks whether an attacker tries to copy more bytes to overflow a buffer and then stops the execution of the program. This protection is enabled with the default CPPFLAGS:\n\n```\nmakepkg.conf\n```\n\n```\nCPPFLAGS=\"-D_FORTIFY_SOURCE=3\"\n```\n\nSee makepkg#Configuration.\n\n"
    },
    {
      "title": "systemd services",
      "level": 2,
      "content": "Note: **This article or section is a candidate for moving to systemd/Sandboxing.** This article or section is a candidate for moving to systemd/Sandboxing.\n\nThis article or section is a candidate for moving to systemd/Sandboxing.\n\nIf a systemd service file is shipped with the package due to upstream not providing any, look into applying the following systemd service hardening features. Systemd provides a way to analyse security features which are enabled for a service.\n\n```\n$ systemd-analyze security reflector.service\n```\n\n"
    },
    {
      "title": "File access",
      "level": 3,
      "content": "A service can be hardened by restricting file system access.\n\nSet up a new file system namespace for the executed process and mounts private /tmp and var/tmp directories inside it that is not shared by processes outside the namespace. Useful for programs which write data to /tmp.\n\n```\nPrivateTmp=true\n```\n\nProtectSystem has three different varieties of mounting directories as read-only for the executed process. The \"full\" option mounts /usr, /boot and /etc read only. ProtectHome makes /home, /root and /run/user inaccessible to the executed process.\n\n```\nProtectSystem=strict\nProtectHome=true\n```\n\nSets up a new /dev namespace for the executed process and only adds API pseudo devices such as /dev/null, /dev/zero or /dev/random, but not for physical devices or system memory, system ports and others. This is useful to secure the execute process from writing directly to physical devices, systemd also adds a system call filter for calls within the @raw-io set.\n\n```\nPrivateDevices=true\n```\n\nThese options make the executed process unable to change kernel variables accessible through /proc/sys, /sys, etc. ProtectControlGroups makes the /sys/fs/cgroup hierarchy read-only.\n\n```\nProtectKernelTunables=true\nProtectControlGroups=true\n```\n\nMaking file paths inaccessible can be done as following:\n\n```\nInaccessiblePaths=/etc\n```\n\nMore detailed information can be found in systemd.exec(5).\n\n"
    },
    {
      "title": "User",
      "level": 3,
      "content": "Ensure that the executed process and its children can never gain new privileges through execve(2).\n\n```\nNoNewPrivileges=true\n```\n\n"
    },
    {
      "title": "Memory",
      "level": 3,
      "content": "Prohibit attempts to create memory mappings that are both writable and executable, to change mappings to be executable or to create executable shared memory. This sandboxes a process against allowing an attacker to write in to memory which is also executed. Note that enabling this is not compatible with all applications which rely on a JIT.\n\n```\nMemoryDenyWriteExecute=true\n```\n\n"
    },
    {
      "title": "System calls",
      "level": 3,
      "content": "Locks down the personality(2) system call so that the kernel execution domain can not be changed.\n\n```\nLockPersonality=true\n```\n\nSystem calls can be restricted in a service as well, systemd can display syscalls to filter on:\n\n```\n$ systemd-analyze syscall-filter\n```\n\nPredefined groups are available, e.g. to use the recommended starting point for whitelisting system calls for system services use:\n\n```\nSystemCallFilter=@system-service\n```\n\nSystem calls can be restricted by their architecture such as to prevent 32-bit binaries from executing on 64-bit machines (no non-native binaries):\n\n```\nSystemCallArchitectures=native\n```\n\n"
    },
    {
      "title": "Network",
      "level": 3,
      "content": "If the running process does not require any network access it can be fully disabled by setting up a new network namespace for the process and only configuration a loopback interface.\n\n```\nPrivateNetwork=true\n```\n\nIf network is required, the type of address families used can be restricted for the socket(2) system call by for example only allowing UNIX sockets.\n\n```\nRestrictAddressFamilies=AF_UNIX\n```\n\nFor when only network to localhost or specific IP ranges is required a process can be restricted by only allowing network access to localhost.\n\n```\nIPAddressAllow=localhost\nIPAddressDeny=any\n```\n\nMore information about network filtering can be found in systemd.resource-control(5).\n\n"
    },
    {
      "title": "Various",
      "level": 3,
      "content": "Sets up a new UTS namespace for the execute process and disallows changing the hostname or domainname.\n\n```\nProtectHostname=true\n```\n\n"
    }
  ]
}