{
  "title": "Hooks",
  "url": "https://wiki.archlinux.org/title/Hooks",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- /Package signing\n- /Pacnew and Pacsave\n- /Restore local database\n- /Rosetta\n- /Tips and tricks\n- Arch User Repository\n- Creating packages\n- Downgrading packages\n- namcap\n- FAQ#Package management\n- System maintenance\n\nThe pacman package manager is one of the major distinguishing features of Arch Linux. It combines a simple binary package format with an easy-to-use Arch build system. The goal of pacman is to make it possible to easily manage packages, whether they are from the official repositories or the user's own builds.\n\nPacman keeps the system up-to-date by synchronizing package lists with the master server. This server/client model also allows the user to download/install packages with a simple command, complete with all required dependencies.\n\nPacman is written in the C programming language and uses the bsdtar(1) tar format for packaging.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "What follows is just a small sample of the operations that pacman can perform. To read more examples, refer to pacman(8).\n\n"
    },
    {
      "title": "Installing packages",
      "level": 3,
      "content": "A package is an archive containing:\n\n- all of the (compiled) files of an application\n- metadata about the application, such as application name, version, dependencies, etc.\n- installation files and directives for pacman\n\nArch's package manager pacman can install, update, and remove those packages. Using packages instead of compiling and installing programs yourself has various benefits:\n\n- easily updatable: pacman will update existing packages as soon as updates are available\n- dependency checks: pacman handles dependencies for you, you only need to specify the program and pacman installs it together with every other program it needs\n- clean removal: pacman has a list of every file in a package; this way, no files are unintentionally left behind when you decide to remove a package.\n\n- Packages often have optional dependencies which are packages that provide additional functionality to the application but not strictly required for running it. When installing a package, pacman will list a package's optional dependencies, but they will not be found in pacman.log. Use the #Querying package databases command to view the optional dependencies of a package.\n- When installing a package which you require only as a (optional) dependency of some other package (i.e. not required by you explicitly), it is recommended to use the --asdeps option. For details, see the #Installation reason section.\n\nNote: **not** \n\n"
    },
    {
      "title": "Installing specific packages",
      "level": 4,
      "content": "To install a single package or list of packages, including dependencies, issue the following command:\n\n```\n# pacman -S package_name1 package_name2 ...\n```\n\nTo install a list of packages with regex (see this forum thread):\n\n```\n# pacman -S $(pacman -Ssq package_regex)\n```\n\nSometimes there are multiple versions of a package in different repositories (e.g. extra and extra-testing). To install the version from the extra repository in this example, the repository needs to be defined in front of the package name:\n\n```\n# pacman -S extra/package_name\n```\n\nTo install a number of packages sharing similar patterns in their names, one can use curly brace expansion. For example:\n\n```\n# pacman -S plasma-{desktop,mediacenter,nm}\n```\n\nThis can be expanded to however many levels needed:\n\n```\n# pacman -S plasma-{workspace{,-wallpapers},pa}\n```\n\nA virtual package is a special package which does not exist by itself, but is provided by one or more other packages. Virtual packages allow other packages to not name a specific package as a dependency, in case there are several candidates. Virtual packages cannot be installed by their name, instead they become installed in your system when you have installed a package providing the virtual package. An example is the dbus-units package.\n\n"
    },
    {
      "title": "Installing package groups",
      "level": 4,
      "content": "Some packages belong to a group of packages that can all be installed simultaneously. For example, issuing the command:\n\n```\n# pacman -S gnome\n```\n\nwill prompt you to select the packages from the gnome group that you wish to install.\n\nSometimes a package group will contain a large amount of packages, and there may be only a few that you do or do not want to install. Instead of having to enter all the numbers except the ones you do not want, it is sometimes more convenient to select or exclude packages or ranges of packages with the following syntax:\n\n```\nEnter a selection (default=all): 1-10 15\n```\n\nwhich will select packages 1 through 10 and 15 for installation, or:\n\n```\nEnter a selection (default=all): ^5-8 ^2\n```\n\nwhich will select all packages except 5 through 8 and 2 for installation.\n\nTo see what packages belong to the gnome group, run:\n\n```\n$ pacman -Sg gnome\n```\n\nAlso visit https://archlinux.org/groups/ to see what package groups are available.\n\n"
    },
    {
      "title": "Removing packages",
      "level": 3,
      "content": "To remove a single package, leaving all of its dependencies installed:\n\n```\n# pacman -R package_name\n```\n\nTo remove a package and its dependencies which are not required by any other installed package:\n\n```\n# pacman -Rs package_name\n```\n\nThe above may sometimes refuse to run when removing a group which contains otherwise needed packages. In this case try:\n\n```\n# pacman -Rsu package_name\n```\n\nTo remove a package, its dependencies and all the packages that depend on the target package:\n\n```\n# pacman -Rsc package_name\n```\n\nTo remove a package, which is required by another package, without removing the dependent package:\n\n```\n# pacman -Rdd package_name\n```\n\nPacman saves important configuration files when removing certain applications and names them with the extension: .pacsave. To prevent the creation of these backup files use the -n option:\n\n```\n# pacman -Rn package_name\n```\n\n"
    },
    {
      "title": "Upgrading packages",
      "level": 3,
      "content": "- Users are expected to follow the guidance in the System maintenance#Upgrading the system section to upgrade their systems regularly and not blindly run the following command.\n- Arch only supports full system upgrades. See System maintenance#Partial upgrades are unsupported and #Installing packages for details.\n\nPacman can update all packages on the system with just one command. This could take quite a while depending on how up-to-date the system is. The following command synchronizes the repository databases and updates the system's packages, excluding \"local\" packages that are not in the configured repositories:\n\n```\n# pacman -Syu\n```\n\n"
    },
    {
      "title": "Querying package databases",
      "level": 3,
      "content": "Pacman queries the local package database with the -Q flag, the sync database with the -S flag and the files database with the -F flag. See pacman -Q --help, pacman -S --help and pacman -F --help for the respective suboptions of each flag.\n\n```\n# pacman -Fy\n```\n\nPacman can search for packages in the database, searching both in packages' names and descriptions:\n\n```\n$ pacman -Ss string1 string2 ...\n```\n\nSometimes, -s's builtin ERE (Extended Regular Expressions) can cause a lot of unwanted results, so it has to be limited to match the package name only; not the description nor any other field:\n\n```\n$ pacman -Ss '^vim-'\n```\n\nTo search for already installed packages:\n\n```\n$ pacman -Qs string1 string2 ...\n```\n\nTo search for package file names in remote packages:\n\n```\n$ pacman -F string1 string2 ...\n```\n\nTo display extensive information about a given package (e.g. its dependencies):\n\n```\n$ pacman -Si package_name\n```\n\nFor locally installed packages:\n\n```\n$ pacman -Qi package_name\n```\n\nPassing two -i flags will also display the list of backup files and their modification states:\n\n```\n$ pacman -Qii package_name\n```\n\nTo retrieve a list of the files installed by a package:\n\n```\n$ pacman -Ql package_name\n```\n\nTo retrieve a list of the files installed by a remote package:\n\n```\n$ pacman -Fl package_name\n```\n\nTo verify the presence of the files installed by a package:\n\n```\n$ pacman -Qk package_name\n```\n\nPassing the k flag twice will perform a more thorough check.\n\nTo query the database to know which package a file in the file system belongs to:\n\n```\n$ pacman -Qo /path/to/file_name\n```\n\nTo query the database to know which remote package a file belongs to:\n\n```\n$ pacman -F /path/to/file_name\n```\n\nTo list all packages no longer required as dependencies (orphans):\n\n```\n$ pacman -Qdt\n```\n\nTo list all packages explicitly installed and not required as dependencies:\n\n```\n$ pacman -Qet\n```\n\nSee pacman/Tips and tricks for more examples.\n\nFor advanced functionality, install pkgfile, which uses a separate database with all files and their associated packages.\n\n"
    },
    {
      "title": "Pactree",
      "level": 4,
      "content": "To view the dependency tree of a package:\n\n```\n$ pactree package_name\n```\n\nTo view the dependent tree of a package, pass the reverse flag -r to pactree.\n\n"
    },
    {
      "title": "Database structure",
      "level": 4,
      "content": "The pacman databases are normally located at /var/lib/pacman/sync. For each repository specified in /etc/pacman.conf, there will be a corresponding database file located there. Database files are gzipped tar archives containing one directory for each package, for example for the which package:\n\n```\n$ tree which-2.21-5\n```\n\n```\nwhich-2.21-5\n|-- desc\n```\n\nThe desc file contains meta data such as the package description, dependencies, file size and MD5 hash.\n\n"
    },
    {
      "title": "Cleaning the package cache",
      "level": 3,
      "content": "Pacman stores its downloaded packages in /var/cache/pacman/pkg/ and does not remove the old or uninstalled versions automatically. This has some advantages:\n\n1. It allows to downgrade a package without the need to retrieve the previous version through other means, such as the Arch Linux Archive.\n1. A package that has been uninstalled can easily be reinstalled directly from the cache directory, not requiring a new download from the repository.\n\nHowever, it is necessary to deliberately clean up the cache periodically to prevent the directory to grow indefinitely in size.\n\nThe paccache(8) script, provided within the pacman-contrib package, deletes all cached versions of installed and uninstalled packages, except for the most recent three, by default:\n\n```\n# paccache -r\n```\n\nEnable and start paccache.timer to discard unused packages weekly. You can configure the arguments for the service in /etc/conf.d/pacman-contrib, e.g with PACCACHE_ARGS='-k1' or PACCACHE_ARGS='-uk0' for the two examples below.\n\nYou can also define how many recent versions you want to keep. To retain only one past version use:\n\n```\n# paccache -rk1\n```\n\nAdd the -u/--uninstalled switch to limit the action of paccache to uninstalled packages. For example to remove all cached versions of uninstalled packages, use the following:\n\n```\n# paccache -ruk0\n```\n\nSee paccache -h for more options.\n\nPacman also has some built-in options to clean the cache and the leftover database files from repositories which are no longer listed in the configuration file /etc/pacman.conf. However pacman does not offer the possibility to keep a number of past versions and is therefore more aggressive than paccache default options.\n\nTo remove all the cached packages that are not currently installed, and the unused sync databases, execute:\n\n```\n# pacman -Sc\n```\n\nTo remove all files from the cache, use the clean switch twice, this is the most aggressive approach and will leave nothing in the cache directory:\n\n```\n# pacman -Scc\n```\n\npkgcachecleanAUR and pacleanerAUR are two further alternatives to clean the cache.\n\n"
    },
    {
      "title": "Additional commands",
      "level": 3,
      "content": "Download a package without installing it:\n\n```\n# pacman -Sw package_name\n```\n\nInstall a 'local' package that is not from a remote repository (e.g. the package is from the AUR):\n\n```\n# pacman -U /path/to/package/package_name-version.pkg.tar.zst\n```\n\nTo keep a copy of the local package in pacman's cache, use:\n\n```\n# pacman -U file:///path/to/package/package_name-version.pkg.tar.zst\n```\n\nInstall a 'remote' package (not from a repository stated in pacman's configuration files):\n\n```\n# pacman -U http://www.example.com/repo/example.pkg.tar.zst\n```\n\n"
    },
    {
      "title": "dry run",
      "level": 4,
      "content": "Pacman always lists packages to be installed or removed, and asks for permission before taking any action.\n\nTo get a list in a processable format, and to prevent the actions of -S, -U and -R, you can use -p, short for --print.\n\n--print-format can be added to format this list in various ways. --print-format %n will return a list without package versions.\n\n"
    },
    {
      "title": "Installation reason",
      "level": 3,
      "content": "The pacman database organizes installed packages into two groups, according to installation reason:\n\n- explicitly-installed: packages that were literally passed to a generic pacman -S or -U command;\n- dependencies: packages that, despite never (in general) having been passed to a pacman installation command, were implicitly installed because they were required by packages explicitly installed.\n\nWhen installing a package, it is possible to force its installation reason to dependency with:\n\n```\n# pacman -S --asdeps package_name\n```\n\nThe command is normally used because explicitly-installed packages may offer optional packages, usually for non-essential features for which the user has discretion.\n\nWhen reinstalling a package, though, the current installation reason is preserved by default.\n\nThe list of explicitly-installed packages can be shown with pacman -Qe, while the complementary list of dependencies can be shown with pacman -Qd.\n\nTo change the installation reason of an already installed package, execute:\n\n```\n# pacman -D --asdeps package_name\n```\n\nUse --asexplicit to do the opposite operation.\n\n"
    },
    {
      "title": "What happens during package install/upgrade/removal",
      "level": 3,
      "content": "When successful, the workflow of a transaction follows five high-level steps plus pre/post transaction hooks:\n\n1. Initialize the transaction if there is not a database lock.\n1. Choose which packages will be added or removed in the transaction.\n1. Prepare the transaction, based on flags, by performing sanity checks on the sync databases, packages, and their dependencies.\n1. Commit the transaction: When applicable, download packages (_alpm_sync_load). If pre-existing pacman PreTransaction hooks apply, they are executed. Packages are removed that are to-be-replaced, conflicting, or explicitly targeted to be removed. If there are packages to add, then each package is committed: If the package has an install script, its pre_install function is executed (or pre_upgrade or pre_remove in the case of an upgraded or removed package). Pacman deletes all the files from a pre-existing version of the package (in the case of an upgraded or removed package). However, files that were marked as configuration files in the package are kept (see /Pacnew and Pacsave). Pacman untars the package and dumps its files into the file system (in the case of an installed or upgraded package). Files that would overwrite kept, and manually modified, configuration files (see previous step), are stored with a new name (.pacnew). If the package has an install script, its post_install function is executed (or post_upgrade or post_remove in the case of an upgraded or removed package). If pacman PostTransaction hooks that exist at the end of the transaction apply, they are executed.\n1. Release the transaction and transaction resource (i.e. database lock).\n\n1. When applicable, download packages (_alpm_sync_load).\n1. If pre-existing pacman PreTransaction hooks apply, they are executed.\n1. Packages are removed that are to-be-replaced, conflicting, or explicitly targeted to be removed.\n1. If there are packages to add, then each package is committed: If the package has an install script, its pre_install function is executed (or pre_upgrade or pre_remove in the case of an upgraded or removed package). Pacman deletes all the files from a pre-existing version of the package (in the case of an upgraded or removed package). However, files that were marked as configuration files in the package are kept (see /Pacnew and Pacsave). Pacman untars the package and dumps its files into the file system (in the case of an installed or upgraded package). Files that would overwrite kept, and manually modified, configuration files (see previous step), are stored with a new name (.pacnew). If the package has an install script, its post_install function is executed (or post_upgrade or post_remove in the case of an upgraded or removed package).\n1. If pacman PostTransaction hooks that exist at the end of the transaction apply, they are executed.\n\n1. If the package has an install script, its pre_install function is executed (or pre_upgrade or pre_remove in the case of an upgraded or removed package).\n1. Pacman deletes all the files from a pre-existing version of the package (in the case of an upgraded or removed package). However, files that were marked as configuration files in the package are kept (see /Pacnew and Pacsave).\n1. Pacman untars the package and dumps its files into the file system (in the case of an installed or upgraded package). Files that would overwrite kept, and manually modified, configuration files (see previous step), are stored with a new name (.pacnew).\n1. If the package has an install script, its post_install function is executed (or post_upgrade or post_remove in the case of an upgraded or removed package).\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "Pacman settings are located in /etc/pacman.conf: this is the place where the user configures the program to work in the desired manner. In-depth information about the configuration file can be found in pacman.conf(5).\n\n"
    },
    {
      "title": "General options",
      "level": 3,
      "content": "General options are in the [options] section. Read pacman.conf(5) or look in the default pacman.conf for information on what can be done here.\n\n"
    },
    {
      "title": "Comparing versions before updating",
      "level": 4,
      "content": "To see old and new versions of available packages, uncomment the \"VerbosePkgLists\" line in /etc/pacman.conf. The output of pacman -Syu will be like this:\n\n```\nPackage (6)             Old Version  New Version  Net Change  Download Size\n\nextra/libmariadbclient  10.1.9-4     10.1.10-1      0.03 MiB       4.35 MiB\nextra/libpng            1.6.19-1     1.6.20-1       0.00 MiB       0.23 MiB\nextra/mariadb           10.1.9-4     10.1.10-1      0.26 MiB      13.80 MiB\n```\n\n"
    },
    {
      "title": "Enabling parallel downloads",
      "level": 4,
      "content": "The number of packages being downloaded in parallel (at the same time) can be set with ParallelDownloads under [options] in /etc/pacman.conf. If the option is unset, packages will be downloaded sequentially.\n\n"
    },
    {
      "title": "Skip package from being upgraded",
      "level": 4,
      "content": "To have a specific package skipped when upgrading the system, add this line in the [options] section:\n\n```\nIgnorePkg=linux\n```\n\nFor multiple packages use a space-separated list, or use additional IgnorePkg lines. Also, glob patterns can be used. If you want to skip packages just once, you can also use the --ignore option on the command-line - this time with a comma-separated list.\n\nIt will still be possible to upgrade the ignored packages using pacman -S: in this case pacman will remind you that the packages have been included in an IgnorePkg statement.\n\n"
    },
    {
      "title": "Skip package group from being upgraded",
      "level": 4,
      "content": "As with packages, skipping a whole package group is also possible:\n\n```\nIgnoreGroup=gnome\n```\n\n"
    },
    {
      "title": "Skip file from being upgraded",
      "level": 4,
      "content": "All files listed with a NoUpgrade directive will never be touched during a package install/upgrade, and the new files will be installed with a .pacnew extension.\n\n```\nNoUpgrade=path/to/file\n```\n\nMultiple files can be specified like this:\n\n```\nNoUpgrade=path/to/file1 path/to/file2\n```\n\n"
    },
    {
      "title": "Skip files from being installed to system",
      "level": 4,
      "content": "To always skip installation of specific files or directories list them under NoExtract. For example, to avoid installing bash completion scripts, use:\n\n```\nNoExtract=usr/share/bash-completion/completions/*\n```\n\nLater rules override previous ones, and you can negate a rule by prepending !.\n\n"
    },
    {
      "title": "Maintain several configuration files",
      "level": 4,
      "content": "If you have several configuration files (e.g. main configuration and configuration with testing repository enabled) and would have to share options between configurations you may use Include option declared in the configuration files, e.g.:\n\n```\nInclude = /path/to/common/settings\n```\n\nwhere /path/to/common/settings file contains the same options for both configurations.\n\n"
    },
    {
      "title": "Hooks",
      "level": 4,
      "content": "Pacman can run pre- and post-transaction hooks from the /usr/share/libalpm/hooks/ directory; more directories can be specified with the HookDir option in pacman.conf, which defaults to /etc/pacman.d/hooks. Hook file names must be suffixed with .hook. Pacman hooks are not interactive.\n\nPacman hooks are used, for example, in combination with systemd-sysusers and systemd-tmpfiles to automatically create system users and files during the installation of packages. For example, tomcat8 specifies that it wants a system user called tomcat8 and certain directories owned by this user. The pacman hooks systemd-sysusers.hook and systemd-tmpfiles.hook invoke systemd-sysusers and systemd-tmpfiles when pacman determines that tomcat8 contains files specifying users and tmp files.\n\nFor more information on alpm hooks, see alpm-hooks(5).\n\n"
    },
    {
      "title": "Repositories and mirrors",
      "level": 3,
      "content": "Besides the special [options] section, each other [section] in pacman.conf defines a package repository to be used. A repository is a logical collection of packages, which are physically stored on one or more servers: for this reason each server is called a mirror for the repository.\n\nRepositories are distinguished between official and unofficial. The order of repositories in the configuration file matters; repositories listed first will take precedence over those listed later in the file when packages in two repositories have identical names, regardless of version number. In order to use a repository after adding it, you will need to upgrade the whole system first.\n\nEach repository section allows defining the list of its mirrors directly or in a dedicated external file through the Include directive; for example, the mirrors for the official repositories are included from /etc/pacman.d/mirrorlist. See the Mirrors article for mirror configuration.\n\n"
    },
    {
      "title": "Package cache directory",
      "level": 4,
      "content": "Pacman stores downloaded package files in cache, in a directory denoted by CacheDir in [options] section of pacman.conf (defaults to /var/cache/pacman/pkg/ if not set).\n\nCache directory may grow over time, even if keeping just the freshest versions of installed packages.\n\nIf you want to move that directory to some more convenient place, do one of the following:\n\n- Set the CacheDir option in pacman.conf to new directory. Remember to retain the trailing slash. This is the recommended solution.\n- Mount a dedicated partition or e.g. Btrfs subvolume in /var/cache/pacman/pkg/.\n- Bind-mount selected directory in /var/cache/pacman/pkg/.\n\nNote: **Do not symlink** \n\n"
    },
    {
      "title": "Package security",
      "level": 4,
      "content": "Pacman supports package signatures, which add an extra layer of security to the packages. The default configuration, SigLevel = Required DatabaseOptional, enables signature verification for all the packages on a global level. This can be overridden by per-repository SigLevel lines. For more details on package signing and signature verification, take a look at pacman-key.\n\n"
    },
    {
      "title": "\"Failed to commit transaction (conflicting files)\" error",
      "level": 3,
      "content": "If you see the following error: [1]\n\n```\nerror: could not prepare transaction\nerror: failed to commit transaction (conflicting files)\npackage: /path/to/file exists in filesystem\nErrors occurred, no packages were upgraded.\n```\n\nThis is happening because pacman has detected a file conflict, and by design, will not overwrite files for you. This is by design, not a flaw.\n\nThe problem is usually trivial to solve (although to be sure, you should try to find out how these files got there in the first place). A safe way is to first check if another package owns the file (pacman -Qo /path/to/file). If the file is owned by another package, file a bug report. If the file is not owned by another package, rename the file which \"exists in filesystem\" and re-issue the update command. If all goes well, the file may then be removed.\n\nIf you had installed a program manually without using pacman, for example through make install, you have to remove/uninstall this program with all of its files. See also Pacman tips#Identify files not owned by any package.\n\nEvery installed package provides a /var/lib/pacman/local/package-version/files file that contains metadata about this package. If this file gets corrupted, is empty or goes missing, it results in file exists in filesystem errors when trying to update the package. Such an error usually concerns only one package. Instead of manually renaming and later removing all the files that belong to the package in question, you may explicitly run pacman -S --overwrite glob package to force pacman to overwrite files that match glob.\n\n"
    },
    {
      "title": "\"Failed to commit transaction (invalid or corrupted package)\" error",
      "level": 3,
      "content": "Look for .part files (partially downloaded packages) in /var/cache/pacman/pkg/ and remove them (often caused by usage of a custom XferCommand in pacman.conf).\n\n```\n# find /var/cache/pacman/pkg/ -iname \"*.part\" -delete\n```\n\nThat same error may also appear if archlinux-keyring is out-of-date, preventing pacman from verifying signatures. See Pacman/Package signing#Upgrade system regularly for the fix and how to avoid it in the future.\n\n"
    },
    {
      "title": "\"Failed to init transaction (unable to lock database)\" error",
      "level": 3,
      "content": "When pacman is about to alter the package database, for example installing a package, it creates a lock file at /var/lib/pacman/db.lck. This prevents another instance of pacman from trying to alter the package database at the same time.\n\nIf pacman is interrupted while changing the database, this stale lock file can remain. If you are certain that no instances of pacman are running then delete the lock file:\n\n```\n# rm /var/lib/pacman/db.lck\n```\n\n"
    },
    {
      "title": "Packages cannot be retrieved on installation",
      "level": 3,
      "content": "This error manifests as Not found in sync db, Target not found or Failed retrieving file.\n\nFirstly, ensure the package actually exists. If certain the package exists, your package list may be out-of-date. Try running pacman -Syu to force a refresh of all package lists and upgrade. Also make sure the selected mirrors are up-to-date and repositories are correctly configured. You can also use Reflector to keep the mirrors up-to-date.\n\nIt could also be that the repository containing the package is not enabled on your system, e.g. the package could be in the multilib repository, but multilib is not enabled in your pacman.conf.\n\nSee also FAQ#Why is there only a single version of each shared library in the official repositories?.\n\n"
    },
    {
      "title": "Fixing an unbootable system caused by an interrupted upgrade",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nWhether due to power loss, kernel panic or hardware failure an update may be interrupted. In most cases, there will not be much damage but the system will likely be unbootable.\n\n1. Ready a USB flash installation medium and boot it.\n1. Mount the root filesystem.\n1. arch-chroot into the mounted root filesystem.\n1. Check /var/log/pacman.log and replicate the exact update by supplying the entire list of packages that was upgraded during the failed transaction to pacman -S and allowing it to reinstall, e.g:\n\n```\n# pacman -S linux linux-headers systemd systemd-libs systemd-sysvcompat firefox texlive-basic texlive-fontsextra texlive-latex texlive-latexextra texlive-latexrecommended texlive-pictures\n```\n\nReplicating the exact upgrade is needed to ensure the right scriptlets and hooks will run.\n\n"
    },
    {
      "title": "Pacman crashes during an upgrade",
      "level": 3,
      "content": "In the case that pacman crashes with a \"database write\" error while removing packages, and reinstalling or upgrading packages fails thereafter, do the following:\n\n1. Boot using the Arch USB flash installation medium. Preferably use a recent media so that the pacman version matches/is newer than the system.\n1. Mount the system's root filesystem, e.g., mount /dev/sdaX /mnt as root, and check the mount has sufficient space with df -h\n1. Mount the proc, sys and dev filesystems as well: mount -t proc proc /mnt/proc; mount --rbind /sys /mnt/sys; mount --rbind /dev /mnt/dev\n1. If the system uses default database and directory locations, you can now update the system's pacman database and upgrade it via pacman --root=/mnt --cachedir=/mnt/var/cache/pacman/pkg -Syu as root. Alternatively, if you cannot update/upgrade, refer to Pacman/Tips and tricks#Reinstalling all packages.\n1. After the upgrade, one way to double-check for not upgraded but still broken packages: find /mnt/usr/lib -size 0\n1. Followed by a re-install of any still broken package via pacman --root /mnt --cachedir=/mnt/var/cache/pacman/pkg -S package.\n\n- Alternatively, if you cannot update/upgrade, refer to Pacman/Tips and tricks#Reinstalling all packages.\n\n"
    },
    {
      "title": "pacman: command not found",
      "level": 4,
      "content": "If /var/cache/pacman/pkg is a symlink, pacman will try to make a directory instead and thus remove this symlink during self-upgrade. This will cause the update to fail. As a result, /usr/bin/pacman and other contents of the pacman package will be missing.\n\nNever symlink /var/cache/pacman/pkg because it is controlled by pacman. Use the CacheDir option or a bind mount instead; see #Package cache directory.\n\nIf you have already encountered this problem and broke your system, you can manually extract /usr contents from the package to restore pacman and then reinstall it properly; see FS#73306 and related forum thread for details.\n\n"
    },
    {
      "title": "Using pacman-static",
      "level": 4,
      "content": "pacman-staticAUR is a statically compiled version of pacman, so it will be able to run even when the libraries on the system are not working. This can also come in handy when a partial upgrade was performed and pacman can not run anymore.\n\nThe pinned comment and the PKGBUILD provides a way to directly download the binary, which can be used to reinstall pacman or to upgrade the entire system in case of partial upgrades.\n\n"
    },
    {
      "title": "Using an external pacman",
      "level": 4,
      "content": "If even pacman-static does not work, it is possible to recover using an external pacman. One of the easiest methods to do so is by using the archiso and simply using --sysroot or --root to specify the mount point of the system to perform the operation on. See Chroot#Using chroot on how to mount the necessary filesystems required by --sysroot.\n\n"
    },
    {
      "title": "By manually extracting",
      "level": 4,
      "content": "Even if pacman is terribly broken, you can fix it manually by downloading the latest packages and extracting them to the correct locations. The rough steps to perform are:\n\n1. Determine the pacman dependencies to install\n1. Download each package from a mirror of your choice\n1. Extract each package to root\n1. Reinstall these packages with pacman -S --overwrite to update the package database accordingly\n1. Do a full system upgrade\n\nIf you have a healthy Arch system on hand, you can see the full list of dependencies with:\n\n```\n$ pacman -Q $(pactree -u pacman)\n```\n\nBut you may only need to update a few of them depending on your issue. An example of extracting a package is\n\n```\n# tar -xvpwf package.tar.zst -C / --exclude .PKGINFO --exclude .INSTALL --exclude .MTREE --exclude .BUILDINFO\n```\n\nNote the use of the w flag for interactive mode. Running non-interactively is very risky since you might end up overwriting an important file. Also take care to extract packages in the correct order (i.e. dependencies first). This forum post contains an example of this process where only a couple pacman dependencies are broken.\n\n"
    },
    {
      "title": "\"Unable to find root device\" error after rebooting",
      "level": 3,
      "content": "Most likely the initramfs became corrupted during a kernel update (improper use of pacman's --overwrite option can be a cause). There are two options; first, try the Fallback entry.\n\nOnce the system starts, run this command (for the stock linux kernel) either from the console or from a terminal to rebuild the initramfs image:\n\n```\n# mkinitcpio -p linux\n```\n\nIf that does not work, from a current Arch release (CD/DVD or USB stick), mount your root and boot partitions to /mnt and /mnt/boot, respectively. Then chroot using arch-chroot:\n\n```\n# arch-chroot /mnt\n# pacman -Syu mkinitcpio systemd linux\n```\n\n- If you do not have a current release or if you only have some other \"live\" Linux distribution laying around, you can chroot using the old fashioned way. Obviously, there will be more typing than simply running the arch-chroot script.\n- If pacman fails with Could not resolve host, please check your internet connection.\n- If you cannot enter the arch-chroot or chroot environment but need to re-install packages, you can use the command pacman --sysroot /mnt -Syu foo bar to use pacman on your root partition.\n\nReinstalling the kernel (the linux package) will automatically re-generate the initramfs image with mkinitcpio -p linux. There is no need to do this separately.\n\nAfterwards, it is recommended that you run exit, umount /mnt/{boot,} and reboot.\n\n"
    },
    {
      "title": "\"Warning: current locale is invalid; using default \"C\" locale\" error",
      "level": 3,
      "content": "As the error message says, your locale is not correctly configured. See Locale.\n\n"
    },
    {
      "title": "Missing Locales Warning Messages",
      "level": 3,
      "content": "When locale files are intentionally removed by tools such as bleachbit or localepurgeAUR, pacman may issue warnings about missing locales during package updates.\n\nTo suppress these warnings, you can comment out the CheckSpace option in pacman.conf. Keep in mind that disabling CheckSpace turns off the space-checking functionality for all package installations, so use this workaround only when you have alternative means to monitor disk space.\n\n"
    },
    {
      "title": "Pacman does not honor proxy settings",
      "level": 3,
      "content": "Make sure that the relevant environment variables ($http_proxy, $ftp_proxy etc.) are set up. If you use pacman with sudo, you need to configure sudo to pass these environment variables to pacman. Also, ensure the configuration of dirmngr has honor-http-proxy in /etc/pacman.d/gnupg/dirmngr.conf to honor the proxy when refreshing the keys.\n\n"
    },
    {
      "title": "How do I reinstall all packages, retaining information on whether something was explicitly installed or as a dependency?",
      "level": 3,
      "content": "To reinstall all the native packages: pacman -Qnq | pacman -S - or pacman -S $(pacman -Qnq) (the -S option preserves the installation reason by default).\n\nYou will then need to reinstall all the foreign packages, which can be listed with pacman -Qmq.\n\n"
    },
    {
      "title": "\"Cannot open shared object file\" error",
      "level": 3,
      "content": "It looks like previous pacman transaction removed or corrupted shared libraries needed for pacman itself.\n\nTo recover from this situation, you need to unpack required libraries to your filesystem manually. First find what package contains the missed library and then locate it in the pacman cache (/var/cache/pacman/pkg/). Unpack required shared library to the filesystem. This will allow to run pacman.\n\nNow you need to reinstall the broken package. Note that you need to use --overwrite flag as you just unpacked system files and pacman does not know about it. Pacman will correctly replace our shared library file with one from package.\n\nThat's it. Update the rest of the system.\n\n"
    },
    {
      "title": "Freeze of package downloads",
      "level": 3,
      "content": "Some issues have been reported regarding network problems that prevent pacman from updating/synchronizing repositories. [2] [3] When installing Arch Linux natively, these issues have been resolved by replacing the default pacman file downloader with an alternative (see Improve pacman performance for more details). When installing Arch Linux as a guest OS in VirtualBox, this issue has also been addressed by using Host interface instead of NAT in the machine properties.\n\n"
    },
    {
      "title": "Failed retrieving file 'core.db' from mirror",
      "level": 3,
      "content": "If you receive this error message with correct mirrors, try setting a different name server.\n\n"
    },
    {
      "title": "error: 'local-package.pkg.tar': permission denied",
      "level": 3,
      "content": "If you want to install a package on an sshfs mount using pacman -U and receive this error, move the package to a local directory and try to install again.\n\n"
    },
    {
      "title": "error: could not determine cachedir mount point /var/cache/pacman/pkg",
      "level": 3,
      "content": "Upon executing, e.g., pacman -Syu inside a chroot environment an error is encountered:\n\n```\nerror: could not determine cachedir mount point /var/cache/pacman/pkg\nerror: failed to commit transaction (not enough free disk space)\n```\n\nThis is frequently caused by the chroot directory not being a mountpoint when the chroot is entered. See the note at Install Arch Linux from existing Linux#Downloading basic tools for a solution, and arch-chroot(8) for an explanation and an example of using bind mounting to make the chroot directory a mountpoint.\n\n"
    },
    {
      "title": "error: GPGME error: No data",
      "level": 3,
      "content": "If you are unable to update packages and receive this error, try rm -r /var/lib/pacman/sync/ before attempting to update.\n\nIf removing sync files doesn't help, check that the sync files are gzip compressed data using file /var/lib/pacman/sync/* before attempting to update. A router or proxy might corrupt the downloads.\n\nIf sync files are of the correct type, there might be an issue with the mirror server. Look up the mirror server(s) in use with pacman-conf -r core and pacman-conf -r extra. Paste the first returned url in a browser and check that a file listing is returned. In case the mirror returns an error, comment it in /etc/pacman.d/mirrorlist.\n\n"
    },
    {
      "title": "error: GPGME error: General error and \":: File /var/cache/pacman/pkg/<package>.pkg.tar.zst is corrupted (invalid or corrupted package (PGP signature)).",
      "level": 3,
      "content": "If this error occurs and you're for instance unable to update your system or any package at all, it is possible that you have DISPLAY set to a blank value, which seems to break the GPG-Flow.\n\nIn this case, unset DISPLAY or setting it to a arbitrary value will most likely allow to update again, in case any other option above didn't do the trick yet. See this post for further details.\n\n"
    },
    {
      "title": "Reinstall broken or out-of-sync packages",
      "level": 3,
      "content": "One may use the pacman -Qk $pkg to check if the installed files of the $pkg package match the files from its database version. For several packages, one may use the following loop to reinstall all packages which have missing file(s):\n\n```\n# LC_ALL=C.UTF-8 pacman -Qk 2>/dev/null | grep -v ' 0 missing files' | cut -d: -f1 |\n    while read -r package; do\n        pacman -S \"$package\" --noconfirm\n    done\n```\n\nSuppose that your local database located in /var/lib/pacman is more up-to-date compared to installed packages in the / filesystem (e.g., because of a partial rollback), then this method is the appropriate one to re-synchronize the root filesystem with the local database.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- libalpm(3)\n- pacman(8)\n- pacman.conf(5)\n- repo-add(8)\n\n"
    }
  ]
}