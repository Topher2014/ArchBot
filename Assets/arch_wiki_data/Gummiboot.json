{
  "title": "Gummiboot",
  "url": "https://wiki.archlinux.org/title/Gummiboot",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Arch boot process\n- Secure Boot\n- Unified Extensible Firmware Interface\n\nsystemd-boot(7), previously called gummiboot (German for \"rubber dinghy\") and sometimes referred to as sd-boot, is an easy-to-configure UEFI boot manager. It provides a textual menu to select the boot entry and an editor for the kernel command line.\n\nNote that systemd-boot can only start EFI executables (e.g., the Linux kernel EFI boot stub, UEFI shell, GRUB, or the Windows Boot Manager) from the EFI system partition it is installed to or from an Extended Boot Loader Partition (XBOOTLDR partition) on the same disk.\n\n"
    },
    {
      "title": "Supported file systems",
      "level": 2,
      "content": "systemd-boot inherits the support for the file systems from the firmware (i.e. at least FAT12, FAT16 and FAT32). Additionally it loads any UEFI drivers placed in esp/EFI/systemd/drivers/.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "systemd-boot is shipped with the systemd package which is a dependency of the base meta package, so no additional packages need to be installed manually.\n\n"
    },
    {
      "title": "Installing the UEFI boot manager",
      "level": 2,
      "content": "To install systemd-boot, first make sure that the system is booted into UEFI mode and UEFI variables are accessible. This can be verified by running efivar --list or, if efivar is not installed, by running ls /sys/firmware/efi/efivars (if the directory exists, the system is booted into UEFI mode.)\n\nUse bootctl(1) to install systemd-boot to the ESP:\n\n```\n# bootctl install\n```\n\nThis will copy the systemd-boot UEFI boot manager to the ESP, create a UEFI boot entry for it and set it as the first in the UEFI boot order.\n\n- On an x64 UEFI, /usr/lib/systemd/boot/efi/systemd-bootx64.efi will be copied to esp/EFI/systemd/systemd-bootx64.efi and esp/EFI/BOOT/BOOTX64.EFI.\n- On an IA32 UEFI, /usr/lib/systemd/boot/efi/systemd-bootia32.efi will be copied to esp/EFI/systemd/systemd-bootia32.efi and esp/EFI/BOOT/BOOTIA32.EFI.\n\nNote: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nThe UEFI boot entry will be called \"Linux Boot Manager\" and will point to, depending on the UEFI bitness, either \\EFI\\systemd\\systemd-bootx64.efi or \\EFI\\systemd\\systemd-bootia32.efi on the ESP.\n\n- When running bootctl install, systemd-boot will try to locate the ESP at /efi, /boot, and /boot/efi. Setting esp to a different location requires passing the --esp-path=esp option. (See bootctl(1) ยง OPTIONS for details.)\n- Installing systemd-boot will overwrite any existing esp/EFI/BOOT/BOOTX64.EFI (or esp/EFI/BOOT/BOOTIA32.EFI on IA32 UEFI), e.g. Microsoft's version of the file.\n\nTo conclude the installation, configure systemd-boot.\n\n"
    },
    {
      "title": "Installation using XBOOTLDR",
      "level": 3,
      "content": "Note: **This article or section is a candidate for moving to Partitioning#Discrete partitions.** This article or section is a candidate for moving to Partitioning#Discrete partitions.\n\nThis article or section is a candidate for moving to Partitioning#Discrete partitions.\n\nA separate /boot partition of type \"Linux extended boot\" (XBOOTLDR) can be created to keep the kernel and initramfs separate from the ESP. This is particularly helpful to dual boot with Windows with an existing ESP that is too small.\n\nPrepare an ESP as usual and create another partition for XBOOTLDR on the same physical drive. The XBOOTLDR partition must have a partition type GUID of bc13c2ff-59e6-4262-a352-b275fd6f7172 [1] (ea00 type for gdisk, xbootldr type for fdisk). The size of the XBOOTLDR partition should be large enough to accommodate all of the kernels you are going to install.\n\n- systemd-boot does not do a file system check like it does for the ESP. Hence, it is possible to use any file system that your UEFI implementation can read.\n- UEFI may skip loading partitions other than the ESP when a \"fast boot\" mode is enabled. This can lead to systemd-boot failing to find entries on the XBOOTLDR partition; in that case, disable the \"fast boot\" mode.\n- The XBOOTLDR partition must be on the same physical disk as the ESP for systemd-boot to recognize it.\n\nDuring install, mount the ESP to /mnt/efi and the XBOOTLDR partition to /mnt/boot.\n\nOnce in chroot, use the command:\n\n```\n# bootctl --esp-path=/efi --boot-path=/boot install\n```\n\nTo conclude the installation, configure systemd-boot.\n\n"
    },
    {
      "title": "Updating the UEFI boot manager",
      "level": 3,
      "content": "Whenever there is a new version of systemd-boot, the UEFI boot manager can be optionally reinstalled by the user. This can be done manually or automatically; the two approaches are described thereafter.\n\n"
    },
    {
      "title": "Manual update",
      "level": 4,
      "content": "Use bootctl to update systemd-boot:\n\n```\n# bootctl update\n```\n\n"
    },
    {
      "title": "Automatic update",
      "level": 4,
      "content": "To update systemd-boot automatically, either use a systemd service or a pacman hook. The two methods are described below.\n\nAs of version 250, systemd ships with systemd-boot-update.service. Enabling this service will update the bootloader after the next boot.\n\nThe package systemd-boot-pacman-hookAUR adds a pacman hook which is executed every time systemd is upgraded.\n\nRather than installing systemd-boot-pacman-hook, you may prefer to manually place the following file in /etc/pacman.d/hooks/:\n\n```\n/etc/pacman.d/hooks/95-systemd-boot.hook\n```\n\n```\n[Trigger]\nType = Package\nOperation = Upgrade\nTarget = systemd\n\n[Action]\nDescription = Gracefully upgrading systemd-boot...\nWhen = PostTransaction\nExec = /usr/bin/systemctl restart systemd-boot-update.service\n```\n\n"
    },
    {
      "title": "Signing for Secure Boot",
      "level": 3,
      "content": "If you have Secure Boot enabled, you may want to add a pacman hook to automatically sign the boot manager upon every upgrade of the package:\n\n```\n/etc/pacman.d/hooks/80-secureboot.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nType = Path\nTarget = usr/lib/systemd/boot/efi/systemd-boot*.efi\n\n[Action]\nDescription = Signing systemd-boot EFI binary for Secure Boot\nWhen = PostTransaction\nExec = /bin/sh -c 'while read -r i; do sbsign --key /path/to/keyfile.key --cert /path/to/certificate.crt \"$i\"; done;'\nDepends = sh\nDepends = sbsigntools\nNeedsTargets\n```\n\nReplace /path/to/keyfile.key and /path/to/certificate.crt with your signing key and certificate respectively. For better understanding of this hook, consult sbsign(1).\n\nThe created /usr/lib/systemd/boot/efi/systemd-boot*.efi.signed will automatically be picked up by bootctl install or bootctl update. See bootctl(1) ยง SIGNED .EFI FILES.\n\nAs an alternative, use sbctl.\n\n"
    },
    {
      "title": "Loader configuration",
      "level": 3,
      "content": "The loader configuration is stored in the file esp/loader/loader.conf. See loader.conf(5) ยง OPTIONS for details.\n\nA loader configuration example is provided below:\n\n```\nesp/loader/loader.conf\n```\n\n```\ndefault  arch.conf\ntimeout  4\nconsole-mode max\neditor   no\n```\n\n- systemd-boot does not accept tabs for indentation, use spaces instead.\n- default and timeout can be changed in the boot menu itself and changes will be stored as UEFI variables LoaderEntryDefault and LoaderConfigTimeout, overriding these options.\n- bootctl set-default \"\" and bootctl set-timeout \"\" can be used to clear the UEFI variables overriding the default and timeout options, respectively.\n- If you have set timeout 0, the boot menu can be accessed by pressing Space.\n- A basic loader configuration file is located at /usr/share/systemd/bootctl/loader.conf.\n- If the bootloader (during the entry selection) appears distorted/uses the wrong resolution you can try to set the console-mode to auto (uses heuristics to select the best resolution), keep (keeps the firmware provided resolution) or 2 (tries to select the first non-UEFI-standard resolution).\n\n"
    },
    {
      "title": "Remember last entry",
      "level": 4,
      "content": "The default can be changed to @saved in order to remember the last picked entry on startup. This is useful for when dual booting Windows and the surprise windows auto update pushes you into Linux.\n\n```\nesp/loader/loader.conf\n```\n\n```\ndefault @saved\n...\n```\n\nConsult loader.conf(5) for more details.\n\n"
    },
    {
      "title": "Adding loaders",
      "level": 3,
      "content": "systemd-boot will search for .conf files in /loader/entries/ on the EFI system partition it was launched from and additionally the XBOOTLDR partition on the same disk.\n\n- Entries in esp/loader/entries/*.conf can only use files (e.g. kernels, initramfs, images, etc.) in esp/ and entries in boot/loader/entries/*.conf can only use files in boot/.\n- The file path parameters are relative to the root of your EFI system partition or XBOOTLDR partition. E.g., if your EFI system partition or XBOOTLDR partition is mounted at /boot, then the /boot/vmlinuz-linux file must be specified in the linux key as /vmlinuz-linux.\n- When Secure Boot is active, unified kernel images (UKIs) with an embedded .cmdline ignore all command line options passed to them (either using a boot entry with options or interactively). When Secure Boot is not active, the options passed via the command line override the embedded .cmdline.\n\nAn example of loader files launching Arch from a volume using its UUID xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx is:\n\n```\nesp/loader/entries/arch.conf\n```\n\n```\ntitle   Arch Linux\nlinux   /vmlinuz-linux\ninitrd  /initramfs-linux.img\noptions root=UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx rw\n```\n\n```\nesp/loader/entries/arch-fallback.conf\n```\n\n```\ntitle   Arch Linux (fallback initramfs)\nlinux   /vmlinuz-linux\ninitrd  /initramfs-linux-fallback.img\noptions root=UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx rw\n```\n\nSee the Boot Loader Specification for details on all configuration options.\n\nsystemd-boot will automatically check at boot time for Windows Boot Manager at the location /EFI/Microsoft/Boot/Bootmgfw.efi, Apple macOS Boot Manager in firmware, UEFI shell /shellx64.efi and EFI Default Loader /EFI/BOOT/bootx64.efi, as well as specially prepared kernel files found in /EFI/Linux/. When detected, corresponding entries with titles auto-windows, auto-osx, auto-efi-shell and auto-efi-default, respectively, will be generated. These entries do not require manual loader configuration. However, it does not auto-detect other EFI applications (unlike rEFInd), so for booting the Linux kernel, manual configuration entries must be created.\n\n- The available boot entries which have been configured can be listed with the command bootctl list.\n- An example entry file is located at /usr/share/systemd/bootctl/arch.conf.\n- The kernel parameters for scenarios such as LVM, LUKS, dm-crypt or Btrfs can be found on the relevant pages.\n\nNote: **first** \n\n"
    },
    {
      "title": "UEFI Shells or other EFI applications",
      "level": 4,
      "content": "In case you installed a UEFI shell with the package edk2-shell, systemd-boot will auto-detect and create a new entry if the EFI file is placed in esp/shellx64.efi. To perform this an example command after installing the package would be:\n\n```\n# cp /usr/share/edk2-shell/x64/Shell.efi /boot/shellx64.efi\n```\n\nOtherwise in case you installed other EFI applications into the ESP, you can use the following snippets.\n\n```\nesp/loader/entries/fwupd.conf\n```\n\n```\ntitle  Firmware updater\nefi     /EFI/tools/fwupdx64.efi\n```\n\n```\nesp/loader/entries/gdisk.conf\n```\n\n```\ntitle  GPT fdisk (gdisk)\nefi     /EFI/tools/gdisk_x64.efi\n```\n\nYou need to install memtest86+-efi for this to work. Also sign the EFI binary when using Secure Boot.\n\n```\nesp/loader/entries/memtest.conf\n```\n\n```\ntitle Memtest86+\nefi /memtest86+/memtest.efi\n```\n\nsystemd-boot can chainload Netboot. Download the ipxe-arch.efi EFI binary and signature, verify it and place it as proposed in esp/EFI/arch_netboot/arch_netboot.efi.\n\n```\nesp/loader/entries/arch_netboot.conf\n```\n\n```\ntitle Arch Linux Netboot\nefi /EFI/arch_netboot/arch_netboot.efi\n```\n\nsystemd-boot can chainload GRUB. The location of the grubx64.efi binary matches the used --bootloader-id= when GRUB was installed to the ESP.\n\n```\nesp/loader/entries/grub.conf\n```\n\n```\ntitle GRUB\nefi /EFI/GRUB/grubx64.efi\n```\n\n"
    },
    {
      "title": "Boot from another disk",
      "level": 4,
      "content": "systemd-boot cannot launch EFI binaries from partitions other than the ESP it is launched from or the XBOOTLDR partition on the same disk, but it can direct the UEFI shell to do so.\n\nFirst, install edk2-shell as described above. In the UEFI shell, use the map command to take notes of the FS alias (ex: HD0a66666a2, HD0b, FS1, or BLK7) of the partition with the corresponding PARTUUID.\n\nThen, use the exit command to boot back into Linux, where you can create a new loader entry to run the target EFI program through the UEFI shell:\n\n```\nesp/loader/entries/windows.conf\n```\n\n```\ntitle   Windows\nefi     /shellx64.efi\noptions -nointerrupt -nomap -noversion HD0b:EFI\\Microsoft\\Boot\\Bootmgfw.efi\n```\n\nEnsure that the efi path matches the location where the shellx64.efi has been copied in the esp partition. Also, note that the shellx64.efi EFI file can be moved elsewhere to avoid the automatic entry creation by systemd-boot.\n\nReplace HD0b with the previously noted FS alias.\n\n- The -nointerrupt option prevents interrupting the target EFI program with Ctrl+c.\n- The -nomap -noversion options hide the default UEFI shell greeting.\n- To have the UEFI shell automatically return to the bootloader if the target EFI program exits (e.g., due to an error), add the -exit option.\n- You can also add the -noconsoleout option if there is still unnecessary output in the UEFI shell.\n\n"
    },
    {
      "title": "Booting into UEFI firmware setup",
      "level": 3,
      "content": "systemd-boot will automatically add an entry to boot into UEFI firmware setup if your device's firmware supports rebooting into setup from the OS.\n\n"
    },
    {
      "title": "Support hibernation",
      "level": 3,
      "content": "See Suspend and hibernate.\n\n"
    },
    {
      "title": "Kernel parameters editor with password protection",
      "level": 3,
      "content": "Alternatively you can install systemd-boot-passwordAUR which supports password basic configuration option. Use sbpctl generate to generate a value for this option.\n\nInstall systemd-boot-password with the following command:\n\n```\n# sbpctl install esp\n```\n\nWith enabled editor you will be prompted for your password before you can edit kernel parameters.\n\n"
    },
    {
      "title": "Keys inside the boot menu",
      "level": 3,
      "content": "You can use t and T while in the menu to adjust the menu timeout and e to edit the kernel parameters for this boot. Press h to see a short list of useful hotkeys. See systemd-boot(7) ยง KEY BINDINGS for the full list of available key bindings inside the boot menu.\n\n"
    },
    {
      "title": "Choosing next boot",
      "level": 3,
      "content": "The boot manager is integrated with the systemctl command, allowing you to choose what option you want to boot after a reboot. For example, suppose you have built a custom kernel and created an entry file esp/loader/entries/arch-custom.conf to boot into it, you can just launch\n\n```\n$ systemctl reboot --boot-loader-entry=arch-custom.conf\n```\n\nand your system will reboot into that entry maintaining the default option intact for subsequent boots. To see a list of possible entries pass the --boot-loader-entry=help option.\n\nIf you want to boot into the firmware of your motherboard directly, then you can use this command:\n\n```\n$ systemctl reboot --firmware-setup\n```\n\n"
    },
    {
      "title": "Unified kernel images",
      "level": 3,
      "content": "Unified kernel images (UKIs) in esp/EFI/Linux/ are automatically sourced by systemd-boot, and do not need an entry in esp/loader/entries. (Note that unified kernel images must have a .efi extension to be identified by systemd-boot.)\n\n"
    },
    {
      "title": "Grml on ESP",
      "level": 3,
      "content": "Grml is a small live system with a collection of software for system administration and rescue.\n\nIn order to install Grml on the ESP, we only need to copy the kernel vmlinuz, the initramfs initrd.img, and the squashed image grml64-small.squashfs from the iso file to the ESP. To do so, first download grml64-small.iso and mount the file (the mountpoint is henceforth denoted mnt); the kernel and initramfs are located in mnt/boot/grml64small/, and the squashed image resides in mnt/live/grml64-small/.\n\nNext, create a directory for Grml in your ESP,\n\n```\n# mkdir -p esp/grml\n```\n\nand copy the above-mentioned files in there:\n\n```\n# cp mnt/boot/grml64small/vmlinuz esp/grml\n# cp mnt/boot/grml64small/initrd.img esp/grml\n# cp mnt/live/grml64-small/grml64-small.squashfs esp/grml\n```\n\nIn the last step, create an entry for the systemd-boot loader: In esp/loader/entries create a grml.conf file with the following content:\n\n```\nesp/loader/entries/grml.conf\n```\n\n```\ntitle   Grml Live Linux\nlinux   /grml/vmlinuz\ninitrd  /grml/initrd.img\noptions apm=power-off boot=live live-media-path=/grml/ nomce net.ifnames=0\n```\n\nFor an overview of the available boot options, consult the cheatcode for Grml.\n\n"
    },
    {
      "title": "Archiso on ESP",
      "level": 3,
      "content": "As with Grml it is possible to use the Arch Linux ISO. To do this we need to copy the kernel vmlinuz-linux, the initramfs initramfs-linux.img, and the squashfs image airootfs.sfs from the ISO file to the EFI system partition.\n\nFirst download archlinux-YYYY.MM.DD-x86_64.iso.\n\nNext, create a directory for archiso in your ESP:\n\n```\n# mkdir -p esp/EFI/archiso\n```\n\nExtract the contents of the arch directory in there:\n\n```\n# bsdtar -v -x --no-same-permissions --strip-components 1 -f archlinux-YYYY.MM.DD-x86_64.iso -C esp/EFI/archiso arch\n```\n\nIn the last step, create a boot entry for the systemd-boot loader: In esp/loader/entries create a arch-rescue.conf file with the following content:\n\n```\nesp/loader/entries/arch-rescue.conf\n```\n\n```\ntitle   Arch Linux (rescue system)\nlinux   /EFI/archiso/boot/x86_64/vmlinuz-linux\ninitrd  /EFI/archiso/boot/x86_64/initramfs-linux.img\noptions archisobasedir=/EFI/archiso archisosearchfilename=/EFI/archiso/boot/x86_64/vmlinuz-linux\n```\n\nFor an overview of the available boot options, consult the README.bootparams for mkinitcpio-archiso.\n\n"
    },
    {
      "title": "systemd-boot on BIOS systems",
      "level": 3,
      "content": "If you need a bootloader for BIOS systems that follows The Boot Loader Specification, then systemd-boot can be pressed into service on BIOS systems. The Clover boot loader supports booting from BIOS systems and provides a emulated UEFI environment.\n\n"
    },
    {
      "title": "systemd-boot does not display my boot entry",
      "level": 3,
      "content": "This may be caused by a variety of issues with the configuration file, such as the path to the kernel being specified incorrectly. To check, run:\n\n```\n# bootctl\n```\n\n"
    },
    {
      "title": "Installing after booting in BIOS mode",
      "level": 3,
      "content": "If booted in BIOS mode, you can still install systemd-boot, however this process requires you to tell firmware to launch systemd-boot's EFI file at boot:\n\n- you have a working UEFI Shell somewhere else.\n- your firmware interface provides a way of properly setting the EFI file that needs to be loaded at boot time.\n- some firmware may use the default esp/EFI/BOOT/BOOTX64.EFI if there is no other entry set in the UEFI.\n\nIf you can do it, the installation is easier: go into your UEFI Shell or your firmware configuration interface and change your machine's default EFI file to esp/EFI/systemd/systemd-bootx64.efi.\n\n"
    },
    {
      "title": "Manual entry using efibootmgr",
      "level": 3,
      "content": "If the bootctl install command failed, you can create a UEFI boot entry manually using efibootmgr:\n\n```\n# efibootmgr --create --disk /dev/sdX --part Y --loader '\\EFI\\systemd\\systemd-bootx64.efi' --label \"Linux Boot Manager\" --unicode\n```\n\nwhere /dev/sdXY is the EFI system partition.\n\n"
    },
    {
      "title": "Manual entry using bcdedit from Windows",
      "level": 3,
      "content": "If for any reason you need to create a UEFI boot entry from Windows, you can use the following commands from an Administrator prompt:\n\n```\n> bcdedit /copy {bootmgr} /d \"Linux Boot Manager\"\n> bcdedit /set {guid} path \\EFI\\systemd\\systemd-bootx64.efi\n```\n\nReplace guid with the id returned by the first command. You can also set it as the default entry using\n\n```\n> bcdedit /default {guid}\n```\n\n"
    },
    {
      "title": "Menu does not appear after Windows upgrade",
      "level": 3,
      "content": "See UEFI#Windows changes boot order.\n\n"
    },
    {
      "title": "Add support for Windows BitLocker TPM unlocking",
      "level": 3,
      "content": "To stop BitLocker from requesting the recovery key, add the following to loader.conf:\n\n```\nesp/loader/loader.conf\n```\n\n```\nreboot-for-bitlocker yes\n```\n\nThis will set the BootNext UEFI variable, whereby Windows Boot Manager is loaded without BitLocker requiring the recovery key. This is a one-time change, and systemd-boot remains the default bootloader. There is no need to specify Windows as an entry if it was autodetected.\n\nThis is an experimental feature, so make sure to consult loader.conf(5).\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- https://systemd.io/BOOT/\n- https://bbs.archlinux.org/viewtopic.php?id=254374\n- https://uapi-group.org/specifications/specs/boot_loader_specification/\n\n"
    }
  ]
}