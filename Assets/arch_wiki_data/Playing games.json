{
  "title": "Playing games",
  "url": "https://wiki.archlinux.org/title/Playing_games",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- List of games\n- Video game platform emulators\n- Xorg\n- Gamepad\n- Wine\n\nLinux has long been considered an \"unofficial\" gaming platform; the support and target audience provided to it is not a primary priority for most gaming organizations. Changes to this situation have accelerated, starting from 2021 onward, as big players like Valve, the CodeWeavers group and the community have made tremendous improvements to the ecosystem, allowing Linux to truly become a viable platform for gaming. Further, more and more indie development teams strive to use cross-platform rendering engines in order to have their game able to compile and run on Linux.\n\nWhen it comes to gaming, the majority of user's thoughts are often directed towards popular AAA games which are usually written exclusively for the Microsoft Windows platform. This is understandable, however, it is not the only and sole availability. Please refer to #Game environments and #Getting games further down the page where you can find software to run games from other platforms.\n\nIf you however are fixated on getting games written for Microsoft Windows to work on Linux, then a different mindset, tools and approach is required; understanding internals and providing functional substitution. Please read #Game technicality below.\n\n"
    },
    {
      "title": "Game technicality",
      "level": 2,
      "content": "There are ultimately three complications that arise from attempting to play AAA games made for Windows on Linux. They are:\n\nGraphics SDK forward graphical calls to the underlying graphics driver which then proceeds to talking to the GPU hardware.\n\nA huge amount of games use DirectX as their main driving SDK. Linux, natively supports only OpenGL and Vulkan. Linux by itself does not support DirectX or any of the aforementioned technologies (Visual C++, MFC, .NET).\n\nInstead, several opensource equivalents have been written which attempt to provide identical functionality, ultimately achieving the same result from a graphics point of view. These equivalents have their \"own\" written substitutes which attempt to \"re-invent\" what the original SDK calls would possibly achieve from a black box point of view. Popular ones include:\n\n- Wine (Wine Is Not an Emulator) [provides a \"loader vm\", self written dependencies, interop and more]\n- Proton (forked Wine project, optimized for Steam by Valve)\n- Mono (.NET alternative)\n- MF-Media (media foundation dependencies)\n\nFor example, a call to load, transform and shade vertices on DirectX may be re-written from scratch in a new .dll/.so owned by Wine, providing their own \"hypothetical\" belief on what the function may be doing underneath, and forward it instead to an OpenGL alternative, effectively trying to achieve similar results. Since these calls are direct equivalents and treated \"as if\" DirectX was running, performance is not impacted. (with the exception of the starting overhead to interop with these)\n\nThese tools are often brought in the distribution together on the system at the same time. A prefix (Wine's terminology for a directory mimicking a Windows sandbox) is created and configured. Dependencies are installed inside the prefix (the \"sandbox\" still needs the game's redistributables), often with winetricks, followed by an attempt to run the game \"as if\" it was executed from Windows.\n\nThis, nowadays, fortunately works for most games (aside from anti-cheat protected ones, which require a kernel driver that Wine/Proton does not yet have). If a game does not work, it is usually as a result of incompatible packages, missing dependencies or unimplemented functionality by Wine/Proton.\n\nLutris is a piece of software that provides runners and sandboxes that handle dependencies for you when you install games, if the above process is found tedious and/or complicated.\n\n"
    },
    {
      "title": "Common game dependencies",
      "level": 2,
      "content": "In order to gain a more in-depth understanding of what you will intend to do if you decide to go the Wine/Proton route, it is worthwhile to cover the common dependencies that games require in order to execute. Architecture also needs to be considered in mind, whether x86 or x64, preferably both.\n\nA prefix would need to have the following populated into it in order to run most Windows games.\n\n"
    },
    {
      "title": "Mandatory (for high coverage)",
      "level": 3,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\n- Microsoft Core Fonts\n- Microsoft Visual C++ 2015 (2017 has the most coverage, recommended) [2005, 2008, 2010, 2012, 2013, 2015, 2017-2018, 2019]\n- DirectX 9.0 (11.0 has the most coverage, recommended) [June SDK update 2010] {which consists of, to name a few:} Direct3D Direct2D DirectShow DirectInput DirectPlay DirectSound DXGI XAudio2\n- .NET Framework (3.5 has most coverage)\n- OpenGL OpenAL OpenAI OpenCL\n- Vulkan\n\n- Direct3D\n- Direct2D\n- DirectShow\n- DirectInput\n- DirectPlay\n- DirectSound\n- DXGI\n- XAudio2\n\n- OpenAL\n- OpenAI\n- OpenCL\n\n"
    },
    {
      "title": "Optional (but still common)",
      "level": 3,
      "content": "- XNA\n- PhysX\n- Media Foundation\n- Quicktime\n- Adobe Reader 11\n- Java SRE (e.g for Minecraft)\n\n"
    },
    {
      "title": "Rare (less common)",
      "level": 3,
      "content": "- Gamespy\n- MIDI driver\n- ACDSee\n\n"
    },
    {
      "title": "Machine requirements",
      "level": 2,
      "content": "It is not enough to just populate a prefix with the dependencies the game will need. The kernel itself has to have the substitution it will provide to the calls the game will make. As already mentioned, drivers and alternatives are available.\n\n"
    },
    {
      "title": "Drivers",
      "level": 3,
      "content": "- AMD drivers: see AMDGPU.\n- Intel drivers: see Intel graphics.\n- NVIDIA drivers: see NVIDIA.\n\n"
    },
    {
      "title": "Dependency for the machine & substitutes",
      "level": 3,
      "content": "- Wine\n- wine-gecko\n- wine-mono\n- Vulkan\n- OpenGL\n- Proton Redistributables (optional, but it may help)\n\n"
    },
    {
      "title": "Game environments",
      "level": 2,
      "content": "Wine/Proton are not the only approaches to play games. Different environments exist to play games in Linux, and have just as many (or more) games than on Windows:\n\n- Native – games which have builds targeting the Linux platform, shipping with OpenGL and/or Vulkan graphics API support.\n- Emulators – required for running software designed for other architectures and systems. Most games run out of the box once the ROM is fed in to the emulator and issues are rarely encountered. For options, see Video game platform emulators.\n- Java - write once, run everywhere platform. Examples of popular games that run on Linux are Minecraft, Runescape, Wurm Online, Puzzle Pirates.\n- Web – games running in a web browser. HTML5 games use canvas and WebGL technologies and work in all modern browsers. Flash-based – you need to install the plugin to play.\n- Wine – Windows compatibility layer, allows to run Windows applications (and a lot of games) on Unix-like operating systems. Supports DirectX to Vulkan translation in runtime with the addition of Wine#DXVK, which improves performance in games which only support DirectX.\n- Virtual machines – can be used to install compatible operating systems (such as Windows). VirtualBox has good 3D support. As an extension of this, if you have compatible hardware you can consider VGA passthrough to a Windows KVM guest, keyword is \"virtual function I/O\" (VFIO), or PCI passthrough via OVMF.\n- Proton/DXVK – Fork of Wine designed for use in the proprietary steam platform, enabling better support for games than Wine. See Steam#Proton Steam-Play for more information.\n\n- HTML5 games use canvas and WebGL technologies and work in all modern browsers.\n- Flash-based – you need to install the plugin to play.\n\n"
    },
    {
      "title": "Increase vm.max_map_count",
      "level": 3,
      "content": "Having the vm.max_map_count set to a low value can affect the stability and performance of some games. It can therefore be desirable to increase the size permanently by creating the following sysctl config file.\n\n```\n/etc/sysctl.d/80-gamecompatibility.conf\n```\n\n```\nvm.max_map_count = 2147483642\n```\n\nArch Linux uses the value 1048576 by default [1], which Fedora considers a safe value [2]. This default value is likely to be sufficient for current games, as increasing the value was mostly important when Arch used the kernel default of 65530 [3]. A value of 2147483642 (MAX_INT - 5) is the default in SteamOS.\n\nApply the changes without reboot by running:\n\n```\n# sysctl --system\n```\n\n"
    },
    {
      "title": "Getting games",
      "level": 2,
      "content": "Just because games are available for Linux does not mean that they are native; they might be pre-packaged with Wine or DOSBox.\n\nFor list of games packaged for Arch in official repositories or the AUR see List of games.\n\n- Athenaeum — A libre replacement to Steam.\n\n- Bottles — Easily run Windows software on Linux with wine and proton.\n\n- Flathub — Central Flatpak repository, has small but growing game section.\n\n- GOG.com — DRM-free game store. Games can be installed through offline installation scripts (either with a gtk2-based UI, or run from a terminal), through the Galaxy client (requiring Wine), or through unofficial clients.\n\n- Heroic Games Launcher — A GUI for GOG and legendary, an open-source alternative for the Epic Games Launcher.\n\n- itch.io — Indie game store.\n\n- Legendary — A free and open-source replacement for the Epic Games Launcher.\n\n- Lutris — Open gaming platform for Linux. Gets games from GOG, Steam, Battle.net, Origin, Uplay and many other sources. Lutris utilizes various game runners to launch the games with fully customizable configuration options.\n\n- Modrinth App — An unique, open source launcher that allows you to play your favorite mods, and keep them up to date, all in one neat little package.\n\n- Play.it — Automates the build of native packages. Also supports Wine, DOSBox and ScummVM games.\n\n- portproton — Software for playing Microsoft Windows games and launchers\n\n- Proton — Compatibility tool for Steam Play based on Wine and additional components\n\n- proton-ge-custom — Compatibility tool for Steam Play based on Wine and additional components, GloriousEggroll's custom build\n\n- Rare — Another GUI for legendary, based on PyQt5.\n\n- Steam — Digital distribution and communications platform developed by Valve.\n\n- umu-launcher — This is the Unified Launcher for Windows Games on Linux, to run Proton with fixes outside of Steam\n\nFor Wine wrappers, see Wine#Third-party applications.\n\n"
    },
    {
      "title": "Game Launchers",
      "level": 2,
      "content": "Game launchers are important tools for managing and running games on various platforms. Below is a comparison of different game launchers available for Linux, particularly focusing on their features and compatibility.\n\nTable content:\nName | Package | Open Source | Supports Wine | DLC Management | Cross-platform | ProtonDB Support | Dependencies | Recommended\nAthenaeum | athenaeum-gitAUR | Yes | No | Yes | Yes | Yes | None | Yes\nFlathub | flatpak | No | No | No | Yes | No | Flatpak runtime | No\nGOG.com | lgogdownloaderAUR | Yes | Yes | Yes | No | Yes | Python 3 | Yes\nHeroic Games Launcher | heroic-games-launcherAUR | Yes | Yes | No | No | Yes | Qt 5 | Yes\nitch.io | itch-setup-binAUR | Yes | No | No | Yes | Yes | None | Yes\nLegendary | legendaryAUR | Yes | Yes | No | No | Yes | None | Yes\nLutris | lutris | Yes | Yes | Yes | Yes | Yes | Python 3, Wine | Yes\nModrinth App | modrinth-app-appimageAUR | Yes | No | No | No | No | None | No\nPlay.it | play.itAUR | Yes | Yes | No | No | No | None | Yes\nportproton | portprotonAUR | Yes | Yes | No | Yes | Yes | None | No\nproton-ge-custom | proton-ge-custom-binAUR | Yes | Yes | No | No | Yes | None | Yes\nRare | rareAUR | Yes | Yes | No | No | No | None | No\nSteam | steam | No | Yes | Yes | Yes | Yes | None | Yes\numu-launcher | umu-launcher | Yes | Yes | No | No | No | None | No\n\n"
    },
    {
      "title": "Configuring games",
      "level": 2,
      "content": "Certain games or game types may need special configuration to run or to run as expected. For the most part, games will work right out of the box in Arch Linux with possibly better performance than on other distributions due to compile time optimizations. However, some special setups may require a bit of configuration or scripting to make games run as smoothly as desired.\n\n"
    },
    {
      "title": "Multi-screen setups",
      "level": 3,
      "content": "Running a multi-screen setup may lead to problems with full-screen games. In such a case, running a second X server is one possible solution. For NVIDIA users, a solution may be found in NVIDIA#Gaming using TwinView.\n\n"
    },
    {
      "title": "Keyboard grabbing",
      "level": 3,
      "content": "Many games grab the keyboard, noticeably preventing you from switching windows (also known as alt-tabbing).\n\nSome SDL games (e.g. Guacamelee) let you disable grabbing by pressing Ctrl-g.\n\n"
    },
    {
      "title": "Starting games in a separate X server",
      "level": 3,
      "content": "In some cases like those mentioned above, it may be necessary or desired to run a second X server. Running a second X server has multiple advantages such as better performance, the ability to \"tab\" out of your game by using Ctrl+Alt+F7/Ctrl+Alt+F8, no crashing your primary X session (which may have open work on) in case a game conflicts with the graphics driver. The new X server will be akin a remote access login for the ALSA, so your user need to be part of the audio group to be able to hear any sound.\n\nTo start a second X server (using the free first person shooter game Xonotic as an example) you can simply do:\n\n```\n$ xinit /usr/bin/xonotic-glx -- :1 vt$XDG_VTNR\n```\n\nThis can further be spiced up by using a separate X configuration file:\n\n```\n$ xinit /usr/bin/xonotic-glx -- :1 -xf86config xorg-game.conf vt$XDG_VTNR\n```\n\nA good reason to provide an alternative xorg.conf here may be that your primary configuration makes use of NVIDIA's Twinview which would render your 3D games like Xonotic in the middle of your multiscreen setup, spanned across all screens. This is undesirable, thus starting a second X with an alternative configuration where the second screen is disabled is advised. Please note, that the X configuration file location is relative to the /etc/X11 directory.\n\nA game starting script making use of Openbox for your home directory or /usr/local/bin may look like this:\n\n```\n~/game.sh\n```\n\n```\nif [ $# -ge 1 ]; then\n        game=\"$(which $1)\"\n        openbox=\"$(which openbox)\"\n        tmpgame=\"/tmp/tmpgame.sh\"\n        DISPLAY=:1.0\n        echo -e \"${openbox} &\\n${game}\" > ${tmpgame}\n        echo \"starting ${game}\"\n        xinit ${tmpgame} -- :1 -xf86config xorg-game.conf || exit 1\nelse\n        echo \"not a valid argument\"\nfi\n```\n\nAfter making it executable you would be able to do:\n\n```\n$ ~/game.sh xonotic-glx\n```\n\n"
    },
    {
      "title": "Adjusting mouse detections",
      "level": 3,
      "content": "For games that require exceptional amount of mouse skill, adjusting the mouse polling rate can help improve accuracy.\n\n"
    },
    {
      "title": "Binaural audio with OpenAL",
      "level": 3,
      "content": "For games using OpenAL, if you use headphones you may get much better positional audio using OpenAL's HRTF filters. To enable, create:\n\n```\n~/.alsoftrc\n```\n\n```\nhrtf = true\n```\n\nAlternatively, install openal-hrtfAUR from the AUR, and edit the options in /etc/openal/alsoftrc.conf.\n\nFor Source games, the ingame setting `dsp_slow_cpu` must be set to `1` to enable HRTF, otherwise the game will enable its own processing instead. You will also either need to set up Steam to use native runtime, or link its copy of openal.so to your own local copy. For completeness, also use the following options:\n\n```\ndsp_slow_cpu 1 # Disable in-game spatialiazation\nsnd_spatialize_roundrobin 1 # Disable spatialization 1.0*100% of sounds\ndsp_enhance_stereo 0 # Disable DSP sound effects. You may want to leave this on, if you find it does not interfere with your perception of the sound effects.\nsnd_pitchquality 1 # Use high quality sounds\n```\n\n"
    },
    {
      "title": "Tuning PulseAudio",
      "level": 3,
      "content": "If you are using PulseAudio, you may wish to tweak some default settings to make sure it is running optimally.\n\n"
    },
    {
      "title": "Enabling realtime priority and negative nice level",
      "level": 4,
      "content": "PulseAudio is built to be run with realtime priority, being an audio daemon. However, because of security risks of it locking up the system, it is scheduled as a regular thread by default. To adjust this, first make sure you are in the audio group. Then, uncomment and edit the following lines in /etc/pulse/daemon.conf:\n\n```\n/etc/pulse/daemon.conf\n```\n\n```\nhigh-priority = yes\nnice-level = -11\n\nrealtime-scheduling = yes\nrealtime-priority = 5\n```\n\nand restart PulseAudio.\n\n"
    },
    {
      "title": "Using higher quality remixing for better sound",
      "level": 4,
      "content": "PulseAudio on Arch uses speex-float-1 by default to remix channels, which is considered a 'medium-low' quality remixing. If your system can handle the extra load, you may benefit from setting it to one of the following instead:\n\n```\nresample-method = speex-float-10\n```\n\n"
    },
    {
      "title": "Matching hardware buffers to Pulse's buffering",
      "level": 4,
      "content": "Matching the buffers can reduce stuttering and increase performance marginally. See here for more details.\n\n"
    },
    {
      "title": "Remote gaming",
      "level": 2,
      "content": "Cloud gaming has gained a lot of popularity in the last few years, because of low client-side hardware requirements. The only important thing is stable internet connection (over the Ethernet cable or 5 GHz Wi-Fi recommended) with a minimum speed of 5–10 Mbit/s (depending on the video quality and framerate).\n\nSee Gamepad#Gamepad over network for using a gamepad over a network with services that do not normally support this.\n\nTable content:\nService | Installer | In browser client | Use your own host | Offers host renting | Full desktop support | Controller support | Remarks\nDixper | – | Yes | Windows-only | ? | ? | ? | –\nReemo | reemod-binAUR | Chromium based only | Yes | Yes | Yes | Windows-only | You can also install the software with the official installation script in the download section via their website.\nXbox Cloud | xbox-cloud-gamingAUR | Yes | No | No | No | Yes | You need Game Pass Ultimate to be able to use XCloud.\nGeForce Now | – | Yes | No | No | Yes | Yes | You must have games on Steam, Epic Client or GOG to use this service. Not all games are available.\nMoonlight | moonlight-qt | No | Yes | No | Yes | Yes | This is only a client. Host machine must use either GeForce Experience (windows only) or Sunshine (multiplatform).\nParsec | parsec-binAUR | Yes (experimental) | Windows-only | No | Yes | Yes | –\nVDI Stream Client | vdi-stream-clientAUR | No | Windows-only | No | Yes | No | VDI client with 3D GPU acceleration and built-in USB redirection\nPlaykey | playkey-linuxAUR | ? | ? | ? | ? | ? | –\nPlayStation Now[dead link 2024-07-30 ⓘ] | Runs under Wine or Steam's proton | No | No | – | No | Yes | Play PS4, PS3 and PS2 games on PC. Alternatively, you can use emulators.\nPlayStation Remote Play | chiakiAUR | No | Yes | – | Yes | Yes | Play games from your PS4 and/or PS5 on PC.\nRainway[dead link 2025-03-15 ⓘ] | Web Browser based | Yes | Windows-only | No | Yes | ? | –\nShadow | shadow-techAUR | No | No | Yes | Yes | Yes | Controller support is dependent on USB over IP, and currently AVC only as HEVC is not supported\nSteam Remote Play | Part of steam | No | Yes | No | No | Yes | –\nVortex[dead link 2024-01-29 ⓘ] | – | Yes | No | – | No | ? | –\nVNC | tigervnc or x11vnc | No | Yes | No | Yes | No | General purpose remote desktop protocol, but the latency should be low enough to use it for gaming over a LAN. See Gamepad#Gamepad over network for gamepad support.\nxrdp | xrdpAUR | No | Yes | No | Yes | No | Another general purpose remote desktop protocol, has both OpenGL and Vulkan support after configuring graphical accleration. Recommended for gaming over a LAN. See Gamepad#Gamepad over network for gamepad support.\nX11 forwarding | openssh | No | Yes | No | No | No | X forwarding over SSH with VirtualGL supports OpenGL and works for some but not all games. See Gamepad#Gamepad over network for gamepad support.\nBoosteroid | boosteroidAUR | Yes | No | No | Yes | Yes | You must have games on a digital distribution platform (Steam, EGS, Origin, etc.) to use this service. Not all games are available. You need to sign up (free) to see the full list of games. You need to purchase a subscription, to launch the games you own on the digital distribution platform.\nBlacknut | blacknut-appimageAUR or Blacknut AppImage | Yes | No | No | Yes | Yes | You need a subscription to be able to use this service. Not all games are available.\n\n"
    },
    {
      "title": "Improving performance",
      "level": 2,
      "content": "See also main article: Improving performance. For Wine programs, see Wine#Performance. For a good gaming experience low latency, a consistent response time (no jitter) and enough throughput (frames per second) are needed. If you have multiple sources with a little jitter they are likely to overlap sometimes and produce noticeable stutter. Therefore most of the time it is preferable to decrease the throughput a little to gain more response time consistency.\n\n"
    },
    {
      "title": "Improve clock_gettime throughput",
      "level": 3,
      "content": "User space programs and especially games do many calls to clock_gettime(2) to get the current time for calculating game physics, fps and so on. The time usage can be seen by running\n\n```\n# perf top\n```\n\nand looking at the overhead of read_hpet (or acpi_pm_read).\n\nIf you are not dependent on a very precise timer you can switch from hpet (high precision event timer) or acpi_pm (ACPI Power Management Timer) to the faster TSC (time stamp counter) timer. Add the kernel parameters\n\n```\ntsc=reliable clocksource=tsc\n```\n\nto make TSC available and enable it. After that reboot and confirm the clocksource by running\n\n```\n# cat /sys/devices/system/clocksource/clocksource*/current_clocksource\n```\n\nYou can see all currently available timers by running\n\n```\n# cat /sys/devices/system/clocksource/clocksource*/available_clocksource\n```\n\nand change between them by echoing one into current_clocksource. On a Zen 3 system benchmarking with [5] shows a ~50 times higher throughput of tsc compared to hpet or acpi_pm.\n\n"
    },
    {
      "title": "Tweaking kernel parameters for response time consistency",
      "level": 3,
      "content": "You can install the realtime kernel to get some advantages by default (see realtime kernel article) but it costs CPU throughput and can delay interrupt handling. Additionally the realtime kernel is not compatible with nvidia-open-dkms and does not change the scheduler for SCHED_NORMAL (also named SCHED_OTHER) processes, which is the default process scheduling type. The following kernel parameter changes improve the response time consistency for the realtime kernel as well as other kernels such as the default linux kernel:\n\nProactive compaction for (Transparent) Hugepage allocation reduces the average but not necessarily the maximum allocation stalls. Disable proactive compaction because it introduces jitter according to kernel documentation (inner workings):\n\n```\n# echo 0 > /proc/sys/vm/compaction_proactiveness\n```\n\nReduce the watermark boost factor to defragment only one pageblock (2MB on 64-bit x86) in case of memory fragmentation. After a memory fragmentation event this helps to better keep the application data in the last level processor cache.\n\n```\n# echo 1 > /proc/sys/vm/watermark_boost_factor\n```\n\nIf you have enough free RAM increase the number of minimum free Kilobytes to avoid stalls on memory allocations: [7][8]. Do not set this below 1024 KB or above 5% of your systems memory. Reserving 1GB:\n\n```\n# echo 1048576 > /proc/sys/vm/min_free_kbytes\n```\n\nIf you have enough free RAM increase the watermark scale factor to further reduce the likelihood of allocation stalls (explanations [9][10]). Setting watermark distances to 5% of RAM:\n\n```\n# echo 500 > /proc/sys/vm/watermark_scale_factor\n```\n\nAvoid swapping (locking pages that introduces latency and uses disk IO) unless the system has no more free memory:\n\n```\n# echo 10 > /proc/sys/vm/swappiness\n```\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nEnable zswap. If there arises the need for swapping pages, then zswap helps reduce swapping related stutter. If you don't have a swap partition you can use zram#Usage as swap instead of zswap. Enabling zswap:\n\n```\n# echo 1 > /sys/module/zswap/parameters/enabled\n```\n\nEnable Multi-Gen Least Recently Used (MGLRU) but reduce the likelihood of lock contention at a minor performance cost [11]:\n\n```\n# echo 5 > /sys/kernel/mm/lru_gen/enabled\n```\n\nDisable zone reclaim (locking and moving memory pages that introduces latency spikes):\n\n```\n# echo 0 > /proc/sys/vm/zone_reclaim_mode\n```\n\nDisable Transparent Hugepages (THP) at a performance cost. Even if defragmentation is disabled, THPs might introduce latency spikes [12][13][14]. Enable only when the application specifically requests it by using madvise and advise:\n\n```\n# echo madvise > /sys/kernel/mm/transparent_hugepage/enabled\n# echo advise > /sys/kernel/mm/transparent_hugepage/shmem_enabled\n# echo never > /sys/kernel/mm/transparent_hugepage/defrag\n```\n\nNote that if your game uses TCMalloc (e.g., Dota 2 and CS:GO) then it is not recommended to disable THP as it comes with a large performance cost [15].\n\nReduce the maximum page lock acquisition latency while retaining adequate throughput [16][17][18]:\n\n```\n# echo 1 > /proc/sys/vm/page_lock_unfairness\n```\n\nTweak the scheduler settings. The following scheduler settings are in conflict with cfs-zen-tweaksAUR so for each setting choose only one provider. By default the linux kernel scheduler is optimized for throughput and not latency. The following hand-made settings change that and are tested with different games to be a noticeable improvement. They might not be optimal for your use case; consider modifying them as necessary [19][20][21]:\n\n```\n# echo 0 > /proc/sys/kernel/sched_child_runs_first\n# echo 1 > /proc/sys/kernel/sched_autogroup_enabled\n# echo 3000 > /proc/sys/kernel/sched_cfs_bandwidth_slice_us\n# echo 3000000 > /sys/kernel/debug/sched/base_slice_ns\n# echo 500000 > /sys/kernel/debug/sched/migration_cost_ns\n# echo 8 > /sys/kernel/debug/sched/nr_migrate\n```\n\n"
    },
    {
      "title": "Make the changes permanent",
      "level": 4,
      "content": "Usually, the advice for permanently setting kernel parameters is to configure create a sysctl configuration file or change your boot loader options. However, since our change span both procfs (/proc, containing sysctl) and sysfs (/sys), the most convenient way is to use systemd-tmpfiles:\n\n```\n/etc/tmpfiles.d/consistent-response-time-for-gaming.conf\n```\n\n```\n#    Path                  Mode UID  GID  Age Argument\nw /proc/sys/vm/compaction_proactiveness - - - - 0\nw /proc/sys/vm/watermark_boost_factor - - - - 1\nw /proc/sys/vm/min_free_kbytes - - - - 1048576\nw /proc/sys/vm/watermark_scale_factor - - - - 500\nw /proc/sys/vm/swappiness - - - - 10\nw /sys/module/zswap/parameters/enabled - - - - 1\nw /sys/kernel/mm/lru_gen/enabled - - - - 5\nw /proc/sys/vm/zone_reclaim_mode - - - - 0\nw /sys/kernel/mm/transparent_hugepage/enabled - - - - madvise\nw /sys/kernel/mm/transparent_hugepage/shmem_enabled - - - - advise\nw /sys/kernel/mm/transparent_hugepage/defrag - - - - never\nw /proc/sys/vm/page_lock_unfairness - - - - 1\nw /proc/sys/kernel/sched_child_runs_first - - - - 0\nw /proc/sys/kernel/sched_autogroup_enabled - - - - 1\nw /proc/sys/kernel/sched_cfs_bandwidth_slice_us - - - - 3000\nw /sys/kernel/debug/sched/base_slice_ns  - - - - 3000000\nw /sys/kernel/debug/sched/migration_cost_ns - - - - 500000\nw /sys/kernel/debug/sched/nr_migrate - - - - 8\n```\n\nAfter that reboot and see if the values applied correctly.\n\n"
    },
    {
      "title": "Reduce buffer bloat",
      "level": 3,
      "content": "A device experiences buffer bloat when a large buffer queues requests, causing new requests to be blocked for a long time. This can occur with both sending and receiving data.\n\nBuffer bloat is solved by having a smart queuing algorithm that gives fair and timely share towards the device. Smart queuing algorithms produce quicker and more consistent response times, but increase CPU overhead. For interactive workloads reduced buffer bloat is desirable.\n\n"
    },
    {
      "title": "Reduce buffer bloat on storage devices",
      "level": 4,
      "content": "For storage devices, the BFQ scheduler is the most effective at minimizing buffer bloat and improving interactivity Improving performance#The scheduling algorithms.\n\n"
    },
    {
      "title": "Reduce buffer bloat on the network",
      "level": 4,
      "content": "You can use the default fq_codel or the improved cake smart queue management algorithms. They can be set via sysctl. Your home internet router can cause buffer bloat, which might be mitigated by reconfiguring it, installing a new router OS, or replacing the router (more info).\n\nHere are some easy ways to test for network buffer bloat.\n\n"
    },
    {
      "title": "Improve PCI Express Latencies",
      "level": 3,
      "content": "Change the PCI Express Latencies similar to CachyOS [22]. Reduce the maximum cycles a PCI-E Client can occupy the bus, except for sound cards [23]. Note that these settings are in conflict with Professional audio#System configuration.\n\n```\n# setpci -v -s '*:*' latency_timer=20\n# setpci -v -s '0:0' latency_timer=0\n# setpci -v -d \"*:*:04xx\" latency_timer=80\n```\n\nTo enable these settings consistently run them as super user on system boot.\n\n"
    },
    {
      "title": "Disabling simultaneous multithreading (SMT)",
      "level": 3,
      "content": "Whether or not disabling SMT improves your gaming experience depends on your hardware and gaming applications.\n\nAdvantages of SMT:\n\n1. Higher total throughput if your application can make use of the additional threads\n1. More run-queues for the scheduler and therefore on average less waiting time for a process thread to get scheduled on a core\n\nAdvantages of disabling SMT:\n\n1. Higher single core performance due to not needing to share core internal resources and the ability of the kernel and firmware to disable SMT related security mitigations\n1. More consistent single core performance. Depending on your processors microarchitecture, SMT shares various processor internal resources like instruction decoding units, micro-operations cache, register renaming capabilities, L1-, L2-Cache and translation lookaside buffer entries. Depending on what a sibling thread does, the throughput of a main thread varies. SMT also lessens the fairness of the process scheduler even if it is aware of SMT.\n\nIf you disable SMT do so in the BIOS/UEFI to get better single core performance.\n\n"
    },
    {
      "title": "Load shared objects immediately for better first time latency",
      "level": 3,
      "content": "Set the environment variable\n\n```\nLD_BIND_NOW=1\n```\n\nfor your games, to avoid needing to load program code at run time (see ld.so(8)), leading to a delay the first time a function is called. Do not set this for startplasma-x11 or other programs that link in libraries that do not actually exist on the system anymore and are never called by the program. If this is the case, the program fails on startup trying to link a nonexistent shared object, making this issue easily identifiable. Most games should start fine with this setting enabled.\n\n"
    },
    {
      "title": "GameMode",
      "level": 4,
      "content": "GameMode is daemon and library combo that allows games to request a set of optimisations be temporarily applied to the host OS. This can improve game performance.\n\n"
    },
    {
      "title": "Gamescope",
      "level": 4,
      "content": "Gamescope is a microcompositor from Valve that is used on the Steam Deck. Its goal is to provide an isolated compositor that is tailored towards gaming and supports many gaming-centric features.\n\n"
    },
    {
      "title": "ACO compiler",
      "level": 3,
      "content": "Note: **only** \n\nSee AMDGPU#ACO compiler\n\n"
    },
    {
      "title": "Reducing DRI latency",
      "level": 3,
      "content": "Direct Rendering Infrastructure (DRI) Configuration Files apply for all DRI drivers including Mesa and Nouveau. You can change the DRI configuration systemwide in /etc/drirc or per user in $HOME/.drirc. If they do not exist, you have to create them first. Both files use the same syntax; documentation for these options can be found at https://dri.freedesktop.org/wiki/ConfigurationOptions/. To reduce input latency by disabling synchronization to vblank, add the following:\n\n```\n<driconf>\n   <device>\n       <application name=\"Default\">\n           <option name=\"vblank_mode\" value=\"0\" />\n       </application>\n   </device>\n</driconf>\n```\n\n"
    },
    {
      "title": "Improving frame rates and responsiveness with scheduling policies",
      "level": 3,
      "content": "Most games can benefit if given the correct scheduling policies for the kernel to prioritize the task. These policies should ideally be set per-thread by the application itself.\n\nFor programs which do not implement scheduling policies on their own, application known as schedtool, and its associated daemon schedtooldAUR can handle many of these tasks automatically.\n\nTo edit what programs relieve what policies, simply edit /etc/schedtoold.conf and add the program followed by the schedtool arguments desired.\n\n"
    },
    {
      "title": "Policies",
      "level": 4,
      "content": "SCHED_ISO (only implemented in BFS/MuQSSPDS schedulers found in -pf and -ck kernels) – will not only allow the process to use a maximum of 80 percent of the CPU, but will attempt to reduce latency and stuttering wherever possible. Most if not all games will benefit from this:\n\n```\nbit.trip.runner -I\n```\n\nSCHED_FIFO provides an alternative, that can even work better. You should test to see if your applications run more smoothly with SCHED_FIFO, in which case by all means use it instead. Be warned though, as SCHED_FIFO runs the risk of starving the system! Use this in cases where -I is used below:\n\n```\nbit.trip.runner -F -p 15\n```\n\n"
    },
    {
      "title": "Nice levels",
      "level": 4,
      "content": "Secondly, the nice level sets which tasks are processed first, in ascending order. A nice level of -4 is recommended for most multimedia tasks, including games:\n\n```\nbit.trip.runner -n -4\n```\n\n"
    },
    {
      "title": "Core affinity",
      "level": 4,
      "content": "There is some confusion in development as to whether the driver should be multithreading, or the program. Allowing both the driver and program to simultaneously multithread can result in significant performance reductions, such as framerate loss and increased risk of crashes. Examples of this include a number of modern games, and any Wine program which is running with GLSL enabled. To select a single core and allow only the driver to handle this process, simply use the -a 0x# flag, where # is the core number, e.g.:\n\n```\nbit.trip.runner -a 0x1\n```\n\nuses first core.\n\nSome CPUs are hyperthreaded and have only 2 or 4 cores but show up as 4 or 8, and are best accounted for:\n\n```\nbit.trip.runner -a 0x5\n```\n\nwhich use virtual cores 0101, or 1 and 3.\n\n"
    },
    {
      "title": "General case",
      "level": 4,
      "content": "For most games which require high framerates and low latency, usage of all of these flags seems to work best. Affinity should be checked per-program, however, as most native games can understand the correct usage. For a general case:\n\n```\nbit.trip.runner -I -n -4\nAmnesia.bin64 -I -n -4\nhl2.exe -I -n -4 -a 0x1 #Wine with GLSL enabled\n```\n\netc.\n\n"
    },
    {
      "title": "Optimus, and other helping programs",
      "level": 4,
      "content": "As a general rule, any other process which the game requires to operate should be reniced to a level above that of the game itself. Strangely, Wine has a problem known as reverse scheduling, it can often have benefits when the more important processes are set to a higher nice level. Wineserver also seems unconditionally to benefit from SCHED_FIFO, since it rarely consumes the whole CPU and needs higher prioritization when possible.\n\n```\noptirun -I -n -5\nwineserver -F -p 20 -n 19\nsteam.exe -I -n -5\n```\n\n"
    },
    {
      "title": "Mouse",
      "level": 3,
      "content": "You might want to set your mouse acceleration to control your mouse more accurately.\n\nIf your mouse has more than 3 buttons, you might want to see Mouse buttons.\n\nIf you are using a gaming mouse (especially Logitech and Steelseries) you may want to configure your mouse polling rate, DPI, LEDs etc. using piper. See this page for a full list of supported devices by piper. Alternatively solaar for logitech devices.\n\n"
    },
    {
      "title": "LEDs",
      "level": 3,
      "content": "You can change and manipulate various RGBs with openrgb, for a list of currently supported devices see [24]\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- linux_gaming - Forum on reddit.com with gaming on linux as its topic, subpages: Wiki, FAQ.\n- Linux Gaming Guide - Compilation of different techniques for optimizing the Linux gaming experience.\n- are we anti cheat yet A comprehensive and crowd-sourced list of games using anti-cheats and their compatibility with GNU/Linux or Wine/Proton.\n- proton db crowdsourced Linux compatibility reports\n\n"
    }
  ]
}