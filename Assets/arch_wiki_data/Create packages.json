{
  "title": "Create packages",
  "url": "https://wiki.archlinux.org/title/Create_packages",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Font – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel modules – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust - Security – Shell – VCS – Web – Wine\n\nRelated articles\n\n- Creating packages for other distributions\n- Patching packages\n- .SRCINFO\n\nThis article aims to assist users creating their own packages using the ports–like Arch build system, also for submission in Arch User Repository. It covers creation of a PKGBUILD(5) — a package build description file sourced by makepkg to create a binary package from source.\n\nFor instructions regarding existing rules and ways to improve package quality, see Arch packaging standards.\n\n"
    },
    {
      "title": "Overview",
      "level": 2,
      "content": "Packages in Arch Linux are built using the makepkg utility and the information stored in a PKGBUILD file. When makepkg runs, it searches for a PKGBUILD in the current directory and follows the instructions in it to acquire the required files and/or compile them to be packed within a package file pkgname.pkg.tar.zst. The resulting package contains binary files and installation instructions ready to be installed by pacman.\n\nAn Arch package is no more than a tar(1) archive, or a tarball, compressed using zstd(1), which contains the following files generated by makepkg:\n\n- The binary files to install.\n- .PKGINFO: contains all the metadata needed by pacman to deal with packages, dependencies, etc.\n- .BUILDINFO: contains information needed for reproducible builds, also see BUILDINFO(5).\n- .MTREE: contains hashes and timestamps of the files, which are included in the local database so that pacman can verify the integrity of the package.\n- .INSTALL: an optional file used to execute commands after the install/upgrade/remove stage (this file is present only if specified in the PKGBUILD).\n- .Changelog: an optional file kept by the package maintainer documenting the changes of the package.\n\n"
    },
    {
      "title": "Prerequisite software",
      "level": 3,
      "content": "First, ensure that the necessary tools are installed: the meta package base-devel should be sufficient; it pulls in make(1) and additional tools needed for compiling from source.\n\nThe key tool for building packages is makepkg (provided by pacman). The tasks it performs can be found in Arch package guidelines#Makepkg duties.\n\n"
    },
    {
      "title": "Download and test the installation",
      "level": 3,
      "content": "Download the source tarball of the software you want to package, extract it, and follow the author's steps to install the program. Make a note of all commands and/or steps needed to compile and install it. You will be repeating those same commands in the PKGBUILD file.\n\nMost software authors stick to the 3-step build cycle:\n\n```\n$ ./configure\n$ make\n# make install\n```\n\nThis is a good time to make sure the program is working correctly.\n\n"
    },
    {
      "title": "Set up clean chroot",
      "level": 3,
      "content": "It is recommended to follow Building in a clean chroot to ensure that packages and configuration of your system do not lead to mistakes in the PKGBUILD. This is a more robust and correct way to build packages and will often catch missing dependencies that you did not realize were needed because they already existed in your system.\n\n"
    },
    {
      "title": "Creating a PKGBUILD",
      "level": 2,
      "content": "When makepkg is run, it looks for a PKGBUILD file in the current working directory. If it finds one, it downloads the software's source code and compiles it according to the instructions specified in the PKGBUILD file. The instructions must be fully interpretable by the Bash shell.\n\nAfter successful completion, the resulting binaries and metadata of the package, i.e. package version and dependencies, are packed in a pkgname.pkg.tar.zst package file. The newly created package can be installed by simply using makepkg --install which will call pacman in the background, or by directly using pacman -U pkgname.pkg.tar.zst.\n\nTo start building a new package, first create a new directory for the package and change current directory into this one. Then, a PKGBUILD file needs to be created: a prototype PKGBUILD found in /usr/share/pacman/ can be used or you can start from a PKGBUILD from another package. The latter may be a good choice if a similar package already exists.\n\nExample PKGBUILDs are located in /usr/share/pacman/.\n\n"
    },
    {
      "title": "PKGBUILD variables",
      "level": 3,
      "content": "makepkg predefines the following variables that should be used by packagers to refer to temporary locations during the build process:\n\nThey contain absolute paths, which means you do not have to worry about your working directory if you use these variables properly.\n\n"
    },
    {
      "title": "PKGBUILD functions",
      "level": 3,
      "content": "When building a package, makepkg will invoke the following five functions if they have been defined in the PKGBUILD. Function package() is required in every PKGBUILD and will always be invoked. If any of the other functions is not defined, makepkg will simply skip the invocation of that function.\n\nDuring the build, the functions are invoked in the order in which they are listed here.\n\nAlso see PKGBUILD(5) § PACKAGING FUNCTIONS.\n\n"
    },
    {
      "title": "prepare()",
      "level": 4,
      "content": "With this function, commands that are used to prepare sources for building are run, such as patching. This function runs right after package extraction, before pkgver() and the build function. If extraction is skipped (makepkg --noextract), then prepare() is not run.\n\nWhen it is not clear whether to put something in prepare() or build(), one rule of thumb is to put in prepare() the steps that should run exactly once after extracting the sources, and put in build() the steps which would make sense to re-run after any manual edits to the extracted files.\n\n"
    },
    {
      "title": "pkgver()",
      "level": 4,
      "content": "pkgver() runs after the sources are fetched, extracted and prepare() executed. So you can update the pkgver variable during a makepkg stage.\n\nThis is particularly useful if you are making git/svn/hg/etc. packages, where the build process may remain the same, but the source could be updated every day, even every hour. The old way of doing this was to put the date into the pkgver field which, if the software was not updated, makepkg would still rebuild it thinking the version had changed. Some useful commands for this are git describe, hg identify -ni, etc. Please test these before submitting a PKGBUILD, as a failure in the pkgver() function can stop a build in its tracks.\n\n"
    },
    {
      "title": "build()",
      "level": 4,
      "content": "Now, you need to implement the build() function in the PKGBUILD file. This function uses common shell commands in Bash syntax to automatically compile software and create a directory called pkg to install the software to. This allows makepkg to package files without having to sift through your file system.\n\nThe first step in the build() function is to change into the directory created by uncompressing the source tarball. makepkg will change the current directory to $srcdir before executing the build() function. Therefore, in most cases, like suggested in /usr/share/pacman/PKGBUILD.proto, the first command will look like this:\n\n```\ncd \"$pkgname-$pkgver\"\n```\n\nNow, you need to list the same commands you used when you manually compiled the software. The build() function in essence automates everything you did by hand and compiles the software in the fakeroot build environment. If the software you are packaging uses a configure script, it is good practice to use --prefix=/usr when building packages for pacman. A lot of software installs files relative to the /usr/local directory, which should only be done if you are manually building from source. All Arch Linux packages should use the /usr directory. As seen in the /usr/share/pacman/PKGBUILD.proto file, the next two lines often look like this:\n\n```\n./configure --prefix=/usr\nmake\n```\n\n"
    },
    {
      "title": "check()",
      "level": 4,
      "content": "Place for calls to make check and similar testing routines. It is highly recommended to have check() as it helps to make sure software has been built correctly and works fine with its dependencies.\n\nUsers who do not need it (and occasionally maintainers who can not fix a package for this to pass) can disable it by adding !check into the options array in PKGBUILD/makepkg.conf(5) or call makepkg with --nocheck flag.\n\nIf you are testing a GUI application, you can run it in a virtual xserver.\n\n"
    },
    {
      "title": "package()",
      "level": 4,
      "content": "The final step is to put the compiled files in a directory where makepkg can retrieve them to create a package. This by default is the pkg directory—a simple fakeroot environment. The pkg directory replicates the hierarchy of the root file system of the software's installation paths. If you have to manually place files under the root of your filesystem, you should install them in the pkg directory under the same directory structure. For example, if you want to install a file to /usr/bin, it should instead be placed under $pkgdir/usr/bin. Very few install procedures require the user to copy dozens of files manually. Instead, for most software, calling make install will do so. The final line should look like the following in order to correctly install the software in the pkg directory:\n\n```\nmake DESTDIR=\"$pkgdir/\" install\n```\n\nmakepkg --repackage runs only the package() function, so it creates a package without building. This may save time e.g. if you have changed just the depends variable of the package.\n\n"
    },
    {
      "title": "Testing the PKGBUILD and package",
      "level": 2,
      "content": "As you are writing the build() function, you will want to test your changes frequently to ensure there are no bugs. You can do this using the makepkg command in the directory containing the PKGBUILD file. With a properly formatted PKGBUILD, makepkg will create a package; with a broken or unfinished PKGBUILD, it will raise an error.\n\nIf makepkg finishes successfully, it will place a file named pkgname-pkgver.pkg.tar.zst in your working directory. This package can be installed with the pacman -U command. However, just because a package file was built does not imply that it is fully functional. It might conceivably contain only the directory and no files whatsoever if, for example, a prefix was specified improperly. You can use pacman's query functions to display a list of files contained in the package with pacman -Qlp pkgname, and the dependencies it requires with pacman -Qip pkgname.\n\nIf the package looks sane, then you are done! However, if you plan on releasing the PKGBUILD file, it is imperative that you check and double-check the contents of the depends array.\n\nAlso ensure that the package binaries actually run flawlessly! It is annoying to release a package that contains all necessary files, but crashes because of some obscure configuration option that does not quite work well with the rest of the system. If you are only going to compile packages for your own system, though, you do not need to worry too much about this quality assurance step, as you are the only person suffering from mistakes, after all.\n\n"
    },
    {
      "title": "Checking package sanity",
      "level": 3,
      "content": "After testing package functionality, check it for errors using namcap:\n\n```\n$ namcap PKGBUILD\n$ namcap pkgname.pkg.tar.zst\n```\n\nNamcap will:\n\n- check PKGBUILD contents for common errors and package file hierarchy for unnecessary/misplaced files,\n- scan all ELF files in the package using ldd(1), automatically reporting which packages with required shared libraries are missing from depends and which can be omitted as transitive dependencies,\n- heuristically search for missing and redundant dependencies,\n\nand much more.\n\nGet into the habit of checking your packages with namcap to avoid having to fix the simplest mistakes after package submission.\n\n"
    },
    {
      "title": "Using pkgctl to build in a clean chroot environment",
      "level": 3,
      "content": "Note: **This article or section is a candidate for merging with Arch build system#Build package.** This article or section is a candidate for merging with Arch build system#Build package.\n\nThis article or section is a candidate for merging with Arch build system#Build package.\n\nYou can use pkgctl from devtools to check if the package can be built where no other packages are already installed. While in the PKGBUILD directory:\n\n```\n$ pkgctl build\n```\n\nAnd check the output for potential errors or warnings. If the package depends on other AUR packages, those packages must be built and brought into chroot jail:\n\n```\n$ pkgctl build -I path/to/somepkg.tar.gz -I ...\n```\n\nRefer to pkgctl-build(1) for more options.\n\n"
    },
    {
      "title": "Submitting packages to the AUR",
      "level": 2,
      "content": "Please read AUR submission guidelines for a detailed description of the submission process.\n\n"
    },
    {
      "title": "Summary",
      "level": 2,
      "content": "1. Download the source tarball of the software to package.\n1. Try compiling the package and installing it into an arbitrary directory.\n1. Copy over the prototype /usr/share/pacman/PKGBUILD.proto and rename it to PKGBUILD in a temporary working directory.\n1. Edit the PKGBUILD according to the needs of your package.\n1. Run makepkg and check whether the package builds correctly.\n1. If not, repeat the previous two steps.\n\n"
    },
    {
      "title": "Warnings",
      "level": 3,
      "content": "- Before you can automate the package building process, you should have done it manually at least once unless you know exactly what you are doing in advance, in which case you would not be reading this in the first place. Unfortunately, although a good bunch of program authors stick to the 3-step build cycle of \"./configure; make; make install\", this is not always the case, and things can get real ugly if you have to apply patches to make everything work at all. Rule of thumb: If you cannot get the program to compile from the source tarball, and make it install itself to a defined, temporary subdirectory, you do not even need to try packaging it. There is not any magic pixie dust in makepkg that makes source problems go away.\n- In a few cases, the packages are not even available as source and you have to use something like sh installer.run to get it to work. You will have to do quite a bit of research (read READMEs, INSTALL instructions, man pages, perhaps ebuilds from Gentoo or other package installers, possibly even the MAKEFILEs or source code) to get it working. In some really bad cases, you have to edit the source files to get it to work at all. However, makepkg needs to be completely autonomous, with no user input. Therefore if you need to edit the makefiles, you may have to bundle a custom patch with the PKGBUILD and install it from inside the prepare() function, or you might have to issue some sed commands from inside the prepare() function.\n\n"
    },
    {
      "title": "Checksums",
      "level": 3,
      "content": "The process of updating checksums for new software releases can be automated by the updpkgsums tool; see Makepkg#Generate new checksums for details.\n\n"
    },
    {
      "title": "PKGBUILD generators",
      "level": 3,
      "content": "PKGBUILDs for some packages can be generated automatically.\n\n- Haskell: cblrepo, arch-hs\n- Node.js: nodejs-npm2archAUR\n- Perl: perl-cpanplus-dist-archAUR\n- Python: pipman-gitAUR, pip2arch-gitAUR, python-pypi2pkgbuildAUR\n- Ruby: gem2archAUR, pacgemAUR\n- Rust: cargo-pkgbuildAUR, cargo-aur-binAUR\n\n"
    },
    {
      "title": "New upstream releases",
      "level": 3,
      "content": "pkgctl (from the devtools package) supports nvchecker integration in the form of a .nvchecker.toml configuration file (which should be placed in the same directory as the PKGBUILD). See the pacman package's .nvchecker.toml configuration file for an example.\n\nYou can then use pkgctl version check to check if a new upstream version has been released (compared to the one specified as pkgver in the PKGBUILD) and pkgctl version upgrade to update the PKGBUILD accordingly. See pkgctl-version(1) for more details.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- How to correctly create a patch file.\n- Arch Linux Classroom IRC Logs of classes about creating PKGBUILDs.\n- Fakeroot approach for package installation\n\n"
    }
  ]
}