{
  "title": "Thinkpad multimedia buttons",
  "url": "https://wiki.archlinux.org/title/Thinkpad_multimedia_buttons",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Extra keyboard keys\n- Input remap utilities\n\nPrerequisite for modifying the key mapping is knowing how a key press results in a symbol:\n\n1. The keyboard sends a scancode to the computer.\n1. The Linux kernel maps the scancode to a keycode; see Map scancodes to keycodes.\n1. The keyboard layout maps the keycode to a symbol or keysym, depending on what modifier keys are pressed. For the Linux console, see Linux console/Keyboard configuration. For Xorg and Wayland, see Xorg/Keyboard configuration.\n\n- For the Linux console, see Linux console/Keyboard configuration.\n- For Xorg and Wayland, see Xorg/Keyboard configuration.\n\nMost of your keys should already have a keycode, or at least a scancode. Keys without a scancode are not recognized by the kernel; these can include additional keys from \"gaming\" keyboards, etc.\n\nIn Xorg, some keysyms (e.g. XF86AudioPlay, XF86AudioRaiseVolume etc.) can be mapped to actions (i.e. launching an external application). See Keyboard shortcuts#Xorg for details.\n\nIn Linux console, some keysyms (e.g. F1 to F246) can be mapped to certain actions (e.g. switch to other console or print some sequence of characters). See Console keyboard configuration#Creating a custom keymap for details.\n\n"
    },
    {
      "title": "Using evtest",
      "level": 3,
      "content": "The most reliable way to obtain a scancode is to reference the MSC_SCAN evdev event produced when the key is pressed [1]. There are multiple evdev API testers, but the most straightforward is evtest(1) from the evtest package:\n\n```\n# evtest /dev/input/event12\n```\n\n```\n...\nEvent: time 1434666536.001123, type 4 (EV_MSC), code 4 (MSC_SCAN), value 70053\nEvent: time 1434666536.001123, type 1 (EV_KEY), code 69 (KEY_NUMLOCK), value 0\nEvent: time 1434666536.001123, -------------- EV_SYN ------------\n```\n\nUse the \"value\" field of MSC_SCAN. This example shows that NumLock has scancode 70053 and keycode 69.\n\n"
    },
    {
      "title": "Using showkey",
      "level": 3,
      "content": "The traditional way to get a scancode is to use the showkey(1) utility. showkey waits for a key to be pressed, or exits if no keys are pressed within 10 seconds. For showkey to work you need to be in a virtual console, not in a graphical environment or logged in via a network connection. Run the following command:\n\n```\n# showkey --scancodes\n```\n\nand try to push keyboard keys; you should see scancodes being printed to the output.\n\n"
    },
    {
      "title": "Using dmesg",
      "level": 3,
      "content": "You can get the scancode of a key by pressing the desired key and looking at the output of dmesg. For example, if you get:\n\n```\nUnknown key pressed (translated set 2, code 0xa0 on isa0060/serio0\n```\n\nthen the scancode you need is 0xa0.\n\n"
    },
    {
      "title": "Identifying keycodes",
      "level": 2,
      "content": "The Linux keycodes are defined in /usr/include/linux/input-event-codes.h (see the KEY_ variables).\n\n"
    },
    {
      "title": "Identifying keycodes in console",
      "level": 3,
      "content": "The keycodes for virtual console are reported by the showkey(1) utility. showkey waits for a key to be pressed and if none are, in a span of 10 seconds, it quits. To execute showkey, you need to be in a virtual console, not in a graphical environment. Run the following command:\n\n```\n# showkey --keycodes\n```\n\nand try to push keyboard keys; you should see keycodes being printed to the output.\n\n"
    },
    {
      "title": "Identifying keycodes in Xorg",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nThe keycodes used by Xorg are reported by a utility called xev(1), which is provided by the xorg-xev package. Of course to execute xev, you need to be in a graphical environment, not in the console.\n\nWith the following command you can start xev and show only the relevant parts:\n\n```\n$ xev | awk -F'[ )]+' '/^KeyPress/ { a[NR+2] } NR in a { printf \"%-3s %s\\n\", $5, $8 }'\n```\n\n```\n38  a\n55  v\n54  c\n50  Shift_L\n133 Super_L\n135 Menu\n```\n\nXbindkeys is another wrapper to xev that reports keycodes.\n\nIf you press a key and nothing appears in the terminal, it means that either the key does not have a scancode, the scancode is not mapped to a keycode, or some other process is capturing the keypress. If you suspect that a process listening to X server is capturing the keypress, you can try running xev from a clean X session:\n\n```\n$ xinit /usr/bin/xterm -- :1\n```\n\n"
    },
    {
      "title": "Identifying keycodes in Wayland",
      "level": 3,
      "content": "Although xev works through xwayland, you can also use wev to access keycodes under pure Wayland.\n\nFor example, this command lets you retrieve only key names and their UTF-8 equivalent:\n\n```\n$ wev | grep 'sym'\n```\n\n"
    },
    {
      "title": "Configuration of VIA compatible keyboards",
      "level": 3,
      "content": "VIA is a program to remap keys directly into compatible keyboards. In case you have one of those, in order for the keyboard to be picked up by the browser and configure it online, you need to add a custom udev rule changing the permissions of devices accessed through the hidraw driver.\n\nCreate the following udev rule:\n\n```\n/etc/udev/rules.d/99-via.rules\n```\n\n```\nKERNEL==\"hidraw*\", SUBSYSTEM==\"hidraw\", MODE=\"0666\", TAG+=\"uaccess\", TAG+=\"udev-acl\"\n```\n\nThen reload the rules to take effect.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- kbd-project - official website of the showkeys utility\n- interception-tools - a set of utilities to control and customize the behavior of keyboard input mappings\n- kmonad - an advanced key rebinding and remapping daemon\n- Hawck - another key rebinding daemon\n- keyd - simplistic key rebinding daemon\n- Vial - VIA standalone program\n- Keyshift - performance oriented keyboard layering and remapping software for linux\n\n"
    }
  ]
}