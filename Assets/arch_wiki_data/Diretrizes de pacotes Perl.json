{
  "title": "Diretrizes de pacotes Perl",
  "url": "https://wiki.archlinux.org/title/Diretrizes_de_pacotes_Perl",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Fonte – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust – Shell – VCS – Web – Wine\n\nEste documento cobre a criação de PKGBUILDs para módulos perl distribuídos pelo CPAN, a Comprehensive Perl Authors Network. Este documento tem como público-alvo aqueles que deseja empacotar módulos perl. Para as políticas do Perl, veja Políticas do Perl.\n\n"
    },
    {
      "title": "Convenções de empacotamento do Arch Linux",
      "level": 2,
      "content": "As seguintes convenções devem ser usadas para manter os pacotes de módulos perl consistentes. Esta seção serve como uma introdução ao conceito de empacotamento de perl, do ponto de vista do Arch Linux; isto é, gerenciamento de pacotes e administração do sistema. Em um esforço para agradar o leitor TL;DR, o material mais fácil e/ou mais popular está no topo.\n\n"
    },
    {
      "title": "Nomes de pacotes",
      "level": 3,
      "content": "Para módulos, o nome do pacote deve começar com perl- e o resto do nome deve ser construído a partir do nome do módulo, convertendo-o em letras minúsculas e, em seguida, substituindo os dois pontos por hífenes. Por exemplo, o nome do pacote correspondente a HTML::Parser será perl-html-parser. Os aplicativos Perl devem ter o mesmo nome do aplicativo, mas em letras minúsculas.\n\n"
    },
    {
      "title": "Colocação de arquivos no pacote",
      "level": 3,
      "content": "Os pacotes Perl devem instalar os arquivos do módulo em /usr/lib/perl5/$version/vendor_perl/ (use perl -V:vendorarch em scripts), ou /usr/share/perl5/vendor_perl/. Isso é feito configurando o parâmetro de linha de comando INSTALLDIRS para vendor como mostrado abaixo. Nenhum arquivo deve ser armazenado em /usr/lib/perl5/$version/site_perl/, pois esse diretório é reservado para uso pelo administrador do sistema para instalar pacotes Perl fora do sistema de gerenciamento de pacotes. Quando um usuário instala módulos em todo o sistema usando o shell cpan, os módulos acabam nos subdiretórios site-perl.\n\nOs arquivos perllocal.pod e .packlist também não devem estar presentes; isso é cuidado pelo exemplo de PKGBUILD descrito abaixo.\n\n"
    },
    {
      "title": "Arquitetura",
      "level": 3,
      "content": "Na maioria dos casos, o vetor arch deve conter 'any' porque a maioria dos pacotes Perl são independentes de arquitetura. Os módulos XS são compilados em bibliotecas carregadas dinamicamente (arquivos .so) e devem explicitamente configurar sua arquitetura para ('x86_64') para indicar que eles são dependentes da arquitetura quando construídos. Um módulo XS geralmente contém um ou mais arquivos .xs que geram dinamicamente arquivos .c.\n\n"
    },
    {
      "title": "Automação",
      "level": 3,
      "content": "Um plugin para o shell CPAN de segunda geração, CPANPLUS, está disponível no pacote perl-cpanplus-dist-arch do repo da comunidade. Este plugin empacota distribuições rapidamente quando elas são instaladas pelo CPANPLUS. A documentação on-line está disponível em https://metacpan.org/release/CPANPLUS-Dist-Arch\n\n"
    },
    {
      "title": "Exemplos de PKGBUILD",
      "level": 2,
      "content": "Um exemplo de PKGBUILD pode ser encontrado em [1].\n\nOs dois exemplos a seguir do PKGBUILD usam técnicas, introduzidas nesta página, destinadas a tornar um PKGBUILD mais resiliente a problemas mais sofisticados. Como existem dois estilos de scripts de construção, há dois exemplos de PKGBUILDS. O primeiro PKGBUILD é um exemplo de como empacotar uma distribuição que usa Makefile.PL. O segundo PKGBUILD pode ser usado como ponto de partida para uma distribuição que usa Build.PL.\n\n```\nPKGBUILD\n```\n\n```\n# Contributor: Your Name <youremail@domain.com>\npkgname=perl-foo-bar\npkgver=1.0\npkgrel=1\npkgdesc='This packages the Foo-Bar distribution, containing the Foo::Bar module!'\n_dist=Foo-Bar\narch=('any')\nurl=\"https://metacpan.org/release/$_dist\"\nlicense=('GPL' 'PerlArtistic')\ndepends=(perl)\noptions=('!emptydirs' purge)\nsource=(\"http://search.cpan.org/CPAN/authors/id/BAZ/$_dist-$pkgver.tar.gz\")\nmd5sums=(...)\n\nbuild() {\n  cd \"$srcdir/$_dist-$pkgver\"\n  unset PERL5LIB PERL_MM_OPT PERL_LOCAL_LIB_ROOT\n  export PERL_MM_USE_DEFAULT=1 PERL_AUTOINSTALL=--skipdeps\n  /usr/bin/perl Makefile.PL\n  make\n}\n\ncheck() {\n  cd \"$srcdir/$_dist-$pkgver\"\n  unset PERL5LIB PERL_MM_OPT PERL_LOCAL_LIB_ROOT\n  export PERL_MM_USE_DEFAULT=1\n  make test\n}\n\npackage() {\n  cd \"$srcdir/$_dist-$pkgver\"\n  unset PERL5LIB PERL_MM_OPT PERL_LOCAL_LIB_ROOT\n  make install INSTALLDIRS=vendor DESTDIR=\"$pkgdir\"\n}\n```\n\n```\nPKGBUILD\n```\n\n```\n# Contributor: Your Name <youremail@domain.com>\npkgname=perl-foo-bar\npkgver=1.0\npkgrel=1\npkgdesc='This packages the Foo-Bar distribution, containing the Foo::Bar module!'\n_dist=Foo-Bar\narch=('any')\nurl=\"https://metacpan.org/release/$_dist\"\nlicense=('GPL' 'PerlArtistic')\ndepends=(perl)\noptions=('!emptydirs' purge)\nsource=(\"http://search.cpan.org/CPAN/authors/id/BAZ/$_dist-$pkgver.tar.gz\")\nmd5sums=(...)\n\nbuild() {\n  cd \"$srcdir/$_dist-$pkgver\"\n  unset PERL5LIB PERL_MM_OPT PERL_MB_OPT PERL_LOCAL_LIB_ROOT\n  export PERL_MM_USE_DEFAULT=1 MODULEBUILDRC=/dev/null\n  /usr/bin/perl Build.PL\n  ./Build\n}\n\ncheck() {\n  cd \"$srcdir/$_dist-$pkgver\"\n  unset PERL5LIB PERL_MM_OPT PERL_MB_OPT PERL_LOCAL_LIB_ROOT\n  export PERL_MM_USE_DEFAULT=1\n  ./Build test\n}\n\npackage() {\n  cd \"$srcdir/$_dist-$pkgver\"\n  unset PERL5LIB PERL_MM_OPT PERL_MB_OPT PERL_LOCAL_LIB_ROOT\n  ./Build install --installdirs=vendor --destdir=\"$pkgdir\"\n}\n```\n\nA justificativa para a complexidade adicional desses PKGBUILDs é apresentada nas seções abaixo.\n\n"
    },
    {
      "title": "Mecanismos de módulo CPAN",
      "level": 2,
      "content": "Há uma série de mecanismos cuidadosamente projetados, e não tão cuidadosamente, que trabalham juntos para criar o sistema de módulos. Ao fazer uso do CPAN, os procedimentos devem ser seguidos para buscar o código-fonte de um módulo, criar esse módulo buscado e inseri-lo no software do sistema para execução posterior. Para entender como os módulos devem ser empacotados, isso ajuda imensamente se entendermos como os módulos funcionam sem qualquer envolvimento dos pacotes pacman e Arch Linux. Nosso objetivo, no final, é tentar ser o mais discreto possível, melhorando a organização e a consistência do produto final.\n\n"
    },
    {
      "title": "Módulos",
      "level": 3,
      "content": "Os módulos são declarados com a palavra-chave package no perl. Os módulos estão contidos em um arquivo .pm (pronuncia-se como \"dót-pi-em\"). Embora seja possível, mais de um módulo (package) está no arquivo. Os módulos têm namespaces separados por :: (dois pontos duplos), como: Archlinux::Module. Ao carregar um módulo, os ::s são substituídos por separadores de diretórios. Por exemplo: Archlinux/Module.pm será carregado para o módulo Archlinux::Module.\n\nO módulos principais estão incluídos com uma instalação do perl. Alguns módulos principais estão apenas disponíveis empacotados com o perl. Outros módulos ainda podem ser baixados e instalados separadamente do CPAN.\n\n"
    },
    {
      "title": "Distribuições",
      "level": 3,
      "content": "Distributions também são conhecidas como dist oupackage no CPAN-lingo, sendo um equivalente a um pacote do Arch Linux neste site. Distribuições são arquivos .tar.gz cheios de arquivos. Esses arquivos contêm principalmente arquivos de módulo .pm, testes para os módulos incluídos, documentação para os módulos e o que for necessário.\n\nNormalmente, uma distribuição contém um módulo primário com o mesmo nome. Às vezes isso não é verdade, como na distribuição do Template-Toolkit. O pacote mais recente, Template-Toolkit-2.22.tar.gz, para o Template-Toolkit dist, não contém o módulo Template::Toolkit!\n\nÀs vezes, porque as distribuições são nomeadas conforme um módulo principal, seus nomes são usados de forma intercambiável e ficam confusos. No entanto, às vezes é útil considerá-los uma entidade separada (como no caso do Template-Toolkit).\n\n"
    },
    {
      "title": "CPAN",
      "level": 3,
      "content": "Cada espelho CPAN contém índices que listam as distribuições no CPAN, os módulos nos dists e o nome do autor que carregou o dist. Estes são simplesmente arquivos de texto. O índice mais útil está no arquivo /modules.dlocaches.details.txt.gz disponível em cada espelho do CPAN. O termo \"pacotes\" aqui se refere à palavra-chave package na própria linguagem perl, não algo similar aos pacotes pacman. O shell CPAN, chamado de letras minúsculas, em itálico cpan, é simplesmente o venerável script perl que navega nos índices para encontrar o módulo que você deseja instalar.\n\nOs módulos são encontrados na lista 02packages.details.txt.gz. Na mesma linha que o nome do módulo/pacote está o caminho para o tarball de distribuição que contém o módulo. Quando você pede ao cpan para instalar um módulo, ele irá procurar o módulo e instalar a distribuição relevante. Como a distribuição está instalando, irá gerar uma lista de dependências do módulo. Cpan tentará carregar cada dependência de módulo no intérprete perl. Se um módulo da versão fornecida não puder ser carregado, o processo será repetido.\n\nO shell cpan não precisa se preocupar com qual versão do módulo necessário está sendo instalado. O cpan pode confiar no fato de que a última versão do módulo deve satisfazer os requisitos do módulo original que começou a instalar em primeiro lugar. Somente as versões mais recentes dos módulos são listadas no arquivo de detalhes dos pacotes. Infelizmente, para o autor do pacote perl, nem sempre podemos confiar no fato de que nossos pacotes oferecem a versão mais recente de uma distribuição perl e os módulos contidos nela. A verificação de dependência do Pacman é muito mais estática e fortemente aplicada.\n\n"
    },
    {
      "title": "Dependências de módulos",
      "level": 3,
      "content": "Perl tem uma maneira única de definir dependências em comparação com sistemas similares, como eggs de python e gems de ruby. Eggs definem dependências de outros eggs. Gems dependem de gems. Dists de perl dependem de módulos. Os módulos só estão disponíveis nas distribuições CPAN, de modo que as distribuições perl dependem apenas indiretamente das distribuições. Os módulos podem definir suas próprias versões independentes das distribuições dentro do código-fonte do módulo. Isso é feito definindo uma variável package chamada $VERSION. Ao usar strict e warnings, isso é definido com a nossa palavra-chave. Por exemplo:\n\n```\npackage Foo::Module;\nuse warnings;\nuse strict;\nour $VERSION = '1.00';\n```\n\nOs módulos podem alterar suas versões da maneira que quiserem e até mesmo ter uma versão diferente da versão de distribuição. A utilidade disso é questionável, mas é importante ter em mente. Versões de módulo são mais difíceis de determinar fora do interpretador perl e requerem análise do próprio código perl e talvez até mesmo carregar o módulo em perl. A vantagem é que, dentro do módulo perl, as versões do módulo são fáceis de determinar. Por exemplo:\n\n```\nuse Foo::Module;\nprint $Foo::Module::VERSION, \"\\n\";\n```\n\n"
    },
    {
      "title": "Definição de dependências",
      "level": 3,
      "content": "Onde estão as dependências definidas nas distribuições perl? Elas são \"definidas\" dentro do script Makefile.PL ou Build.PL. Por exemplo, dentro do script Makefile.PL, a função WriteMakeFile é chamada para gerar o Makefile assim:\n\n```\nuse ExtUtils::MakeMaker;\nWriteMakeFile(\n    'NAME' => 'ArchLinux::Module',\n    'VERSION' => '0.01',\n    'PREREQ_PM' => { 'POSIX' => '0.01' },\n);\n```\n\nEste é um exemplo artificial, mas é importante entender que as dependências não são finais até que o script Makefile.PL ou Build.PL seja executado. Dependências são especificadas em tempo de execução, o que significa que elas podem ser alteradas ou modificadas usando todo o poder do perl. Isso significa que o autor do módulo pode adicionar, remover ou alterar versões de dependências antes da instalação da distribuição. Alguns autores de módulos usam isso para fazer coisas excessivamente inteligentes, como depender de módulos apenas se eles estiverem instalados. Algumas dists multiplataformas também dependem de módulos específicos do sistema quando instalados em sistemas operacionais diferentes.\n\nComo exemplo, a distribuição CPANPLUS procura por plugins CPANPLUS::Dist que estão atualmente instalados. Se algum plug-in estiver instalado para a versão atualmente instalada do CPANPLUS, ele será incluído nos pré-requisitos do novo CPANPLUS. Não sei bem por quê. Felizmente para o perl empacotador, a maioria das dependências é estática, como no exemplo acima, que requer o módulo POSIX com uma versão mínima de 0.01.\n\n"
    },
    {
      "title": "Informações meta",
      "level": 3,
      "content": "Os arquivos meta são incluídos em distribuições recentes que contêm meta-informações sobre distribuições, como nome, autor, descrição abstrata e requisitos do módulo. Anteriormente, havia arquivos META.yml no formato YAML, mas, mais recentemente, a mudança foi feita para arquivos META.json no formato JSON. Esses arquivos podem ser editados manualmente, mas com mais frequência eles são gerados automaticamente pelos scripts Makefile.PL ou Build.PL ao empacotar uma distribuição para lançamento. A última especificação é descrita nas documentações online do CPAN::Meta::Spec.\n\nLembre-se que as dependências podem ser alteradas em tempo de execução! Por esse motivo, outro meta arquivo é gerado após a execução do script de compilação. Este segundo meta arquivo é chamado MYMETA.json e reflete as alterações feitas no script em tempo de execução e pode ser diferente do arquivo meta gerado quando a distribuição foi empacotada para o CPAN.\n\nDistribuições idosas no CPAN não possuem nenhum arquivo meta. Esses lançamentos antigos são anteriores à ideia do arquivo META.yml e descrevem apenas seus pré-requisitos em seu Makefile.PL.\n\n"
    },
    {
      "title": "Módulos instaláveis",
      "level": 2,
      "content": "Um dos maiores pontos fortes do perl é o grande número de módulos disponíveis no CPAN. Não muito surpreendentemente, existem também vários módulos diferentes usados para instalar... bem... módulos! Há mais de uma maneira de fazer isso! Eu não estou ciente de um nome padrão para esses tipos de módulos, então eu os chamei de \"Módulos de Instalação\".\n\nEstes módulos estão preocupados com a compilação da distribuição e instalação dos arquivos do módulo, sempre que o usuário preferir. Isso parece simples, mas considerando o número de diferentes sistemas em que perl é executado, isso pode se tornar complexo. Todos os módulos de instalação colocam um arquivo de código perl dentro do tarball dist. A execução deste script perl iniciará o processo de compilação e instalação. O script sempre termina com o sufixo .PL e é denominado \"Script de compilação\" na lista abaixo.\n\n"
    },
    {
      "title": "ExtUtils::MakeMaker",
      "level": 3,
      "content": "O módulo mais antigo e original para a instalação de módulos é o ExtUtils::MakeMaker. A principal desvantagem deste módulo é que ele requer que o programa make compile e instale tudo. Isso pode não parecer um grande problema para os usuários do Linux, mas é um verdadeiro aborrecimento para as pessoas do Windows!\n\n"
    },
    {
      "title": "Module::Build",
      "level": 3,
      "content": "A principal vantagem do Module::Build é que ele é puro perl. Isto significa que não requer que um programa make seja instalado para você compilar/instalar módulos. Sua adoção foi complicada porque se o Module::Build ainda não estivesse instalado, você não poderia executar o script Build.PL incluído! Este não é um problema com versões recentes do perl porque Module::Build é um módulo central. (NOTE A partir do perl 5.22, o Module::Build não será mais um módulo central)\n\n"
    },
    {
      "title": "Module::Build::Tiny",
      "level": 3,
      "content": "Esta é outra ferramenta de compilação de puro perl. Como interface, implementa um subconjunto da interface do Module::Build, em particular, requer traços antes de seus argumentos (Module::Build aceita com e sem) e não suporta .modulebuildrc.\n\n"
    },
    {
      "title": "Module::Install",
      "level": 3,
      "content": "Outro módulo moderno de compilação/instalação, Module::Install ainda requer que o programa make seja instalado para funcionar. MI foi criado para substituir MakeMaker, para resolver algumas das deficiências do MakeMaker. Ironicamente, isso depende do MakeMaker para operar. Os arquivos Makefile.PL que são gerados pelo MI são muito diferentes e são implementados usando uma linguagem simples específico do domínio.\n\nUma característica muito interessante é que o Module::Install empacota uma cópia completa de si mesmo no arquivo de distribuição. Por causa disso, ao contrário de MakeMaker ou M::B, você não precisa que Module::Install esteja instalado em seu sistema.\n\nOutra característica muito original é a instalação automática. Embora não seja recomendado pelos autores de Module::Install, esse recurso é usado com bastante frequência. Quando o autor do módulo habilita a auto-instalação para sua distribuição, Module::Install irá procurar e instalar quaisquer módulos de pré-requisito que não estejam instalados quando o Makefile.PL for executado. Este recurso é ignorado quando Module::Install detecta que está sendo executado por CPAN ou CPANPLUS. No entanto, esse recurso não é ignorado quando executado dentro... oh, eu não sei ... um PKGBUILD! Espero que você possa ver como um programa permissivo do perl baixando e instalando módulos a qualquer momento, dentro de um PKGBUILD, possa ser um problema. Veja a variável de ambiente #PERL_AUTOINSTALL para ver como corrigir isso.\n\n"
    },
    {
      "title": "Variáveis de ambiente",
      "level": 3,
      "content": "Diversas variáveis de ambiente podem afetar o modo como os módulos são construídos ou instalados. Alguns têm um efeito muito dramático e podem causar problemas se forem mal compreendidos. Um usuário avançado pode estar usando essas variáveis de ambiente. Algumas delas quebrarão um PKGBUILD desavisado ou causarão um comportamento inesperado.\n\n"
    },
    {
      "title": "PERL_MM_USE_DEFAULT",
      "level": 4,
      "content": "Quando esta variável é definida para um valor verdadeiro, o módulo de instalação fingirá que a resposta padrão foi dada para qualquer pergunta que normalmente faria. Isso não \"sempre\" funciona, mas todos os módulos de instalação o honram. Isso não significa que o autor do módulo irá!\n\n"
    },
    {
      "title": "PERL_AUTOINSTALL",
      "level": 4,
      "content": "Você pode passar argumentos adicionais de linha de comando para o Makefile.PL do Module::Install com essa variável. Para desativar a instalação automática (altamente recomendado), atribua --skipdeps a este.\n\n```\nexport PERL_AUTOINSTALL='--skipdeps'\n```\n\n"
    },
    {
      "title": "PERL_MM_OPT",
      "level": 4,
      "content": "Você pode passar argumentos adicionais de linha de comando a Makefile.PL e/ou Build.PL com essa variável. Por exemplo, você pode instalar módulos em seu diretório pessoal usando:\n\n```\nexport PERL_MM_OPT=INSTALLBASE=~/perl5\n```\n\n"
    },
    {
      "title": "PERL_MB_OPT",
      "level": 4,
      "content": "Essa é a mesma coisa que PERL_MM_OPT, exceto por ser apenas para Module::Build. Por exemplo, você poderia instalar módulos em seu diretório pessoal usando:\n\n```\nexport PERL_MB_OPT=--install_base=~/perl5\n```\n\n"
    },
    {
      "title": "MODULEBUILDRC",
      "level": 4,
      "content": "Module::Build permite que você sobrescreva seus argumentos de linha de comando com um arquivo rc. O padrão deste é ~/.modulebuildrc. É considerado obsoleto no conjunto de ferramentas perl. Você pode sobrescrever qual arquivo usa definindo o caminho para o arquivo rc em MODULEBUILDRC. Os paranoicos podem definir MODULEBUILDRC para /dev/null ... apenas por precaução.\n\n"
    },
    {
      "title": "PERL5LIB",
      "level": 4,
      "content": "Os diretórios pesquisados por bibliotecas podem ser configurados pelo usuário (especialmente se eles estiverem usando Local::Lib) definindo PERL5LIB. Isso deve ser apagado antes de compilar.\n\n"
    },
    {
      "title": "PERL_LOCAL_LIB_ROOT",
      "level": 4,
      "content": "Se o usuário estiver usando Local::Lib, então PERL_LOCAL_LIB_ROOT será definido. Isso deve ser apagado antes de compilar.\n\n"
    },
    {
      "title": "Problemas com perl instalado pelo usuário",
      "level": 2,
      "content": "Um problema sutil é que os programadores avançados de perl podem gostar de ter múltiplas versões de perl instaladas. Isso é útil para testar a compatibilidade com versões anteriores em programas criados. Também há benefícios de velocidade para compilar seu próprio interpretador perl personalizado (p. ex., sem threads). Outra razão para um perl personalizado é simplesmente porque o pacote perl do Arch Linux às vezes fica atrás de versões perl. O usuário pode estar experimentando o perl mais recente ... quem sabe?\n\nSe o usuário tiver um executável personalizado do perl em seu $PATH, o perl personalizado será executado quando o usuário digita o comando perl na shell. Na verdade, o perl personalizado será executado dentro do PKGBUILD também! Isso pode levar a problemas traiçoeiros que são difíceis de entender.\n\nO problema reside nos módulos XS compilados. Esses módulos ligam perl e C. Como tal, eles devem usar a API C internal do perl para realizar essa ponte. A API C do perl muda um pouco entre diferentes versões do perl. Se o usuário tiver uma versão diferente do perl do que o perl do sistema (/usr/bin/perl), então qualquer módulo XS compilado com o perl do usuário será incompatível com o perl do sistema. Ao tentar usar o módulo XS compilado com o perl do sistema, o módulo vai falhar em carregar com um erro de vinculação.\n\nUma solução simples é sempre usar o caminho absoluto do interpretador perl do sistema (/usr/bin/perl) ao executar perl no PKGBUILD.\n\n"
    }
  ]
}