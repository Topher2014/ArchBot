{
  "title": "UDF",
  "url": "https://wiki.archlinux.org/title/UDF",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Partitioning\n- Device file#lsblk\n- File permissions and attributes\n- fsck\n- fstab\n- List of applications/Utilities#Mount tools\n- QEMU#Mounting a partition from a raw image\n- udev\n- udisks\n- umask\n- USB storage devices\n\nFrom Wikipedia:\n\nIndividual drive partitions can be set up using one of the many different available file systems. Each has its own advantages, disadvantages, and unique idiosyncrasies. A brief overview of supported file systems follows; the links are to Wikipedia pages that provide much more information.\n\n"
    },
    {
      "title": "Types of file systems",
      "level": 2,
      "content": "See filesystems(5) for a general overview and Wikipedia:Comparison of file systems for a detailed feature comparison. File systems already loaded by the kernel or built-in are listed in /proc/filesystems, while all the installed modules can be seen with ls /lib/modules/$(uname -r)/kernel/fs.\n\nTable content:\nFile system | Creation command | Userspace utilities | Archiso [1] | Kernel documentation [2] | Notes\nBcachefs | bcachefs(8) | bcachefs-tools | Yes | [3] | Available in Linux 6.7+, experimental\nBtrfs | mkfs.btrfs(8) | btrfs-progs | Yes | btrfs.html | Stability status\nVFAT | mkfs.fat(8) | dosfstools | Yes | vfat.html | Windows 9x file system. Commonly used for USB flash drives and SD cards.\nexFAT | mkfs.exfat(8) | exfatprogs | Yes |  | Native file system in Linux 5.4.[4] Commonly used for USB flash drives and SD cards.\nmkexfatfs(8) | exfat-utils | No | N/A (FUSE-based) | \nF2FS | mkfs.f2fs(8) | f2fs-tools | Yes | f2fs.html | Flash-based devices. Cannot be shrunk.\next3 | mkfs.ext3(8) | e2fsprogs | Yes | ext3.html | \next4 | mkfs.ext4(8) | e2fsprogs | Yes | ext4.html | \nHFS | mkfs.hfsplus(8) | hfsprogsAUR | No | hfs.html | Classic Mac OS file system\nHFS+ | mkfs.hfsplus(8) | hfsprogsAUR | No | hfsplus.html | macOS (8–10.12) file system\nJFS | mkfs.jfs(8) | jfsutils | Yes | jfs.html | \nNILFS2 | mkfs.nilfs2(8) | nilfs-utils | Yes | nilfs2.html | Mostly intended for flash based devices. Does not support xattrs and ACLs.\nNTFS |  |  | Yes | ntfs3.html | Windows NT file system. New driver, available since Linux 5.15.\nmkfs.ntfs(8) | ntfs-3g | Yes | N/A (FUSE-based) | FUSE driver with extended capabilities.\nReiserFS | mkfs.reiserfs(8) | reiserfsprogsAUR | No |  | Deprecated since Linux 5.18 and removed in Linux 6.13.\nUDF | mkfs.udf(8) | udftools | Yes | udf.html | ISO/IEC 13346 file system for disc images and DVDs/Blu-rays.\nXFS | mkfs.xfs(8) | xfsprogs | Yes | xfs.html xfs-delayed-logging-design.html xfs-self-describing-metadata.html | Cannot be shrunk\n\nxfs.html xfs-delayed-logging-design.html xfs-self-describing-metadata.html\n\nTable content:\nFile system | Creation command | Kernel patchset | Userspace utilities | Notes\nAPFS | mkapfs(8) | linux-apfs-rw-dkms-gitAUR | apfsprogs-gitAUR | macOS (10.13 and newer) file system. Read-only, experimental write support. See also apfs-fuse-gitAUR FUSE version.\nReiser4 | mkfs.reiser4(8) |  | reiser4progsAUR | \nZFS |  | zfs-linuxAUR, zfs-dkmsAUR | zfs-utilsAUR | OpenZFS port\n\n"
    },
    {
      "title": "Journaling",
      "level": 3,
      "content": "The ext3/4, HFS+, JFS, NTFS, ReiserFS, and XFS file systems use journaling. Journaling provides fault-resilience by logging changes before they are committed to the file system. In the event of a system crash or power failure, such file systems are faster to bring back online and less likely to become corrupted. The logging takes place in a dedicated area of the file system.\n\next3/4 offer data-mode journaling, which can optionally log data in addition to the metadata. Data-mode journaling comes with a speed penalty, because it does two write operations: first to the journal and then to the disk. Therefore, data-mode journaling is not enabled by default. The trade-off between system speed and data safety should be considered when choosing the file system type and features.\n\nIn the same vein, Reiser4 offers configurable \"transaction models\": a special model called wandering logs, which eliminates the need to write to the disk twice; write-anywhere, a pure copy-on-write approach; and a combined approach called hybrid which heuristically alternates between the two.\n\nFile systems based on copy-on-write (also known as write-anywhere), such as Reiser4, Btrfs, Bcachefs and ZFS, by design operate on full atomicity and also provide checksums for both metadata and inline data (operations entirely occur, or they entirely do not, and in properly functioning hardware data does not corrupt due to operations half-occurring). Therefore, these file systems are by design much less prone to data loss than other file systems and have no need to use traditional journal to protect metadata, because they are never updated in-place. Although Btrfs still has a journal-like log tree, it is only used to speed-up fdatasync/fsync.\n\nFAT, exFAT, ext2, and HFS provide neither journaling nor atomicity, They are for temporary or legacy use and not recommended for use when reliable storage is needed.\n\n"
    },
    {
      "title": "FUSE-based file systems",
      "level": 3,
      "content": "See FUSE.\n\n"
    },
    {
      "title": "Stackable file systems",
      "level": 3,
      "content": "- eCryptfs — The enterprise cryptographic file system is a package of disk encryption software for Linux. It is implemented as a POSIX-compliant file system–level encryption layer, aiming to offer functionality similar to that of GnuPG at the operating system level.\n\n- mergerfs — a FUSE based union file system.\n\n- mhddfs — Multi-HDD FUSE file system, a FUSE based union file system.\n\n- overlayfs — OverlayFS is a file system service for Linux which implements a union mount for other file systems.\n\n- unionfs-fuse — A user space Unionfs implementation.\n\n"
    },
    {
      "title": "Read-only file systems",
      "level": 3,
      "content": "- DwarFS — DwarFS is a fast high compression read-only file system for Linux and Windows. DwarFS more or less supports the same features as SquashFS, but is able to compress better, and has configurable hash algorithm.\n\n- EROFS — Enhanced Read-Only File System is a lightweight read-only file system, it aims to improve performance and compress storage capacity.\n\n- SquashFS — SquashFS is a compressed read-only file system. SquashFS compresses files, inodes and directories, and supports block sizes up to 1 MiB for greater compression.\n\n"
    },
    {
      "title": "Clustered file systems",
      "level": 3,
      "content": "- BeeGFS — A parallel file system, developed and optimized for high-performance computing.\n\n- Ceph — Unified, distributed storage system designed for excellent performance, reliability and scalability.\n\n- Glusterfs — Cluster file system capable of scaling to several peta-bytes.\n\n- IPFS — A peer-to-peer hypermedia protocol to make the web faster, safer, and more open. IPFS aims replace HTTP and build a better web for all of us. Uses blocks to store parts of a file, each network node stores only content it is interested, provides deduplication, distribution, scalable system limited only by users. (currently in alpha)\n\n- MinIO — MinIO offers high-performance, S3 compatible object storage.\n\n- MooseFS — MooseFS is a fault tolerant, highly available and high performance scale-out network distributed file system.\n\n- OpenAFS — Open source implementation of the AFS distributed file system\n\n- OrangeFS — OrangeFS is a scale-out network file system designed for transparently accessing multi-server-based disk storage, in parallel. Has optimized MPI-IO support for parallel and distributed applications. Simplifies the use of parallel storage not only for Linux clients, but also for Windows, Hadoop, and WebDAV. POSIX-compatible. Part of Linux kernel since version 4.6.\n\n- Sheepdog — Distributed object storage system for volume and container services and manages the disks and nodes intelligently.\n\n- Tahoe-LAFS — Tahoe Least-Authority File Store is a free and open, secure, decentralized, fault-tolerant, peer-to-peer distributed data store and distributed file system.\n\n"
    },
    {
      "title": "Shared-disk file system",
      "level": 3,
      "content": "- GFS2 — GFS2 allows all members of a cluster to have direct concurrent access to the same shared block storage\n\n- OCFS2 — The Oracle Cluster File System (version 2) is a shared disk file system developed by Oracle Corporation and released under the GNU General Public License\n\n- VMware VMFS — VMware's VMFS (Virtual Machine File System) is used by the company's flagship server virtualization suite, vSphere.\n\n"
    },
    {
      "title": "Identify existing file systems",
      "level": 2,
      "content": "To identify existing file systems, you can use lsblk:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE LABEL     UUID                                 MOUNTPOINT\nsdb\n└─sdb1 vfat   Transcend 4A3C-A9E9\n```\n\nAn existing file system, if present, will be shown in the FSTYPE column. If mounted, it will appear in the MOUNTPOINT column.\n\n"
    },
    {
      "title": "Create a file system",
      "level": 2,
      "content": "File systems are usually created on a partition, inside logical containers such as LVM, RAID and dm-crypt, or on a regular file (see Wikipedia:Loop device). This section describes the partition case.\n\nNote: **Create a backup of any data you want to keep** \n\n- After creating a new file system, data previously stored on this partition can unlikely be recovered. Create a backup of any data you want to keep.\n- The purpose of a given partition may restrict the choice of file system. For example, an EFI system partition must contain a FAT32 file system, and the file system containing the /boot directory must be supported by the boot loader.\n\nBefore continuing, identify the device where the file system will be created and whether or not it is mounted. For example:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE   LABEL       UUID                                 MOUNTPOINT\nsda\n├─sda1                      C4DA-2C4D\n├─sda2 ext4                 5b1564b2-2e2c-452c-bcfa-d1f572ae99f2 /mnt\n└─sda3                      56adc99b-a61e-46af-aab7-a6d07e504652\n```\n\nMounted file systems must be unmounted before proceeding. In the above example an existing file system is on /dev/sda2 and is mounted at /mnt. It would be unmounted with:\n\n```\n# umount /dev/sda2\n```\n\nTo find just mounted file systems, see #List mounted file systems.\n\nTo create a new file system, use mkfs(8). See #Types of file systems for the exact type, as well as userspace utilities you may wish to install for a particular file system.\n\nFor example, to create a new file system of type ext4 (common for Linux data partitions) on /dev/sda1, run:\n\n```\n# mkfs.ext4 /dev/sda1\n```\n\n- Use the -L flag of mkfs.ext4 to specify a file system label. e2label can be used to change the label on an existing file system.\n- File systems may be resized after creation, with certain limitations. For example, an XFS file system's size can be increased, but it cannot reduced. See Wikipedia:Comparison of file systems#Resize capabilities and the respective file system documentation for details.\n\nThe new file system can now be mounted to a directory of choice.\n\n"
    },
    {
      "title": "Mount a file system",
      "level": 2,
      "content": "To manually mount a file system located on a device (e.g., a partition) to a directory, use mount(8). This example mounts /dev/sda1 to /mnt.\n\n```\n# mount /dev/sda1 /mnt\n```\n\nThis attaches the file system on /dev/sda1 at the directory /mnt, making the contents of the file system visible. Any data that existed at /mnt before this action is made invisible until the device is unmounted.\n\nfstab contains information on how devices should be automatically mounted if present. See the fstab article for more information on how to modify this behavior.\n\nIf a device is specified in /etc/fstab and only the device or mount point is given on the command line, that information will be used in mounting. For example, if /etc/fstab contains a line indicating that /dev/sda1 should be mounted to /mnt, then the following will automatically mount the device to that location:\n\n```\n# mount /dev/sda1\n```\n\nOr\n\n```\n# mount /mnt\n```\n\nmount contains several options, many of which depend on the file system specified. The options can be changed, either by:\n\n- using flags on the command line with mount\n- editing fstab\n- creating udev rules\n- compiling the kernel yourself\n- or using file system–specific mount scripts (located at /usr/bin/mount.*).\n\nSee these related articles and the article of the file system of interest for more information.\n\n- File systems can also be mounted with systemd-mount instead of mount. If the mount point is not specified, the file system will be mounted at /run/media/system/device_identifier/. This allows to easily mount a file system without having to decide where to mount it. See systemd-mount(1) for usage and more details.\n- To mount file systems as an ordinary user, see udisks#Usage. This also allows mounting without having root permissions, a full graphical environment or a file manager which utilizes udisks.\n\n"
    },
    {
      "title": "List mounted file systems",
      "level": 3,
      "content": "To list all mounted file systems, use findmnt(8):\n\n```\n$ findmnt\n```\n\nfindmnt takes a variety of arguments which can filter the output and show additional information. For example, it can take a device or mount point as an argument to show only information on what is specified:\n\n```\n$ findmnt /dev/sda1\n```\n\nfindmnt gathers information from /etc/fstab, /etc/mtab, and /proc/self/mounts.\n\n"
    },
    {
      "title": "Unmount a file system",
      "level": 3,
      "content": "To unmount a file system use umount(8). Either the device containing the file system (e.g., /dev/sda1) or the mount point (e.g., /mnt) can be specified:\n\n```\n# umount /dev/sda1\n```\n\nor\n\n```\n# umount /mnt\n```\n\n"
    },
    {
      "title": "\"linux Structure needs cleaning\"",
      "level": 3,
      "content": "Unmount the file system and run fsck on the problematic volume.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- filesystems(5)\n- systemd-mount(1)\n- Documentation of file systems supported by Linux\n- Wikipedia:File systems\n- Wikipedia:Mount (Unix)\n\n"
    }
  ]
}