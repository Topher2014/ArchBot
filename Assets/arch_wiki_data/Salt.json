{
  "title": "Salt",
  "url": "https://wiki.archlinux.org/title/Salt",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "From docs.saltproject.io:\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the saltAUR package.\n\n"
    },
    {
      "title": "Components of Salt Stack",
      "level": 2,
      "content": "Salt is at its core a Remote Execution solution. Running pre-defined or arbitrary commands on remote hosts. Salt functions on a master/minion topology. A master server acts as a central control bus for the clients (called minions), and the minions connect back to the master.\n\n"
    },
    {
      "title": "Salt Master",
      "level": 3,
      "content": "The default configuration is suitable for the vast majority of installations. Start/enable salt-master.service.\n\nThe Salt master can also be started in the foreground in debug mode, greatly increasing the command output:\n\n```\n# salt-master -l debug\n```\n\nThe Salt master needs to bind to 2 TCP network ports on the system, these ports are 4505 and 4506.\n\n"
    },
    {
      "title": "Salt Minion",
      "level": 3,
      "content": "The Salt Minion can operate with or without a Salt Master. This wiki assumes that the minion will be connected to the master. For information on how to run a master-less minion please see the masterless quickstart guide: https://docs.saltproject.io/en/latest/topics/tutorials/quickstart.html\n\nThe Salt minion only needs to be aware of one piece of information to run, the network location of the master. By default the minion will look for the DNS name salt for the master, making the easiest approach to set internal DNS to resolve the name salt back to the Salt Master IP. Otherwise the minion configuration file will need to be edited, edit the configuration option master to point to the DNS name or the IP of the Salt Master.\n\n```\n/etc/salt/minion\n```\n\n```\nmaster: saltmaster.example.com\n```\n\nNow that the master can be found, start/enable salt-minion.service.\n\nOr to run in debug mode\n\n```\n# salt-minion -l debug\n```\n\n"
    },
    {
      "title": "Salt Key",
      "level": 3,
      "content": "Salt authenticates minion using public key encryption and authentication. For a minion to start accepting commands from the master the minion keys need to be accepted. The salt-key command is used to manage all of the keys on the master. To list the keys that are on the master run salt-key list command:\n\n```\n# salt-key -L\n```\n\nThe keys that have been rejected, accepted and pending acceptance are listed. To accept a minion:\n\n```\n# salt-key -a minion.example.com\n```\n\nOr you can accept all keys at once with :\n\n```\n# salt-key -A\n```\n\n"
    },
    {
      "title": "Salt Cloud",
      "level": 3,
      "content": "Salt can also be used to provision cloud servers on most major cloud providers. In order to connect to these providers, additional dependencies may be required. python-apache-libcloudAUR is required for many popular providers such as Rackspace and Amazon. Further details for configuring your cloud provider can be found at the official wiki: https://docs.saltproject.io/en/latest/topics/cloud/\n\n"
    },
    {
      "title": "Salt commands",
      "level": 2,
      "content": "After connecting and accepting the minion on the Salt master, you can now send commands to the minion. Salt commands allow for a vast set of functions to be executed and for specific minion and groups of minions to be targeted for execution. This makes the salt command very powerful, but the command is also very usable, and easy to understand.\n\nThe salt command is comprised of command options, target specification, the function to execute, and arguments to the function. A simple command to start with looks like this:\n\n```\n# salt '*' test.ping\n```\n\nThe * is the target, which specifies all minions, and test.ping tells the minions to run the test.ping function. This salt command will tell all of the minions to execute the test.ping in parallel and return the result.\n\nFor more commands see documentation or run:\n\n```\n# salt '*' sys.doc\n```\n\n"
    },
    {
      "title": "Salt States",
      "level": 2,
      "content": "In addition to running commands, salt can use what are known as states. A state is like a configuration file that allows setting up a new installation in the exact same way. A state can also be ran on that install after several weeks to make sure the computer is still in a known configuration.\n\n"
    },
    {
      "title": "Salt Environments",
      "level": 3,
      "content": "States can be separated into different environments. These environments can be used for making changes in a test environment before moving to a production machine, configuring a group of servers the same way, etc. The base environment is /srv/salt by default, and sometimes /srv/salt must be manually created.\n\nDifferent environments can be set up in the salt-master file. Check /etc/salt/master for more info.\n\n"
    },
    {
      "title": "Creating a State",
      "level": 3,
      "content": "A state is a text file with the .sls extension, located within a configured environment. This assumes the only the default base environment set up.\n\nCreate a file in /srv/salt called test.sls, with the following content:\n\n```\n/srv/salt/test.sls\n```\n\n```\nnetcat:\n pkg.installed: []\n```\n\nNow run the state:\n\n```\n# salt '*' state.apply test\n```\n\nSalt will search the base environment folder for anything called test.sls and apply the configuration it finds to all servers. In this case, netcat will be installed on all servers.\n\nFor more information on state file syntax and using states, see here: https://docs.saltproject.io/en/latest/topics/tutorials/starting_states.html\n\n"
    },
    {
      "title": "The top file",
      "level": 3,
      "content": "The top file is the main way to apply different configs to different servers at once. The top file is called top.sls and is placed in the root of an environment. The top file configuration can be ran with the following command:\n\n```\n# salt '*' state.apply\n```\n\nLet us assume we have 2 servers: fs01, web01. Let us also assume we have 3 states in the base environment: nettools.sls, samba.sls, apache.sls. Here is a sample:\n\n```\ntop.sls\n```\n\n```\n# Applied to all servers\n'*':\n  nettools\n\n# Applied only to fs01\nfs01:\n  samba\n\n# Applied only to web01\nweb01:\n  apache\n```\n\nWhen state.apply is ran, the top file is read, and the states are applied to the correct servers. IE: nettools on all servers, samba on fs01, apache on web01.\n\n"
    },
    {
      "title": "Scheduling Tasks",
      "level": 3,
      "content": "Enable the salt scheduler on the minion with\n\n```\n# salt 'minion-name' schedule.enable\n```\n\nInstall python2-dateutilAUR on the master and any minions that will be using the scheduler and restart the salt-minion service on that server. Remember, you can easily install python2-dateutilAUR and restart the salt-minion service on all minions using a state or a salt '*' command.\n\nAssume samba.sls, stored in /srv/salt, needs to be run every Monday on fs01. This can be accomplished by placing the following into a state file and running it.\n\n```\nconfigure_samba_daily:\n   schedule.present:\n     - function: state.sls\n     - job_args:\n       - samba\n     - when:\n       - Monday 5:00am\n```\n\nRun\n\n```\n# salt 'minion-name' schedule.list\n```\n\nto verify the job was placed on the schedule.\n\nNote: **not** \n\nFor more details on configuring schedules, see https://docs.saltproject.io/en/latest/ref/states/all/salt.states.schedule.html\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- https://docs.saltproject.io/ - Official documentation\n\n"
    }
  ]
}