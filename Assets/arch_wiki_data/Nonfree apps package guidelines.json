{
  "title": "Nonfree apps package guidelines",
  "url": "https://wiki.archlinux.org/title/Nonfree_apps_package_guidelines",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Font – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel modules – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust - Security – Shell – VCS – Web – Wine\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nFor many applications (most of which are Windows ones) there are neither sources nor tarballs available. Many of such applications can not be freely distributed because of license restrictions and/or lack of legal ways to obtain installer for no fee.\n\n"
    },
    {
      "title": "Rationale",
      "level": 2,
      "content": "There are multiple reasons for packaging even non-packageable software:\n\n- Simplification of installation/removal process\n\n```\n$ chmod +x filename$ chown root:root filename# cp filename /usr/bin/\n```\n\n```\n$ makepkg -i\n```\n\n- Utilizing pacman capabilities\n\n- Sharing code and knowledge\n\n"
    },
    {
      "title": "Avoid nonfree software when possible",
      "level": 3,
      "content": "Yes, it is better to leave this guide and spend some time searching (or maybe even creating) alternatives to an application you wanted to package because:\n\n- It is better to support software that is owned by us all than software that is owned by a company\n- It is better to support software that is actively maintained\n- It is better to support software that can be fixed if just one person out of millions cares enough\n\n"
    },
    {
      "title": "Use open source variants where possible",
      "level": 3,
      "content": "Many commercial games (some are listed in this Wiki) have open source engines and many old games can be played with emulators such as ScummVM. Using open source engines together with the original game assets gives users access to bug fixes and eliminates several issues caused by binary packages.\n\n"
    },
    {
      "title": "Keep it simple",
      "level": 3,
      "content": "If the packaging of some program requires more effort and hacks than buying and using the original version, do the simplest thing—it is Arch!\n\n"
    },
    {
      "title": "Package naming",
      "level": 2,
      "content": "Before naming a package, search the AUR for existing packages of software that you are packaging. Try to use established naming conventions, e.g. do not name your package gish-hb if there are existing packages called aquaria-hib, crayonphysicsdeluxe-hib and uplink-hib. If you are certain there will never be a source-based package, you can omit the suffix -bin. Otherwise, always use this suffix. A user submitting a source-based package of the software would have to ask the maintainer of your package (or, in the worst case, a Package maintainer) to orphan the existing package so that their source-based package could be submitted, and both the original binary package and the new source-based package would end up having their respective PKGBUILDs cluttered with additional replaces and conflicts entries.\n\n"
    },
    {
      "title": "File placement",
      "level": 2,
      "content": "Again, analyze existing packages (if present) and decide whether or not you want to conflict with them. Do not place things under /opt unless you want to use some ugly hacks like giving ownership root:games to the package directory (so users in group games running the game can write files in the game's own folder).\n\n"
    },
    {
      "title": "Missing files",
      "level": 2,
      "content": "For most commercial games there is no way to (legally) download game files, which is the preferable way to get them for normal packages. Even when it is possible to download files after providing a password (like with all Humble Indie Bundle games) asking user for this password and downloading somewhere in build function is not recommended for a variety of reasons (for example, the user may have no Internet access but have all files downloaded and stored locally).\n\nThe subsections below provide recommendations for a few situations you may encounter.\n\n"
    },
    {
      "title": "Files can only be obtained in a distributed archive/installer",
      "level": 3,
      "content": "The software is only available via that archive/installer file, which must be obtained in order to get the missing files.\n\nAdd the required archive/installer to the source array, renaming the source filename so the source's link in the AUR web interface looks different from names of files included in the source tarball:\n\n```\nsources=(... \"originalname::local://originalname\")\n```\n\nAlso add a pinned comment like the one below to the package page in the AUR, and explain the details in the PKGBUILD:\n\n```\nNeed archive/installer to work.\n```\n\n"
    },
    {
      "title": "Scheme to choose",
      "level": 4,
      "content": "In case you use the local:// scheme in a source array, makepkg behaves as though no scheme were specified, and the file must be manually placed in the same directory as the PKGBUILD.\n\nIn case you use the file:// scheme, you can additionally specify DLAGENTS for the file protocol, so it may be obtained in a special way. See examples below.\n\nHowever, there are still no clear rules which of these schemes you should use.\n\n"
    },
    {
      "title": "Files can only be obtained in an distributed compact-disk or other type of optical disk media",
      "level": 3,
      "content": "The software is only available via an optical disk media (e.g. CD, DVD, Bluray etc.), which must be inserted into the optical disk drive in order get the missing files.\n\nAdd an installer script and an .install file to the package contents.\n\n"
    },
    {
      "title": "Files can be obtained from several ways",
      "level": 3,
      "content": "Copying files from disk, downloading from Net or getting from archive during the build phase may look like a good idea but it is not recommended because it limits the user's possibilities and makes package installation interactive (which is generally discouraged and just annoying). Again, a good installer script and .install file can work instead.\n\nFew examples of various strategies for obtaining files required for package:\n\n- worldofgooAUR – dependency on user-provided file\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n"
    },
    {
      "title": "Custom DLAGENTS",
      "level": 3,
      "content": "Some software authors aggressively protect their software from automatic downloading: ban certain \"User-Agent\" strings, create temporary links to files etc. You can still conveniently download these files by using DLAGENTS variable in the PKGBUILD (see makepkg.conf(5)). This is used by some packages in official repositories, for example in previous version of ttf-baekmuk.\n\nPlease pay attention, if you want to have a customized user-agent string, if the latter contains spaces, parentheses, or slashes in it (or actually anything that can break parsing), this will not work. There is no workaround, this is the nature of arrays in bash and the way DLAGENTS was designed to be consumed in makepkg. The following example will thus not work:\n\n```\nDLAGENTS=(\"http::/usr/bin/curl -A 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)' -fLC - --retry 3 --retry-delay 3 -o %o %u\")\n```\n\nShorten it to the following which is working:\n\n```\nDLAGENTS=(\"http::/usr/bin/curl -A 'Mozilla' -fLC - --retry 3 --retry-delay 3 -o %o %u\")\n```\n\nAnd the following allows to extract temporary link to file from download page:\n\n```\nDLAGENTS=(\"http::/usr/bin/wget -r -np -nd -H %u\")\n```\n\nIn order to download temporary links to files or get past an interactive download, it is possible to analyze the HTTP request used to create the final download link, and then create a DLAGENTS that emulates this using curl. See for example decklink-sdkAUR or jlink-software-and-documentationAUR.\n\nAlternatively, the DLAGENTS can be used to provide a more informative error message to the user when a file is missing. See for example ttf-ms-win10AUR.\n\n"
    },
    {
      "title": "Unpacking",
      "level": 3,
      "content": "Many proprietary programs are shipped in nasty installers which sometimes do not even run in Wine. The following tools may be of some help:\n\n- libarchive contains bsdtar, which can extract .iso images and .AppImage files (which are actually hybrid self-executable iso9660). It also provides bsdunzip which can be used in place of unzip. libarchive is required by pacman and so it is part of a base install.\n- unzip and unrar unpack executable SFX archives, based on this formats\n- cabextract can unpack most .cab files (including ones with .exe extension)\n- unshield can extract CAB files from InstallShield installers\n- 7zip unpacks not only many archive formats but also NSIS-based .exe installers it even can extract single sections from common PE (.exe & .dll) files!\n- upx is sometimes used to compress above-listed executables and can be used for decompressing them as well\n- innoextract can unpack .exe installers created with Inno Setup (used for example by GOG.com games)\n\n- libarchive is required by pacman and so it is part of a base install.\n\n- it even can extract single sections from common PE (.exe & .dll) files!\n\nIn order to determine exact type of file run file file_of_unknown_type.\n\n"
    },
    {
      "title": "Getting icons for .desktop files",
      "level": 3,
      "content": "Proprietary software often have no separate icon files, so there is nothing to use in .desktop file creation. Fortunately, .ico files can be easily extracted from executables using programs from the icoutils package. You can even do it on the fly during the build phase, for example:\n\n```\n$ wrestool -x --output=icon.ico -t14 executable.exe\n```\n\n"
    },
    {
      "title": "Auto-bumping your pkgver",
      "level": 3,
      "content": "Non-free software vendors often don’t include a version number in their download source URL:\n\n```\nsource=('https://downloads.example.com/NonFreePackageWithPoorFileName.exe')\n```\n\nThat will likely cause the release upstream package to change without notice, which is an issue for packaging. Just like in VCS packages, you may want to auto-bump your pkgver to handle that.\n\n"
    },
    {
      "title": "From the installer package",
      "level": 4,
      "content": "For example, some .exe installers have the Product Version field set in their PE. The peres command from the pevAUR package may help you extract and use that value to auto-bump your pkgver:\n\n```\npkgver=VERSION\nmakedepends=('pev')\n\npkgver() {\n  peres -v -f csv \"${srcdir}/NonFreePackageWithPoorFileName.exe\" \\\n    | awk -F , '/^Product Version,/ { print $2 }'\n}\n```\n\n"
    },
    {
      "title": "From the main executable",
      "level": 4,
      "content": "Sometimes the .exe installer doesn’t carry a meaningful value for Product Version but the main executable does. In that case, you can use the prepare step to extract the nested main executable (see Unpacking for details) and then auto-bump the pkgver:\n\nFor example:\n\n```\npkgver=VERSION\nmakedepends=('p7zip' 'pev')\n\nprepare() {\n  mkdir -p \"${srcdir}/${pkgname}-unpacked\"\n  7z x -o\"${srcdir}/${pkgname}-unpacked\" \"${srcdir}/NonFreePackageWithPoorFileName.exe\"\n}\n\npkgver() {\n  peres -v -f csv \"${srcdir}/${pkgname}-unpacked/NonFreeApp.exe\" \\\n    | awk -F , '/^Product Version,/ { print $2 }'\n}\n```\n\n"
    },
    {
      "title": "From a Debian (.deb) file",
      "level": 4,
      "content": "Sometimes a .deb file doesn’t have a version number in its name but in its control file.\n\nYou can use dpkg-deb to extract the version directly from the control file inside the .deb package:\n\n```\npkgver=VERSION\nmakedepends=('dpkg')\nsource=('https://example.com/vendor/nonfree-app-latest.deb')\n\npkgver() {\n  # shellcheck disable=SC2016\n  dpkg-deb --show --showformat='${Version}' nonfree-app-latest.deb | tr - .\n}\n```\n\n"
    },
    {
      "title": "Replacing bundled runtimes",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nSome non-free applications bundle pre-built open source runtimes. However, there are advantages in replacing them.\n\nYou can use pacman -F to look for packages that provide the corresponding unbundled runtime. To replace the bundled libraries, try replacing them with symbolic links or just removing them from your package.\n\n"
    },
    {
      "title": "Security considerations",
      "level": 4,
      "content": "Vendored runtimes are sometimes built with insecure flags. If your package must use vendored libraries or executables, consider scanning them for insecure RPATH entries. To remove insecure entries, use patchelf --remove-rpath /path/to/binary.\n\n"
    },
    {
      "title": "Plugin interoperability",
      "level": 4,
      "content": "Some non-free Qt applications lack important plugins such as qt5-wayland or fcitx5-qt5. To make an application work with those system-provided packages, you might want to remove its bundled Qt runtime altogether, because mixing different Qt versions is impossible.\n\n"
    },
    {
      "title": "Disk space",
      "level": 4,
      "content": "As an added benefit, replacing bundled libraries with system-provided ones saves disk space.\n\n"
    }
  ]
}