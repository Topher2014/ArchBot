{
  "title": "Namcap",
  "url": "https://wiki.archlinux.org/title/Namcap",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Creating packages\n- pacman\n\nNamcap is an Arch Linux tool to check binary packages and source PKGBUILDs for common packaging mistakes.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the namcap package.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "To run namcap on a file, where filename is PKGBUILD or the name of a package binary package_name.tar.zst:\n\n```\n$ namcap filename\n```\n\nIf you want to see extra informational messages, then invoke namcap with the --info (-i) flag:\n\n```\n$ namcap --info filename\n```\n\nNamcap uses a system of tags to classify the output. Tags are of three types — errors (denoted by E), warnings (denoted by W) and informational (denoted by I). An error is important and should be fixed immediately; mostly they relate to insufficient security, missing licenses or permission problems.\n\nNormally namcap prints a human-readable explanation (sometimes with suggestions on how to fix the problem). If you want output which can be easily parsed by a program, then pass the --machine-readable (-m) flag to namcap.\n\nThe tag file /usr/share/namcap/namcap-tags (online source) consists of lines specifying the human-readable form of the hyphenated tags used in the namcap code. A line beginning with a # is treated as a comment:\n\n```\n# The comment\nmachine-parsable-tag %s :: The human-readable description for the tag %s\n```\n\n- :: (double colon) separates the hyphenated machine-readable tag from the human-readable description.\n- %s is a format specifier, see #Creating a module for more information.\n\nSee namcap(1), README and NEWS for more information.\n\n"
    },
    {
      "title": "Creating a module",
      "level": 2,
      "content": "The main namcap program namcap.py takes as parameters the filename of a package or a PKGBUILD and makes a pkginfo object, which it passes to a list of rules defined in __tarball__ and __pkgbuild__. Once your module is finalized, remember to add it to the appropriate array:\n\n- __tarball__ defines the rules which process binary packages,\n- __pkgbuild__ defines the rules which process PKGBUILDs.\n\nA sample namcap module is like this:\n\n```\nnamcap/url.py\n```\n\n```\nimport pacman\n\nclass package:\n    def short_name(self):\n        return \"url\"\n\n    def long_name(self):\n        return \"Verifies url is included in a PKGBUILD\"\n\n    def prereq(self):\n        return \"\"\n\n    def analyze(self, pkginfo, tar):\n        ret = [[], [], []]\n        if not hasattr(pkginfo, 'url'):\n            ret[0].append((\"missing-url\", ()))\n        return ret\n\n    def type(self):\n        return \"pkgbuild\"\n```\n\nEach namcap module must have the following methods:\n\n- short_name(self) — returns a string containing a short name of the module. Usually, this is the same as the basename(1) of the module file.\n\n- long_name(self) — returns a string containing a concise description of the module. This description is used when listing all the rules using namcap --rules=rule_list.\n\n- prereq(self) — returns a string containing the prerequisites needed for the module to operate properly. Usually empty string (\"\") for modules processing PKGBUILDs and \"tar\" for modules processing package files. \"extract\" should be specified if the package contents should be extracted to a temporary directory before further processing.\n\n- analyze(self, pkginfo, tar) — should return a list comprising in turn of three lists: error, warning and information tags respectively. Each member of these tag lists should be a tuple consisting of two components: the short — hyphenated — form of the tag with the appropriate format specifiers (like %s) and the parameters.\n\n- type(self) — returns \"pkgbuild\" for a module processing PKGBUILDs, and \"tarball\" for a module processing a binary package file.\n\n"
    }
  ]
}