{
  "title": "Diretrizes de pacotes MinGW",
  "url": "https://wiki.archlinux.org/title/Diretrizes_de_pacotes_MinGW",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Fonte – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust – Shell – VCS – Web – Wine\n\nEsta página explica como escrever PKGBUILDs para software em execução no Windows usando o GCC. Existem duas opções para criar software para o Windows no Linux:\n\n- mingw-w64: fornece cadeia de ferramentas de 32 e 64 bits com suporte a secure crt, Vista+ API, DDK (ReactOS) e DirectX (WINE). Para uma lista completa dos recursos e diferenças suportados com o antigo MinGW.org, veja aqui. Disponível em mingw-w64-gcc.\n- MinGW: fornece cadeia de ferramentas de 32 bits com suporte limitado a DirectX. Ele também sofre com a quebra de longa duração na implementação do armazenamento local de encadeamento e no suporte à biblioteca de ponto flutuante. Foi removido dos repositórios oficiais e do AUR.\n\n"
    },
    {
      "title": "Nomenclatura de pacote",
      "level": 2,
      "content": "Um pacote para mingw-w64 deve ser nomeado mingw-w64-pkgname. Se uma variante estática do pacote está sendo compilado, acrescente o sufixo de nome de pacote com -static (veja abaixo para os casos nos quais isso é necessário).\n\n"
    },
    {
      "title": "Empacotamento",
      "level": 2,
      "content": "O empacotamento para pacotes de plataforma cruzada pode ser bastante complicada, pois há muitos sistemas de construção diferentes e peculiaridades de baixo nível. Tome nota das seguintes coisas:\n\n- sempre adicione mingw-w64-crt ao depends, a menos que ele dependa de outro pacote que implicitamente depende dele\n- sempre adicione mingw-w64-gcc ao makedepends, a menos que esteja usando mingw-w64-configureAUR ou mingw-w64-cmakeAUR\n- sempre adicione !strip, staticlibs e !buildflags ao options\n- sempre use o pkgdesc original e adicione (mingw-w64) ao fim do pkgdesc\n- sempre use e siga o pkgver original do pacote oficial\n- sempre compile as versões 32 bit e 64 bit das bibliotecas\n- sempre coloque todas as coisas sob o prefixo /usr/i686-w64-mingw32 e /usr/x86_64-w64-mingw32\n- sempre use any como a arquitetura (exceto que o pacote contém executáveis que devem ser executados no sistema de compilação)\n- sempre compile os binários compartilhados e estáticos, a menos que eles conflitem\n- considere a remoção de documentação desnecessária (rm -r $pkgdir/usr/i686-w64-mingw32/share/{doc,info,man}, rm -r $pkgdir/usr/x86_64-w64-mingw32/share/{doc,info,man})\n- considere usar mingw-w64-configureAUR para compilação com scripts de configuração\n- considere usar mingw-w64-cmakeAUR para compilação com CMake\n- considere usar mingw-w64-qt5-baseAUR ou mingw-w64-qt4AUR[link quebrado: package not found] para compilação com QMake\n- considere usar opções de compilação -D_FORTIFY_SOURCE=2 -O2 -pipe -fno-plt -fexceptions --param=ssp-buffer-size=4 (geralmente nomeadas com CFLAGS, CXXFLAGS) quando nenhum sistema de compilação adequado foi fornecido\n- considere remover símbolos explicitamente com ${_arch}-strip em loop for package() como demonstrado nos exemplos de PKGBUILD abaixo. considere usar o comando find para interagir com $pkgdir já que todas DLLs, bibliotecas estáticas ou executáveis podem residir em localizações apropriadas. se o binário é uma DLL, use ${_arch}-strip --strip-unneeded *.dll se o binário é uma biblioteca estática, use ${_arch}-strip -g *.a\n- se um pacote é modular (requer certas dependências de compilação, mas tais dependências são opcionais para o usuário final) adicione essas ao makedepends e optdepends. Certifique-se de subtrai-los do depends se estiver atualizando um pacote existente. Exemplo disto em uso: mingw-w64-rubyAUR[link quebrado: package not found], mingw-w64-allegroAUR[link quebrado: package not found]\n- se um pacote instala um script $pkgdir/usr/${_arch}/bin/*-config, crie um link simbólico para $pkgdir/usr/bin/${_arch}-*-config\n- se um pacote usa autoconf, defina explicitamente --build=\"$CHOST\" no configure para contornar o bug #108405 do autoconf ou usar mingw-w64-configureAUR\n\n- considere usar o comando find para interagir com $pkgdir já que todas DLLs, bibliotecas estáticas ou executáveis podem residir em localizações apropriadas. se o binário é uma DLL, use ${_arch}-strip --strip-unneeded *.dll se o binário é uma biblioteca estática, use ${_arch}-strip -g *.a\n\n- se o binário é uma DLL, use ${_arch}-strip --strip-unneeded *.dll\n- se o binário é uma biblioteca estática, use ${_arch}-strip -g *.a\n\nComo mencionado acima, os arquivos devem ser todos instalados em /usr/i686-w64-mingw32 e /usr/x86_64-w64-mingw32. Especificamente, todas as DLLs devem ser colocadas em /usr/*-w64-mingw32/bin, pois são bibliotecas dinâmicas necessárias no tempo de execução. Seus arquivos .dll.a correspondentes devem ir para /usr/*-w64-mingw32/lib. Por favor, exclua qualquer documentação desnecessária e talvez outros arquivos de /usr/share. Os pacotes de compilações cruzadas não são destinados ao usuário, mas apenas ao compilador e à distribuição binária, e, como tal, você deve tentar torná-los o menor possível.\n\nSempre tente combinar o pkgver em seus pacotes mingw-w64 com o pkgver dos pacotes comuns correspondentes nas repositórios oficiais do Arch Linux (e não nos repos de teste). Isso garante que o software de compilação cruzada funcione exatamente da mesma maneira no Windows, sem nenhum erro inesperado. Se os pacotes no Arch estão desatualizados, geralmente há uma boa razão e você ainda deve seguir a versão do Arch em vez de usar o release upstream mais recente. Se o pacote nativo correspondente estiver no AUR, não será necessário seguir esta política de versão, pois muitos pacotes do AUR são muitas vezes órfãos ou não são mantidos.\n\n"
    },
    {
      "title": "Exemplos",
      "level": 2,
      "content": "Os exemplos a seguir tentarão cobrir algumas das convenções e sistemas de compilação mais comuns.\n\n"
    },
    {
      "title": "Autotools",
      "level": 3,
      "content": "```\npkgname=mingw-w64-foo\npkgver=1.0\npkgrel=1\npkgdesc=\"Foo bar (mingw-w64)\"\narch=('any')\nurl=\"http://www.foo.bar\"\nlicense=('GPL')\nmakedepends=('mingw-w64-configure')\ndepends=('mingw-w64-crt')\noptions=('!strip' '!buildflags' 'staticlibs')\nsource=(\"http://www.foo.bar/foobar.tar.gz\")\nsha256sums=('8f32d4617390d1c2d16f26a27ab60d97807b35440d45891fa340fc2648b04406')\n\n_architectures=\"i686-w64-mingw32 x86_64-w64-mingw32\"\n\nbuild() {\n  cd \"${srcdir}/foo-$pkgver/\"\n  for _arch in ${_architectures}; do\n    mkdir -p build-${_arch} && pushd build-${_arch}\n    ${_arch}-configure ..\n    make\n    popd\n  done\n}\n\npackage() {\n  for _arch in ${_architectures}; do\n    cd \"${srcdir}/foo-$pkgver/build-${_arch}\"\n    make DESTDIR=\"${pkgdir}\" install\n    ${_arch}-strip --strip-unneeded \"$pkgdir\"/usr/${_arch}/bin/*.dll\n    ${_arch}-strip -g \"$pkgdir\"/usr/${_arch}/lib/*.a\n  done\n}\n```\n\n"
    },
    {
      "title": "CMake",
      "level": 3,
      "content": "```\npkgname=mingw-w64-foo\npkgver=1.0\npkgrel=1\npkgdesc=\"Foo bar (mingw-w64)\"\narch=('any')\nurl=\"http://www.foo.bar\"\nlicense=('GPL')\nmakedepends=('mingw-w64-cmake')\ndepends=('mingw-w64-crt')\noptions=('!strip' '!buildflags' 'staticlibs')\nsource=(\"http://www.foo.bar/foobar.tar.gz\")\nsha256sums=('8f32d4617390d1c2d16f26a27ab60d97807b35440d45891fa340fc2648b04406')\n_architectures=\"i686-w64-mingw32 x86_64-w64-mingw32\"\n\nbuild() { \n  cd \"$srcdir/foo-$pkgver/\"\n  for _arch in ${_architectures}; do\n    mkdir -p build-${_arch} && pushd build-${_arch}\n    ${_arch}-cmake ..\n    make\n    popd\n  done\n}\n\npackage() {\n  for _arch in ${_architectures}; do\n    cd \"${srcdir}/foo-$pkgver/build-${_arch}\"\n    make DESTDIR=\"${pkgdir}\" install\n    ${_arch}-strip --strip-unneeded \"$pkgdir\"/usr/${_arch}/bin/*.dll\n    ${_arch}-strip -g \"$pkgdir\"/usr/${_arch}/lib/*.a\n  done\n}\n```\n\n"
    }
  ]
}