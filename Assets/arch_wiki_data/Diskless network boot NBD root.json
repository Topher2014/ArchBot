{
  "title": "Diskless network boot NBD root",
  "url": "https://wiki.archlinux.org/title/Diskless_network_boot_NBD_root",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- NFS\n- NFS Troubleshooting\n- PXE\n- Mkinitcpio#Using net\n- iSCSI Boot\n\nFrom Wikipedia:Diskless node:\n\n"
    },
    {
      "title": "Server configuration",
      "level": 2,
      "content": "First of all, we must install the following components:\n\n- A DHCP server to assign IP addresses to our diskless nodes.\n- A TFTP server to transfer the boot image (a requirement of all PXE option roms).\n- A form of network storage (NFS, Samba or NBD) to export the Arch installation to the diskless node.\n\n- dnsmasq is capable of simultaneously acting as both DHCP and TFTP server. For more information, see the dnsmasq article.\n- You can also boot Arch Linux without using PXE at all. See the SKUF item below.\n\n"
    },
    {
      "title": "DHCP",
      "level": 3,
      "content": "Install ISC dhcp and configure it:\n\n```\n/etc/dhcpd.conf\n```\n\n```\nallow booting;\nallow bootp;\n\nauthoritative;\n\noption domain-name-servers 10.0.0.1;\n\noption architecture code 93 = unsigned integer 16;\n\ngroup {\n    next-server 10.0.0.1;\n\n    if option architecture = 00:07 {\n        filename \"/grub/x86_64-efi/core.efi\";\n    } else {\n        filename \"/grub/i386-pc/core.0\";\n    }\n\n    subnet 10.0.0.0 netmask 255.255.255.0 {\n        option routers 10.0.0.1;\n        range 10.0.0.128 10.0.0.254;\n    }\n}\n```\n\nRFC:4578 defines the \"Client System Architecture Type\" dhcp option. In the above configuration, if the PXE client requests an x86_64-efi binary (type 0x7), we appropriately give them one, otherwise falling back to the legacy binary. This allows both UEFI and legacy BIOS clients to boot simultaneously on the same network segment.\n\nStart ISC DHCP systemd service.\n\n"
    },
    {
      "title": "TFTP",
      "level": 3,
      "content": "The TFTP server will be used to transfer the boot loader, kernel, and initramfs to the client.\n\nSet the TFTP root to /srv/arch/boot. See TFTP for installation and configuration.\n\n"
    },
    {
      "title": "Network storage",
      "level": 3,
      "content": "The primary difference between using NFS and NBD is while with both you can in fact have multiple clients using the same installation, with NBD (by the nature of manipulating a filesystem directly) you will need to use the copyonwrite mode to do so, which ends up discarding all writes on client disconnect. In some situations however, this might be highly desirable.\n\n"
    },
    {
      "title": "NFS",
      "level": 4,
      "content": "Install nfs-utils on the server.\n\nYou will need to add the root of your Arch installation to your NFS exports:\n\n```\n/etc/exports\n```\n\n```\n/srv       *(rw,fsid=0,no_root_squash,no_subtree_check)\n/srv/arch  *(rw,no_root_squash,no_subtree_check)\n```\n\nNext, start NFS services: nfs-idmapd nfs-mountd.\n\n"
    },
    {
      "title": "NBD",
      "level": 4,
      "content": "Install nbd and configure it.\n\n```\n/etc/nbd-server/config\n```\n\n```\n[generic]\n    user = nbd\n    group = nbd\n[arch]\n    exportname = /srv/arch.img\n    copyonwrite = false\n```\n\nStart nbd.service.\n\n"
    },
    {
      "title": "SKUF",
      "level": 4,
      "content": "You can boot Arch Linux using the SKUF Network Boot System project, where the root of the file system will be a sparse file located on Samba server.\n\nTo get started, install samba and create a configuration file:\n\n```\n/etc/samba/smb.conf\n```\n\n```\n[global]\n\tworkgroup = WORKGROUP\n\tsecurity = user\n\n[arch]\n\tpath = /srv/samba\n\tvalid users = @skuf\n\twrite list = @skuf\n\tguest ok = no\n\tread only = no\n\twriteable = yes\n\tbrowseable = yes\n```\n\nStart smb systemd service\n\nThen, create a skuf group and users who will be members of it and through whom SAMBA mounting on the client machine will happen.\n\n```\n# groupadd skuf\n# useradd test -g skuf\n# smbpasswd -a test\n```\n\n"
    },
    {
      "title": "Client installation",
      "level": 2,
      "content": "Next we will create a full Arch Linux installation in a subdirectory on the server. During boot, the diskless client will get an IP address from the DHCP server, then boot from the host using PXE and mount this installation as its root.\n\n"
    },
    {
      "title": "Directory setup",
      "level": 3,
      "content": "Create a sparse file of at least 2 gibibytes, and create a btrfs filesystem on it (you can of course also use a real block device or LVM if you want).\n\n```\n# truncate -s 2G /srv/arch.img\n# mkfs.btrfs /srv/arch.img\n# export root=/srv/arch\n# mount --mkdir -o loop,compress=lzo /srv/arch.img \"$root\"\n```\n\n"
    },
    {
      "title": "Bootstrapping installation",
      "level": 3,
      "content": "Install devtools and arch-install-scripts, and run pacstrap to install the essential packages for the client:\n\n```\n# pacstrap -K \"$root\" base linux linux-firmware mkinitcpio-nfs-utils nfs-utils\n```\n\nNow the initramfs needs to be constructed.\n\n"
    },
    {
      "title": "NFS",
      "level": 4,
      "content": "Trivial modifications to the net hook are required in order for NFSv4 mounting to work (not supported by nfsmount â€“ the default for the net hook).\n\n```\n# sed s/nfsmount/mount.nfs4/ \"$root/usr/lib/initcpio/hooks/net\" > \"$root/usr/lib/initcpio/hooks/netnfs4\"\n# cp $root/usr/lib/initcpio/install/net{,nfs4}\n```\n\nThe copy of net is unfortunately needed so it does not get overwritten when mkinitcpio-nfs-utils is updated on the client installation.\n\nEdit $root/etc/mkinitcpio.conf and add nfsv4 to MODULES, netnfs4 to HOOKS, and /usr/bin/mount.nfs4 to BINARIES.\n\nNext, we chroot our installation and run mkinitcpio:\n\n```\n# arch-chroot \"$root\" mkinitcpio -p linux\n```\n\n"
    },
    {
      "title": "NBD",
      "level": 4,
      "content": "The mkinitcpio-nbdAUR package needs to be installed on the client. Build it with makepkg and install it:\n\n```\n# pacman --root \"$root\" --dbpath \"$root/var/lib/pacman\" -U mkinitcpio-nbd-0.4-1-any.pkg.tar.xz\n```\n\nYou will then need to append nbd to your HOOKS array after net; net will configure your networking for you, but not attempt a NFS mount if nfsroot is not specified in the kernel line.\n\n"
    },
    {
      "title": "SKUF",
      "level": 4,
      "content": "To install Arch Linux on sparse file using SKUF Network Boot System, clone the git repository:\n\n```\n$ git clone https://github.com/BiteDasher/skuf.git\n$ cd skuf\n$ ./switch-tag latest\n```\n\nThen, build the skuf package and ISO image which will later be used as a \"kickstart\" to start the main system using kexec\n\nFirst of all, you need to tune the method of encrypting your passwords for SAMBA (see [1] for more details):\n\n```\ntune.crypt\n```\n\n```\nA B\nX Y\nI O\n```\n\n```\ntune.password\n```\n\n```\n1234 Test password!\n```\n\nSet up defaults:\n\n```\ndefaults\n```\n\n```\nSAMBA_USERNAME=\"testuser\"\nSAMBA_PASSWORD=\"pa33w0rd\"\nSAMBA_ADDRESS=\"192.168.0.5\"\nSAMBA_PORT=\"445\"\nSAMBA_VERSION=\"3.0\"\n...\n```\n\nInstall required packages:\n\n```\n# ./install_deps.sh\n```\n\nAnd finally, build skuf package:\n\n```\n$ ./tune_crypt.sh\n$ ./tune_password.sh\n$ ./setup_defaults.sh\n$ ./build_rootfs_tar.sh\n$ ./build_package.sh\n```\n\nISO image:\n\n```\n# ./setup_repo.sh\n# ./build_iso.sh\n```\n\nAnd sparse file with Arch Linux:\n\n```\n# ./create_image.sh -s SIZE_IN_GIGABYTES additional_packages\n```\n\nThen, move arch.ext4 in /srv/samba.\n\n"
    },
    {
      "title": "Client configuration",
      "level": 2,
      "content": "In addition to the setup mentioned here, you should also set up your hostname, timezone, locale, and keymap, and follow any other relevant parts of the Installation guide.\n\n"
    },
    {
      "title": "GRUB",
      "level": 4,
      "content": "Note: **This article or section is a candidate for merging with GRUB.** This article or section is a candidate for merging with GRUB.\n\nThis article or section is a candidate for merging with GRUB.\n\nThough poorly documented, GRUB supports being loaded via PXE.\n\n```\n# pacman --root \"$root\" --dbpath \"$root/var/lib/pacman\" -S grub\n```\n\nCreate a grub prefix on the target installation for both architectures using grub-mknetdir.\n\n```\n# arch-chroot \"$root\" grub-mknetdir --net-directory=/boot --subdir=grub\n```\n\nLuckily for us, grub-mknetdir creates prefixes for all currently compiled/installed targets, and the grub maintainers were nice enough to give us both in the same package, thus grub-mknetdir only needs to be run once.\n\nNow we create a trivial GRUB configuration:\n\n```\n# vim \"$root/boot/grub/grub.cfg\"\n```\n\n```\nmenuentry \"Arch Linux\" {\n    linux /vmlinuz-linux quiet add_efi_memmap ip=:::::eth0:dhcp nfsroot=10.0.0.1:/arch\n    initrd /initramfs-linux.img\n}\n\nmenuentry \"Arch Linux (NBD)\" {\n    linux /vmlinuz-linux quiet add_efi_memmap ip=:::::eth0:dhcp nbd_host=10.0.0.1 nbd_name=arch root=/dev/nbd0\n    initrd /initramfs-linux.img\n}\n```\n\nGRUB will set root=(tftp,10.0.0.1) automatically, so that the kernel and initramfs are transferred via TFTP without any additional configuration, though you might want to set it explicitly if you have any other non-tftp menuentries.\n\n- All GRUB files and initcpio files must be available through TFTP. For example, for an NBD install with TFTP root set to /srv/tftp, /srv/tftp/grub/x86_64-efi/core.efi, /srv/tftp/vmlinuz-linux must be present to boot successfully. You may copy all the /boot files inside the image to TFTP server's root.\n- You may generate grub config by grub-mkconfig to ensure video settings are set correctly. However, it is needed to edit boot.cfg afterwards, to remove search --no-floppy ... and ensure linux initrd options (paths, NBD settings, NFS settings) are set correctly.\n- Modify your kernel line as-necessary, refer to PXELINUX for NBD-related options.\n\n"
    },
    {
      "title": "PXELINUX",
      "level": 4,
      "content": "PXELINUX is provided by syslinux, see PXELINUX for details.\n\n"
    },
    {
      "title": "NBD root",
      "level": 4,
      "content": "In late boot, you will want to switch your root filesystem mount to both rw, and enable compress=lzo, for much improved disk performance in comparison to NFS.\n\n```\n# vim \"$root/etc/fstab\"\n```\n\n```\n/dev/nbd0  /  btrfs  rw,noatime,compress=lzo  0 0\n```\n\n"
    },
    {
      "title": "Program state directories",
      "level": 4,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nYou could mount /var/log, for example, as tmpfs so that logs from multiple hosts do not mix unpredictably, and do the same with /var/spool/cups, so the 20 instances of cups using the same spool do not fight with each other and make 1,498 print jobs and eat an entire ream of paper (or worse: toner cartridge) overnight.\n\n```\n# vim \"$root/etc/fstab\"\n```\n\n```\ntmpfs   /var/log        tmpfs     nodev,nosuid    0 0\ntmpfs   /var/spool/cups tmpfs     nodev,nosuid    0 0\n```\n\nIt would be best to configure software that has some sort of state/database to use unique state/database storage directories for each host. If you wanted to run puppet, for example, you could simply use the %H specifier in the puppet unit file:\n\n```\n# vim \"$root/etc/systemd/system/puppetagent.service\"\n```\n\n```\n[Unit]\nDescription=Puppet agent\nWants=basic.target\nAfter=basic.target network.target\n\n[Service]\nType=forking\nPIDFile=/run/puppet/agent.pid\nExecStartPre=/usr/bin/install -d -o puppet -m 755 /run/puppet\nExecStart=/usr/bin/puppet agent --vardir=/var/lib/puppet-%H --ssldir=/etc/puppet/ssl-%H\n\n[Install]\nWantedBy=multi-user.target\n```\n\nPuppet-agent creates vardir and ssldir if they do not exist.\n\nIf neither of these approaches are appropriate, the last sane option would be to create a systemd.generator(7) that creates a mount unit specific to the current host (specifiers are not allowed in mount units, unfortunately).\n\n"
    },
    {
      "title": "NBD",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nIf you are using NBD, you will need to umount the arch.img before/while you boot your client.\n\nThis makes things particularly interesting when it comes to kernel updates. You cannot have your client filesystem mounted while you are booting a client, but that also means you need to use a kernel separate from your client filesystem in order to build it.\n\nYou will need to first copy $root/boot from the client installation to your tftp root (i.e. /srv/boot).\n\n```\n# cp -r \"$root/boot\" /srv/boot\n```\n\nYou will then need to umount $root before you start the client.\n\n```\n# umount \"$root\"\n```\n\n"
    },
    {
      "title": "SKUF",
      "level": 3,
      "content": "Write skuflinux-smth.iso to your USB drive, plug it in client computer and select in UEFI/BIOS settings as a boot device.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- kernel.org: Mounting the root filesystem via NFS (nfsroot)\n- syslinux.org: pxelinux FAQ\n\n"
    }
  ]
}