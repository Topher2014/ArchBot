{
  "title": "SELinux",
  "url": "https://wiki.archlinux.org/title/SELinux",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Security\n- AppArmor\n- TOMOYO Linux\n\nSecurity-Enhanced Linux (SELinux) is a Linux feature that provides a variety of security policies, including U.S. Department of Defense style Mandatory Access Control (MAC), through the use of Linux Security Modules (LSM) in the Linux kernel. It is not a Linux distribution, but rather a set of modifications that can be applied to Unix-like operating systems, such as Linux and BSD.\n\nRunning SELinux under a Linux distribution requires three things: An SELinux enabled kernel, SELinux Userspace tools and libraries, and SELinux Policies (mostly based on the Reference Policy). Some common Linux programs will also need to be patched/compiled with SELinux features.\n\n"
    },
    {
      "title": "Current status in Arch Linux",
      "level": 2,
      "content": "SELinux is not officially supported (see [1][2]). The status of unofficial support is:\n\nTable content:\nName | Status | Available at\nSELinux enabled kernel | Implemented for all officially supported kernels | Available in official repositories since 4.18.8.\nSELinux Userspace tools and libraries | Implemented in AUR: https://aur.archlinux.org/packages/?O=0&K=selinux | Work is done at https://github.com/archlinuxhardened/selinux\nSELinux Policy | Work in progress, using Reference Policy as upstream | Upstream: https://github.com/SELinuxProject/refpolicy (since release 20170805 the policy has integrated support for systemd and single-/usr/bin directory)\n\nSummary of changes in AUR as compared to official core packages:\n\nTable content:\nName | Status and comments\nlinux, linux-lts, linux-zen, linux-hardened | Need to set the lsm= kernel parameter\ncoreutils | Need a rebuild with --with-selinux flag to link with libselinux\ncronie | Need a rebuild with --with-selinux flag\ndbus | Need a rebuild with --enable-libaudit and --enable-selinux flags\nfindutils | Need a rebuild with libselinux installed to enable SELinux-specific options\niproute2 | Need a rebuild with --with-selinux flag\nlogrotate | Need a rebuild with --with-selinux flag\nopenssh | Need a rebuild with --with-selinux flag\npam | Need a rebuild with --enable-selinux flag for Linux-PAM ; Need a patch for pam_unix2, which only removes a function already implemented in a recent versions of libselinux\npambase | Configuration changes to add pam_selinux.so to /etc/pam.d/system-login\npsmisc | Need a rebuild with --with-selinux flag\nshadow | Need a rebuild with --with-selinux flags\nsudo | Need a rebuild with --with-selinux flag\nsystemd | Need a rebuild with --enable-audit and --enable-selinux flags\nutil-linux | Need a rebuild with --with-selinux flag\n\nAll of the other SELinux-related packages may be included without changes nor risks.\n\n"
    },
    {
      "title": "Concepts: Mandatory Access Controls",
      "level": 2,
      "content": "Before you enable SELinux, it is worth understanding what it does. Simply and succinctly, SELinux enforces Mandatory Access Controls (MACs) on Linux. In contrast to SELinux, the traditional user/group/rwx permissions are a form of Discretionary Access Control (DAC). MACs are different from DACs because security policy and its execution are completely separated.\n\nAn example would be the use of the sudo command. When DACs are enforced, sudo allows temporary privilege escalation to root, giving the process so spawned unrestricted systemwide access. However, when using MACs, if the security administrator deems the process to have access only to a certain set of files, then no matter what the kind of privilege escalation used, unless the security policy itself is changed, the process will remain constrained to simply that set of files. So if sudo is tried on a machine with SELinux running in order for a process to gain access to files its policy does not allow, it will fail.\n\nAnother set of examples are the traditional (-rwxr-xr-x) type permissions given to files. When under DAC, these are user-modifiable. However, under MAC, a security administrator can choose to freeze the permissions of a certain file by which it would become impossible for any user to change these permissions until the policy regarding that file is changed.\n\nAs you may imagine, this is particularly useful for processes which have the potential to be compromised, i.e. web servers and the like. If DACs are used, then there is a particularly good chance of havoc being wreaked by a compromised program which has access to privilege escalation.\n\nFor further information, visit Wikipedia:Mandatory access control.\n\n"
    },
    {
      "title": "Package description",
      "level": 3,
      "content": "All SELinux related packages belong to the selinux group in the AUR. Before you manually install any of these, read #Installation to see recommended options for a comprehensive installation.\n\n"
    },
    {
      "title": "SELinux policy packages",
      "level": 4,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n"
    },
    {
      "title": "Installation",
      "level": 3,
      "content": "There are three methods to install the requisite SELinux packages.\n\n"
    },
    {
      "title": "Via binary package on GitHub",
      "level": 4,
      "content": "All packages are available from the selinux unofficial repository. the base package can be replaced with base-selinux during the arch-bootstrap stage of system installation.\n\n"
    },
    {
      "title": "Via build script from GitHub",
      "level": 4,
      "content": "This repository also contains a script named build_and_install_all.sh which builds and installs (or updates) all packages in the needed order. Here is an example of a way this script can be used in a user shell to install all packages (with downloading the GPG keys which are used to verify the source tarballs of the package):\n\n```\n$ git clone https://github.com/archlinuxhardened/selinux.git\n$ cd selinux\n$ ./recv_gpg_keys.sh\n$ ./build_and_install_all.sh\n```\n\nOf course, it is possible to modify the content of build_and_install_all.sh before running it, for example if you already have SELinux support in your kernel.\n\n"
    },
    {
      "title": "Via AUR",
      "level": 4,
      "content": "- First, install SELinux userspace tools and libraries, in this order (because of the dependencies): libsepolAUR, libselinuxAUR, checkpolicyAUR, secilcAUR, setoolsAUR, libsemanageAUR, semodule-utilsAUR, policycoreutilsAUR, selinux-pythonAUR (which depends on python-ipyAUR), mcstransAUR and restorecondAUR.\n- Then install pambase-selinuxAUR and pam-selinuxAUR and make sure you can login again after the installation completed, because files in /etc/pam.d/ got removed and created when pambase got replaced with pambase-selinuxAUR.\n- Next you can recompile some core packages by installing: coreutils-selinuxAUR, findutils-selinuxAUR, iproute2-selinuxAUR, logrotate-selinuxAUR, openssh-selinuxAUR, psmisc-selinuxAUR, shadow-selinuxAUR, cronie-selinuxAUR\n- Next, backup your /etc/sudoers file. Install sudo-selinuxAUR and restore your /etc/sudoers (it is overridden when this package is installed as a replacement of sudo).\n- Next come util-linux and systemd. Because of a cyclic makedepends between these two packages which will not be fixed (FS#39767), you need to build the source package systemd-selinuxAUR, install systemd-libs-selinuxAUR, build and install util-linux-selinuxAUR (with util-linux-libs-selinuxAUR) and rebuild and install systemd-selinuxAUR.\n- Next, install dbus-selinuxAUR.\n- Next, install selinux-alpm-hookAUR in order to run restorecon every time pacman installs a package.\n\nAfter all these steps, you can install a SELinux kernel (like linux) and a policy (like selinux-refpolicy-archAUR or selinux-refpolicy-gitAUR).\n\n"
    },
    {
      "title": "Enable SELinux LSM",
      "level": 3,
      "content": "To enable SELinux as default security model on every boot, set the following kernel parameter:\n\n```\nlsm=landlock,lockdown,yama,integrity,selinux,bpf\n```\n\n- Make sure that selinux is the first \"major\" module in the list.[3] Examples of valid values and their order can be found in security/Kconfig.\n- capability should be omitted from lsm= as it will always get included automatically.\n\n"
    },
    {
      "title": "Custom kernel",
      "level": 4,
      "content": "When compiling the kernel, it is required to set at least the following options:\n\n```\nCONFIG_SECURITY_SELINUX=y\nCONFIG_AUDIT=y\n```\n\nTo enable the SELinux Linux security model by default and omit the need to set kernel parameters, additionally set the CONFIG_LSM option and specify selinux as the first \"major\" module in the list:\n\n```\nCONFIG_LSM=\"landlock,lockdown,yama,integrity,selinux,bpf\"\n```\n\n"
    },
    {
      "title": "Checking PAM",
      "level": 3,
      "content": "A correctly set-up PAM is important to get the proper security context after login. Check for the presence of the following lines in /etc/pam.d/system-login:\n\n```\n# pam_selinux.so close should be the first session rule\nsession         required        pam_selinux.so close\n```\n\n```\n# pam_selinux.so open should only be followed by sessions to be executed in the user context\nsession         required        pam_selinux.so open\n```\n\n"
    },
    {
      "title": "Installing a policy",
      "level": 3,
      "content": "Policies are the mainstay of SELinux. They are what govern its behaviour. The only policy currently available in the AUR is the Reference Policy. In order to install it, you should use the source files, which may be got from the package selinux-refpolicy-srcAUR or by downloading the latest release on https://github.com/SELinuxProject/refpolicy/wiki/DownloadRelease#current-release. When using the AUR package, navigate to /etc/selinux/refpolicy/src/policy and run the following commands:\n\n```\n# make bare\n# make conf\n# make install\n```\n\nto install the reference policy as it is. Those who know how to write SELinux policies can tweak them to their heart's content before running the commands written above. The command takes a while to do its job and taxes one core of your system completely, so do not worry. Just sit back and let the command run for as long as it takes.\n\nTo load the reference policy run:\n\n```\n# make load\n```\n\nThen, make the file /etc/selinux/config with the following contents (Only works if you used the defaults as mentioned above. If you decided to change the name of the policy, you need to tweak the file):\n\n```\n/etc/selinux/config\n```\n\n```\n# This file controls the state of SELinux on the system.\n# SELINUX= can take one of these three values:\n#       enforcing - SELinux security policy is enforced.\n#                   Set this value once you know for sure that SELinux is configured the way you like it and that your system is ready for deployment\n#       permissive - SELinux prints warnings instead of enforcing.\n#                    Use this to customise your SELinux policies and booleans prior to deployment. Recommended during policy development.\n#       disabled - No SELinux policy is loaded.\n#                  This is not a recommended setting, for it may cause problems with file labelling\nSELINUX=permissive\n# SELINUXTYPE= takes the name of SELinux policy to\n# be used. Current options are:\n#       refpolicy (vanilla reference policy)\n#       <custompolicy> - Substitute <custompolicy> with the name of any custom policy you choose to load\nSELINUXTYPE=refpolicy\n```\n\nNow, you may reboot. After rebooting, run:\n\n```\n# restorecon -r /\n```\n\nto label your filesystem.\n\nNow, make a file requiredmod.te with the contents:\n\n```\nrequiredmod.te\n```\n\n```\nmodule requiredmod 1.0;\n\nrequire {\n        type devpts_t;\n        type kernel_t;\n        type device_t;\n        type var_run_t;\n        type udev_t;\n        type hugetlbfs_t;\n        type udev_tbl_t;\n        type tmpfs_t;\n        class sock_file write;\n        class unix_stream_socket { read write ioctl };\n        class capability2 block_suspend;\n        class dir { write add_name };\n        class filesystem associate;\n}\n\n#============= devpts_t ==============\nallow devpts_t device_t:filesystem associate;\n\n#============= hugetlbfs_t ==============\nallow hugetlbfs_t device_t:filesystem associate;\n\n#============= kernel_t ==============\nallow kernel_t self:capability2 block_suspend;\n\n#============= tmpfs_t ==============\nallow tmpfs_t device_t:filesystem associate;\n\n#============= udev_t ==============\nallow udev_t kernel_t:unix_stream_socket { read write ioctl };\nallow udev_t udev_tbl_t:dir { write add_name };\nallow udev_t var_run_t:sock_file write;\n```\n\nand run the following commands:\n\n```\n# checkmodule -m -o requiredmod.mod requiredmod.te\n# semodule_package -o requiredmod.pp -m requiredmod.mod\n# semodule -i requiredmod.pp\n```\n\nThis is required to remove a few messages from /var/log/audit/audit.log which are a nuisance to deal with in the reference policy. This is an ugly hack and it should be made very clear that the policy so installed simply patches the reference policy in order to hide the effects of incorrect labelling.\n\n"
    },
    {
      "title": "Testing in a Vagrant virtual machine",
      "level": 3,
      "content": "It is possible to use Vagrant to provision a virtual Arch Linux machine with SELinux configured. This is a convenient way to test an Arch Linux system running SELinux without modifying a current system. Here are commands which can be used to achieve this:\n\n```\n$ git clone https://github.com/archlinuxhardened/selinux.git\n$ cd selinux/_vagrant\n$ vagrant up\n$ vagrant ssh\n```\n\n"
    },
    {
      "title": "Post-installation steps",
      "level": 2,
      "content": "You can check that SELinux is working with sestatus. You should get something like:\n\n```\nSELinux status:                 enabled\nSELinuxfs mount:                /sys/fs/selinux\nSELinux root directory:         /etc/selinux\nLoaded policy name:             refpolicy\nCurrent mode:                   permissive\nMode from config file:          permissive\nPolicy MLS status:              disabled\nPolicy deny_unknown status:     allowed\nMax kernel policy version:      28\n```\n\nTo maintain correct context, you can enable restorecond.service.\n\nTo switch to enforcing mode without rebooting, you can use:\n\n```\n# echo 1 > /sys/fs/selinux/enforce\n```\n\n"
    },
    {
      "title": "Swapfiles",
      "level": 3,
      "content": "If you have a swap file instead of a swap partition, issue the following commands in order to set the appropriate security context:\n\n```\n# semanage fcontext -a -t swapfile_t \"/path/to/swapfile\"\n# restorecon /path/to/swapfile\n```\n\n"
    },
    {
      "title": "Working with SELinux",
      "level": 2,
      "content": "SELinux defines security using a different mechanism than traditional Unix access controls. The best way to understand it is by example. For example, the SELinux security context of the apache homepage looks like the following:\n\n```\n$ ls -lZ /var/www/html/index.html\n```\n\n```\n-rw-r--r--  username username system_u:object_r:httpd_sys_content_t /var/www/html/index.html\n```\n\nThe first three and the last columns should be familiar to any (Arch) Linux user. The fourth column is new and has the format:\n\n```\nuser:role:type[:level]\n```\n\nTo explain:\n\n1. User: The SELinux user identity. This can be associated to one or more roles that the SELinux user is allowed to use.\n1. Role: The SELinux role. This can be associated to one or more types the SELinux user is allowed to access.\n1. Type: When a type is associated with a process, it defines what processes (or domains) the SELinux user (the subject) can access. When a type is associated with an object, it defines what access permissions the SELinux user has to that object.\n1. Level: This optional field can also be know as a range and is only present if the policy supports MCS or MLS.\n\nThis is important in case you wish to understand how to build your own policies, for these are the basic building blocks of SELinux. However, for most purposes, there is no need to, for the reference policy is sufficiently mature. However, if you are a power user or someone with very specific needs, then it might be ideal for you to learn how to make your own SELinux policies.\n\nThis is a great series of articles for someone seeking to understand how to work with SELinux.\n\n"
    },
    {
      "title": "Troubleshooting",
      "level": 2,
      "content": "The place to look for SELinux errors is the systemd journal. In order to see SELinux messages related to the label system_u:system_r:policykit_t:s0 (for example), you would need to run:\n\n```\n# journalctl _SELINUX_CONTEXT=system_u:system_r:policykit_t:s0\n```\n\n"
    },
    {
      "title": "Useful tools",
      "level": 3,
      "content": "There are some tools/commands that can greatly help with SELinux.\n\n"
    },
    {
      "title": "Reporting issues",
      "level": 3,
      "content": "Please report issues on GitHub: https://github.com/archlinuxhardened/selinux/issues\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Security Enhanced Linux\n- Gentoo:SELinux\n- Fedora:SELinux\n- NSA's Official SELinux Homepage\n- SELinux Project Homepage Reference Policy Homepage SETools Homepage\n- ArchLinux, SELinux and You (archived)\n\n- Reference Policy Homepage\n- SETools Homepage\n\n"
    }
  ]
}