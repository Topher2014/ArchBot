{
  "title": "Iriun",
  "url": "https://wiki.archlinux.org/title/Iriun",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Webcam setup\n\nFrom the project repository:\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the v4l2loopback-dkms package and the headers for the target kernel/kernels (see Dynamic Kernel Module Support#Installation). For example, for the default linux kernel this would be linux-headers. Other kernels have their own respective headers packages.\n\nCommand line utilities are provided by v4l2loopback-utils and v4l-utils.\n\nMany of the use case examples in this article also use ffmpeg.\n\n"
    },
    {
      "title": "Loading the kernel module",
      "level": 2,
      "content": "The v4l2loopback kernel module can be loaded via the Dynamic Kernel Module Support:\n\n```\n# modprobe v4l2loopback\n```\n\nv4l2-ctl can be used to list all video devices, where the new v4l2loopback device should appear:\n\n```\n$ v4l2-ctl --list-devices\n```\n\nv4l2loopback can be loaded with various options for device creation:\n\n```\n# modprobe v4l2loopback video_nr=9 card_label=Video-Loopback exclusive_caps=1\n```\n\nThis should create /dev/video9 as a loopback device. exclusive_caps=1 is necessary for some Chromium/WebRTC based application like jitsi-meet-desktop-binAUR or zoomAUR. This will enable exclusive_caps mode that only reports CAPTURE/OUTPUT capabilities exclusively. The newly created device will announce OUTPUT capabilities only (so ordinary webcam applications (including Chrome) will not see it). As soon as you have attached a producer to the device, it will start announcing CAPTURE capabilities only (so applications that refuse to open devices that have other capabilities apart from capturing can open it too). More options can be found in the official documentation.\n\nIf the module is already loaded, the above command has likely no effect. The module first has to be unloaded, before loaded again:\n\n```\n# modprobe -r v4l2loopback\n```\n\nSee Kernel module#Manual module handling for more details.\n\nIt is possible to create multiple loopback devices by using the devices argument. Options for the every device are specified by using a comma. The following command creates three loopback devices, /dev/video8, /dev/video9 and the first available /dev/videoX, all with exclusive_caps enabled.\n\n```\n# modprobe v4l2loopback devices=3 video_nr=8,9 exclusive_caps=1,1,1 card_label=\"Loopback-1,Loopback-2,Loopback-3\"\n```\n\nRestarting the system will unload the module, but is possible to load the modules automatically at boot with custom device options, which is useful if one loopback device is used for an internal webcam. See Kernel module#Automatic module loading and the official documentation for details.\n\n"
    },
    {
      "title": "Viewing a v4l2loopback video feed",
      "level": 2,
      "content": "A loopback video device at /dev/video0 can be viewed for testing with any of the following: ffplay (part of ffmpeg), mpv, or gst-launch (part of gstreamer):\n\n```\n$ ffplay /dev/video0\n$ mpv av://v4l2:/dev/video0\n$ gst-launch-1.0 -v v4l2src device=/dev/video0Â ! glimagesink\n```\n\nAs noted in #Loading the kernel module, when exclusive_caps=1 is used Chromium and applications like jitsi-meet-desktop-binAUR and zoomAUR should be able to use the loopback device as a virtual webcam, while a video stream is piped into them. In a browser the virtual webcam can be tested on webcamtests.com.\n\nSee also Webcam setup#Applications.\n\n- Various other issues with Firefox have been reported.\n- It has been reported, that skypeforlinux-binAUR detects the virtual video device, but outputs a blank screen.\n\n"
    },
    {
      "title": "Use cases",
      "level": 2,
      "content": "Generally, FFmpeg is very convenient in combination with v4l2loopback, because it can transcode various input streams to the widely supported yuv420p pixel format and pipe the output to a v4l2loopback device by using the ffmpeg arguments -vf format=yuv420p -f v4l2. See the examples below in this article.\n\nFFmpeg can also use the v4l2loopback device as an input stream. See FFmpeg#Recording webcam.\n\nGStreamer can also use v4l2loopback devices as sources and sinks.\n\nFurther examples can be found at the official v4l2loopback wiki.\n\n"
    },
    {
      "title": "Screen casting",
      "level": 3,
      "content": "Below are examples how to implement screen sharing by streaming the screen to a v4l2 loopback device, which can be used as a virtual webcam.\n\n"
    },
    {
      "title": "Casting X11 using FFmpeg",
      "level": 4,
      "content": "FFmpeg can be used to select a region on a X11 display and then stream it to a v4l2 loopback device:\n\n```\n$ ffmpeg -f x11grab -select_region 1 -show_region 1 -framerate 25 -i $DISPLAY -vf format=yuv420p -f v4l2 /dev/video0\n```\n\nSee the x11grab docs for a description of all the arguments.\n\n"
    },
    {
      "title": "Casting Wayland using wf-recorder",
      "level": 4,
      "content": "- See also PipeWire#WebRTC screen sharing for a different approach to this.\n- This requires #Loading the kernel module with exclusive_caps=1 and assumes the created video device is /dev/video0.\n\nInstall wf-recorder (or wf-recorder-gitAUR). To start recording the screen with wf-recorder and stream it to a v4l2 loopback device use:\n\n```\n$ wf-recorder --muxer=v4l2 --codec=rawvideo --file=/dev/video0 -x yuv420p\n```\n\nIf you encounter Unknown V4L2 pixel format equivalent for rgb0 run wf-recorder with --force-yuv or -t to force conversion of the data to yuv format, before sending it to the GPU. [1]\n\nAs explained above, wf-recorder is able to record only a portion of the screen by first selecting a region with slurp. To use this functionality for sharing a specific region/application window through a virtual video device, start recording the screen with the following modified command:\n\n```\n$ wf-recorder -g \"$(slurp)\" --muxer=v4l2 --codec=rawvideo --file=/dev/video0 -x yuv420p\n```\n\n"
    },
    {
      "title": "Using a photo camera as webcam with gPhoto",
      "level": 3,
      "content": "If gPhoto is installed and working with your camera, you can use gphoto2 and FFmpeg to pipe the liveview stream of the camera to a v4l2 loopback device:\n\n```\n$ gphoto2 --stdout --capture-movie | ffmpeg -i - -vf format=yuv420p -f v4l2 /dev/video0\n```\n\nFor troubleshooting refer to gPhoto#Troubleshooting. This should work with all cameras, which have the liveview functionality listed on the official gPhoto website.\n\n"
    },
    {
      "title": "Using a network stream as webcam",
      "level": 3,
      "content": "FFmpeg can be used to capture a network stream and pipe it to a v4l2 loopback device:\n\n```\n$ ffmpeg -i http://ip_address:port/video -vf format=yuv420p -f v4l2 /dev/video0\n```\n\n"
    },
    {
      "title": "Using an Android device as webcam",
      "level": 4,
      "content": "On Android IP Webcam can be used to broadcast a network video stream. Then the command above can be used to pipe it into a v4l2 loopback device and use it like a webcam. IP Webcam defaults to port 8080.\n\nDepending on the network connection, the network stream over Wi-Fi might have a lot of latency and could be stuttering. If you have Android Debug Bridge configured with your computer and the Android device, it is possible to tunnel the stream over a USB cable using adb forward, which provides a more stable connection:\n\n```\n$ adb wait-for-usb-device && adb forward tcp:8080 tcp:8080 && ffmpeg -i http://127.0.0.1:8080/video -vf format=yuv420p -f v4l2 /dev/video0\n```\n\nAnother easier way is to use scrcpy:\n\n```\n$ scrcpy --video-source=camera --camera-id=0 --camera-size=1920x1080 --video-bit-rate=20M --v4l2-sink=/dev/video0 --no-playback\n```\n\n"
    },
    {
      "title": "Using a background image in video conferencing",
      "level": 3,
      "content": "There are a number of different options for hiding/replacing the background in video conferencing software like Microsoft Teams and Zoom.\n\n"
    },
    {
      "title": "OBS",
      "level": 4,
      "content": "OBS is used by streamers as a real-time video management system, for switching between video feeds. It can have multiple \"scenes\" set up (e.g. each with a different background image) and then they can be switched with a button click. It can also provide other video filters, has a plugin system for new ones, can display multiple video feeds at the same time, and so on. It can send its output to a v4l2loopback device that works with any application that supports V4L2 cameras.\n\nTo set this up:\n\n1. Install the main obs-studio package and the obs-backgroundremovalAUR plugin.\n1. Load obs and add the real camera as an input source for the scene.\n1. Right-click on the source and edit the filters, and add the background removal filter. You should now see the background erased, only showing black. (You can also opt to blur the background instead of removing it, in the advanced options.)\n1. Add another input source of type \"Image\" and select your preferred background image. The source type could also be a video file or another webcam, but start with an image until everything is working.\n1. Drag the image entry in the source list so that it is below the entry for the video source, in order for the image to appear behind the video instead of in front of it.\n1. Move/resize the background image so that it takes up most of the scene.\n1. Enable the virtual output and the virtual webcam is ready to use.\n\nobs must be left running with the virtual output enabled in order for the virtual webcam to be usable by video conferencing software.\n\nIf you get a corrupted or blank image (common after changing the output resolution) you may need to delete and recreate the V4L2 loopback device (or unload and reload the v4l2loopback module).\n\nSee #Viewing a v4l2loopback video feed above for troubleshooting - if these programs play the feed fine then the problem is with the application consuming the video. If these utilities also do not see video properly, the problem is with the loopback set up.\n\n"
    },
    {
      "title": "Firefox",
      "level": 3,
      "content": "If Firefox is unable to read the video stream and prints a message like AbortError: Starting video failed, try preloading v4l2compat.so:\n\n```\n$ LD_PRELOAD=/usr/lib/v4l1compat.so firefox\n```\n\n"
    },
    {
      "title": "ioctl(VIDIOC_G_FMT)",
      "level": 3,
      "content": "If you get a ioctl(VIDIOC_G_FMT) error, when trying to use the video device with ffmpeg, try unloading and reloading the kernel module. [2]\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- v4l2loopback repository\n- v4l2loopback wiki\n\n"
    }
  ]
}