{
  "title": "Partitioning",
  "url": "https://wiki.archlinux.org/title/Partitioning",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- File systems\n- fdisk\n- gdisk\n- parted\n- fstab\n- LVM\n- Swap\n- Arch boot process\n- Unified Extensible Firmware Interface\n- systemd-repart\n\nFrom Wikipedia:\n\nAn entire disk may be allocated to a single partition, or multiple ones for cases such as dual-booting, maintaining a swap partition, or to logically separate data such as audio and video files. The partitioning scheme is stored in a partition table such as Master Boot Record (MBR) or GUID Partition Table (GPT).\n\nPartition tables are created and modified using one of many partitioning tools. The tools available for Arch Linux are listed in the #Partitioning tools section.\n\nPartitions usually contain a file system directly which is accomplished by creating a file system on (a.k.a. formatting) the partition. Alternatively, partitions can contain LVM, block device encryption or RAID, which ultimately provide device files on which a file system can be placed (or the devices can be stacked further).\n\nAny block device (e.g. disk, partition, LUKS device, LVM logical volume or RAID array) that directly contains a mountable file system is called a volume.\n\n"
    },
    {
      "title": "Partition table",
      "level": 2,
      "content": "There are two main types of partition table available. These are described below in the #Master Boot Record (MBR) and #GUID Partition Table (GPT) sections along with a discussion on how to choose between the two. A third, less common alternative is using a partitionless disk, which is also discussed.\n\nUse a partitioning tool to view the partition table of a block device.\n\n"
    },
    {
      "title": "Master Boot Record",
      "level": 3,
      "content": "The Master Boot Record (MBR) is the first 512 bytes of a storage device. It contains an operating system bootloader and the storage device's partition table. It plays an important role in the boot process under BIOS systems. See Wikipedia:Master boot record#Disk partitioning for the MBR structure.\n\n- The MBR is not located in a partition; it is located at the first sector of the device (physical offset 0), preceding the first partition.\n- The boot sector present on a partitionless device or within an individual partition is called a volume boot record (VBR) instead.\n\n"
    },
    {
      "title": "Master Boot Record (bootstrap code)",
      "level": 4,
      "content": "The first 440 bytes of MBR are the bootstrap code area. On BIOS systems it usually contains the first stage of the boot loader. The bootstrap code can be backed up, restored from backup or erased using dd.\n\n"
    },
    {
      "title": "Master Boot Record (partition table)",
      "level": 4,
      "content": "In the MBR partition table (also known as DOS or MS-DOS partition table) there are 3 types of partitions:\n\n- Primary\n- Extended Logical\n\n- Logical\n\nPrimary partitions can be bootable and are limited to four partitions per disk or RAID volume. If the MBR partition table requires more than four partitions, then one of the primary partitions needs to be replaced by an extended partition containing logical partitions within it.\n\nExtended partitions can be thought of as containers for logical partitions. A hard disk can contain no more than one extended partition. The extended partition is also counted as a primary partition so if the disk has an extended partition, only three additional primary partitions are possible (i.e. three primary partitions and one extended partition). The number of logical partitions residing in an extended partition is unlimited. A system that dual boots with Windows will require for Windows to reside in a primary partition.\n\nThe customary numbering scheme is to create primary partitions sda1 through sda3 followed by an extended partition sda4. The logical partitions on sda4 are numbered sda5, sda6, etc.\n\n"
    },
    {
      "title": "GUID Partition Table",
      "level": 3,
      "content": "GUID Partition Table (GPT) is a partitioning scheme that is part of the Unified Extensible Firmware Interface specification; it uses globally unique identifiers (GUIDs), or UUIDs in the Linux world, to define partitions and partition types. It is designed to succeed the Master Boot Record partitioning scheme method.\n\nAt the start of a GUID Partition Table disk there is a protective Master Boot Record (PMBR) to protect against GPT-unaware software. This protective MBR just like an ordinary MBR has a bootstrap code area which can be used for BIOS/GPT booting with boot loaders that support it.\n\n"
    },
    {
      "title": "Choosing between GPT and MBR",
      "level": 3,
      "content": "GUID Partition Table (GPT) is an alternative, contemporary, partitioning style; it is intended to replace the old Master Boot Record (MBR) system. GPT has several advantages over MBR which has quirks dating back to MS-DOS times. With the recent developments to the formatting tools, it is equally easy to get good dependability and performance for GPT or MBR.\n\nSome points to consider when choosing:\n\n- To dual-boot with Windows (both 32-bit and 64-bit) using Legacy BIOS, the MBR scheme is required.\n- To dual-boot Windows 64-bit using UEFI mode instead of BIOS, the GPT scheme is required.\n- If you are installing on older hardware, especially on old laptops, consider choosing MBR because its BIOS might not support GPT (but see below how to fix it).\n- If you are partitioning a disk that is larger than 2 TiB (≈2.2 TB), you need to use GPT.\n- It is recommended to always use GPT for UEFI boot, as some UEFI implementations do not support booting to the MBR while in UEFI mode.\n- If none of the above apply, choose freely between GPT and MBR. Since GPT is more modern, it is recommended in this case.\n\nSome advantages of GPT over MBR are:\n\n- Provides a unique disk GUID and unique partition GUID (PARTUUID) for each partition – a good filesystem-independent way of referencing partitions and disks. GUIDs are a prerequisite for the Discoverable Partitions Specification that can be utilized in a systemd-enabled initramfs.\n- Provides a filesystem-independent partition name (PARTLABEL).\n- Arbitrary number of partitions - depends on space allocated for the partition table - No need for extended and logical partitions. By default the GPT table contains space for defining 128 partitions. However if you want to define more partitions, you can allocate more space to the partition table (currently only gdisk is known to support this feature).\n- Uses 64-bit LBA for storing Sector numbers - maximum addressable disk size is 2 ZiB. MBR is limited to addressing 2 TiB of space per drive.[1]\n- Stores a backup header and partition table at the end of the disk that aids in recovery in case the primary ones are damaged.\n- CRC32 checksums to detect errors and corruption of the header and partition table.\n\nThe section on #Partitioning tools contains a table indicating which tools are available for creating and modifying GPT and MBR tables.\n\n"
    },
    {
      "title": "Partitionless disk",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nPartitionless disk a.k.a. superfloppy refers to a storage device without a partition table, having one file system occupying the whole storage device. The boot sector present on a partitionless device is called a volume boot record (VBR).\n\n"
    },
    {
      "title": "Btrfs partitioning",
      "level": 4,
      "content": "Btrfs can occupy an entire data storage device and replace the MBR or GPT partitioning schemes. See the Btrfs#Partitionless Btrfs disk instructions for details.\n\n"
    },
    {
      "title": "Partition scheme",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nThere are no strict rules for partitioning a hard drive, although one may follow the general guidance given below. A disk partitioning scheme is determined by various issues such as desired flexibility, speed, security, as well as the limitations imposed by available disk space. It is essentially personal preference. If you would like to dual boot Arch Linux and a Windows operating system please see Dual boot with Windows.\n\n- UEFI systems typically need an EFI system partition.\n- BIOS systems that are partitioned with GPT require a BIOS boot partition if GRUB is used as the bootloader.\n\n"
    },
    {
      "title": "Single root partition",
      "level": 3,
      "content": "This scheme is the simplest, most flexible and should be enough for most use cases given the increase in storage size of consumer grade devices. A swap file can be created and easily resized as needed. It usually makes sense to start by considering a single / partition and then separate out others based on specific use cases like RAID, encryption, a shared media partition, etc… See #Discrete partitions for a description of some common to uncommon dedicated partitions.\n\nThe suggested minimum size is 23–32 GiB for a single root partition. More space may be needed for user files and when using a swap file. A bare minimal installation requires about 2 GiB. As examples, a simple server can fit under 4 GiB while a full KDE Plasma installation uses 10 GiB. Both examples require frequent purges of the package cache.\n\nA GPT partition should have the \"Linux root (x86-64)\" type GUID 4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709 (8304 type for gdisk). An MBR partition should have the default \"Linux\" type ID 83.\n\n"
    },
    {
      "title": "Discrete partitions",
      "level": 3,
      "content": "Separating out a path as a partition allows for the choice of a different filesystem and mount options. In some cases like a media partition, they can also be shared between operating systems.\n\nBelow are some example layouts that can be used when partitioning, and the following subsections detail a few of the directories which can be placed on their own separate partition and then mounted at mount points under /. See file-hierarchy(7) for a full description of the contents of these directories.\n\n"
    },
    {
      "title": "/",
      "level": 4,
      "content": "The root directory is the top of the hierarchy, the point where the primary filesystem is mounted and from which all other filesystems stem. All files and directories appear under the root directory /, even if they are stored on different physical devices. The contents of the root filesystem must be adequate to boot, restore, recover, and/or repair the system. Therefore, certain directories under / are not candidates for separate partitions.\n\nThe / partition or root partition is necessary and it is the most important. The other partitions can be replaced by it.\n\nNote: **must** \n\n/ traditionally contains the /usr directory, which can grow significantly depending upon how much software is installed. 15–20 GiB should be sufficient for most users with modern hard disks. If you plan to store a swap file here and do not plan on using a separate /var, you might need a larger partition size (i.e. adding the size of your RAM to be able to hibernate and an additional 8–12 GiB for /var).\n\nA GPT partition should have the \"Linux root (x86-64)\" type GUID 4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709 (8304 for gdisk). An MBR partition should have the default \"Linux\" type ID 83.\n\n"
    },
    {
      "title": "/boot",
      "level": 4,
      "content": "The /boot directory contains the vmlinuz and initramfs images as well as the boot loader configuration file and boot loader stages. It also stores data that is used before the kernel begins executing user-space programs. /boot is not required for normal system operation, but only during boot and kernel upgrades (when regenerating the initial ramdisk).\n\nNote: See Arch boot process#Boot loader for more information on boot loader requirements and capabilities.\n\n- Your boot loader must be capable of accessing the /boot partition. That means the boot loader must have support for everything starting from the block devices, stacked block devices (LVM, RAID, dm-crypt, LUKS, etc.) and ending with the file system on which the kernel(s) and initramfs image(s) reside.\n- File systems can get new features not yet supported by boot loaders (e.g. archlinux/packaging/packages/grub#7, FS#79857, FS#59047, FS#58137, FS#51879, FS#46856, FS#38750, FS#21733 and fscrypt encrypted directories), making them unsuitable for a /boot partition unless disabling incompatible features. This can be typically avoided by using FAT32 since it is supported by practically everything and it will not be getting any new features.\n\nSee Arch boot process#Boot loader for more information on boot loader requirements and capabilities.\n\nWhen using an EFI system partition as /boot, the requirements are as described in the EFI system partition article—the correct partition type must be set.\n\nIn other cases, it is recommended to set the partition type to Extended Boot Loader (XBOOTLDR) Partition which is GPT partition type GUID BC13C2FF-59E6-4262-A352-B275FD6F7172 (ea00 type for gdisk, xbootldr type for fdisk) or MBR partition type ID ea.\n\nIn both cases the suggested size for the partition is 1 GiB, which should give enough space to house multiple kernels. If still in doubt, 4 GiB ought to be enough for anybody.\n\n"
    },
    {
      "title": "/home",
      "level": 4,
      "content": "The /home directory contains user-specific configuration files, caches, application data and media files.\n\nSeparating out /home allows / to be re-partitioned separately, but note that you can still reinstall Arch with /home untouched even if it is not separate—the other top-level directories just need to be removed, and then pacstrap can be run.\n\nYou should not share home directories between users on different distributions, because they use incompatible software versions and patches. Instead, consider sharing a media partition or at least using different home directories on the same /home partition. The size of this partition varies.\n\nA GPT partition should have the \"Linux home\" type GUID 933AC7E1-2EB4-4F13-B844-0E14E2AEF915 (8302 type for gdisk, home type for fdisk). An MBR partition should have the default \"Linux\" type ID 83.\n\n"
    },
    {
      "title": "Swap",
      "level": 4,
      "content": "A swap is a file or partition that provides disk space used as virtual memory. Swap files and swap partitions are equally performant, but swap files are much easier to resize as needed. A swap partition can potentially be shared between operating systems, but not if hibernation is used.\n\nSince computers have gained memory capacities superior to a gibibit, the previous \"twice the amount of physical RAM\" rule has become outdated. A sane default size is 4 GiB.\n\nTo use hibernation (a.k.a suspend to disk) it is advised to create the swap partition at the size of RAM. Although the kernel will try to compress the suspend-to-disk image to fit the swap space there is no guarantee it will succeed if the used swap space is significantly smaller than RAM. See Power management/Suspend and hibernate#Hibernation for more information.\n\nA GPT partition should have the \"Linux swap\" type with GUID 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F (8200 type for gdisk, swap type for fdisk). An MBR partition should have the \"Linux swap\" type ID 82.\n\n"
    },
    {
      "title": "/data",
      "level": 4,
      "content": "One can consider mounting a \"data\" partition to cover various files to be shared by all users. Using the /home partition for this purpose is fine as well. The size of this partition varies.\n\nA GPT partition should have the default \"Linux filesystem\" type GUID 0FC63DAF-8483-4772-8E79-3D69D8477DE4. An MBR partition should have the default \"Linux\" type ID 83.\n\n"
    },
    {
      "title": "/var",
      "level": 4,
      "content": "The /var directory stores variable data such as spool directories and files, administrative and logging data, pacman's cache, etc. It is used, for example, for caching and logging, and hence frequently read or written. Keeping it in a separate partition avoids running out of disk space due to flunky logs, etc.\n\nIt exists to make it possible to mount /usr as read-only. Everything that historically went into /usr that is written to during system operation (as opposed to installation and software maintenance) must reside under /var.\n\n- /var contains many small files. The choice of file system type should consider this fact if a separate partition is used.\n- Since /var is frequently read or written, it is recommended that you consider the location of this partition on a spinning disk.\n\n/var will contain, among other data, the pacman cache. Retaining these packages is helpful in case a package upgrade causes instability, requiring a downgrade to an older, archived package. The pacman cache will grow as the system is expanded and updated, but it can be safely cleared if space becomes an issue.\n\n8–12 GiB on a desktop system should be sufficient for /var, depending on how much software will be installed. For users of NVIDIA, Wayland and GDM, consider adding to this partition size as to have enough free space to fit your whole video memory.\n\nA GPT partition should have the \"Linux variable data\" a.k.a \"Linux /var\" type GUID 4D21B016-B534-45C2-A9FB-5C16E091FD2D (8310 type for gdisk). An MBR partition should have the default \"Linux\" type ID 83.\n\n"
    },
    {
      "title": "Example layouts",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nThe following examples use /dev/sda as the example disk with /dev/sda1 as the first partition. The block device naming scheme will differ if you are partitioning a NVMe disk (e.g. /dev/nvme0n1 with partitions starting from /dev/nvme0n1p1) or an SD card or eMMC disk (e.g. /dev/mmcblk0 with partitions starting from /dev/mmcblk0p1). See Device file#Block device names for more information.\n\n- UEFI booting does not involve any \"boot\" flag, booting relies solely on the boot entries in NVRAM. Parted and its front-ends use a \"boot\" flag on GPT to indicate that a partition is an EFI system partition.\n- There is no requirement to have all required/wanted partitions on the same disk or to use the same type of partition table for all disks.\n\n"
    },
    {
      "title": "UEFI/GPT layout example",
      "level": 4,
      "content": "Table content:\nMount point on the installed system | Partition | Partition type GUID | Suggested size\n/boot or /efi1 | /dev/sda1 | C12A7328-F81F-11D2-BA4B-00A0C93EC93B: EFI system partition | 1 GiB\n[SWAP] | /dev/sda2 | 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F: Linux swap | At least 4 GiB or the size of RAM to use hibernation\n/ | /dev/sda3 | 4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709: Linux x86-64 root (/) | Remainder of the device. At least 23–32 GiB.\n\n"
    },
    {
      "title": "BIOS/MBR layout example",
      "level": 4,
      "content": "Table content:\nMount point on the installed system | Partition | Partition type ID | Boot flag | Suggested size\n[SWAP] | /dev/sda1 | 82: Linux swap | No | At least 4 GiB or the size of RAM to use hibernation\n/ | /dev/sda2 | 83: Linux | Yes | Remainder of the device. At least 23–32 GiB.\nN/A | Unallocated space2 | N/A | N/A | At least 16.5 KiB at the end of the disk\n\n"
    },
    {
      "title": "BIOS/GPT layout example",
      "level": 4,
      "content": "Table content:\nMount point on the installed system | Partition | Partition type GUID | Suggested size\nNone | /dev/sda1 | 21686148-6449-6E6F-744E-656564454649: BIOS boot partition3 | 1 MiB\n[SWAP] | /dev/sda2 | 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F: Linux swap | At least 4 GiB or the size of RAM to use hibernation\n/ | /dev/sda3 | 4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709: Linux x86-64 root (/) | Remainder of the device. At least 23–32 GiB.\n\n1. The ESP can be mounted to /efi if the used boot loader is capable of accessing the file system (and everything above it) on which the kernel and initramfs images are located. See EFI system partition#Typical mount points and the warning in Arch boot process#Boot loader for details.\n1. An unpartitioned space of at least 33 512-byte sectors (16.5 KiB) at the end of the disk to allow converting to GPT in the future. The space will be required for the backup GPT header. The recommendation to preserve an unpartitioned space applies to all MBR partitioned disks.\n1. A BIOS boot partition is only required when using GRUB for BIOS booting from a GPT disk, it is not needed when using other boot loaders. The partition has nothing to do with /boot, and it must not be formatted with a file system or mounted.\n\n"
    },
    {
      "title": "Partitioning tools",
      "level": 3,
      "content": "The following programs are used to create and/or manipulate device partition tables and partitions. See the linked articles for the exact commands to be used.\n\nThis table will help you to choose utility for your needs:\n\nTable content:\nName | Package | MBR | GPT | CLI | TUI | Scripting utility\nfdisk | util-linux | Yes | Yes | fdisk(8) | cfdisk(8) | sfdisk(8)\nGPT fdisk | gptfdisk | No | Yes | gdisk(8) | cgdisk(8) | sgdisk(8)\nParted | parted | Yes | Yes | parted(8) | No | parted(8)\n\n"
    },
    {
      "title": "GUI frontends",
      "level": 4,
      "content": "- blivet-gui — Graphical tool for storage configuration. It uses parted as backend via python-blivetAUR and libblockdev.\n\n- GNOME Disks — A GNOME utility for dealing with storage devices. It uses parted as backend via udisks2 and libblockdev. Part of gnome.\n\n- GParted — Partition editor for graphically managing your disk partitions. It can be used to resize, copy and move partitions without data loss. It uses parted as backend.\n\n- KDE Partition Manager — Utility to help you manage the disks, partitions, and file systems on your computer. It uses sfdisk as backend via kpmcore. Part of kde-system.\n\n"
    },
    {
      "title": "Backup",
      "level": 3,
      "content": "- fdisk can create a backup of the partitions table. See fdisk#Backup and restore partition table.\n- GPT fdisk can create a binary backup consisting of the protective MBR, the main GPT header, the backup GPT header, and one copy of the partition table. See GPT fdisk#Backup and restore partition table.\n\n"
    },
    {
      "title": "Recovery",
      "level": 3,
      "content": "- gpart — A utility that guesses the contents of a destroyed MBR partition table. Its usage is explained in the gpart(8) man page.\n\n- GPT fdisk — A partitioning tool that can restore the primary GPT header (located at the start of the disk) from the secondary GPT header (located at the end of the disk) or vice versa.\n\n- TestDisk — A utility that supports recovering lost partitions on both MBR and GPT.\n\n"
    },
    {
      "title": "Partition alignment",
      "level": 2,
      "content": "The rule of thumb is to align a partition's start and size to mebibytes. See Advanced Format#Partition alignment.\n\n"
    },
    {
      "title": "GPT kernel support",
      "level": 2,
      "content": "The CONFIG_EFI_PARTITION option in the kernel config enables GPT support in the kernel (despite the name, EFI PARTITION which looks close to EFI system partition). This option must be built in the kernel and not compiled as a loadable module. This option is required even if GPT disks are used only for data storage and not for booting. This option is enabled by default in all Arch's officially supported kernels. In case of a custom kernel, enable this option by doing CONFIG_EFI_PARTITION=y.\n\n"
    },
    {
      "title": "Tricking old BIOS into booting from GPT",
      "level": 3,
      "content": "Some old BIOSes (from before year 2010) attempt to parse the boot sector and refuse to boot it if it does not contain a bootable MBR partition. This is a problem if one wants to use GPT on this disk, because, from the BIOS viewpoint, it contains only one, non-bootable, MBR partition of type ee (i.e., the protective MBR partition). One can mark the protective MBR entry as bootable using fdisk -t mbr /dev/sda, and it will work on some BIOSes. However, the UEFI specification prohibits the protective MBR partition entry from being bootable, and UEFI-based boards do care about this, even in the legacy boot mode. So, this matters if one wants to create a GPT-based USB flash drive that is supposed to boot both on modern UEFI-based boards and also on old BIOSes that insist on finding a bootable MBR partition. It is not possible to solve this problem using traditional tools such as fdisk or gdisk, but it is possible to create a fake MBR partition entry suitable for both kinds of BIOSes manually as a sequence of bytes.\n\nThe command below will overwrite the second MBR partition slot and add a bootable partition there of type 0 (i.e. unused), covering only the first sector of the device. It will not interfere with the GPT or with the first MBR partition entry which normally contains a protective MBR partition.\n\n```\n# printf '\\200\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\001\\0\\0\\0' | dd of=/dev/sda bs=1 seek=462\n```\n\nThe end result will look like this:\n\n```\n# fdisk -t mbr -l /dev/sda\n```\n\n```\nDisk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectors\nDisk model: ST3250820AS     \nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisklabel type: dos\nDisk identifier: 0x00000000\n\nDevice     Boot Start       End   Sectors   Size Id Type\n/dev/sda1           1 488397167 488397167 232.9G ee GPT\n/dev/sda2  *        0         0         1   512B  0 Empty\n\nPartition table entries are not in disk order.\n```\n\n"
    },
    {
      "title": "Drives are not visible when firmware RAID is enabled",
      "level": 3,
      "content": "If a SATA or NVMe drive is visible in firmware setup, but not to Linux (e.g. fdisk -l does not list it), it is possible that the controller is in firmware RAID mode.\n\nFor NVMe, the journal should show something like:\n\n```\nkernel: ahci 0000:00:17.0: Found 1 remapped NVMe devices.\nkernel: ahci 0000:00:17.0: Switch your BIOS from RAID to AHCI mode to use them.\n```\n\nThe solution is to enter firmware setup and disable NVMe RAID mode and change the SATA controller operation mode from RAID to AHCI. Mind that the setting may have a different name (e.g. \"Intel Rapid Storage Technology\", \"Intel RST\", \"Intel VMD controller\" or \"VMD\") and it could also be per-controller or per-port.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Wikipedia:Disk partitioning\n- Wikipedia:Binary prefix\n- Understanding Disk Drive Terminology\n- Rod Smith's page on What's a GPT? and Booting OSes from GPT\n- Make the most of large drives with GPT and Linux - IBM Developer\n- Microsoft's Windows and GPT FAQ\n- Partition Alignment (with examples)\n\n"
    }
  ]
}