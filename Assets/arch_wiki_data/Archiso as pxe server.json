{
  "title": "Archiso as pxe server",
  "url": "https://wiki.archlinux.org/title/Archiso_as_pxe_server",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Diskless system\n\nFrom Wikipedia:Preboot Execution Environment:\n\nIn this guide, PXE is used to boot the installation medium with an appropriate option ROM that supports PXE on the target. This works well when you already have a server set up.\n\n"
    },
    {
      "title": "Overview",
      "level": 3,
      "content": "It is useful to give an overview of the PXE boot process in order to understand the #Server setup, the #Installation on the client side and the Arch Linux files needed.\n\nThe client starts by broadcasting packets asking for a DHCP server and containing specific PXE options. The DHCP server responds with networking information (the IP address assigned to the client) and also provides, by using specific bootstrap protocol (BOOTP) parameters of the DHCP, additional information like the TFTP server address, the path of the initial network bootstrap program (NBP) to download or the boot configuration file name.\n\nThe NBP is transferred from the PXE server to the client using TFTP, to be loaded into memory and executed. The kernel and the initramfs are also transferred this way.\n\nThen the root file system is transferred using one of the following protocols: HTTP, NFS or NBD.\n\n"
    },
    {
      "title": "Boot from install medium",
      "level": 3,
      "content": "In order to gather the files that will be transferred from the server to the client for booting, get the latest official install image from the download page.\n\nNext mount the image:\n\n```\n# mount --mkdir -o loop,ro archlinux-release_date-x86_64.iso /mnt/archiso\n```\n\nwhere release_date is the release date in the ISO filename like, e.g., 2022.10.01.\n\nNote: **BIOS** \n\n"
    },
    {
      "title": "Boot from netboot",
      "level": 3,
      "content": "Arch Linux netboot images can be used to download the latest Arch Linux release on the fly upon system boot. Download the image compatible with your configuration.\n\nNote: **BIOS** \n\n"
    },
    {
      "title": "Pixiecore",
      "level": 2,
      "content": "An all-in-one solution is provided by pixiecore\n\n1. Install pixiecore-gitAUR\n1. Run pixiecore quick arch --dhcp-no-bind as root\n1. Boot via PXE\n\n"
    },
    {
      "title": "Server setup",
      "level": 2,
      "content": "You will need to setup a DHCP server, a TFTP server for transferring the NBP and one of the following services for transferring the root file system: HTTP server, NFS or NBD.\n\n"
    },
    {
      "title": "Network",
      "level": 3,
      "content": "Bring up your wired network adapter, and assign it an address appropriately.\n\n```\n# ip link set eth0 up\n# ip addr add 192.168.0.1/24 dev eth0\n```\n\nYou can also use one of the network managers to configure the static IP.\n\n"
    },
    {
      "title": "DHCP + TFTP",
      "level": 3,
      "content": "You will need both a DHCP server and a TFTP server to configure networking on the install target and to facilitate the transfer of files between the server and the client. dnsmasq does both, and is extremely easy to set up.\n\nInstall the dnsmasq package.\n\ndnsmasq needs to be configured. See instructions on how to setup a dnsmasq#TFTP server and a dnsmasq#PXE server.\n\nAre provided below some common configuration instructions. tftp_root is the directory where the Arch ISO is mounted (e.g. /mnt/archiso) or where the network boot program is located.\n\n```\n# /etc/dnsmasq.conf\n```\n\n```\n# Listen only to the specified interface\ninterface=eth0\n\n# Do not function as DNS server\nport=0\n\n# TFTP server setup\nenable-tftp\ntftp-root=tftp_root\n\n# Log extra information about DHCP transactions (for debug purposes)\nlog-dhcp\n```\n\nTo enable the DHCP server and give IPv4 addresses within a range, add to the configuration file a line similar to:\n\n```\ndhcp-range=192.168.0.50,192.168.0.150\n```\n\nOr in case there is already a DHCP-server running on the network and you want to interoperate with it, see dnsmasq#Proxy DHCP.\n\nTwo examples covering different boot style and installation media are provided below.\n\nOnce configured according to your needs, start dnsmasq.service.\n\n"
    },
    {
      "title": "BIOS boot from install medium",
      "level": 4,
      "content": "The path of the initial bootstrap program to be transferred is defined with the dhcp-boot option in the configuration file.\n\n```\ndhcp-boot=/boot/syslinux/lpxelinux.0\n```\n\nIn order to send specific bootstrap protocol (BOOTP) parameters, like the configuration file path, the dhcp-option-force=flag,value line is used.\n\n```\ndhcp-option-force=209,archiso_pxe.cfg # this file might be under /mnt/archiso/boot/syslinux\ndhcp-option-force=210,\n```\n\n"
    },
    {
      "title": "UEFI boot from netboot",
      "level": 4,
      "content": "To send a file depending on the architecture, here the netboot image for UEFI-style boot, use:\n\n```\npxe-service=BC_EFI, \"Boot from network BC EFI\", ipxe.efi\npxe-service=X86-64_EFI, \"Boot from network X86-64 EFI\", ipxe.efi\n```\n\nIf using netboot, the rest of the server setup section which focuses on the Arch ISO does not apply.\n\n"
    },
    {
      "title": "Transferring archiso root file system",
      "level": 3,
      "content": "Thanks to archiso_pxe_http, archiso_pxe_nfs and archiso_pxe_nbd initcpio hooks in archiso, it is possible to boot using HTTP, NFS or NBD. Boot time is approximately the same in all three methods, but HTTP method allows you to watch a state of downloading airootfs.sfs in percents.\n\n"
    },
    {
      "title": "HTTP",
      "level": 4,
      "content": "Among all alternatives, darkhttpd is by far the most trivial to setup (and the lightest-weight).\n\nFirst, install the darkhttpd package.\n\nThen start darkhttpd using our /mnt/archiso as the document root:\n\n```\n# darkhttpd /mnt/archiso\n```\n\n```\ndarkhttpd/1.8, copyright (c) 2003-2011 Emil Mikulic.\nlistening on: http://0.0.0.0:80/\n```\n\nNote: **80** \n\n"
    },
    {
      "title": "NFS",
      "level": 4,
      "content": "You will need to set up an NFS server with an export at the root of your mounted installation medium, which would be /mnt/archiso if you followed #Preparation. After setting up the server, add the following line to your /etc/exports file:\n\n```\n/etc/exports\n```\n\n```\n/mnt/archiso 192.168.0.0/24(ro,no_subtree_check)\n```\n\nIf the server was already running, re-export the file systems with exportfs -r -a -v.\n\nThe default settings in the installer expect to find the NFS at /run/archiso/bootmnt/, so you will need to edit the boot options. To do this, press Tab on the appropriate boot menu choice and edit the archiso_nfs_srv option accordingly:\n\n```\narchiso_nfs_srv=${pxeserver}:/mnt/archiso\n```\n\nAlternatively, you can use /run/archiso/bootmnt for the entire process.\n\nAfter the kernel loads, the Arch bootstrap image will copy the root file system via NFS to the booting host. This can take a little while. Once this completes, you should have a running system.\n\n"
    },
    {
      "title": "NBD",
      "level": 4,
      "content": "Install the nbd package and configure it:\n\n```\n/etc/nbd-server/config\n```\n\n```\n[generic]\n[archiso]\n    readonly = true\n    exportname = /srv/archlinux-release_date-x86_64.iso\n```\n\nwhere release_date is the release date in the ISO filename like, e.g., 2022.10.01.\n\nStart nbd.service.\n\n"
    },
    {
      "title": "Existing PXE server",
      "level": 3,
      "content": "If you have an existing PXE server with a PXELINUX system setup (e.g. a combination of DHCP and TFTP), you can add the following menu items to your /tftpboot/pxelinux.cfg/default file in order to boot Arch via your preferred method.\n\nSince PXELINUX supports HTTP, only the boot loader needs to be transferred over TFTP, everything else can use HTTP. E.g.:\n\n```\nLABEL archlinux\n        MENU LABEL Arch Linux x86_64\n        LINUX http://httpserver/path/to/extracted/Arch/ISO/arch/boot/x86_64/vmlinuz-linux\n        INITRD http://httpserver/path/to/extracted/Arch/ISO/arch/boot/x86_64/initramfs-linux.img\n        APPEND archisobasedir=arch archiso_http_srv=http://httpserver/path/to/extracted/Arch/ISO/ cms_verify=y\n        SYSAPPEND 3\n        TEXT HELP\n        Arch Linux 2022.10.01 x86_64\n        ENDTEXT\n```\n\nFor NFS and NBD, the kernel and initramfs must be downloaded from TFTP. E.g., for NFS:\n\n```\nLABEL archlinux\n        MENU LABEL Arch Linux x86_64\n        LINUX /path/to/extracted/Arch/ISO/arch/boot/x86_64/vmlinuz-linux\n        INITRD /path/to/extracted/Arch/ISO/arch/boot/x86_64/initramfs-linux.img\n        APPEND archisobasedir=arch archiso_nfs_srv=pxeserver:/run/archiso/bootmnt cms_verify=y\n        SYSAPPEND 3\n        TEXT HELP\n        Arch Linux 2022.10.01 x86_64\n        ENDTEXT\n```\n\nThe LINUX and INITRD paths are relative to TFTP root. For NBD, replace archiso_nfs_srv with archiso_nbd_srv in the above example. See usage examples in boot/syslinux/archiso_pxe.cfg file resided on Arch Linux ISO.\n\nWhichever method you choose, you must pass ip= parameter to instruct the kernel to bring up the network interface before it attempts to mount the installation medium over the network. Passing BOOTIF= is required when there are several wired interfaces on the client side and/or you want resolv.conf to be already configured inside booted archiso. You can use sysappend mask 3 (which is 1+2) to pass these parameters automatically. For available boot parameters see README.bootparams.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "For this portion you will need to figure out how to tell the client to attempt a PXE boot; in the corner of the screen along with the normal post messages, usually there will be some hint on which key to press to try PXE booting first. On an IBM x3650 F12 brings up a boot menu, the first option of which is Network; on a Dell PE 1950/2950 pressing F12 initiates PXE booting directly.\n\n"
    },
    {
      "title": "Boot",
      "level": 3,
      "content": "Looking at journald on the PXE server will provide some additional insight to what exactly is going on during the early stages of the PXE boot process:\n\n```\n# journalctl -u dnsmasq.service -f\n```\n\n```\ndnsmasq-dhcp[2544]: DHCPDISCOVER(eth1) 00:1a:64:6a:a2:4d \ndnsmasq-dhcp[2544]: DHCPOFFER(eth1) 192.168.0.110 00:1a:64:6a:a2:4d \ndnsmasq-dhcp[2544]: DHCPREQUEST(eth1) 192.168.0.110 00:1a:64:6a:a2:4d \ndnsmasq-dhcp[2544]: DHCPACK(eth1) 192.168.0.110 00:1a:64:6a:a2:4d \ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/pxelinux.0 to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/archiso.cfg to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/whichsys.c32 to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/archiso_pxe_choose.cfg to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/ifcpu64.c32 to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/archiso_pxe_both_inc.cfg to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/archiso_head.cfg to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/archiso_pxe32.cfg to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/archiso_pxe64.cfg to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/archiso_tail.cfg to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/vesamenu.c32 to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/boot/syslinux/splash.png to 192.168.0.110\n```\n\nAfter you load pxelinux.0 and archiso.cfg via TFTP, you will (hopefully) be presented with a syslinux boot menu with several options, where you can select Boot Arch Linux (x86_64) (HTTP).\n\nNext the kernel and initramfs (appropriate for the architecture you selected) will be transferred, again via TFTP:\n\n```\ndnsmasq-tftp[2544]: sent /mnt/archiso/arch/boot/x86_64/vmlinuz to 192.168.0.110\ndnsmasq-tftp[2544]: sent /mnt/archiso/arch/boot/x86_64/initramfs-linux.img to 192.168.0.110\n```\n\nIf all goes well, you should then see activity on darkhttpd coming from the PXE-target; at this point the kernel would be loaded on the PXE-target, and in init:\n\n```\n1348347586 192.168.0.110 \"GET /arch/aitab\" 200 678 \"\" \"curl/7.27.0\"\n1348347587 192.168.0.110 \"GET /arch/x86_64/root-image.fs.sfs\" 200 107860206 \"\" \"curl/7.27.0\"\n1348347588 192.168.0.110 \"GET /arch/x86_64/usr-lib-modules.fs.sfs\" 200 36819181 \"\" \"curl/7.27.0\"\n1348347588 192.168.0.110 \"GET /arch/any/usr-share.fs.sfs\" 200 63693037 \"\" \"curl/7.27.0\"\n```\n\nAfter the root file system is downloaded via HTTP, you will eventually end up at the normal live system root zsh prompt.\n\n"
    },
    {
      "title": "Post-boot",
      "level": 3,
      "content": "Unless you want all traffic to be routed through your PXE server (which will not work anyway unless you set it up properly), you will want to stop dnsmasq.service and get a new lease on the install target, as appropriate for your network layout.\n\nYou can also kill darkhttpd; the target has already downloaded the root file system, so it is no longer needed. While you are at it, you can also unmount the installation image:\n\n```\n# umount /mnt/archiso\n```\n\nAt this point you can follow the Installation guide.\n\n"
    },
    {
      "title": "Low memory systems",
      "level": 3,
      "content": "The copytoram initramfs option can be used to control whether the root file system should be copied to ram in its entirety in early-boot.\n\nIt highly recommended to leave this option alone, and should only be disabled if entirely necessary (systems with less than ~256MB physical memory). Append copytoram=n to your kernel line if you wish to do so.\n\n"
    },
    {
      "title": "Sharing internet with PXE clients",
      "level": 3,
      "content": "If your network for PXE clients is private (for example, 192.168.1.0/24), and you want them to be able to access internet (for example, for packages installation), you should configure masquerade/source nat properly. Your PXE server must have a separate NIC connected to the internet. You can use such command to pass through the internet to clients:\n\n```\niptables -t nat -A POSTROUTING -s 192.168.1.0/24 -j MASQUERADE\n```\n\nTo make this rule persistent after reboot, run the following command:\n\n```\niptables-save -f /etc/iptables/iptables.rules\n```\n\nand enable iptables.service.\n\nSee Simple stateful firewall#Setting up a NAT gateway and Internet sharing#Enable NAT for more information.\n\n"
    },
    {
      "title": "DHCP interface rename bug",
      "level": 3,
      "content": "FS#36749 causes default predictable network interface renaming to fail and then DHCP client to fail because of it. A workaround is to add the kernel boot parameter net.ifnames=0 to disable predictable interface names.\n\n"
    },
    {
      "title": "VirtualBox cannot boot while real machines can",
      "level": 3,
      "content": "When using VirtualBox to test your configuration, the virtual machine may get stuck at:\n\n```\nProbing EDD (edd=off to disable)... ok\n```\n\nWhile PXE booting with a real machine works fine. The problem may be because you have set several CPU cores to your client machine, and you set its type as Other and version as Other/Unknown (64 bit). So VirtualBox does not know which paravirtualization interface to use by default.\n\nAdding loglevel=7 to the kernel parameters lets you see where it actually got stuck:\n\n```\n[    0.063697] smp: Bringing up secondary CPUs...\n[    0.103768] x86: Booting SMP configuration:\n```\n\nTo resolve this, either use one CPU core, or go to Machine > Settings > System > Acceleration and set one of the following paravirtualization interface: Minimal, Hyper-V or KVM.\n\n"
    }
  ]
}