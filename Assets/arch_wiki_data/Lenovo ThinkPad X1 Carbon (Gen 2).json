{
  "title": "Lenovo ThinkPad X1 Carbon (Gen 2)",
  "url": "https://wiki.archlinux.org/title/Lenovo_ThinkPad_X1_Carbon_(Gen_2)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section does not follow the Laptop page guidelines.** This article or section does not follow the Laptop page guidelines.\n\nThis article or section does not follow the Laptop page guidelines.\n\nTable content:\nHardware | PCI/USB ID | Working?\nGPU | 8086:0a16 | Yes\nAudio | 8086:9c20 | Yes\nWi-Fi | 8086:08b2 | Yes\nEthernet | 8086:155a | Yes\nWWAN | 1199:a001 | Yes\nGPS | Untested\nBluetooth | 8087:07dc | Yes\nWebcam | 04ca:7036 | Yes\nFingerprint reader | 138a:0017 | Yes\nTrackpad |  | Yes\nTouchscreen |  | Yes\n\nAlmost everything works out of the box. Most of the hardware is based on the Intel Lynx Point reference design.\n\n"
    },
    {
      "title": "Power management",
      "level": 2,
      "content": "The kernel module thinkpad_acpi picks up most of the sensors. The kernel module tp_smapi is not currently supported. PCIe ASPM does not currently work.\n\nUdev does not not notify whenever battery discharges by 1%, but it does notify at 80%, 20%, 5%, 4% and 0%. To take advantage of this, see (Suspend On Low Battery Laptop#Hibernate on low battery level)\n\n"
    },
    {
      "title": "Wake from suspend",
      "level": 3,
      "content": "Wake from suspend can be buggy with earlier versions of the bios, see: [1]\n\nThis can be solved by flashing the bios to a version >=1.13. Look here for Lenovo's bios versions: [2]\n\nA guide how to make a bootable BIOS key drive can be found here: [3]\n\nAnd some fairly old help from Lenovo here: [4]\n\nIf the function keys fail to wake after suspend, ensure you have a kernel version >=3.15.\n\nIf you build your own kernels, make sure to either enable TPM (Trusted Platform Module) drivers or disable the Security Chip in the BIOS.\n\n"
    },
    {
      "title": "Keyboard",
      "level": 2,
      "content": "On kernel 3.14 and lower the adaptive panel at the top of the keyboard is locked to function mode.\n\nFrom kernel 3.15, Home mode is also available which allows access to screen brightness and other controls.\n\nIf you wish to remap keys to get back to a sane keyboard layout, you can use either xmodmap or other input remap utilities.\n\n"
    },
    {
      "title": "Automatically turn on keyboard backlight when typing",
      "level": 3,
      "content": "The keyboard backlight works out of the box and there is a button on the soft keyboard to toggle it between off, low, and high brightness. Using a C program that continuously checks for keyboard input, it is possible to only activate the backlight for a certain time.\n\nNote: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nThe program source is as a follows\n\n```\nkbdbacklight.c\n```\n\n```\n/* Original Author: Howard Chu <hyc@symas.com> 2013-01-15\n *\n * compile as \"gcc -O2 -o kbdbacklight kbdbacklight.c\" and run it in the background, or arrange to have it run at bootup.\n *\n * adapted by gabtub@gmail.com 2017-01-22\n * using https://gist.github.com/hadess/6847281\n * based on http://askubuntu.com/questions/383501/enable-the-keyboard-backlights-on-supported-lenovo-e-g-carbon-x1-with-command\n * original code found at  http://forum.notebookreview.com/threads/asus-keyboard-backlight-controller.703985/\n * sigterm catching done as shown in https://airtower.wordpress.com/2010/06/16/catch-sigterm-exit-gracefully/\n *\n * fixed by sva 2022-10-08\n * refactored the whole code out of boredom. keyboard should now be detected automatically using libudev.h 2023-06-25\n * uses /sys/class/leds/, s.t. ec_sys is not necessary\n *\n * monitor keyboard activity and toggle keyboard backlight\n */\n#include <stdio.h> // fprintf(), snprintf(), stderr\n#include <unistd.h> // write(), close(), read()\n#include <string.h> // strlen(), strncpy()\n#include <fcntl.h> // open(), O_RDONLY, O_WRONLY\n#include <limits.h> // PATH_MAX\n#include <poll.h> // poll()\n\n#include <linux/input.h> // struct input_event, EV_KEY\n#include <libudev.h> // udev stuff\n\n#define IDLE_MSEC 1000\n#define BRGHT_OFF 0\n#define BRGHT_MED 128\n#define BRGHT_HI 255\n\nstatic volatile int running = 1;\n\nstatic int find_keyboard(char* devnode, size_t size) {\n  struct udev* udev = udev_new();\n  if (!udev) {\n    fprintf(stderr, \"Failed to create udev context\\n\");\n    return -1;\n  }\n\n  struct udev_enumerate* enumerate = udev_enumerate_new(udev);\n  if (!enumerate) {\n    fprintf(stderr, \"Failed to create udev enumerate\\n\");\n    udev_unref(udev);\n    return -1;\n  }\n\n  udev_enumerate_add_match_subsystem(enumerate, \"input\");\n  udev_enumerate_add_match_property(enumerate, \"ID_INPUT_KEYBOARD\", \"1\");\n  udev_enumerate_scan_devices(enumerate);\n\n  struct udev_list_entry* devices = udev_enumerate_get_list_entry(enumerate);\n  struct udev_list_entry* entry;\n  int found = 0;\n\n  udev_list_entry_foreach(entry, devices) {\n    const char* path = udev_list_entry_get_name(entry);\n    struct udev_device* dev = udev_device_new_from_syspath(udev, path);\n    if (!dev) {\n      fprintf(stderr, \"Failed to create udev device\\n\");\n      continue;\n    }\n\n    const char* devnode_path = udev_device_get_devnode(dev);\n    if (devnode_path) {\n      if (strlen(devnode_path) < size) {\n        strncpy(devnode, devnode_path, size);\n        found = 1;\n        break;\n      } else {\n        fprintf(stderr, \"Device node path is too long\\n\");\n      }\n    }\n\n    udev_device_unref(dev);\n  }\n\n  udev_enumerate_unref(enumerate);\n  udev_unref(udev);\n\n  return found ? 0 : -1;\n}\n\nstatic int set_backlight(int brightness) {\n  char buf[16];\n  snprintf(buf, sizeof(buf), \"%d\", brightness);\n  int fd = open(\"/sys/class/leds/tpacpi::kbd_backlight/brightness\", O_WRONLY);\n  if (fd < 0) {\n    fprintf(stderr, \"Failed to open keyboard backlight file\\n\");\n    return -1;\n  }\n  if (write(fd, buf, strlen(buf)) != strlen(buf)) {\n    fprintf(stderr, \"Failed to set keyboard backlight\\n\");\n    close(fd);\n    return -1;\n  }\n  close(fd);\n  return 0;\n}\n\nstatic void handle_input(int fd, int* brightness) {\n  struct input_event ev;\n  int rc = read(fd, &ev, sizeof(ev));\n  if (rc > 0) {\n    if (ev.type == EV_KEY && ev.value == 1) {\n      set_backlight(BRGHT_HI);\n      *brightness = BRGHT_HI;\n    }\n  }\n}\n\nstatic void handle_timeout(int fd, int* brightness) {\n  set_backlight(BRGHT_OFF);\n  *brightness = BRGHT_OFF;\n}\n\nstatic void handle_poll(int fd, int* brightness) {\n  struct pollfd pfd;\n  pfd.fd = fd;\n  pfd.events = POLLIN;\n  int timeout = IDLE_MSEC;\n  while (running) {\n    int rc = poll(&pfd, 1, timeout);\n    if (rc > 0) {\n      handle_input(fd, brightness);\n      timeout = IDLE_MSEC;\n    } else if (rc == 0) {\n      handle_timeout(fd, brightness);\n      timeout = -1;\n    }\n  }\n}\n\nint main(int argc, char** argv) {\n  char devnode[PATH_MAX];\n  if (find_keyboard(devnode, sizeof(devnode)) < 0) {\n    fprintf(stderr, \"Failed to find keyboard device\\n\");\n    return 1;\n  }\n\n  int fd = open(devnode, O_RDONLY);\n  if (fd < 0) {\n    fprintf(stderr, \"Failed to open keyboard device\\n\");\n    return 1;\n  }\n\n  int brightness = BRGHT_OFF;\n  set_backlight(brightness);\n  handle_poll(fd, &brightness);\n  close(fd);\n  return 0;\n}\n```\n\nThis file can be compiled with:\n\n```\n$ gcc -O2 -o kbdbacklight kbdbacklight.c -ludev\n```\n\nand must be executed as root.\n\nIt would be possible to autostart this by creating a systemd service as follows:\n\n- Create a folder /usr/local/customscripts/kbdbacklight/\n- Save the compiled c program to /usr/local/customscripts/kbdbacklight/kbdbacklight\n- Create the following bash script in the same folder:\n\n```\n/usr/local/customscripts/kbdbacklight/kbdbacklight.sh\n```\n\n```\n#!/bin/bash\n# must be executed as root\n./kbdbacklight &\nRETVAL=$?\nPID=$!\n[ $RETVAL -eq 0 ] && echo $PID > /usr/local/customscripts/kbdbacklight/pid\n```\n\n- Create the following systemd service and place it in /etc/systemd/system/kbdbacklight.service\n\n```\n/etc/systemd/system/kbdbacklight.service\n```\n\n```\n[Unit]\nDescription=starts a daemon monitoring keyboard usage. will turn on keyboard backlight until no key is pressed for a TIMEOUT period\nRequires=\nAfter=\n\n[Service]\nType=forking\nUser=root\nWorkingDirectory=/usr/local/customscripts/kbdbacklight/\nExecStart=/usr/local/customscripts/kbdbacklight/kbdbacklight.sh &\nPIDFile=/usr/local/customscripts/kbdbacklight/pid\n\n[Install]\nWantedBy=multi-user.target\n```\n\n- start/enable kbdbacklight.service\n\n"
    },
    {
      "title": "Trackpad",
      "level": 2,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nTo enable Trackpad support you need to install xf86-input-synaptics.\n\n"
    },
    {
      "title": "Lock-ups on click",
      "level": 3,
      "content": "There are significant issues with the trackpad locking up on click. This is due to the trackpad operating in buggy PS/2 mode.\n\nOne alternative is to abandon the trackpad completely and use the trackpoint. Make sure xf86-input-synaptics is not installed - the trackpad will still register button one mouse clicks. Using xbindkeys Xbindkeys and xdotool, right button clicks can be mapped to some other event. For example:\n\n```\n~/.xbindkeysrc\n```\n\n```\n# Emit a right click on Alt + trackpad click\n\"xdotool click 3\"\n  Mod1 + b:1 + Release\n```\n\n"
    },
    {
      "title": "Tweaking trackpad behavior",
      "level": 3,
      "content": "The behavior of the trackpad by default can be contrary to your expectations, particularly if you are coming from an OS X style trackpad. The following settings can help significantly:\n\n```\n/etc/X11/xorg.conf.d/99-x1carbon.conf\n```\n\n```\n# Copy this to /etc/X11/xorg.conf.d/99-x1carbon.conf\n Section \"InputClass\"\n     Identifier \"X1 carbon stuff\"\n     MatchIsTouchpad \"on\"\n     MatchDevicePath \"/dev/input/event*\"\n     Driver \"synaptics\"\n\n     # Enable two finger scrolling vertically, disable horizontally\n     Option \"VertTwoFingerScroll\" \"1\"\n     Option \"HorizTwoFingerScroll\" \"0\"\n\n     # No scrolling along the edge\n     Option \"VertEdgeScroll\" \"0\"\n     Option \"HorizEdgeScroll\" \"0\"\n\n     Option \"LockedDrags\" \"0\"\n     Option \"FingerPress\" \"1\"\n\n     # Turn off the blasted corners as buttons\n     Option \"RTCornerButton\" \"0\"\n     Option \"RBCornerButton\" \"0\"\n     Option \"LTCornerButton\" \"0\"\n     Option \"LBCornerButton\" \"0\"\n\n     # Ignore \"taps\" and listen for \"clicks\"\n     Option \"TapButton1\" \"0\"\n     Option \"TapButton2\" \"0\"\n     Option \"TapButton3\" \"0\"\n     Option \"ClickFinger1\" \"1\" # Left click one finger\n     Option \"ClickFinger2\" \"3\" # Right click two fingers\n     Option \"ClickFinger3\" \"0\" # Three finger click disabled\n\n     Option \"TapAndDragGesture\" \"0\"\n\n     # No circular scrolling\n     Option \"CircularScrolling\" \"0\"\n EndSection\n```\n\nIf you are using gnome-shell, you may need to tell the settings app not to overwrite our changes:\n\n```\n$ gsettings set org.gnome.settings-daemon.plugins.mouse active false\n```\n\n"
    },
    {
      "title": "Touchpad not working after wake up from sleep",
      "level": 3,
      "content": "See Touchpad Synaptics#Touchpad does not work after resuming from hibernate/suspend.\n\n"
    },
    {
      "title": "Audio",
      "level": 2,
      "content": "You may need to add a default sound card options to its kernel module parameter:\n\n```\n/etc/modprobe.d/alsa-base.conf\n```\n\n```\noptions snd_hda_intel index=1\n```\n\n"
    },
    {
      "title": "ALSA-Preamplifier",
      "level": 3,
      "content": "It is a common problem on laptops running linux that the sound, even on maximum, is not loud enough. This can be fixed by adding an ALSA preamplifier.\n\nInstall alsa-utils.\n\nChange the config in /etc/asound.conf to the following ( you might have to adjust the cardnumber):\n\n```\n# Set your DEFAULT device to the softvol plug-in\n# NOT to a hardware card device\n#\n# The \"!\" means completely override the previous default\n# Not just changing/adding to it.\npcm.!default {\n  type plug\n  slave.pcm \"softvol\"\n}\n\n# Configure softvol\npcm.softvol {\n  type softvol\n\n  # Send softvol's output to dmix\n  slave {\n    pcm \"dmix\"\n    # If you wanted to you could send the output to a card directly\n    # But in most cases it's better to send it to dmix and let\n    # dmix handle where to send it. You can add a whole extra section\n    # to configure dmix and where it sends output, but I'm\n    # not covering that here.\n\n    ## Use Card 0 Device 0 instead of dmix\n    # pcm \"hw:0,0\"\n    ## Use Card 2 Device 0 instead of dmix\n    # pcm \"hw:2,0\"\n  }\n\n  # Add a control slider in your mixer interfaces\n  # i.e. KMix and alsamixer\n  control {\n    name \"Pre-Amp\"\n    card 0 #<CardNumberYouWantControlToShowOn> i.e. card 0 or card 2\n  }\n\n  # Minimum dB when slider is at 0%\n  min_dB -5.0\n\n  # Maximum DB when slider is at 100%\n  max_dB 40.0\n\n  # How many levels the slider should go through\n  # i.e. how granular do you want your control to be\n  resolution 12\n}\n```\n\nTaken from here.\n\n"
    },
    {
      "title": "Processor",
      "level": 2,
      "content": "See Microcode how to update to processor's microcode.\n\n"
    },
    {
      "title": "BIOS update",
      "level": 2,
      "content": "To install a BIOS update from linux, download the bootable iso from here\n\nSince there is no CD drive, this method can be used (German).\n\n"
    },
    {
      "title": "Wired",
      "level": 3,
      "content": "There is a small port on the right side for Ethernet. An adapter is required. In case of loss of the adapter, the part number for ordering is 04X6435.\n\n"
    },
    {
      "title": "Wireless",
      "level": 3,
      "content": "Works out of the box. The module iwlwifi should be automatically loaded by udev.\n\n```\n$ lspci\n```\n\n```\nNetwork controller: Intel Corporation Wireless 7260 (rev 83)\n```\n\n"
    },
    {
      "title": "Touchscreen",
      "level": 3,
      "content": "Works out of the box as single touch. The hardware is multi-touch, but current stable drivers only support left-click mouse emulation. Seems to work with Touchegg.\n\n"
    },
    {
      "title": "HiDPI",
      "level": 3,
      "content": "Since the display has such a high pixel density, you might encounter problems. See here: HiDPI\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- ThinkWiki\n\n"
    }
  ]
}