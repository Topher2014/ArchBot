{
  "title": "Ranger",
  "url": "https://wiki.archlinux.org/title/Ranger",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- File manager functionality\n- lf\n- Midnight Commander\n- nnn\n- Vifm\n\nranger is a text-based file manager written in Python. Directories are displayed in one pane with three columns. Moving between them is accomplished with keystrokes, bookmarks, the mouse or the command history. File previews and directory contents show automatically for the current selection.\n\nFeatures include: vi-style key bindings, bookmarks, selections, tagging, tabs, command history, the ability to make symbolic links, several console modes, and a task view. ranger has customizable commands and key bindings, including bindings to external scripts. Ranger also comes with its own file opener, rifle(1).\n\nThe closest competitors are lf and Vifm.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Install the ranger package, or ranger-gitAUR for the development version.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "To start ranger, launch a terminal and run ranger.\n\nTable content:\nKey | Command\n? | Open the manual or list keybindings, commands and settings\nl, Enter | Launch files\nj, k | Select file in the current directory\nh, l | Travel up and down in the directory tree\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "After startup, ranger creates a directory ~/.config/ranger. To copy the default configuration to this directory issue the following command:\n\n```\n$ ranger --copy-config=all\n```\n\nAfterwards, set RANGER_LOAD_DEFAULT_RC=false as an environment variable to avoid loading the global configuration in addition to the local.\n\n- rc.conf - startup commands and key bindings\n- commands.py - commands which are launched with :\n- rifle.conf - applications used when a given type of file is launched.\n\nrc.conf only needs to include changes from the default file as both are loaded. For commands.py, if you do not include the whole file, put this line at the top:\n\n```\nfrom ranger.api.commands import *\n```\n\nSee ranger(1) for general configuration.\n\n"
    },
    {
      "title": "Move to trash",
      "level": 3,
      "content": "To add a keybind that moves files to your trash directory ~/.local/share/Trash/files/ with DD, amend the configuration file as follows:\n\n```\n~/.config/ranger/rc.conf\n```\n\n```\n...\nmap DD shell mv %s /home/${USER}/.local/share/Trash/files/\n...\n```\n\nAlternatively, use GIO commandline tool provided by glib2 package:\n\n```\nmap DD shell gio trash %s\n```\n\nInspecting and emptying the \"trash\" is normally supported by graphical file managers such as nautilus, but you can also see the trash with the command gio list trash://, and empty it with: gio trash --empty.\n\n"
    },
    {
      "title": "Defining commands",
      "level": 3,
      "content": "Continuing the above example, add the following entry to empty the trash directory ~/.Trash.\n\n```\n~/.config/ranger/commands.py\n```\n\n```\n...\n\nclass empty(Command):\n    \"\"\":empty\n\n    Empties the trash directory ~/.Trash\n    \"\"\"\n\n    def execute(self):\n        self.fm.run(\"rm -rf /home/myname/.Trash/\")\n```\n\nTo use it, type :empty and Enter with tab completion as desired.\n\n"
    },
    {
      "title": "Color schemes",
      "level": 3,
      "content": "Ranger comes with four color schemes: default, jungle, snow and solarized. You can change your color scheme using:\n\n```\nset colorscheme scheme\n```\n\nCustom color schemes can be placed in ~/.config/ranger/colorschemes.\n\n"
    },
    {
      "title": "Color highlight in file previews",
      "level": 3,
      "content": "Install the python-pygments package, then copy /usr/share/doc/ranger/config/scope.sh to ~/.config/ranger/scope.sh and edit the variable PYGMENTIZE_STYLE in the configuration file of ranger to your liking. The complete list of supported themes can be obtained via pygmentize -L style.\n\n"
    },
    {
      "title": "File association",
      "level": 3,
      "content": "Ranger uses its own file opener called rifle. It is configured in ~/.config/ranger/rifle.conf. Run ranger --copy-config=rifle if it does not exist. For example, the following line makes kile the default program for tex files:\n\n```\next tex = kile \"$@\"\n```\n\nTo open all files with xdg-utils, make sure your $EDITOR and $PAGER are set and add:\n\n```\nelse = xdg-open \"$1\"\nlabel editor = \"$EDITOR\" -- \"$@\"\nlabel pager  = \"$PAGER\" -- \"$@\"\n```\n\n"
    },
    {
      "title": "Tips and tricks",
      "level": 2,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\n"
    },
    {
      "title": "Archives",
      "level": 3,
      "content": "These commands use atool to perform archive operations.\n\n"
    },
    {
      "title": "Archive extraction",
      "level": 4,
      "content": "The following command implements archive extraction of the selected items to the current directory.\n\n```\nimport os\nfrom ranger.core.loader import CommandLoader\n\nclass extract_here(Command):\n    def execute(self):\n        \"\"\" extract selected files to current directory.\"\"\"\n        cwd = self.fm.thisdir\n        marked_files = tuple(cwd.get_selection())\n\n        def refresh(_):\n            cwd = self.fm.get_directory(original_path)\n            cwd.load_content()\n\n        one_file = marked_files[0]\n        cwd = self.fm.thisdir\n        original_path = cwd.path\n        au_flags = ['-x', cwd.path]\n        au_flags += self.line.split()[1:]\n        au_flags += ['-e']\n\n        self.fm.copy_buffer.clear()\n        self.fm.cut_buffer = False\n        if len(marked_files) == 1:\n            descr = \"extracting: \" + os.path.basename(one_file.path)\n        else:\n            descr = \"extracting files from: \" + os.path.basename(\n                one_file.dirname)\n        obj = CommandLoader(args=['aunpack'] + au_flags\n                            + [f.path for f in marked_files], descr=descr,\n                            read=True)\n\n        obj.signal_bind('after', refresh)\n        self.fm.loader.add(obj)\n```\n\n"
    },
    {
      "title": "Compression",
      "level": 4,
      "content": "The following command allows users to compress several files on the current directory by marking them and then calling :compress package name. It supports name suggestions by getting the basename of the current directory and appending several possibilities for the extension. You need to have atool installed, otherwise you will see an error message when you create the archive.\n\n```\nimport os\nfrom ranger.core.loader import CommandLoader\n\nclass compress(Command):\n    def execute(self):\n        \"\"\" Compress marked files to current directory \"\"\"\n        cwd = self.fm.thisdir\n        marked_files = cwd.get_selection()\n\n        if not marked_files:\n            return\n\n        def refresh(_):\n            cwd = self.fm.get_directory(original_path)\n            cwd.load_content()\n\n        original_path = cwd.path\n        parts = self.line.split()\n        au_flags = parts[1:]\n\n        descr = \"compressing files in: \" + os.path.basename(parts[1])\n        obj = CommandLoader(args=['apack'] + au_flags + \\\n                [os.path.relpath(f.path, cwd.path) for f in marked_files], descr=descr, read=True)\n\n        obj.signal_bind('after', refresh)\n        self.fm.loader.add(obj)\n\n    def tab(self, tabnum):\n        \"\"\" Complete with current folder name \"\"\"\n\n        extension = ['.zip', '.tar.gz', '.rar', '.7z']\n        return ['compress ' + os.path.basename(self.fm.thisdir.path) + ext for ext in extension]\n```\n\n"
    },
    {
      "title": "External drives",
      "level": 3,
      "content": "External drives can be automatically mounted with udev or udisks. The default key mappings to go to common mount points /media and /run/media/$USER are gm and gi respectively.\n\n"
    },
    {
      "title": "Hidden files",
      "level": 3,
      "content": "You can toggle the visibility of hidden files with the following command: :set show_hidden!, or use :set show_hidden true to make hidden files visible.\n\nTo make this permanent, add the setting to your configuration file:\n\n```\nrc.conf\n```\n\n```\nset show_hidden true\n```\n\nAlternatively, hidden files can be toggled by pressing zh.\n\n"
    },
    {
      "title": "Image mounting",
      "level": 3,
      "content": "The following command assumes you are using CDemu as your image mounter and some kind of system like autofs which mounts the virtual drive to a specified location ('/media/virtualrom' in this case). Do not forget to change mountpath to reflect your system settings.\n\nTo mount an image (or images) to a cdemud virtual drive from ranger you select the image files and then type ':mount' on the console. The mounting may actually take some time depending on your setup (in mine it may take as long as one minute) so the command uses a custom loader that waits until the mount directory is mounted and then opens it on the background in tab 9.\n\n```\nimport os, time\nfrom ranger.core.loader import Loadable\nfrom ranger.ext.signals import SignalDispatcher\nfrom ranger.ext.shell_escape import *\n\nclass MountLoader(Loadable, SignalDispatcher):\n    \"\"\"\n    Wait until a directory is mounted\n    \"\"\"\n    def __init__(self, path):\n        SignalDispatcher.__init__(self)\n        descr = \"Waiting for dir '\" + path + \"' to be mounted\"\n        Loadable.__init__(self, self.generate(), descr)\n        self.path = path\n\n    def generate(self):\n        available = False\n        while not available:\n            try:\n                if os.path.ismount(self.path):\n                    available = True\n            except:\n                pass\n            yield\n            time.sleep(0.03)\n        self.signal_emit('after')\n\nclass mount(Command):\n    def execute(self):\n        selected_files = self.fm.thisdir.get_selection()\n\n        if not selected_files:\n            return\n\n        space = ' '\n        self.fm.execute_command(\"cdemu -b system unload 0\")\n        self.fm.execute_command(\"cdemu -b system load 0 \" + \\\n                space.join([shell_escape(f.path) for f in selected_files]))\n\n        mountpath = \"/media/virtualrom/\"\n\n        def mount_finished(path):\n            currenttab = self.fm.current_tab\n            self.fm.tab_open(9, mountpath)\n            self.fm.tab_open(currenttab)\n\n        obj = MountLoader(mountpath)\n        obj.signal_bind('after', mount_finished)\n        self.fm.loader.add(obj)\n```\n\n"
    },
    {
      "title": "New tab in current folder",
      "level": 3,
      "content": "You may have noticed there are two shortcuts for opening a new tab in home (gn and Ctrl+n). Let us rebind Ctrl+n:\n\n```\nrc.conf\n```\n\n```\nmap <c-n>  eval fm.tab_new('%d')\n```\n\n"
    },
    {
      "title": "PDF file preview",
      "level": 3,
      "content": "By default, ranger will preview PDF files as text. However, you can preview PDF files as an image in ranger by first converting the PDF file to an image. Ranger stores the image previews in ~/.cache/ranger/. You either need to create this directory manually or set preview_images to true in ~/.config/ranger/rc.conf to tell ranger to create it automatically at the next start. However, note that preview_images does not need to be set to true the whole time to preview PDF file as images, only ~/.cache/ranger directory is needed.\n\nTo enable this feature, uncomment the appropriate lines in /usr/share/doc/ranger/config/scope.sh, or add/uncomment these lines in your local file ~/.config/ranger/scope.sh.\n\n"
    },
    {
      "title": "Synchronize path",
      "level": 4,
      "content": "Ranger provides a shell function /usr/share/doc/ranger/examples/shell_automatic_cd.sh. Running ranger_cd instead of ranger will automatically cd to the last browsed folder.\n\nIf you launch ranger from a graphical launcher (such as $TERMCMD -e ranger, where TERMCMD is an X terminal), you cannot use ranger_cd. Instead, create an executable script:\n\n```\nranger-launcher.sh\n```\n\n```\n#!/bin/sh\nexport RANGERCD=true\n$TERMCMD\n```\n\nAnd add the following at the end of your shell configuration:\n\n```\n.shellrc\n```\n\n```\n$RANGERCD && unset RANGERCD && ranger_cd\n```\n\nThis will launch ranger_cd only if the RANGERCD variable is set. It is important to unset this variable again, otherwise launching a subshell from this terminal will automatically relaunch ranger.\n\n"
    },
    {
      "title": "Preventing nested ranger instances",
      "level": 4,
      "content": "You can start a shell in the current directory with S, when you exit the shell you get back to your ranger instance.\n\nWhen you however forget that you already are in a ranger shell and start ranger again you end up with ranger running a shell running ranger.\n\nTo prevent this you can create the following function in your shell's startup file:\n\n```\nranger() {\n    if [ -z \"$RANGER_LEVEL\" ]; then\n        /usr/bin/ranger \"$@\"\n    else\n        exit\n    fi\n}\n```\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- BBS thread\n- DotShare.it configurations\n- GitHub\n- Official User Guide\n- Installing and using ranger\n- Mailing list\n- Ranger tutorial\n\n"
    }
  ]
}