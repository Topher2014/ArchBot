{
  "title": "Reformatar",
  "url": "https://wiki.archlinux.org/title/Reformatar",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- Particionamento\n- Arquivo de dispositivo#lsblk\n- Permissões e atributos de arquivo\n- fsck\n- fstab\n- List of applications/Utilities#Mount tools\n- QEMU#Mounting a partition from a raw image\n- udev\n- udisks\n- umask (Português)\n- USB storage devices\n\nDo Wikipédia:\n\nPartições de unidades individuais podem ser configuradas usando um dos muitos sistemas de arquivos disponíveis diferentes. Cada um tem suas próprias vantagens, desvantagens e idiossincrasias únicas. Uma breve visão geral dos sistemas de arquivos suportados segue; os links são para páginas da Wikipédia que fornecem muito mais informações.\n\n"
    },
    {
      "title": "Tipos de sistemas de arquivos",
      "level": 2,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nVeja filesystems(5) para uma visão geral e Wikipedia:Comparison of file systems para uma comparação detalhada das funcionalidades. Sistemas de arquivos suportados pelo kernel estão listados em /proc/filesystems.\n\nTable content:\nSistema de arquivos | Comando de criação | Utilitários do userspace | Archiso [1] | Documentação do kernel [2][3] | Notas\nBtrfs | mkfs.btrfs(8) | btrfs-progs | Sim | btrfs.html | status de estabilidade\nVFAT | mkfs.fat(8) | dosfstools | Sim | vfat.html | Sistema de arquivos do Windows 9x\nexFAT | mkfs.exfat(8) | exfatprogs | Sim |  | Sistema de arquivos nativo no Linux 5.4. [4]\nmkexfatfs(8) | exfat-utils | Não | N/A (baseado no FUSE) | \nF2FS | mkfs.f2fs(8) | f2fs-tools | Sim | f2fs.html | Dispositivos baseados no Flash\next3 | mke2fs(8) | e2fsprogs | Sim | ext3.html | \next4 | mke2fs(8) | e2fsprogs | Sim | ext4.html | \nHFS | mkfs.hfsplus(8) | hfsprogsAUR | Não | hfs.html | sistema de arquivos do Mac OS Clássico\nHFS+ | mkfs.hfsplus(8) | hfsprogsAUR | Não | hfsplus.html | sistema de arquivos do macOS\nJFS | mkfs.jfs(8) | jfsutils | Sim | jfs.html | \nNILFS2 | mkfs.nilfs2(8) | nilfs-utils | Sim | nilfs2.html | \nNTFS | mkfs.ntfs(8) | ntfs-3g | Sim | N/A (baseado no FUSE) | sistema de arquivos do Windows NT\nReiserFS | mkfs.reiserfs(8) | reiserfsprogsAUR | Sim |  | \nUDF | mkfs.udf(8) | udftools | opcional | udf.html | \nXFS | mkfs.xfs(8) | xfsprogs | Sim | xfs.html xfs-delayed-logging-design.html[link inativo 2024-03-03 ⓘ] xfs-self-describing-metadata.html[link inativo 2024-03-03 ⓘ] | \n\nxfs.html xfs-delayed-logging-design.html[link inativo 2024-03-03 ⓘ] xfs-self-describing-metadata.html[link inativo 2024-03-03 ⓘ]\n\nTable content:\nSistema de arquivos | Comando de criação | Conjunto de patches para o kernel | Utilitários do userspace | Notas\nAPFS | mkapfs(8) | linux-apfs-dkms-gitAUR[link quebrado: package not found] | apfsprogs-gitAUR | sistema de arquivos do macOS (10.13 e posterior). Somente leitura, experimental.\nBcachefs | bcachefs(8) | linux-bcachefs-gitAUR | bcachefs-tools-gitAUR | \nReiser4 | mkfs.reiser4(8) |  | reiser4progsAUR | \nZFS |  | zfs-linuxAUR, zfs-dkmsAUR | zfs-utilsAUR | porte, OpenZFS\n\n"
    },
    {
      "title": "Journaling",
      "level": 3,
      "content": "Todos os sistemas de arquivos acima, com exceção do exFAT, ext2, FAT16/32, Reiser4 (opcional), Btrfs e ZFS, usam journaling. O journaling fornece resiliência a falhas registrando as alterações antes que elas sejam confirmadas no sistema de arquivos. No caso de uma falha no sistema ou falha de energia, esses sistemas de arquivos são mais rápidos para voltar a ficar online e menos propensos a serem corrompidos. O registro ocorre em uma área dedicada do sistema de arquivos.\n\nNem todas as técnicas de journaling são iguais. Ext3 e ext4 oferecem journaling de modo de dados, que registra dados e metadados, além da possibilidade de registrar apenas alterações de metadados. O journaling em modo de dados tem uma penalidade de velocidade e não é ativado por padrão. Na mesma linha, o Reiser4 oferece os chamados \"modelos de transação\" que não apenas alteram os recursos que oferecem, mas também em seu modo de journaling. Ele usa diferentes técnicas de journaling: um modelo especial chamado logs errantes que elimina a necessidade de gravar no disco duas vezes write-anywhere—uma abordagem pura de copiar-ao-gravar (principalmente equivalente ao padrão do btrfs, mas com um design de \"árvore\" fundamentalmente diferente) e uma abordagem combinada chamada hybrid que alterna heuristicamente entre as duas anteriores.\n\nNote: **node41** \n\nOs outros sistemas de arquivos fornecem journaling em modo ordenado, que registra apenas metadados. Embora todo o journaling retorne um sistema de arquivos a um estado válido após uma falha, o journaling no modo de dados oferece a maior proteção contra corrupção e perda de dados. Há um comprometimento no desempenho do sistema, no entanto, porque o journaling no modo de dados realiza duas operações de gravação: primeiro no journal e depois no disco (que o Reiser4 evita com o recurso \"registros errantes\"). A troca entre velocidade e dados do sistema segurança deve ser considerada ao escolher o tipo de sistema de arquivos Reiser4 é o único sistema de arquivos que, por padrão, opera com atomicidade total e também fornece somas de verificação para metadados e dados em linha (as operações ocorrem inteiramente, ou não e não corrompem ou destroem completamente) dados devido a operações que ocorrem pela metade) e, por design, são muito menos propensos à perda de dados do que outros sistemas de arquivos como Btrfs.\n\nOs sistemas de arquivos baseados na cópia na gravação (também conhecidos como gravação em qualquer lugar), como Reiser4, Btrfs e ZFS, não precisam usar o journal tradicional para proteger os metadados, porque eles nunca são atualizados no local. Embora o Btrfs ainda tenha uma árvore de logs semelhante a um diário, ele é usado apenas para acelerar o fdatasync/fsync.\n\n"
    },
    {
      "title": "Sistema de arquivos baseados em FUSE",
      "level": 3,
      "content": "Veja FUSE.\n\n"
    },
    {
      "title": "Sistemas de arquivos empilháveis",
      "level": 3,
      "content": "- eCryptfs — O sistema de arquivos empresárial criptográfico é um pacote de encriptação de disco para Linux. É implementado com uma camada de encriptação no nível do sistema de arquivos e compátivel com POSIX, propondo funcionalidade similar ao GnuPG a nível do sistema operacional.\n\n- mergerfs — Um sistema de arquivos de união baseado no FUSE.\n\n- mhddfs — Sistema de arquivos de união FUSE para múltiplos HDDs.\n\n- overlayfs — OverlayFS é um serviço de sistema de arquivos que implementa uma montagem de união para outros sistemas de arquivos.\n\n- Unionfs — Unionfs é um serviço de sistema de arquivos para Linux, FreeBSD e NetBSD que implementa uma união para outros sistemas de arquivos.\n\n- unionfs-fuse — Uma implementação do Unionfs para o userspace.\n\n"
    },
    {
      "title": "Sistema de arquivos somente leitura",
      "level": 3,
      "content": "- EROFS — O Enhanced Read-Only File System é um sistema de arquivos somente leitura leve, que visa melhorar o desempenho e compactar a capacidade de armazenamento.\n\n- SquashFS — SquashFS é um sistema de arquivos compactado somente leitura. SquashFS compacta arquivos, inodes e diretórios, suporta tamanhos de blocos até 1 MB para maior compactação.\n\n"
    },
    {
      "title": "Sistemas de arquivos em cluster",
      "level": 3,
      "content": "- Ceph — Unificado, distribuído sistema de armazenamento feito para excelente desempenho, confiabilidade e escabilidade.\n\n- Glusterfs — Sistema de arquivos de cluster capaz de ecalar para vários peta-bytes.\n\n- IPFS — Um protocolo de hipermídia ponto a ponto para fazer a web mais rápida, segura e aberta. IPFS aims replace HTTP and build a better web for all of us. Usa blocos para guardar partes de um arquivos, cada célula de rede guarda somente o conteúdo que é do seu interesse, oferece desduplicação, distribuição, sistema escalável limitado somente pelos usuários. (atualmente em alpha)\n\n- MooseFS — MooseFS é sistema de arquivos tolerante a falhas, alta disponibilidade e de alto desempenho distribuído em rede.\n\n- OpenAFS — Implementação de código aberto do sistema de arquivos distribuído AFS\n\n- OrangeFS — OrangeFS é um sistema de arquivos de rede em expansão feito para transparentemente acessar discos de armazenamento baseado em multiplos servidores, em paralelo. Tem suporte otimizado MPI-IO para aplicações paralelas e distribuídas. Simplifica o uso de armazenamento paraleo não somente para clientes Linux como também para Windows, Hadoop, e WebHAV. Compátivel com POSIX. Parte do Linux desde a versão 4.6.\n\n- Sheepdog — Sistema de armazenamento de objetos distribuído para serviços de volume e container e gerencia os discos e células de forma inteligente.\n\n- Tahoe-LAFS — Tahoe Least-Authority Filesystem é um sistema de arquivos distribuído grátis e aberto, seguro, descentralizado, tolerante a falhas e banco de dados ponto a ponto.\n\n"
    },
    {
      "title": "Identificando sistemas de arquivos existentes",
      "level": 2,
      "content": "Para identificar sistemas de arquivos existentes, você pode usar o lsblk:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE LABEL     UUID                                 MOUNTPOINT\nsdb\n└─sdb1 vfat   Transcend 4A3C-A9E9\n```\n\nUm sistema de arquivos existente, se presente, vai ser mostrado na coluna FSTYPE. Se montado, vai aparecer na coluna MOUNTPOINT.\n\n"
    },
    {
      "title": "Criar um sistema de arquivos",
      "level": 2,
      "content": "Sistemas de arquivo são normalmente criados em uma partição, dentro de containers lógicos como LVM, RAID e dm-crypt, ou em um arquivo normal (veja Wikipedia:Loop device). Esta seção descreve o caso da partição.\n\nNote: **faça um backup de quaisquer dados que você deseja manter** \n\n- Depois de criar o novo sistema de arquivos, dados antes presentes nesta partição podem não ser mais recuperados. faça um backup de quaisquer dados que você deseja manter.\n- O propósito de dada partição pode restringir a escolha do sistema de arquivos. Por exemplo, uma partição de sistema EFI deve ter um sistema de arquivos FAT32, e o sistema de arquivo do diretório /boot deve ser suportado pelo gerenciador de boot.\n\nAntes de continuar, identifique o dispositivo onde o sistema de arquivos vai ser criado e se ele está ou não montado. Por exemplo:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE   LABEL       UUID                                 MOUNTPOINT\nsda\n├─sda1                      C4DA-2C4D\n├─sda2 ext4                 5b1564b2-2e2c-452c-bcfa-d1f572ae99f2 /mnt\n└─sda3                      56adc99b-a61e-46af-aab7-a6d07e504652\n```\n\nSistemas de arquivos montados devem ser desmontados antes de proceder. No exemplo acima um sistema de arquivo existente no /dev/sda2 está montado em /mnt. Este deve ser desmontado com:\n\n```\n# umount /dev/sda2\n```\n\nPara achar somente os sistemas de arquivos montados, veja #Listar sistemas de arquivos montados.\n\nPara criar um novo sistema de arquivos, use o mkfs(8). Veja #Tipos de sistemas de arquivos para o exato tipo, e também os utilitários do userspace que você pode instalar para um sistema de arquivos particular.\n\nPor exemplo, para criar um novo sistema de arquivos do tipo ext4 (comum para partições de dados no Linux) no /dev/sda1, rode:\n\n```\n# mkfs.ext4 /dev/sda1\n```\n\n- Use a opção -L do mkfs.ext4 para especificar um rotúlo (label) sistema de arquivos. e2label pode ser usado para mudar o rotúlo de um sistema de arquivos existente.\n- Sistemas de arquivos podem ser redimensionados depois da criação, no entanto, podem existir com certas limitações. Por exemplo, o tamanho do sistema de arquivos XFS pode ser aumentado, mas não reduzido. Veja Wikipedia:Comparison of file systems#Resize capabilities e a documentação do respectivo sistema de arquivos para detalhes.\n\nO novo sistema de arquivos pode ser montado para um diretório de escolha.\n\n"
    },
    {
      "title": "Montar um sistema de arquivos",
      "level": 2,
      "content": "Para manualmente montar um sistema de arquivos localizado em um dispositivo (exemplo, uma partição) para um diretório, use mount(8). Este exemplo monta /dev/sda1 no /mnt.\n\n```\n# mount /dev/sda1 /mnt\n```\n\nIsto liga o sistema de arquivos em /dev/sda1 para o diretório /mnt, fazendo seu conteúdo visível. Quaisquer dados que existiam no /mnt antes desta ação ficam invisíveis até que o dispositivo seja desmontado.\n\nO fstab contém informações de como dispositivos devem ser automaticamente montados, se presentes. Veja o artigo do fstab para mais informações de como modificar este comportamento.\n\nSe um dispositivo é especificado no /etc/fstab e somente o dispositivo ou ponto de montagem é dado na linha de comando, a informação presente no fstab vai ser usada para a montagem. Por exemplo, se o /etc/fstab contém uma linha indicando que /dev/sda1 deveria ser montado para /mnt, então o seguinte vai automaticamente montar o dispositivo para este diretório:\n\n```\n# mount /dev/sda1\n```\n\nOu\n\n```\n# mount /mnt\n```\n\nmount contém algumas opções, muitas destas dependem do sistema de arquivos especificado. As opções podem ser mudadas, ao:\n\n- usar opções na linha de comando com mount\n- editando o fstab\n- criando regras do udev\n- compilando o kernel você mesmo\n- ou usando scripts para montagem de um sistema de arquivos específico (localizado em /usr/bin/mount.*).\n\nVeja estes artigos relacionados e o artigo do sistema de arquivos de interesse para mais informações.\n\n"
    },
    {
      "title": "Listar sistemas de arquivos montados",
      "level": 3,
      "content": "Para listar todos os sistemas de arquivos montados, use findmnt(8):\n\n```\n$ findmnt\n```\n\nfindmnt recebe uma variedade de argumentos que podem filtrar a saída e mostra informações adicionais. Por exemplo, é possível receber um dispositivo ou ponto de montagem como um argumento para somente mostrar informações sobre ele:\n\n```\n$ findmnt /dev/sda1\n```\n\nfindmnt coleta informações do /etc/fstab, /etc/mtab, e /proc/self/mounts.\n\n"
    },
    {
      "title": "Desmontar um sistema de arquivos",
      "level": 3,
      "content": "Para desmontar um sistema de arquivos, use umount(8). O dispositivo que contém o sistema de arquivos (exemplo, /dev/sda1) ou o ponto de montagem (exemplo, /mnt) deve ser especificado:\n\n```\n# umount /dev/sda1\n```\n\nou\n\n```\n# umount /mnt\n```\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- filesystems(5)\n- systemd-mount(1)\n- Documentação de sistemas de arquivos suporteados pelo Linux\n- Wikipedia:File systems\n- Wikipedia:Mount (Unix)\n\n"
    }
  ]
}