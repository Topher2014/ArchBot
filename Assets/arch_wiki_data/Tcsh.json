{
  "title": "Tcsh",
  "url": "https://wiki.archlinux.org/title/Tcsh",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Core utilities\n- dotfiles\n\nFrom Wikipedia:\n\n"
    },
    {
      "title": "List of shells",
      "level": 2,
      "content": "Shells that are more or less POSIX compliant are listed under #POSIX compliant, while shells that have a different syntax are under #Alternative shells.\n\n"
    },
    {
      "title": "POSIX compliant",
      "level": 3,
      "content": "These shells can all be linked from /usr/bin/sh. When Bash, mkshAUR and zsh are invoked with the sh name, they automatically become more POSIX compliant.\n\n- Bash — Bash extends the Bourne shell with command-line history and completion, indexed and associative arrays, integer arithmetic, process substitution, here strings, regular expression matching and brace expansion.\n\n- Dash — Descendant of the NetBSD version of the Almquist SHell (ash). A fast POSIX-compliant shell that aims to be as small as possible.\n\n- KornShell (ksh) — The KornShell language is a complete, powerful, high-level programming language for writing applications, often more easily and quickly than with other high-level languages. This makes it especially suitable for prototyping. ksh has the best features of the Bourne shell and the C shell, plus many new features of its own. Thus ksh can do much to enhance your productivity and the quality of your work, both in interacting with the system, and in programming. ksh programs are easier to write, and are more concise and readable than programs written in a lower level language such as C.\n\n- nsh — A command-line shell like fish, but POSIX compatible.\n\n- Oil Shell (OSH) — Oil Shell is a Bash-compatible UNIX command-line shell. OSH can be run on most UNIX-like operating systems, including GNU/Linux. It is written in Python (v2.7), but ships with a native executable. The dialect of Bash recognized by OSH is called the OSH language.\n\n- Yash — Yet another shell, is a POSIX-compliant command line shell written in C99 (ISO/IEC 9899:1999). Yash is intended to be the most POSIX-compliant shell in the world while supporting features for daily interactive and scripting use.\n\n- Zsh — Shell designed for interactive use, although it is also a powerful scripting language. Many of the useful features of Bash, ksh, and tcsh were incorporated into Zsh; many original features were added. The introductory document details some of the unique features of Zsh.\n\n"
    },
    {
      "title": "Alternative shells",
      "level": 3,
      "content": "- C shell (tcsh) — Command language interpreter usable both as an interactive login shell and a shell script command processor. It includes a command-line editor, programmable word completion, spelling correction, a history mechanism, job control and a C-like syntax.\n\n- Closh — Bash-like shell based on Clojure.\n\n- Elvish — Elvish is a modern and expressive shell, that can carry internal structured values through pipelines. This feature makes possible avoiding a lot of complex text processing code. It features an expressive programming language, with features like exceptions, namespacing and anonymous functions. It also has a powerful readline which checks the syntax while typing, and syntax highlighting by default.\n\n- fish — Smart and user-friendly command line shell. Fish performs full-color command line syntax highlighting, as well as highlighting and completion for commands and their arguments, file existence, and history. It supports complete-as-you-type for history and commands. Fish is able to parse the system's man pages in order to determine valid arguments for commands, allowing it to highlight and complete commands. Easy last-command revision can be done using Alt+Up. The fish daemon (fishd) facilitates synchronized history across all instances of fish, as well as universal and persistent environment variables. Additionally, fish features significantly simplified programming syntax and control flow (similar to ruby). For more information, see the tutorial.\n\n- ion — Ion is a modern system shell that features a simple, yet powerful, syntax. It is written entirely in Rust, which greatly increases the overall quality and security of the shell, eliminating the possibilities of a ShellShock-like vulnerability, and making development easier. It also offers a level of performance that exceeds that of Dash, when taking advantage of Ion's features. While it is developed alongside, and primarily for, RedoxOS, it is a fully capable on other *nix platforms. For more details lookup its manual.\n\n- Murex — A command line shell with improved features and an enhanced UX.\n\n- nushell — Nu draws inspiration from functional programming languages, and modern CLI tools. Rather than thinking of files and services as raw streams of text, Nu looks at each input as something with structure.\n\n- Oh — Unix shell written in Go. It is similar in spirit but different in detail from other Unix shells. Oh extends the shell's programming language features without sacrificing the shell's interactive features.\n\n- PowerShell — PowerShell is an object-oriented programming language and interactive command line shell, originally written for and exclusive to Windows. Later on, it was open sourced and ported to macOS and Linux.\n\n- rc — Command interpreter for Plan 9 that provides similar facilities to UNIX’s Bourne shell, with some small additions and less idiosyncratic syntax.\n\n- xonsh — Python-powered shell with additional shell primitives that you are used to from Bash and IPython.\n\n"
    },
    {
      "title": "Changing your default shell",
      "level": 2,
      "content": "After installing one of the above shells, you can execute that shell inside of your current shell, by just running its executable. If you want to be served that shell when you login however, you will need to change your default shell.\n\nTo list all installed shells, run:\n\n```\n$ chsh -l\n```\n\nAnd to set one as default for your user do:\n\n```\n$ chsh -s /full/path/to/shell\n```\n\nIf you are using systemd-homed, run:\n\n```\n$ homectl update --shell=/full/path/to/shell user\n```\n\nwhere /full/path/to/shell is the full path as given by chsh -l.\n\nIf you now log out and log in again, you will be greeted by the other shell.\n\n"
    },
    {
      "title": "Uninstalling shell",
      "level": 2,
      "content": "Change the default shell before removing the package of the shell.\n\nAlternatively, modify the user database.\n\nUse it for every user with a shell other than bash set as their login shell (including root if needed). When completed, the package can be removed.\n\n"
    },
    {
      "title": "Login shell",
      "level": 2,
      "content": "A login shell is an invocation mode, in which the shell reads files intended for one-time initialization, such as system-wide /etc/profile or the user's ~/.profile or other shell-specific file(s). These files set up the initial environment, which is inherited by all other processes started from the shell (including other non-login shells or graphical programs). Hence, they are read-only once at the beginning of a session, which is, for example, when the user logs in to the console or via SSH, changes the user with sudo or su using the --login parameter, or when the user manually invokes a login shell (e.g. by bash --login).\n\nSee #Configuration files and the links therein for an overview of the various initialization files. For more information about login shell, see also Difference between Login Shell and Non-Login Shell? and Why a \"login\" shell over a \"non-login\" shell? on Stack Exchange.\n\n"
    },
    {
      "title": "Configuration files",
      "level": 2,
      "content": "To autostart programs in console or upon login, you can use shell startup files/directories. Read the documentation for your shell, or its ArchWiki article, e.g. Bash#Configuration files or Zsh#Startup/Shutdown files.\n\nSee also Wikipedia:Unix shell#Configuration files for a comparison of various configuration files of various shells.\n\n"
    },
    {
      "title": "/etc/profile",
      "level": 3,
      "content": "Upon login, all Bourne-compatible shells source /etc/profile, which in turn sources any readable *.sh files in /etc/profile.d/: these scripts do not require an interpreter directive, nor do they need to be executable. They are used to set up an environment and define application-specific settings.\n\n"
    },
    {
      "title": "Standardisation",
      "level": 3,
      "content": "It is possible to make (some) shells configuration files follow the same naming convention, as well as supporting some common configuration between the shells.\n\nSee the article about this and the related repository. See also xsh.\n\n"
    },
    {
      "title": "Input and output",
      "level": 2,
      "content": "See also GregsWiki and I/O Redirection.\n\n- Redirections truncate files before commands are executed: $ command file > file will therefore not work as expected. While some commands (sed for example) provide an option to edit files in-place, many do not. In such cases you can use the sponge(1) command from the moreutils package.\n- Because cat is not built into the shell, on many occasions you may find it more convenient to use a redirection, for example in scripts, or if you care a lot about performance. In fact < file does the same as cat file.\n- POSIX-compliant shells support Here Documents: $ cat << EOF one two three EOF\n- Shell pipelines operate on stdout by default. To operate on stderr(3) you can redirect stderr to stdout with command 2>&1 | othercommand or, for Bash 4, command |& othercommand.\n- Remember that many GNU core utilities accept files as arguments, so for example grep pattern < file is replaceable with grep pattern file.\n\n```\n$ command file > file\n```\n\n```\n$ cat << EOF\none\ntwo\nthree\nEOF\n```\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Evolution of shells in Linux on the IBM developerWorks\n- terminal.sexy — Terminal Color Scheme Designer\n- Hyperpolyglot — Side-by-side comparison of shell syntaxes\n- UNIX Power Tools — General command-line tool usage\n- commandlinefu.com — Command-line snippets sharing\n- List of applications/Utilities#Terminal emulators\n\n"
    }
  ]
}