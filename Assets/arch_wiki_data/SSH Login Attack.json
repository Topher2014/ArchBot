{
  "title": "SSH Login Attack",
  "url": "https://wiki.archlinux.org/title/SSH_Login_Attack",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Port knocking is a stealth method to externally open ports that, by default, the firewall keeps closed. It works by requiring connection attempts to a series of predefined closed ports. With a simple port knocking method, when the correct sequence of port \"knocks\" (connection attempts) is received, the firewall opens certain port(s) to allow a connection.\n\nThe benefit is that, for a regular port scan, it may appear as the service of the port is just not available. This article shows how to use port knocking with either a daemon, or with firewall rules only.\n\n"
    },
    {
      "title": "Introduction",
      "level": 2,
      "content": "Installing and configuring nftables or iptables is a prerequisite for the content of this article.\n\nThe module recent in iptables is used to dynamically create list of IP addresses based on their (successful or unsuccessful) port connections. Using recent, the firewall can find out if a certain IP address has knocked the correct ports, and if that is the case, open certain port(s).\n\nA session with port knocking may look like this:\n\n```\n$ ssh username@hostname # No response (Ctrl+c to exit)\n^C\n$ nmap -Pn --host-timeout 201 --max-retries 0  -p 1111 host #knocking port 1111\n$ nmap -Pn --host-timeout 201 --max-retries 0  -p 2222 host #knocking port 2222\n$ ssh user@host # Now logins are allowed\nuser@host's password:\n```\n\nIt is wise to randomly select the ports that you use for the knock sequence. random.org can help you generate a selection of ports between 1 and 65535. To check that you have not inadvertantly selected commonly used ports, use this port database, and/or your /etc/services file.\n\n"
    },
    {
      "title": "With a daemon helper",
      "level": 4,
      "content": "A specialised daemon can be used to handle port knocking. Besides easing the setup of rules these helper programs may also offer advanced features.\n\nknockd is such a port knocking daemon that can provide an added layer of security to your network. knockd(1) ยง CONFIGURATION provides three example port knocking configurations. These configs can be easily altered to integrate properly with an iptables firewall. If you followed Simple stateful firewall, you should substitute the INPUT chain specification, with the custom open chain used in the firewall.\n\nFor example:\n\n```\n[options]\n        logfile = /var/log/knockd.log\n[opencloseSSH]\n        sequence      = 8881:tcp,7777:tcp,9991:tcp\n        seq_timeout   = 15\n        tcpflags      = syn,ack\n        start_command = /usr/bin/iptables -A TCP -s %IP% -p tcp --dport 22 -j ACCEPT\n        cmd_timeout   = 10\n        stop_command  = /usr/bin/iptables -D TCP -s %IP% -p tcp --dport 22 -j ACCEPT\n```\n\n"
    },
    {
      "title": "With iptables only",
      "level": 4,
      "content": "In the following we construct an /etc/iptables/iptables.rules file to handle port knocking for SSH. The rules are setup to open the standard SSH port 22 after a series of single knocks to the ports 8881, 7777 and 9991 in that order.\n\nFirst we define the default filter policies and chains for this sample script. The OUTPUT ACCEPT is necessary in this example, because otherwise the SSH port could be opened, but traffic would be dropped - which defeats the purpose. The last three chains we require for the port knocking in the following rules.\n\n```\n# Filter definition\n```\n\n```\n*filter\n:INPUT DROP [0:0]\n:FORWARD DROP [0:0]\n:OUTPUT ACCEPT [0:0]\n:TRAFFIC - [0:0]\n:SSH-INPUT - [0:0]\n:SSH-INPUTTWO - [0:0]\n```\n\nNow we add the rules for the main chain, TRAFFIC. The concept of port knocking is based on sending singular connect requests to the right ports in a sequence. We need ICMP for some network traffic control and to allow an established connection, e.g. to SSH.\n\n```\n# INPUT definition\n```\n\n```\n-A INPUT -j TRAFFIC\n-A TRAFFIC -m state --state ESTABLISHED,RELATED -j ACCEPT\n-A TRAFFIC -m state --state NEW -m tcp -p tcp --dport 22 -m recent --rcheck --seconds 30 --name SSH2 -j ACCEPT\n```\n\nThe last of the above rules is the one to open the port 22 for 30 seconds, if the connecting IP is on the list SSH2. It can be on top of the chain, because it will only apply if this condition is met. It also introduces the first of the lists of connection attempts, which are used to track the port knocking sequence in the following. In this example, the port will be closed again after 30 seconds, but nothing else is triggered. So, a new port knocking attempt could be done from the same source IP.\n\nIf the last rule did not accept the traffic (e.g. no connection attempt in 30 seconds) but the connecting IP is on the correct list to allow SSH2, it is removed from that to knock again from the beginning. The removal directly after the check for the respective list is important for the correct handling of the sequence.\n\n```\n-A TRAFFIC -m state --state NEW -m tcp -p tcp -m recent --name SSH2 --remove -j DROP\n```\n\nNow that the end of the sequence has been handled first, the following rules do the checking of the port sequence. For each of the ports to knock, one rule checks for the correct port in sequence. If the sequence is met, a jump occurs to where the IP is added to the list for the next knock in sequence. If no jump to SSH-INPUT or SSH-INPUTTWO occured, it can only mean that the wrong port was knocked or (more likely) that it is some other traffic. Hence, the second rule removes the IP from the list and drops the traffic, same as the rule for SSH2 before.\n\n```\n-A TRAFFIC -m state --state NEW -m tcp -p tcp --dport 9991 -m recent --rcheck --name SSH1 -j SSH-INPUTTWO\n-A TRAFFIC -m state --state NEW -m tcp -p tcp -m recent --name SSH1 --remove -j DROP\n```\n\nThe same procedure is followed for the next port to be knocked. The ordering of the sequence in the TRAFFIC chain can be any way, as long as the rules corresponding to the same list are kept together and in the right order.\n\n```\n-A TRAFFIC -m state --state NEW -m tcp -p tcp --dport 7777 -m recent --rcheck --name SSH0 -j SSH-INPUT\n-A TRAFFIC -m state --state NEW -m tcp -p tcp -m recent --name SSH0 --remove -j DROP\n```\n\nIn the final block of rules, the magic of setting the connection attempt for the IP to the respective recent list of allowed IPs for the next step of the knocking sequence is done.\n\nThe first is the one for the first knock in sequence, which is checked as part of the main chain TRAFFIC since any new connection attempt may be the start of a port knocking. On success (correct port) it sets the knock to the first list, SSH0. This in turn one can see in the last block of rules to be checked against, where the rule for checking the second knock (7777) requires a recent knock on the first port and only then may set the next recent list (SSH1). This switch brings the sequencing of the lists.\n\n```\n-A TRAFFIC -m state --state NEW -m tcp -p tcp --dport 8881 -m recent --name SSH0 --set -j DROP\n-A SSH-INPUT -m recent --name SSH1 --set -j DROP\n-A SSH-INPUTTWO -m recent --name SSH2 --set -j DROP\n-A TRAFFIC -j DROP\nCOMMIT\n```\n\nNote that the traffic is dropped in the last rules too, although a correct port is knocked. This DROP disguises that the connection attempt was a successful knock for any of them.\n\nNow that the rules are complete, do a daemon-reload and restart iptables.service with with the rules.\n\nExample of iptables.rules file after running all the commands from above:\n\n```\n*filter\n:INPUT DROP [0:0]\n:FORWARD DROP [0:0]\n:OUTPUT ACCEPT [0:0]\n:TRAFFIC - [0:0]\n:SSH-INPUT - [0:0]\n:SSH-INPUTTWO - [0:0]\n# TRAFFIC chain for Port Knocking. The correct port sequence in this example is  8881 -> 7777 -> 9991; any other sequence will drop the traffic\n-A INPUT -j TRAFFIC\n-A TRAFFIC -p icmp --icmp-type any -j ACCEPT\n-A TRAFFIC -m state --state ESTABLISHED,RELATED -j ACCEPT\n-A TRAFFIC -m state --state NEW -m tcp -p tcp --dport 22 -m recent --rcheck --seconds 30 --name SSH2 -j ACCEPT\n-A TRAFFIC -m state --state NEW -m tcp -p tcp -m recent --name SSH2 --remove -j DROP\n-A TRAFFIC -m state --state NEW -m tcp -p tcp --dport 9991 -m recent --rcheck --name SSH1 -j SSH-INPUTTWO\n-A TRAFFIC -m state --state NEW -m tcp -p tcp -m recent --name SSH1 --remove -j DROP\n-A TRAFFIC -m state --state NEW -m tcp -p tcp --dport 7777 -m recent --rcheck --name SSH0 -j SSH-INPUT\n-A TRAFFIC -m state --state NEW -m tcp -p tcp -m recent --name SSH0 --remove -j DROP\n-A TRAFFIC -m state --state NEW -m tcp -p tcp --dport 8881 -m recent --name SSH0 --set -j DROP\n-A SSH-INPUT -m recent --name SSH1 --set -j DROP\n-A SSH-INPUTTWO -m recent --name SSH2 --set -j DROP\n-A TRAFFIC -j DROP\nCOMMIT\n# END or further rules\n```\n\n"
    },
    {
      "title": "With nftables only",
      "level": 4,
      "content": "Port knocking examples with nftables only.\n\n"
    },
    {
      "title": "Client script",
      "level": 3,
      "content": "Now that configuration is done, to do the port knocking you will need a tool. knockd, mentioned above, comes with the knock tool, which is simple and probably sufficient for many requirements. The upstream site has the knock tool for other OSs.\n\nnmap can also be used here. A simple shell script (knock) automates the port knocking:\n\n```\n/usr/local/bin/knock\n```\n\n```\n#!/bin/bash\nHOST=$1\nshift\nfor ARG in \"$@\"\ndo\n        nmap -Pn --host-timeout 100 --max-retries 0 -p $ARG $HOST\ndone\n```\n\nAlternatively, you could use openbsd-netcat and simply set a shell alias:\n\n```\nalias knock=\"nc -z\"\n```\n\nYou can call all above methods with knock HOST PORT1 PORT2 PORTx.\n\nIn the following we use the script. In order not to have adverse effects from other ongoing networking, this test has been done on localhost.\n\nFirst, the IP for SSHD to listen to is setup, after pulling the network cable:\n\n```\n[user@host ~]# ip link set up dev enp8s0\n[user@host ~]# ip address add 192.168.1.1/24 dev enp8s0\n[user@host ~]# ip route add default via 192.168.1.1\n[user@host ~]# systemctl status sshd |grep listening\nAug 21 14:36:53 host sshd[3572]: Server listening on 192.168.1.1 port 22\n```\n\nSecond, it is checked if SSHD accepts connections and then the script is executed, followed by a successful SSH login:\n\n```\n$ ssh user@host # No response (Ctrl+c to exit)\n^C\n$ knock host 8881 7777 9991\n$ ssh user@host           # Now logins are allowed\nuser@host's password:\nLast login: Tue Aug 20 23:00:27 2013 from host\n```\n\nThe first connection attempt has to be stopped, because the DROP of the connection sends no reply. For testing purposes one can change the last rules' DROP to REJECT, which will return a connection refused instead. Finally, right after the successful login, one can see the successful knocks in the kernel's recent lists:\n\n```\n[user@host ~]$ cat /proc/net/xt_recent/SSH*\nsrc=192.168.1.1 ttl: 64 last_seen: 296851 oldest_pkt: 1 296851\nsrc=192.168.1.1 ttl: 64 last_seen: 297173 oldest_pkt: 1 297173\nsrc=192.168.1.1 ttl: 64 last_seen: 297496 oldest_pkt: 1 297496\n[user@host ~]$ exit\nlogout\nConnection to 192.168.1.1 closed.\n```\n\n"
    },
    {
      "title": "fwknop",
      "level": 2,
      "content": "fwknop attempts to overcome some of the limitations mentioned above for simpler port knocking method. At the price of higher complexity and resource usage, mainly for the server to be protected. It provides port knocking and Single Package Authorization (SPA). It achieves its goals by using libpcap and a cryptographic method. The usage of libpcap, which is the underlying library beneath tcpdump, enables it to examine all the incoming packets. Including packets the firewall does not let through. And including packets that no service is openly listens to. The usage of cryptography prevents an attacker from bypassing fwknop by retransmitting previous packets.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Port knocking homepage (archived)\n\n"
    }
  ]
}