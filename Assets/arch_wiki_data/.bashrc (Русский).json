{
  "title": ".bashrc (Русский)",
  "url": "https://wiki.archlinux.org/title/.bashrc_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Bash/Функции\n- Bash/Настройка приглашения\n- Переменные окружения\n- Readline (Русский)\n- Fortune\n- Pkgfile (Русский)\n- Командная оболочка\n\nBash (Bourne-again Shell) — командная оболочка/язык программирования проекта GNU. Название представляет собой отсылку к предшественнику, существовавшей некогда командной оболочке Борна (Bourne shell). Bash работает в большинстве UNIX-подобных операционных систем, в том числе и в GNU/Linux.\n\nВ Arch Linux Bash является командной оболочкой, используемой по умолчанию.\n\n"
    },
    {
      "title": "Запуск",
      "level": 2,
      "content": "Поведение Bash зависит от способа, каким он был запущен.\n\nЕсли Bash был вызван в TTY в процессе работы команды login, демоном SSH или другим схожим образом, то он считается оболочкой входа (login shell). Этот режим также можно выбрать флагом -l/--login.\n\nBash считается интерактивной оболочкой (interactive shell), если его стандартные потоки ввода/вывода/ошибок подключены к терминалу (например, при запуске в эмуляторе терминала), причём запуск выполнялся без опции -c и не с неопциональным аргументом (вроде bash скрипт). Все интерактивные оболочки при запуске считывают файлы /etc/bash.bashrc и ~/.bashrc, а интерактивные оболочки входа — также /etc/profile и ~/.bash_profile.\n\n"
    },
    {
      "title": "Файлы настроек",
      "level": 3,
      "content": "В зависимости от способа запуска Bash считывает и исполняет определённый набор файлов. Подробнее см. раздел Bash Startup Files справочного руководства GNU Bash.\n\nTable content:\nФайл | Описание | Оболочки входа (см. примечание) | Интерактивные оболочки (не входа)\n/etc/profile | Системный, считывает и исполняет файлы /etc/profile.d/*.sh и /etc/bash.bashrc с настройками приложений. | Да | Нет\n~/.bash_profile | Пользовательский, исполняется после /etc/profile. Если не существует, проверяются ~/.bash_login и ~/.profile (в указанном порядке). Файл-образец /etc/skel/.bash_profile содержит также указание на исполнение файла ~/.bashrc. | Да | Нет\n~/.bash_logout | Пользовательский, исполняется после выхода из оболочки входа. | Да | Нет\n/etc/bash.bash_logout | Системный, исполняется после выхода из оболочки входа. Зависит от флага компиляции -DSYS_BASH_LOGOUT=\"/etc/bash.bash_logout\". | Да | Нет\n/etc/bash.bashrc | Системный, исполняет файл /usr/share/bash-completion/bash_completion. Зависит от флага компиляции -DSYS_BASHRC=\"/etc/bash.bashrc\". | Нет | Да\n~/.bashrc | Пользовательский, исполняется после /etc/bash.bashrc. | Нет | Да\n\nNote: **не** \n\n- Оболочка входа будет неинтерактивной, если вызывается с флагом --login.\n- Интерактивные оболочки (не входа) не исполняют файл ~/.bash_profile, они наследуют окружение от родительского процесса (которым может быть в том числе и оболочка входа). Подробнее см. GregsWiki:ProcessManagement#On processes, environments and inheritance.\n\n"
    },
    {
      "title": "Оболочка и переменные окружения",
      "level": 3,
      "content": "Поведение оболочки Bash и запущенных в ней программ зависит от переменных окружения. Переменные окружения хранят значения различных параметров оболочки, например, расположение каталогов с исполняемыми файлами или название используемого по умолчанию браузера. При запуске новой оболочки или сценария они наследуют переменные окружения родительского процесса, то есть начинают работу с набором переменных исходной оболочки [1].\n\nДля создания переменной окружения необходимо экспортировать переменную оболочки:\n\n```\nVARIABLE=content\nexport VARIABLE\n```\n\nили более кратко:\n\n```\nexport VARIABLE=content\n```\n\nПеременные окружения принято перечислять в файлах ~/.profile или /etc/profile, чтобы другие Bourne-совместимые оболочки могли их использовать.\n\nПодробнее см. Переменные окружения.\n\n"
    },
    {
      "title": "Командная строка",
      "level": 2,
      "content": "Командная строка Bash работает под управлением библиотеки Readline. Readline позволяет использовать комбинации клавиш в стиле emacs и vi для взаимодействия с командной строкой, например, для перемещения назад и вперёд целыми словами, удаления слов и т.д. Кроме того, Readline отвечает за хранение истории выполненных команд, а также позволяет создавать макросы.\n\n"
    },
    {
      "title": "Автодополнение",
      "level": 3,
      "content": "Автодополнение (tab completion) — завершение вводимых команд по нажатию клавиши Tab (работает по умолчанию).\n\n"
    },
    {
      "title": "Одиночное нажатие",
      "level": 4,
      "content": "Вывести список возможных завершений для частично введённой команды можно несколькими повторными нажатиями клавиши Tab — иногда двумя или тремя. В статье Readline#Быстрое завершение описано, как уменьшить количество нажатий до одного.\n\n"
    },
    {
      "title": "Дополнительные программы и опции",
      "level": 4,
      "content": "По умолчанию Bash позволяет дополнять команды, имена файлов и переменные. Пакет bash-completion добавляет автодополнение для наиболее распространённых команд и их опций, которые можно включить, считав и исполнив файл /usr/share/bash-completion/bash_completion (обычно считывается автоматически в /etc/bash.bashrc). С пакетом bash-completion обычные завершения (вроде $ ls file.*<tab><tab>) будут вести себя немного по-другому, вернуть старое поведение можно командой $ compopt -o bashdefault программа (подробнее см. [2] и [3]).\n\n"
    },
    {
      "title": "Настройки для команд",
      "level": 4,
      "content": "По умолчанию Bash помогает завершать только имена файлов, которые следуют за командой. Это можно перенастроить командой complete -c, чтобы дополнялись и определённые команды:\n\n```\n~/.bashrc\n```\n\n```\ncomplete -c man which\n```\n\nС флагами -cf завершаться будут и команды, и имена файлов после них:\n\n```\ncomplete -cf sudo\n```\n\nДругие опции автодополнения можно найти в руководстве Bash.\n\n"
    },
    {
      "title": "Автодополнение истории",
      "level": 4,
      "content": "Клавиши стрелок \"вверх\" и \"вниз\" можно назначить для поиска команд в истории (см. Readline#История команд и Синтаксис init-файлов Readline):\n\n```\n~/.bashrc\n```\n\n```\nbind '\"\\e[A\": history-search-backward'\nbind '\"\\e[B\": history-search-forward'\n```\n\nИли же, чтобы это работало во всех программах Readline:\n\n```\n~/.inputrc\n```\n\n```\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n```\n\n"
    },
    {
      "title": "Сокращение истории",
      "level": 4,
      "content": "Переменная HISTCONTROL позволяет предотвратить логирование некоторых команд. Например, чтобы одинаковые команды не попадали в историю, присвойте переменной следующее значение:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=ignoredups\n```\n\nЕсли же задать значение erasedups, то дополнительно из истории будут удалены уже существующие дубликаты команд. Подробнее см. руководство Bash.\n\n"
    },
    {
      "title": "Отключение истории",
      "level": 4,
      "content": "Чтобы временно отключить историю, выполните:\n\n```\n$ set +o history\n```\n\nПосле этого вводимые команды не будут сохраняться в $HISTFILE.\n\nТеперь можно выполнять \"чувствительные\" в плане безопасности действия, вроде вычисления хэш-суммы пароля (printf secret | sha256sum) или работы с GPG (gpg -eaF secret-pubkey.asc), не опасаясь, что секретный ключ будет сохранён на диск.\n\nВключить историю обратно можно командой\n\n```\n$ set -o history\n```\n\nЧтобы отключить всю историю Bash:\n\n```\n~/.bashrc или /etc/profile\n```\n\n```\nexport HISTSIZE=0\n```\n\nПосле необходимо удалить старый файл истории (имейте в виду — команды ниже удалят его безвозвратно):\n\n```\n$ wipe -i -l2 -x4 -p4 \"$HISTFILE\"\n$ ln -sv /dev/null \"$HISTFILE\"\n```\n\n"
    },
    {
      "title": "run-help из Zsh",
      "level": 3,
      "content": "В Zsh есть возможность вызывать справочное руководство для команды перед курсором по комбинации клавиш Alt+h. В Bash то же самое можно сделать с помощью привязки комбинации клавиш в Readline:\n\n```\n~/.bashrc\n```\n\n```\nrun-help() { help \"$READLINE_LINE\" 2>/dev/null || man \"$READLINE_LINE\"; }\nbind -m vi-insert -x '\"\\eh\": run-help'\nbind -m emacs -x     '\"\\eh\": run-help'\n```\n\nПредполагается, что вы используете (стандартный) режим редактирования Emacs.\n\n"
    },
    {
      "title": "Псевдонимы",
      "level": 2,
      "content": "alias (англ. псевдоним) — команда для замены одной строки на другую. Часто используется для сокращения системных команд до аббревиатур или для добавления стандартных аргументов к часто используемым командам.\n\nПользовательские псевдонимы хранятся в файле ~/.bashrc, а системные (для всех пользователей) — в /etc/bash.bashrc. Примеры можно посмотреть в [4].\n\nФункции Bash подробно описаны в Bash/Функции.\n\n"
    },
    {
      "title": "Настройка приглашения",
      "level": 3,
      "content": "См. Bash/Настройка приглашения.\n\n"
    },
    {
      "title": "Подстветка синтаксиса и подсказки",
      "level": 3,
      "content": "blesh-gitAUR — редактор командной строки, который написан на чистом Bash и предназначен заменить Readline. Предлагает множество дополнительных возможностей вроде подстветки синтаксиса, подсказок, завершения команд с выпадающим меню, аббревиатур, режима редактирования Vim, хук-функций и т.д.\n\nПосле установки необходимо считать и выполнить его в интерактивном сеансе. Настройки подробно объясняются в файле ~/.blerc и wiki. Доступна также стабильная сборка bleshAUR.\n\n"
    },
    {
      "title": "Command not found",
      "level": 3,
      "content": "В pkgfile есть хук \"command not found\", который при вводе неизвестной команды автоматически ищет подходящий исполняемый файл в пакетах в официальных репозиториях.\n\nЧтобы хук заработал, его необходимо считать и исполнить:\n\n```\n~/.bashrc\n```\n\n```\nsource /usr/share/doc/pkgfile/command-not-found.bash\n```\n\nПосле этого при попытке запустить недоступную команду будет выведена следующая информация:\n\n```\n$ abiword\n```\n\n```\nabiword may be found in the following packages:\n  extra/abiword 3.0.1-2\t/usr/bin/abiword\n```\n\n"
    },
    {
      "title": "Отключение комбинации Ctrl+z",
      "level": 3,
      "content": "Нажатие Ctrl+z в терминале ставит приложение на паузу или закрывает его. Отключить эту комбинацию клавиш можно следующим образом:\n\n```\n#!/bin/bash\ntrap \"\" 20\nadom\n```\n\nЕсли после этого во время работы adomAUR вы по ошибке вместо Shift+z нажмёте комбинацию Ctrl+z, то она будет проигнорирована и ничего не произойдёт.\n\n"
    },
    {
      "title": "Очистка экрана после выхода",
      "level": 3,
      "content": "Очистка экрана виртуального терминала после выхода:\n\n```\n~/.bash_logout\n```\n\n```\nclear\nreset\n```\n\n"
    },
    {
      "title": "Смена каталога при вводе пути",
      "level": 3,
      "content": "Bash может автоматически добавлять команду cd , если введён только путь к каталогу. Стандартное поведение:\n\n```\n$ /etc\n```\n\n```\nbash: /etc: Is a directory\n```\n\nЕсли же добавить в .bashrc строку\n\n```\n~/.bashrc\n```\n\n```\n...\nshopt -s autocd\n...\n```\n\nто произойдёт следующее:\n\n```\n[user@host ~]$ /etc\ncd /etc\n[user@host etc]$\n```\n\n"
    },
    {
      "title": "Autojump",
      "level": 3,
      "content": "autojump-gitAUR позволяет перемещаться по файловой системе с помощью поиска строк в базе данных с часто посещаемыми путями. Чтобы приложение заработало, после установки необходимо считать и выполнить файл /etc/profile.d/autojump.bash.\n\n"
    },
    {
      "title": "Запрет на перезапись файлов",
      "level": 3,
      "content": "Отключение перезаписи файлов с помощью перенаправления вывода на время текущего сеанса:\n\n```\n$ set -o noclobber\n```\n\nКоманда set -C делает то же самое.\n\nСделать изменения постоянными:\n\n```\n~/.bashrc\n```\n\n```\nset -o noclobber\n```\n\nПринудительно перезаписать файл при установленном noclobber:\n\n```\n$ echo \"output\" >| file.txt\n```\n\n"
    },
    {
      "title": "Перенос строк при изменении размера окна",
      "level": 3,
      "content": "При изменении размера окна эмулятора терминала Bash может не получить соответствующий сигнал. В результате выведенный текст будет переноситься некорректно и перекроет приглашение командной строки. Опция оболочки checkwinsize проверяет размер окна после каждой команды и при необходимости обновляет значения переменных LINES и COLUMNS.\n\n```\n~/.bashrc\n```\n\n```\nshopt -s checkwinsize\n```\n\n"
    },
    {
      "title": "Оболочка завершается даже с опцией ignoreeof",
      "level": 3,
      "content": "После задания опции ignoreeof вы можете обнаружить, что многократное нажатие Ctrl-d всё равно приводит к завершению процесса оболочки. Дело в том, что по умолчанию эта опция позволяет игнорировать только 10 нажатий данной комбинации клавиш (если быть точным — 10 ситуаций EOF) перед выходом из оболочки.\n\nЗадать большее значение можно переменной IGNOREEOF. Например:\n\n```\nexport IGNOREEOF=100\n```\n\n"
    },
    {
      "title": "Анализ сценария и поиск ошибок",
      "level": 3,
      "content": "Программа shellcheck проверяет сценарии Bash (и других командных оболочек) на предмет ошибок и предлагает возможные улучшения кода.\n\nСуществует также веб-сайт shellcheck.net, разработанный на основе одноименной программы и предназначенный для той же цели.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Wikipedia:ru:Bash\n- Справочное руководство Bash, также локально в файле /usr/share/doc/bash/bashref.html\n- Синтаксис init-файлов Readline\n- The Bourne-Again Shell — Третья глава книги The Architecture of Open Source Applications\n- PS1 generator — Наглядное создание приглашения Bash с помощью мыши\n- Полезные команды для .bashrc\n\n"
    },
    {
      "title": "Обучение",
      "level": 3,
      "content": "- Greg's Wiki\n- GregsWiki:BashGuide\n- GregsWiki:BashFAQ\n- Quote Tutorial\n\n"
    },
    {
      "title": "Сообщество",
      "level": 3,
      "content": "- Активный и дружелюбный IRC-канал Bash\n\n"
    },
    {
      "title": "Примеры",
      "level": 3,
      "content": "- Как изменить название окна xterm\n\n"
    }
  ]
}