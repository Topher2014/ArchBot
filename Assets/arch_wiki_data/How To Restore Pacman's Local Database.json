{
  "title": "How To Restore Pacman's Local Database",
  "url": "https://wiki.archlinux.org/title/How_To_Restore_Pacman%27s_Local_Database",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Signs that pacman needs a local database restoration:\n\n- pacman -Q gives absolutely no output, and pacman -Syu erroneously reports that the system is up to date.\n- When trying to install a package using pacman -S package, and it outputs a list of already satisfied dependencies.\n\nMost likely, pacman's database of installed software, /var/lib/pacman/local, has been corrupted or deleted. While this is a serious problem, it can be restored by following the instructions below.\n\nFirstly, make sure pacman's log file is present:\n\n```\n$ ls /var/log/pacman.log\n```\n\nIf it does not exist, it is not possible to continue with this method. You may be able to use Xyne's package detection script to recreate the database. If not, then the likely solution is to re-install the entire system.\n\n"
    },
    {
      "title": "Generating the package recovery list",
      "level": 2,
      "content": "Install the pacman-contrib package to get paclog-pkglist.\n\nCreate the log filter script and make it executable:\n\n```\npacrecover\n```\n\n```\n#!/bin/bash -e\n\n# load configuration settings from the makepkg configuration file\n. /etc/makepkg.conf\n\n# determine the cache directory from pacman configuration, defaulting to /var/cache/pacman/pkg, remove prefix with sed\nPKGCACHE=$( (grep -m 1 '^CacheDir' /etc/pacman.conf || echo 'CacheDir = /var/cache/pacman/pkg') | sed 's/CacheDir = //')\n\n# define directories to search for package files\npkgdirs=(\"$@\" \"$PKGDEST\" \"$PKGCACHE\")\n\n# read package name and version from input and construct a search pattern for package files\nwhile read -r -a parampart; do\n\n        # loop through each directory to search for matching package files\n        for pkgdir in \"${pkgdirs[@]}\"; do\n\n                # check each file matching the pattern in the current directory\n                for i in \"$pkgdir\"/\"${parampart[0]}\"-\"${parampart[1]}\"-*.pkg.tar.{xz,zst} ; do\n\n                        # if a file exists, print its path and stop checking further\n                        [ -f \"${i}\" ] && { echo \"${i}\" ; break; };\n                done\n\n                # If no file is found, output the package name to stderr\n        done || echo \"${parampart[0]}\" 1>&2 \ndone\n```\n\nRun the script (optionally passing additional directories with packages as parameters):\n\n```\n$ paclog-pkglist /var/log/pacman.log | ./pacrecover >files.list 2>pkglist.orig\n```\n\nThis way two files will be created: files.list with package files, still present on machine and pkglist.orig, packages from which should be downloaded. Later operation may result in mismatch between files of older versions of package, still present on machine, and files, found in new version. Such mismatches will have to be fixed manually.\n\nHere is a way to automatically restrict second list to packages available in a repository:\n\n```\n$ { cat pkglist.orig; pacman -Slq; } | sort | uniq -d > pkglist\n```\n\nNote: **retry the previous command** \n\nCheck if some important base packages are missing, and add them to the list:\n\n```\n$ comm -23 <({ echo base ; expac -l '\\n' '%E' base; } | sort) pkglist.orig >> pkglist\n```\n\nProceed once the contents of both lists are satisfactory, since they will be used to restore pacman's installed package database; /var/lib/pacman/local/.\n\n"
    },
    {
      "title": "Performing the recovery",
      "level": 2,
      "content": "Define a bash function for recovery purposes:\n\n```\nrecovery-pacman() {\n    pacman \"$@\"  \\\n    --log /dev/null   \\\n    --noscriptlet     \\\n    --dbonly          \\\n    --overwrite \"*\"   \\\n    --nodeps          \\\n    --needed\n}\n```\n\n--log /dev/null allows to avoid needless pollution of pacman log, --needed will save some time by skipping packages, already present in database, --nodeps will allow installation of cached packages, even if packages being installed depend on newer versions. Rest of options will allow pacman to operate without reading/writing filesystem.\n\nPopulate the sync database:\n\n```\n# pacman -Sy\n```\n\nStart database generation by installing locally available package files from files.list:\n\n```\n# recovery-pacman -U $(< files.list)\n```\n\nInstall the rest from pkglist:\n\n```\n# recovery-pacman -S $(< pkglist)\n```\n\nUpdate the local database so that packages that are not required by any other package are marked as explicitly installed and the other as dependences. You will need to be extra careful in the future when removing packages, but with the original database lost, it is the best we can do.\n\n```\n# pacman -D --asdeps $(pacman -Qq)\n# pacman -D --asexplicit $(pacman -Qtq)\n```\n\nOptionally check all installed packages for corruption:\n\n```\n# pacman -Qk\n```\n\nOptionally Pacman/Tips and tricks#Identify files not owned by any package.\n\nUpdate all packages:\n\n```\n# pacman -Su\n```\n\n"
    }
  ]
}