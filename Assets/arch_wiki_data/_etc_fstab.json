{
  "title": "/etc/fstab",
  "url": "https://wiki.archlinux.org/title//etc/fstab",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Persistent block device naming\n- File systems\n- tmpfs\n- swap\n- genfstab\n\nThe fstab(5) file can be used to define how disk partitions, various other block devices, or remote file systems should be mounted into the file system.\n\nEach file system is described in a separate line. These definitions will be converted into systemd mount units dynamically at boot, and when the configuration of the system manager is reloaded. The default setup will automatically fsck and mount file systems before starting services that need them to be mounted. For example, systemd automatically makes sure that remote file system mounts like NFS or Samba are only started after the network has been set up. Therefore, local and remote file system mounts specified in /etc/fstab should work out-of-the-box. See systemd.mount(5) for details.\n\nThe mount command will use fstab, if just one of either directory or device is given, to fill in the value for the other parameter. When doing so, mount options which are listed in fstab will also be used.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n"
    },
    {
      "title": "Usage",
      "level": 2,
      "content": "A simple /etc/fstab, using file system UUIDs:\n\n```\n/etc/fstab\n```\n\n```\n# <device>                                <dir> <type> <options>                                        <dump> <fsck>\nUUID=0a3407de-014b-458b-b5c1-848e92a327a3 /     ext4 defaults                                           0      1\nUUID=CBB6-24F2                            /boot vfat defaults,nodev,nosuid,noexec,fmask=0177,dmask=0077 0      2\nUUID=f9fe0b69-a280-415d-a03a-a32752370dee none  swap defaults                                           0      0\nUUID=b411dc99-f0a0-4c87-9e05-184977be8539 /home ext4 defaults                                           0      2\n```\n\n- <device> describes the block special device or remote file system to be mounted; see #Identifying file systems.\n- <dir> is the directory where the file system will be mounted to, aka the mountpoint. The directory must be created beforehand.\n- <type> is the file system type.\n- <options> are the file system mount options; see mount(8) ยง FILESYSTEM-INDEPENDENT MOUNT OPTIONS and ext4(5) ยง Mount options for ext4.\n- <dump> is checked by the dump(8) utility. This field is usually set to 0, which disables the check.\n- <fsck> sets the order for file system checks at boot time; see fsck(8). For the root device it should be 1. For other partitions it should be 2, or 0 to disable checking.\n\n- The auto type lets the mount command guess what type of file system is used. This is useful for optical media (CD/DVD/Blu-ray).\n- If the root file system is btrfs or XFS, the fsck order should be set to 0 instead of 1. See fsck.btrfs(8) and fsck.xfs(8).\n\nAll specified devices within /etc/fstab will be automatically mounted on startup and when the -a flag is used with mount(8) unless the noauto option is specified. Devices that are listed and not present will result in an error unless the nofail option is used.\n\nSee fstab(5) ยง DESCRIPTION for details.\n\n"
    },
    {
      "title": "Identifying file systems",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nThere are different ways to identify file systems that will be mounted in /etc/fstab: kernel name descriptor, file system label and UUID, and GPT partition label and UUID for GPT disks. Kernel name descriptors should not be used, while UUIDs or PARTUUIDs should be preferred over labels. See Persistent block device naming for more explanations. It is recommended to read that article first before continuing with this article.\n\nIn this section, we will describe how to mount file systems using all the mount methods available via examples. The output of the commands lsblk -f and blkid used in the following examples are available in the article Persistent block device naming.\n\n"
    },
    {
      "title": "Kernel name descriptors",
      "level": 3,
      "content": "Run lsblk -f to list the partitions and prefix the values in the NAME column with /dev/.\n\n```\n/etc/fstab\n```\n\n```\n# <device <dir> <type> <options>                                          <dump> <fsck>\n/dev/sda2 /     ext4   defaults                                           0      1\n/dev/sda1 /boot vfat   defaults,nodev,nosuid,noexec,fmask=0177,dmask=0077 0      2\n/dev/sda3 /home ext4   defaults                                           0      2\n/dev/sda4 none  swap   defaults                                           0      0\n```\n\n"
    },
    {
      "title": "File system labels",
      "level": 3,
      "content": "Run lsblk -f to list the partitions, and prefix the values in the LABEL column with LABEL= or alternatively run blkid and use the LABEL values without the quotes:\n\n```\n/etc/fstab\n```\n\n```\n# <device>   <dir> <type> <options>                                          <dump> <fsck>\nLABEL=System /     ext4   defaults                                           0      1\nLABEL=ESP    /boot vfat   defaults,nodev,nosuid,noexec,fmask=0177,dmask=0077 0      2\nLABEL=Data   /home ext4   defaults                                           0      2\nLABEL=Swap   none  swap   defaults                                           0      0\n```\n\n"
    },
    {
      "title": "File system UUIDs",
      "level": 3,
      "content": "Run lsblk -f to list the partitions, and prefix the values in the UUID column with UUID= or alternatively run blkid and use the UUID values without the quotes:\n\n```\n/etc/fstab\n```\n\n```\n# <device>                                <dir> <type> <options>                                        <dump> <fsck>\nUUID=0a3407de-014b-458b-b5c1-848e92a327a3 /     ext4 defaults                                           0      1\nUUID=CBB6-24F2                            /boot vfat defaults,nodev,nosuid,noexec,fmask=0177,dmask=0077 0      2\nUUID=b411dc99-f0a0-4c87-9e05-184977be8539 /home ext4 defaults                                           0      2\nUUID=f9fe0b69-a280-415d-a03a-a32752370dee none  swap defaults                                           0      0\n```\n\n"
    },
    {
      "title": "GPT partition labels",
      "level": 3,
      "content": "Run blkid to list the partitions, and use the PARTLABEL values without the quotes:\n\n```\n/etc/fstab\n```\n\n```\n# <device>                           <dir> <type> <options>                                        <dump> <fsck>\nPARTLABEL=GNU/Linux                  /     ext4 defaults                                           0      1\nPARTLABEL=EFI\\040system\\040partition /boot vfat defaults,nodev,nosuid,noexec,fmask=0177,dmask=0077 0      2\nPARTLABEL=Home                       /home ext4 defaults                                           0      2\nPARTLABEL=Swap                       none  swap defaults                                           0      0\n```\n\n"
    },
    {
      "title": "GPT partition UUIDs",
      "level": 3,
      "content": "Run blkid to list the partitions, and use the PARTUUID values without the quotes:\n\n```\n/etc/fstab\n```\n\n```\n# <device>                                    <dir> <type> <options>                                        <dump> <fsck>\nPARTUUID=98a81274-10f7-40db-872a-03df048df366 /     ext4 defaults                                           0      1\nPARTUUID=d0d0d110-0a71-4ed6-936a-304969ea36af /boot vfat defaults,nodev,nosuid,noexec,fmask=0177,dmask=0077 0      2\nPARTUUID=7280201c-fc5d-40f2-a9b2-466611d3d49e /home ext4 defaults                                           0      2\nPARTUUID=039b6c1c-7553-4455-9537-1befbc9fbc5b none  swap defaults                                           0      0\n```\n\n"
    },
    {
      "title": "Automount with systemd",
      "level": 3,
      "content": "See systemd.mount(5) for all systemd mount options.\n\n"
    },
    {
      "title": "Local partition",
      "level": 4,
      "content": "In case of a large partition, it may be more efficient to allow services that do not depend on it to start while it is checked by fsck. This can be achieved by adding the following options to the /etc/fstab entry of the partition:\n\n```\nx-systemd.automount\n```\n\nThis will fsck and mount the partition only when it is first accessed, and the kernel will buffer all file access to it until it is ready. This method can be relevant if one has, for example, a significantly large /home partition.\n\n"
    },
    {
      "title": "Remote file system",
      "level": 4,
      "content": "The same applies to remote file system mounts. If you want them to be mounted only upon access, you will need to use the x-systemd.automount parameters. In addition, you can use the x-systemd.mount-timeout= option to specify how long systemd should wait for the mount command to finish. Also, the _netdev option ensures systemd understands that the mount is network dependent and order it after the network is online.\n\n```\nx-systemd.automount,x-systemd.mount-timeout=30,_netdev\n```\n\n"
    },
    {
      "title": "Encrypted file system",
      "level": 4,
      "content": "Note: **This article or section is a candidate for merging with dm-crypt/System configuration#Mounting on demand.** This article or section is a candidate for merging with dm-crypt/System configuration#Mounting on demand.\n\nThis article or section is a candidate for merging with dm-crypt/System configuration#Mounting on demand.\n\nIf you have encrypted file systems with keyfiles, you can also add the noauto parameter to the corresponding entries in /etc/crypttab. systemd will then not open the encrypted device on boot, but instead wait until it is actually accessed and then automatically open it with the specified keyfile before mounting it. This might save a few seconds on boot if you are using an encrypted RAID device for example, because systemd does not have to wait for the device to become available. For example:\n\n```\n/etc/crypttab\n```\n\n```\ndata /dev/md/MyRAIDArray /etc/cryptsetup-keys.d/data.key noauto\n```\n\n"
    },
    {
      "title": "Automatic unmount",
      "level": 4,
      "content": "You may also specify an idle timeout for a mount with the x-systemd.idle-timeout flag. For example:\n\n```\nx-systemd.automount,x-systemd.idle-timeout=1min\n```\n\nThis will make systemd unmount the mount after it has been idle for 1 minute.\n\n"
    },
    {
      "title": "External devices",
      "level": 3,
      "content": "External devices that are to be mounted when present but ignored if absent may require the nofail option. This prevents errors being reported at boot. For example:\n\n```\n/etc/fstab\n```\n\n```\nLABEL=MyExternalDrive /media/backup    jfs    nofail,x-systemd.device-timeout=5    0  2\n```\n\nThe nofail option is best combined with the x-systemd.device-timeout option. This is because the default device timeout is 90 seconds, so a disconnected external device with only nofail will make your boot take 90 seconds longer, unless you reconfigure the timeout as shown. Make sure not to set the timeout to 0, as this translates to infinite timeout.\n\n"
    },
    {
      "title": "Filepath spaces",
      "level": 3,
      "content": "Since spaces are used in fstab to delimit fields, if any field (PARTLABEL, LABEL or the mount point) contains spaces, these spaces must be replaced by escape characters \\ followed by the 3 digit octal code 040:\n\n```\n/etc/fstab\n```\n\n```\nUUID=47FA-4071         /home/username/Camera\\040Pictures   vfat  defaults      0  0\nLABEL=Storage\\040drive /media/100\\040GB\\040(Storage)       ext4  defaults,user 0  2\n```\n\n"
    },
    {
      "title": "atime options",
      "level": 3,
      "content": "Below atime options can impact drive performance.\n\n- The strictatime option updates the access time of the files every time they are accessed. This is more purposeful when Linux is used for servers; it does not have much value for desktop use. The drawback about the strictatime option is that even reading a file from the page cache (reading from memory instead of the drive) will still result in a write.\n- The noatime option fully disables writing file access times to the drive every time you read a file. This works well for almost all applications, except for those that need to know if a file has been read since the last time it was modified. The write time information to a file will continue to be updated anytime the file is written to with this option enabled.\n- The nodiratime option disables the writing of file access times only for directories while other files still get access times written. Note: noatime implies nodiratime. You do not need to specify both.\n- relatime updates the access time only if the previous access time was earlier than the current modify or change time. In addition, since Linux 2.6.30, the access time is always updated if the previous access time was more than 24 hours old. This option is used when the defaults option, atime option (which means to use the kernel default, which is relatime; see mount(8) and wikipedia:Stat (system call)#Criticism of atime) or no options at all are specified.\n\nWhen using Mutt or other applications that need to know if a file has been read since the last time it was modified, the noatime option should not be used; using the relatime option is acceptable and still provides a performance improvement.\n\nSince kernel 4.0 there is another related option:\n\n- lazytime reduces writes to disk by maintaining changes to inode timestamps (access, modification and creation times) only in memory. The on-disk timestamps are updated only when either (1) the file inode needs to be updated for some change unrelated to file timestamps, (2) a sync to disk occurs, (3) an undeleted inode is evicted from memory or (4) if more than 24 hours passed since the last time the in-memory copy was written to disk.\n\nNote that the lazytime option works in combination with the aforementioned *atime options, not as an alternative. That is relatime by default, but can be even strictatime with the same or less cost of disk writes as the plain relatime option.\n\n"
    },
    {
      "title": "Remounting the root partition",
      "level": 3,
      "content": "If for some reason the root partition has been improperly mounted read only, remount the root partition with read-write access with the following command:\n\n```\n# mount -o remount,rw /\n```\n\n"
    },
    {
      "title": "GPT partition automounting",
      "level": 3,
      "content": "When using UEFI/GPT, it is possible to omit certain partitions from /etc/fstab by partitioning according to the Discoverable Partitions Specification and have systemd-gpt-auto-generator(8) mount the partitions. See systemd#GPT partition automounting.\n\nTo specify custom mount options for the root volume, use /dev/gpt-auto-root as the device name:\n\n```\n/etc/fstab\n```\n\n```\n/dev/gpt-auto-root  /  ext4  defaults,noatime  0  1\n```\n\n"
    },
    {
      "title": "Bind mount",
      "level": 3,
      "content": "You can link directories with the bind option:\n\n```\n/etc/fstab\n```\n\n```\n# <device>                             <dir>                         <type> <options>     <dump> <fsck>\nUUID=94649E22649E06E0                  /media/user/OS/               ntfs    defaults,rw,errors=remount-ro  0  0\n/media/user/OS/Users/user/Music/       /home/user/Music/             none    defaults,bind 0   0\n/media/user/OS/Users/user/Pictures/    /home/user/Pictures/          none    defaults,bind 0   0\n/media/user/OS/Users/user/Videos/      /home/user/Videos/            none    defaults,bind 0   0\n/media/user/OS/Users/user/Downloads/   /home/user/Downloads/         none    defaults,bind 0   0\n/media/user/OS/Users/user/Documents/   /home/user/Documents/         none    defaults,bind 0   0\n/media/user/OS/Users/user/projects/    /home/user/projects/windows/  none    defaults,bind 0   0\n```\n\nSee mount(8) ยง Bind mount operation for details.\n\n"
    },
    {
      "title": "Automatically generate an fstab using genfstab",
      "level": 3,
      "content": "You can use the genfstab tool to create an fstab file. See genfstab for details.\n\n"
    },
    {
      "title": "GUI utilities",
      "level": 3,
      "content": "Here is a list of programs that can be used to modify mount points. They might not have all the features possible for editing fstab, but have all of the most used ones and might make your workflow much easier:\n\n- GNOME Disks โ A GNOME utility for dealing with storage devices. Part of gnome.\n\n- KDE Partition Manager โ Utility to help you manage the disks, partitions, and file systems on your computer. Part of kde-system.\n\n"
    },
    {
      "title": "Modifying user permissions and ownership",
      "level": 3,
      "content": "If you want to allow any user to mount the drive, consider adding these mount options to add onto your fstab entries.\n\n- users - Allow any user to mount and to unmount the filesystem, even when some other ordinary user mounted it. This option implies the options noexec, nosuid, and nodev (unless overridden by subsequent options, as in the option line users,exec,dev,suid). Simply add users to the mount options to enable this.\n- user - Allow an ordinary user to mount the filesystem. Only allows the same user to unmount. This option implies the options noexec, nosuid, and nodev (unless overridden by subsequent options, as in the option line user,exec,dev,suid). Simply add user to the mount options to enable this.\n\nFor filesystems that do not have file permissions built in such as FAT and exFAT, you can explicitly set the user or group for the entire drive and its files. You can view the ID of a specific user in /etc/passwd. The uid is the third number in the entry, and the group id is the fourth.\n\n- uid - Set the owner ID of the drive\n- gid - Set the group ID of the drive\n\nFor ext4, btrfs, and other filesystems that have permission abilities, other users might not be permitted to see the drive. Be sure to double check the permissions of /path/to/drive/ and modify them for what you need.\n\n"
    },
    {
      "title": "Verify changes",
      "level": 3,
      "content": "Use findmnt --verify --verbose to check for syntax errors and invalid options in fstab.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Full device listing including block device\n- Filesystem Hierarchy Standard\n- 30x Faster Cache and Site Speed with TMPFS\n\n"
    }
  ]
}