{
  "title": "Arptables",
  "url": "https://wiki.archlinux.org/title/Arptables",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- nftables\n- Fail2ban\n- sshguard\n- Simple stateful firewall\n- Sysctl#TCP/IP stack hardening\n- Uncomplicated Firewall\n\niptables is a command line utility for configuring Linux kernel firewall implemented within the Netfilter project. The term iptables is also commonly used to refer to this kernel-level firewall. It can be configured directly with iptables, or by using one of the many console and graphical front-ends. iptables is used for IPv4 and ip6tables is used for IPv6. Both iptables and ip6tables have the same syntax, but some options are specific to either IPv4 or IPv6.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "The stock Arch Linux kernel is compiled with iptables support. You will only need to install the userland utilities, which are provided by the package iptables. The iptables package is an indirect dependency of the base meta package, so it should be installed on your system by default.\n\n"
    },
    {
      "title": "Console",
      "level": 4,
      "content": "- Arno's firewall — Secure firewall for both single and multi-homed machines. Very easy to configure, handy to manage and highly customizable. Supports: NAT and SNAT, port forwarding, ADSL ethernet modems with both static and dynamically assigned IPs, MAC address filtering, stealth port scan detection, DMZ and DMZ-2-LAN forwarding, protection against SYN/ICMP flooding, extensive user definable logging with rate limiting to prevent log flooding, all IP protocols and VPNs such as IPsec, plugin support to add extra features.\n\n- ferm — Tool to maintain complex firewalls, without having the trouble to rewrite the complex rules over and over again. It allows the entire firewall rule set to be stored in a separate file, and to be loaded with one command. The firewall configuration resembles structured programming-like language, which can contain levels and lists.\n\n- FireHOL — Language to express firewalling rules, not just a script that produces some kind of a firewall. It makes building even sophisticated firewalls easy - the way you want it.\n\n- Firetable — Tool to maintain an IPtables firewall. Each interface can be configured separately via its own configuration file, which holds an easy and human readable syntax.\n\n- firewalld (firewall-cmd) — Daemon and console interface for configuring network and firewall zones as well as setting up and configuring firewall rules.\n\n- Shorewall — High-level tool for configuring Netfilter. You describe your firewall/gateway requirements using entries in a set of configuration files.\n\n- Uncomplicated Firewall — Simple front-end for iptables.\n\n- PeerGuardian (pglcmd) — Privacy oriented firewall application. It blocks connections to and from hosts specified in huge block lists (thousands or millions of IP ranges).\n\n- Vuurmuur — Powerful firewall manager. It has a simple and easy to learn configuration that allows both simple and complex configurations. The configuration can be fully configured through an ncurses GUI, which allows secure remote administration through SSH or on the console. Vuurmuur supports traffic shaping, has powerful monitoring features, which allow the administrator to look at the logs, connections and bandwidth usage in realtime.\n\n"
    },
    {
      "title": "Graphical",
      "level": 4,
      "content": "- Firewall Builder — GUI firewall configuration and management tool that supports iptables (netfilter), ipfilter, pf, ipfw, Cisco PIX (FWSM, ASA) and Cisco routers extended access lists. The program runs on Linux, FreeBSD, OpenBSD, Windows and macOS and can manage both local and remote firewalls.\n\n- firewalld (firewall-config) — Daemon and graphical interface for configuring network and firewall zones as well as setting up and configuring firewall rules.\n\n- Gufw — GTK-based front-end to ufw which happens to be a CLI front-end to iptables (gufw->ufw->iptables). It is super easy and super simple to use.\n\n- PeerGuardian GUI (pglgui) — Privacy oriented firewall application. It blocks connections to and from hosts specified in huge block lists (thousands or millions of IP ranges).\n\n- Portmaster — Portmaster is a free and open-source application firewall with defaults to improve your privacy.\n\n"
    },
    {
      "title": "Basic concepts",
      "level": 2,
      "content": "iptables is used to inspect, modify, forward, redirect, and/or drop IP packets. The code for filtering IP packets is already built into the kernel and is organized into a collection of tables, each with a specific purpose. The tables are made up of a set of predefined chains, and the chains contain rules which are traversed in order. Each rule consists of a predicate of potential matches and a corresponding action (called a target) which is executed if the predicate is true; i.e. the conditions are matched. If the IP packet reaches the end of a built-in chain, including an empty chain, then the chain's policy target determines the final destination of the IP packet. iptables is the user utility which allows you to work with these chains/rules. Most new users find the complexities of linux IP routing quite daunting, but, in practice, the most common use cases (NAT and/or basic Internet firewall) are considerably less complex.\n\nThe key to understanding how iptables works is this chart. The lowercase word on top is the table and the uppercase word below is the chain. Every IP packet that comes in on any network interface passes through this flow chart from top to bottom. A common misconception is that packets entering from, say, an internal interface are handled differently than packets from an Internet-facing interface. All interfaces are handled the same way; it is up to you to define rules that treat them differently. Of course, some packets are intended for local processes, hence they come in from the top of the chart and stop at <Local Process>, while other packets are generated by local processes; hence they start at <Local Process> and proceed downward through the flowchart. A detailed explanation of how this flow chart works can be found here.\n\nIn the vast majority of use cases, you will not need to use the raw, mangle, or security tables at all. Consequently, the following chart depicts a simplified network packet flow through iptables:\n\n```\nXXXXXXXXXXXXXXXXXX\n                             XXX     Network    XXX\n                               XXXXXXXXXXXXXXXXXX\n                                       +\n                                       |\n                                       v\n +-------------+              +------------------+\n |table: filter| <---+        | table: nat       |\n |chain: INPUT |     |        | chain: PREROUTING|\n +-----+-------+     |        +--------+---------+\n       |             |                 |\n       v             |                 v\n [local process]     |           ****************          +--------------+\n       |             +---------+ Routing decision +------> |table: filter |\n       v                         ****************          |chain: FORWARD|\n****************                                           +------+-------+\nRouting decision                                                  |\n****************                                                  |\n       |                                                          |\n       v                        ****************                  |\n+-------------+       +------>  Routing decision  <---------------+\n|table: nat   |       |         ****************\n|chain: OUTPUT|       |               +\n+-----+-------+       |               |\n      |               |               v\n      v               |      +-------------------+\n+--------------+      |      | table: nat        |\n|table: filter | +----+      | chain: POSTROUTING|\n|chain: OUTPUT |             +--------+----------+\n+--------------+                      |\n                                      v\n                               XXXXXXXXXXXXXXXXXX\n                             XXX    Network     XXX\n                               XXXXXXXXXXXXXXXXXX\n```\n\n"
    },
    {
      "title": "Tables",
      "level": 3,
      "content": "iptables contains five tables:\n\n1. raw is used only for configuring packets so that they are exempt from connection tracking.\n1. filter is the default table, and is where all the actions typically associated with a firewall take place.\n1. nat is used for network address translation (e.g. port forwarding).\n1. mangle is used for specialized packet alterations.\n1. security is used for Mandatory Access Control networking rules (e.g. SELinux -- see this article for more details).\n\nIn most common use cases, you will only use two of these: filter and nat. The other tables are aimed at complex configurations involving multiple routers and routing decisions and are in any case beyond the scope of these introductory remarks.\n\n"
    },
    {
      "title": "Chains",
      "level": 3,
      "content": "Tables consist of chains, which are lists of rules which are followed in order. The default table, filter, contains three built-in chains: INPUT, OUTPUT and FORWARD which are activated at different points of the packet filtering process, as illustrated in the flow chart. The nat table includes PREROUTING, POSTROUTING, and OUTPUT chains.\n\nSee iptables(8) for a description of built-in chains in other tables.\n\nBy default, none of the chains contain any rules. It is up to you to append rules to the chains that you want to use. Chains do have a default policy, which is generally set to ACCEPT, but can be reset to DROP, if you want to be sure that nothing slips through your ruleset. The default policy always applies at the end of a chain only. Hence, the packet has to pass through all existing rules in the chain before the default policy is applied.\n\nUser-defined chains can be added to make rulesets more efficient or more easily modifiable. See Simple stateful firewall for an example of how user-defined chains are used.\n\n"
    },
    {
      "title": "Rules",
      "level": 3,
      "content": "Packet filtering is based on rules, which are specified by multiple matches (conditions the packet must satisfy so that the rule can be applied), and one target (action taken when the packet matches all conditions). The typical things a rule might match on are what interface the packet came in on (e.g eth0 or eth1), what type of packet it is (ICMP, TCP, or UDP), or the destination port of the packet.\n\nTargets are specified using the -j or --jump option. Targets can be either user-defined chains (i.e. if these conditions are matched, jump to the following user-defined chain and continue processing there), one of the special built-in targets, or a target extension. Built-in targets are ACCEPT, DROP, QUEUE and RETURN, target extensions are, for example, REJECT and LOG. If the target is a built-in target, the fate of the packet is decided immediately and processing of the packet in current table is stopped. If the target is a user-defined chain and the fate of the packet is not decided by this second chain, it will be filtered against the remaining rules of the original chain. Target extensions can be either terminating (as built-in targets) or non-terminating (as user-defined chains), see iptables-extensions(8) for details.\n\n"
    },
    {
      "title": "Traversing Chains",
      "level": 3,
      "content": "A network packet received on any interface traverses the traffic control chains of tables in the order shown in the flow chart. The first routing decision involves deciding if the final destination of the packet is the local machine (in which case the packet traverses through the INPUT chains) or elsewhere (in which case the packet traverses through the FORWARD chains). Subsequent routing decisions involve deciding what interface to assign to an outgoing packet. At each chain in the path, every rule in that chain is evaluated in order and whenever a rule matches, the corresponding target/jump action is executed. The 3 most commonly used targets are ACCEPT, DROP, and jump to a user-defined chain. While built-in chains can have default policies, user-defined chains can not. If every rule in a chain that you jumped fails to provide a complete match, the packet is dropped back into the calling chain; see the following illustration. If at any time a complete match is achieved for a rule with a DROP target, the packet is dropped and no further processing is done. If a packet reaches a jump to the ACCEPT target, it will not traverse any further rules of the chain and subsequent chains of the table. Its processing will jump to the first chain of the next table in order. See also Traversing tables and chains and Accept Target of the frozentux tutorial.\n\n"
    },
    {
      "title": "Modules",
      "level": 3,
      "content": "There are many modules which can be used to extend iptables such as connlimit, conntrack, limit and recent. These modules add extra functionality to allow complex filtering rules.\n\n"
    },
    {
      "title": "Configuration and usage",
      "level": 2,
      "content": "By default, iptables provides an empty set of rules in /etc/iptables/iptables.rules. To be able to load iptables rules automatically on boot, you can enable the iptables.service unit provided by iptables or start the systemd service unit to load iptables rules at once.\n\nSimilarly, iptables rules for IPv6 are, by default, stored in /etc/iptables/ip6tables.rules, which is read by ip6tables.service. You can start it the same way as above.\n\nAfter adding rules via command-line as shown in the following sections, the configuration file is not changed automatically — you have to save it manually:\n\n```\n# iptables-save -f /etc/iptables/iptables.rules\n```\n\nIf you edit the configuration file manually, you have to reload iptables.\n\nOr you can load it directly through iptables:\n\n```\n# iptables-restore /etc/iptables/iptables.rules\n```\n\n"
    },
    {
      "title": "Showing the current rules",
      "level": 4,
      "content": "The basic command to list current rules is --list-rules (-S), which is similar in output format to the iptables-save utility. The main difference of the two is that the latter outputs the rules of all tables per default, while all iptables commands default to the filter table only.\n\nWhen working with iptables on the command line, the --list (-L) command accepts more modifiers and shows more information. For example, you can check the current ruleset and the number of hits per rule by using the command:\n\n```\n# iptables -nvL\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n```\n\nIf the output looks like the above, then there are no rules (i.e. nothing is blocked) in the default filter table. Other tables can be specified with the -t option.\n\nTo show the line numbers when listing rules, append --line-numbers to that input. The line numbers are a useful shorthand when #Editing rules on the command line.\n\n"
    },
    {
      "title": "Resetting rules",
      "level": 4,
      "content": "You can flush and reset iptables to default using these commands:\n\n```\n# iptables -F\n# iptables -X\n# iptables -t nat -F\n# iptables -t nat -X\n# iptables -t mangle -F\n# iptables -t mangle -X\n# iptables -t raw -F\n# iptables -t raw -X\n# iptables -t security -F\n# iptables -t security -X\n# iptables -P INPUT ACCEPT\n# iptables -P FORWARD ACCEPT\n# iptables -P OUTPUT ACCEPT\n```\n\nThe -F command with no arguments flushes all the chains in its current table. Similarly, -X deletes all empty non-default chains in a table.\n\nIndividual chains may be flushed or deleted by following -F and -X with a [chain] argument.\n\n"
    },
    {
      "title": "Editing rules",
      "level": 4,
      "content": "Rules can be edited by appending -A a rule to a chain, inserting -I it at a specific position on the chain, replacing -R an existing rule, or deleting -D it. The first three commands are exemplified in the following.\n\nFirst of all, our computer is not a router (unless, of course, it is a router). We want to change the default policy on the FORWARD chain from ACCEPT to DROP.\n\n```\n# iptables -P FORWARD DROP\n```\n\nThe Dropbox LAN sync feature broadcasts packets every 30 seconds to all computers it can see. If we happen to be on a LAN with Dropbox clients and do not use this feature, then we might wish to reject those packets.\n\n```\n# iptables -A INPUT -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable\n```\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nNow, say we change our mind about Dropbox and decide to install it on our computer. We also want to LAN sync, but only with one particular IP on our network. So we should use -R to replace our old rule. Where 10.0.0.85 is our other IP:\n\n```\n# iptables -R INPUT 1 -p tcp --dport 17500 ! -s 10.0.0.85 -j REJECT --reject-with icmp-port-unreachable\n```\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 REJECT     tcp  --  *      *      !10.0.0.85            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nWe have now replaced our original rule with one that allows 10.0.0.85 to access port 17500 on our computer. But now we realize that this is not scalable. If our friendly Dropbox user is attempting to access port 17500 on our device, we should allow them immediately, not test them against any firewall rules that might come afterwards!\n\nSo we write a new rule to allow our trusted user immediately. Using -I to insert the new rule before our old one:\n\n```\n# iptables -I INPUT -p tcp --dport 17500 -s 10.0.0.85 -j ACCEPT -m comment --comment \"Friendly Dropbox\"\n```\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 ACCEPT     tcp  --  *      *       10.0.0.85            0.0.0.0/0            tcp dpt:17500 /* Friendly Dropbox */\n2        0     0 REJECT     tcp  --  *      *      !10.0.0.85            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nAnd replace our second rule with one that rejects everything on port 17500:\n\n```\n# iptables -R INPUT 2 -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable\n```\n\nOur final rule list now looks like this:\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 ACCEPT     tcp  --  *      *       10.0.0.85            0.0.0.0/0            tcp dpt:17500 /* Friendly Dropbox */\n2        0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\n"
    },
    {
      "title": "Allowing multicast traffic",
      "level": 3,
      "content": "Protocols that use multicast identification (e.g. SANE searching for network scanners) will send traffic to the network's broadcast IP and responses will come back from a specific client's IP. Since these IP addresses are different, iptables will not recognize the response as RELATED or ESTABLISHED, and it will block the response. See [1] for how to accept multicast traffic without creating an overly-permissive firewall.\n\nFirst, create an ipset hash container. The timeout is the window of time to accept client responses.\n\n```\n# ipset create upnp hash:ip,port timeout 3\n```\n\nSecond, create a rule to add outgoing multicast traffic to the ipset hash.\n\n```\n# iptables -A OUTPUT -d 239.255.255.250/32 -p udp -m udp -j SET --add-set upnp src,src --exist\n```\n\nThird, create a rule to allow incoming traffic that matches against the ipset hash.\n\n```\n# iptables -A INPUT -p udp -m set --match-set upnp dst,dst -j ACCEPT\n```\n\nFinally, remember to save the new rules (see #Configuration and usage and ipset#Making ipset persistent), and ensure iptables.service and ipset.service are enabled so the rules load upon system start.\n\n"
    },
    {
      "title": "Guides",
      "level": 3,
      "content": "- Simple stateful firewall\n- Router\n\n"
    },
    {
      "title": "Logging",
      "level": 2,
      "content": "The LOG target can be used to log packets that hit a rule. Unlike other targets like ACCEPT or DROP, the packet will continue moving through the chain after hitting a LOG target. This means that in order to enable logging for all dropped packets, you would have to add a duplicate LOG rule before each DROP rule. Since this reduces efficiency and makes things less simple, a logdrop chain can be created instead.\n\nCreate the chain with:\n\n```\n# iptables -N logdrop\n```\n\nAnd add the following rules to the newly created chain:\n\n```\n# iptables -A logdrop -m limit --limit 5/m --limit-burst 10 -j LOG\n# iptables -A logdrop -j DROP\n```\n\nExplanation for limit and limit-burst options is given below.\n\nNow whenever we want to drop a packet and log this event, we just jump to the logdrop chain, for example:\n\n```\n# iptables -A INPUT -m conntrack --ctstate INVALID -j logdrop\n```\n\n"
    },
    {
      "title": "Limiting log rate",
      "level": 3,
      "content": "The above logdrop chain uses the limit module to prevent the iptables log from growing too large or causing needless hard drive writes. Without limiting an erroneously configured service trying to connect, or an attacker, could fill the drive (or at least the /var partition) by causing writes to the iptables log.\n\nThe limit module is called with -m limit. You can then use --limit to set an average rate and --limit-burst to set an initial burst rate. In the logdrop example above:\n\n```\niptables -A logdrop -m limit --limit 5/m --limit-burst 10 -j LOG\n```\n\nappends a rule which will log all packets that pass through it. The first 10 consecutive packets will be logged, and from then on only 5 packets per minute will be logged. The \"limit burst\" count is reset every time the \"limit rate\" is not broken, i.e. logging activity returns to normal automatically.\n\n"
    },
    {
      "title": "Viewing logged packets",
      "level": 3,
      "content": "Logged packets are visible as kernel messages in the systemd journal.\n\nTo view all packets that were logged since the machine was last booted:\n\n```\n# journalctl -k --grep=\"IN=.*OUT=.*\"\n```\n\n"
    },
    {
      "title": "syslog-ng",
      "level": 3,
      "content": "Assuming you are using syslog-ng, you can control where iptables' log output goes in syslog-ng.conf. Replace:\n\n```\nfilter f_everything { level(debug..emerg) and not facility(auth, authpriv); };\n```\n\nto\n\n```\nfilter f_everything { level(debug..emerg) and not facility(auth, authpriv) and not filter(f_iptables); };\n```\n\nThis will stop logging iptables output to /var/log/everything.log.\n\nIf you also want iptables to log to a different file than /var/log/iptables.log, you can simply change the file value of destination d_iptables here (still in syslog-ng.conf):\n\n```\ndestination d_iptables { file(\"/var/log/iptables.log\"); };\n```\n\n"
    },
    {
      "title": "ulogd",
      "level": 3,
      "content": "ulogd is a specialized userspace packet logging daemon for netfilter that can replace the default LOG target.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Wikipedia article\n- Port knocking\n- Official iptables web site\n- iptables Tutorial 1.2.2 by Oskar Andreasson\n- Debian Wiki - iptables\n- Secure use of connection tracking helpers\n\n"
    }
  ]
}