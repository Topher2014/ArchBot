{
  "title": "Przewodnik Instalacyjny",
  "url": "https://wiki.archlinux.org/title/Przewodnik_Instalacyjny",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ten dokument jest przewodnikiem do instalacji systemu Arch Linux z środowiska live uruchomionego z oficjalnego obrazu instalacyjnego (iso). Przed instalacją zalecane jest przejrzenie najczęściej zadawanych pytań (FAQ). Dla konwencji użytych w tym dokumencie, zobacz stronę Help:Reading (Polski). W szczególności, wycinki kodu mogą zawierać tekst zastępczy zapisany kursywą, zamiast którego trzeba ręcznie wprowadzić odpowiednie wyrażenia. Należy również wziąć pod uwagę, że większość linków na tej stronie prowadzi do ich angielskich wersji językowych.\n\nDla dokładniejszych instrukcji, zobacz odpowiednie artykuły ArchWiki lub strony podręcznika poszczególnych programów, oba podlinkowane w tym przewodniku. Można też szukać pomocy innych użytkowników Arch Linuksa, online poprzez forum oraz kanał IRC.\n\nArch Linux powinien działać na dowolnej maszynie x86_64 z minimum 512 MB pamięci RAM, choć więcej pamięci jest potrzebne do uruchomienia systemu na żywo w celu instalacji.[1]. Podstawowa instalacja powinna zająć mniej niż 2 GiB miejsca na dysku. Ponieważ proces instalacji wymaga pobrania pakietów ze zdalnego repozytorium, niniejszy przewodnik zakłada, że dostępne jest działające połączenie internetowe.\n\n"
    },
    {
      "title": "Zdobądź obraz dysku",
      "level": 3,
      "content": "Odwiedź stronę Download i pobierz plik ISO dysku lub obraz netboot (zależnie od tego, w jaki sposób chcesz uruchomić środowisko live), a także odpowiedni podpis GnuPG.\n\n"
    },
    {
      "title": "Zweryfikuj podpis",
      "level": 3,
      "content": "Zaleca się zweryfikowanie podpisu pobranego obrazu dysku przed uruchomieniem go na komputerze docelowym, szczególnie podczas pobierania z serwera lustrzanego HTTP, który może paść ofiarą ataku i serwować niebezpieczne oprogramowanie (link do artykułu po angielsku).\n\nProcedurę sprawdzającą można przeprowadzić na systemie z zainstalowanym GnuPG. Pobierz odpowiedni podpis PGP (w sekcji Checksums na stronie pobierania) do folderu z obrazem ISO i zweryfikuj go, używając polecenia:\n\n```\n$ gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.iso.sig\n```\n\nDruga opcja to uruchomienie na istniejącej instalacji Archa następującej komendy:\n\n```\n$ pacman-key -v archlinux-version-x86_64.iso.sig\n```\n\n- Sam podpis może zostać zmanipulowany, jeżeli został pobrany z serwera lustrzanego zamiast z archlinux.org. W tym wypadku upewnij się, że klucz publiczny, który jest używany do odszyfrowania podpisu, jest podpisany przez inny, zaufany klucz. Komenda gpg wyświetli cyfrowy odcisk palca danego klucza publicznego.\n- Inną metodą weryfikacji autentyczności podpisu GPG jest upewnienie się, że cyfrowy odcisk palca jest taki sam jak cyfrowy odcisk palca dewelopera Arch Linux który podpisał obraz ISO. Odwiedź stronę Wikipedia:Kryptografia klucza publicznego po więcej informacji o tym procesie.\n\n"
    },
    {
      "title": "Przygotuj nośnik instalacyjny",
      "level": 3,
      "content": "Obraz instalacyjny ISO może zostać uruchomiony na komputerze docelowym z dysku USB, płyty CD/DVD, bądź sieci z PXE: odwołaj się do odpowiedniego artykułu, aby przygotować nośnik instalacyjny z pliku ISO.\n\n"
    },
    {
      "title": "Uruchom środowisko live",
      "level": 3,
      "content": "1. Z listy urządzeń rozruchowych wybierz przygotowany wcześniej nośnik instalacyjny Archa. Dostęp do menu można zazwyczaj uzyskać przez wciśnięcie odpowiedniego klawisza podczas fazy POST, jak to jest pokazane na ekranie powitalnym BIOS/UEFI. Odnieś się do podręcznika swojej płyty głównej po informacje.\n1. Kiedy pojawi się menu rozruchowe nośnika instalacyjnego, jeśli użyłeś ISO, wybierz Arch Linux install medium i naciśnij Enter, aby wejść do środowiska instalacyjnego. jeśli użyłeś obrazu Netboot, wybierz geograficznie bliski serwer lustrzany z menu Mirror, następnie wybierz Boot Arch Linux i naciśnij Enter.Tip: ISO używa systemd-boot dla UEFI i syslinux dla rozruchu BIOS. Użyj odpowiednio e lub Tab, aby wejść do boot parameters. Obraz Netboot używa iPXE, a parametry rozruchu można określić w menu Opcje rozruchu. Zobacz listę README.bootparams. Typowym przykładem ręcznie zdefiniowanego parametru rozruchowego jest rozmiar czcionki. Dla lepszej czytelności na ekranach HiDPI - gdy nie są one jeszcze rozpoznane jako takie - pomocne może być użycie fbcon=font:TER16x32. Zobacz HiDPI#Linux console (tty) aby uzyskać szczegółowe wyjaśnienie.\n1. \n1. Zostaniesz zalogowany na pierwszej wirtualnej konsoli jako użytkownik root, z dostępem do powłoki Zsh.\n\n- jeśli użyłeś ISO, wybierz Arch Linux install medium i naciśnij Enter, aby wejść do środowiska instalacyjnego.\n- jeśli użyłeś obrazu Netboot, wybierz geograficznie bliski serwer lustrzany z menu Mirror, następnie wybierz Boot Arch Linux i naciśnij Enter.Tip: ISO używa systemd-boot dla UEFI i syslinux dla rozruchu BIOS. Użyj odpowiednio e lub Tab, aby wejść do boot parameters. Obraz Netboot używa iPXE, a parametry rozruchu można określić w menu Opcje rozruchu. Zobacz listę README.bootparams. Typowym przykładem ręcznie zdefiniowanego parametru rozruchowego jest rozmiar czcionki. Dla lepszej czytelności na ekranach HiDPI - gdy nie są one jeszcze rozpoznane jako takie - pomocne może być użycie fbcon=font:TER16x32. Zobacz HiDPI#Linux console (tty) aby uzyskać szczegółowe wyjaśnienie.\n\n- ISO używa systemd-boot dla UEFI i syslinux dla rozruchu BIOS. Użyj odpowiednio e lub Tab, aby wejść do boot parameters. Obraz Netboot używa iPXE, a parametry rozruchu można określić w menu Opcje rozruchu. Zobacz listę README.bootparams.\n- Typowym przykładem ręcznie zdefiniowanego parametru rozruchowego jest rozmiar czcionki. Dla lepszej czytelności na ekranach HiDPI - gdy nie są one jeszcze rozpoznane jako takie - pomocne może być użycie fbcon=font:TER16x32. Zobacz HiDPI#Linux console (tty) aby uzyskać szczegółowe wyjaśnienie.\n\nAby dostać się do innej konsoli - np. żeby przeglądać tą stronę w programie ELinks podczas instalacji - użyj skrótu klawiaturowego Alt+strzałka. Do edytowania plików konfiguracyjnych dostępne są programy nano oraz vim. Odwiedź stronę pkglist.x86_64.txt, aby zobaczyć listę dołączonych do nośnika instalacyjnego pakietów.\n\n"
    },
    {
      "title": "Układ klawiatury",
      "level": 3,
      "content": "Domyślny układ klawiatury w konsoli to układ amerykański - US. By wyświetlić dostępne układy klawiatury, wpisz w konsoli\n\n```\n# localectl list-keymaps\n```\n\nAby zmienić układ, użyj odpowiedniej nazwy układu w poleceniu loadkeys(1) (bez położenia lub rozszerzenia pliku). Przykładowo, aby ustawić polski układ klawiatury:\n\n```\n# loadkeys pl\n```\n\nCzcionki konsolowe są zlokalizowane w /usr/share/kbd/consolefonts/ i mogą być w podobny sposób ustawione poleceniem setfont(8).\n\nJeśli polskie znaki diakrytyczne (ą, ę, ł, itp.) nie wyświetlają się poprawnie, wpisz:\n\n```\n# setfont Lat2-Terminus16\n```\n\nPowyższa komenda ustawia czcionkę z polskimi znakami diakrytycznymi w konsoli. W późniejszej części artykułu opisany zostanie sposób, by permanentnie ustawić polski układ i odpowiednią czcionkę.\n\n"
    },
    {
      "title": "Zweryfikuj tryb uruchomionego systemu",
      "level": 3,
      "content": "Aby zweryfikować tryb rozruchu, sprawdź bitowość UEFI:\n\n```\n# cat /sys/firmware/efi/fw_platform_size\n```\n\nJeśli polecenie zwróci 64, to system jest uruchamiany w trybie UEFI i ma 64-bitowy x64 UEFI. Jeśli polecenie zwróci 32, system zostanie uruchomiony w trybie UEFI i będzie miał 32-bitowy IA32 UEFI; choć jest to obsługiwane, ograniczy to wybór programu ładującego do systemd-boot i GRUB. Jeśli plik nie istnieje, system może zostać uruchomiony w trybie BIOS (lub CSM). Jeśli system nie uruchomił się w żądanym trybie (UEFI vs BIOS), zapoznaj się z instrukcją obsługi płyty głównej.\n\n"
    },
    {
      "title": "Połącz się z Internetem",
      "level": 3,
      "content": "Aby ustanowić połączenie z internetem, wykonaj odpowiednie czynności:\n\n- Upewnij się, że twój interfejs sieciowy jest wykryty i włączony, na przykład używając ip-link(8):\n\n```\n# ip link\n```\n\n- Dla połączeń bezprzewodowych upewnij się, że karta bezprzewodowa nie jest blokowana, używając rfkill.\n- Połącz się z siecią: Ethernet - podłącz kabel sieciowy Wi-Fi - połącz się z siecią bezprzewodową i uwierzytelnij za pomocą iwctl Mobilny modem szerokopasmowy - połączenie z siecią komórkową za pomocą narzędzia mmcli.\n- Skonfiguruj swoje połączenie sieciowe: DHCP: dynamiczne przydzielanie adresu IP oraz serwera DNS (dostarczone przez systemd-networkd i systemd-resolved) powinno działać od razu, zarówno dla przewodowych, jak i bezprzewodowych połączeń. Statyczny adres IP: zobacz Network configuration#Static IP address.\n- Możesz przetestować połączenie komendą ping\n\n- Ethernet - podłącz kabel sieciowy\n- Wi-Fi - połącz się z siecią bezprzewodową i uwierzytelnij za pomocą iwctl\n- Mobilny modem szerokopasmowy - połączenie z siecią komórkową za pomocą narzędzia mmcli.\n\n- DHCP: dynamiczne przydzielanie adresu IP oraz serwera DNS (dostarczone przez systemd-networkd i systemd-resolved) powinno działać od razu, zarówno dla przewodowych, jak i bezprzewodowych połączeń.\n- Statyczny adres IP: zobacz Network configuration#Static IP address.\n\n```\n# ping archlinux.org\n```\n\n"
    },
    {
      "title": "Zaktualizuj systemowy zegar",
      "level": 3,
      "content": "W środowisku live systemd-timesyncd jest domyślnie włączony, czas będzie automatycznie synchronizowany po nawiązaniu połączenia z Internetem.\n\nUżyj timedatectl(1) by upewnić się, że systemowy zegar jest zsynchronizowany:\n\n```\n# timedatectl\n```\n\n"
    },
    {
      "title": "Partycjonowanie dysków",
      "level": 3,
      "content": "Rozpoznane przez system live dyski są przypisane do urządzeń blokowych (block devices) takich jak /dev/sda, /dev/nvme0n1, czy /dev/mmcblk0. By zidentyfikować je, użyj lsblk lub fdisk:\n\n```\n# fdisk -l\n```\n\nWyniki kończące się na rom, loop lub airootfs mogą zostać zignorowane. Nazwy urządzeń mmcblk* kończących się na rpbm, boot0 oraz boot1 również mogą zostać zignorowane.\n\nNastępujące partycje są wymagane:\n\n- Jedna partycja dla katalogu głównego root /.\n- Dla systemu działającego w trybie UEFI: partycja rozruchowa EFI.\n\n"
    },
    {
      "title": "Przykładowe układy partycji",
      "level": 4,
      "content": "Table content:\nBIOS z MBR\nPunkt montowania w zainstalowanym systemie | Partycja | Typ partycji | Sugerowany rozmiar\n/ | /dev/sdX1 | Linux | Reszta urządzenia (dysku), co najmniej 23-32 GiB.\n[SWAP] | /dev/sdX2 | Partycja wymiany (SWAP) | Przynajmniej 4 GiB\nUEFI z GPT\nPunkt montowania w zainstalowanym systemie | Partycja | Typ partycji | Sugerowany rozmiar\n/boot1 | /dev/sdX1 | Partycja systemowa EFI | 1 GiB.\n/ | /dev/sdX2 | Partycja główna root (/) | Reszta urządzenia (dysku), co najmniej 23-32 GiB.\n[SWAP] | /dev/sdX3 | Partycja wymiany (SWAP) | Przynajmniej 4 GiB\n\n1. Inne punkty montowania, takie jak /efi, są możliwe, pod warunkiem, że używany program ładujący jest w stanie załadować obrazy jądra i initramfs z woluminu głównego. Zobacz ostrzeżenie w Arch boot process#Boot loader.\n\nZobacz też przykładowe układy partycjonowania.\n\n- Poświęć trochę czasu na zaplanowanie długoterminowego schematu partycjonowania, aby uniknąć ryzykownych i skomplikowanych procedur konwersji lub ponownego partycjonowania w przyszłości.\n- Jeśli chcesz utworzyć stos urządzeń blokowych dla LVM, szyfrowania systemu lub RAID, zrób to teraz.\n- Do modyfikacji tablic partycji użyj programu fdisk lub parted, przykładowo fdisk /dev/sdX.\n- Przestrzeń wymiany może zostać utworzona jako plik swap dla pozwalających na to systemów plików.\n\n"
    },
    {
      "title": "Formatowanie partycji",
      "level": 3,
      "content": "Po utworzeniu odpowiednich partycji, każda z nich musi zostać sformatowana w odpowiednim systemie plików. Na przykład, by sformatować partycję główną (/) na /dev/sdX1 jako partycja ext4, uruchom:\n\n```\n# mkfs.ext4 /dev/sdX1\n```\n\nJeżeli została utworzona partycja przestrzeni wymiany, zainicjuj ją używając narzędzia mkswap(8):\n\n```\n# mkswap /dev/sdX2\n# swapon /dev/sdX2\n```\n\nJeśli utworzono partycję systemową EFI, sformatuj ją do FAT32 za pomocą mkfs.fat(8).\n\n```\n# mkfs.fat -F 32 /dev/efi_system_partition\n```\n\nZobacz File systems#Create a file system po więcej informacji.\n\n"
    },
    {
      "title": "Montowanie systemu plików",
      "level": 3,
      "content": "Zamontuj system plików na partycji głównej (/) jako /mnt, na przykład:\n\n```\n# mount /dev/sdX2 /mnt\n```\n\nUtwórz pozostałe punkty montowania w /mnt (np. (takie jak /mnt/boot dla /boot) i zamontuj woluminy w odpowiedniej kolejności hierarchicznej.\n\nDla systemów UEFI, zamontuj systemową partycję EFI:\n\n```\n# mount --mkdir /dev/sdX1 /mnt/boot\n```\n\nJeżeli wolumin wymiany został stworzony, włącz go za pomocą swapon(8):\n\n```\n# swapon /dev/sdX3\n```\n\nPolecenie genfstab(8) wykryje po zainstalowaniu systemu zamontowane systemy plików i przestrzeń wymiany.\n\n"
    },
    {
      "title": "Wybierz serwery lustrzane",
      "level": 3,
      "content": "Pakiety do instalacji muszą być pobrane z serwerów lustrzanych, które są zdefiniowane w pliku /etc/pacman.d/mirrorlist. W systemie live, po połączeniu się z internetem, Reflector aktualizuje listę serwerów lustrzanych, wybierając 20 ostatnio zsynchronizowanych serwerów lustrzanych HTTPS i sortując je według szybkości pobierania.\n\nIm wyżej serwer jest położony na liście, tym ma wyższy priorytet, gdy pobierany jest pakiet. Możesz podejrzeć plik - jeśli wynik nie jest zadowalający, edytuj go, i przenieś najbliższe geograficznie serwery na górę listy, chociaż inne kryteria też mogą być brane pod uwagę.\n\nTen plik zostanie później skopiowany do nowego systemu przez skrypt pacstrap, więc warto jest go dobrze skonfigurować.\n\n"
    },
    {
      "title": "Instalacja podstawowych pakietów",
      "level": 3,
      "content": "Używając skryptu pacstrap(8), zainstaluj podstawowy system (pakiet base, kernel linux oraz podstawowe sterowniki sprzętu linux-firmware):\n\n```\n# pacstrap -K /mnt base linux linux-firmware\n```\n\n- Możesz zamienić pakiet linux na inny wybrany kernel, lub pominąć go całkowicie, jeżeli instalujesz Arch w kontenerze.\n- Możesz pominąć instalację pakietu firmware, jeżeli instalujesz system na maszynie wirtualnej bądź w kontenerze.\n\nPowyższa komenda NIE zainstaluje wszystkich narzędzi ze środowiska live - instalacja pozostałych pakietów może być konieczne dla uzyskania w pełni funkcjonalnego systemu. W szczególności rozważ zainstalowanie takiego oprogramowania, jak:\n\n- Aktualizacje mikrokodu procesora — amd-ucode lub intel-ucode dla poprawek błędów sprzętowych i bezpieczeństwa,\n- narzędzia do obsługi systemów plików (np. e2fsprogs dla ext4 czy btrfs-progs dla btrfs),\n- narzędzia do obsługi partycji RAID i LVM,\n- specyficzne sterowniki sprzętu spoza pakietu linux-firmware (np. sof-firmware dla zintegrowanego sprzętu dźwiękowego, linux-firmware-marvell dla sprzętu sieci bezprzewodowych Marvell, oraz którekolwiek z wielu paczek oprogramowania dla sprzętu sieciowego Broadcom),\n- oprogramowanie wymagane do połączenia z siecią,\n- konsolowe edytory tekstu (np. nano) aby umożliwić edycję plików konfiguracyjnych z konsoli,\n- pakiety dostępu do dokumentacji (man-db, man-pages i texinfo).\n\nBy zainstalować dodatkowe pakiety i grupy pakietów, takie jak grupę base-devel, dodaj ich nazwy do polecenia pacstrap (oddzielone spacją) lub użyj menedżera pakietów pacman po wejściu do środowiska #Chroot. Dla porównania, pakiety dostępne w systemie live można znaleźć w pkglist.x86_64.txt.\n\n"
    },
    {
      "title": "Fstab",
      "level": 3,
      "content": "Wygeneruj plik fstab (użyj -U lub -L by zdefiniować wpisy przy użyciu UUID lub etykiet):\n\n```\n# genfstab -U /mnt >> /mnt/etc/fstab\n```\n\nSprawdź gotowy plik w /mnt/etc/fstab i edytuj go w razie błędów.\n\n"
    },
    {
      "title": "Chroot",
      "level": 3,
      "content": "Wejdź przez chroot do nowego systemu:\n\n```\n# arch-chroot /mnt\n```\n\nPo wejściu do chroot zostanie otwarty wiersz poleceń Twojego systemu. Każda komenda będzie miała wpływ na zainstalowany system, a wszelkie zmiany zostaną zapisane.\n\n"
    },
    {
      "title": "Strefa czasowa",
      "level": 3,
      "content": "Ustaw strefę czasową:\n\n```\n# ln -sf /usr/share/zoneinfo/Region/City /etc/localtime\n```\n\nDla Polski polecenie będzie wyglądało w następujący sposób:\n\n```\n# ln -sf /usr/share/zoneinfo/Europe/Warsaw /etc/localtime\n```\n\nUruchom hwclock(8) by wygenerować /etc/adjtime:\n\n```\n# hwclock --systohc\n```\n\nTa komenda zakłada, że zegar sprzętowy komputera jest ustawiony w UTC. Zobacz System time#Time standard po więcej informacji.\n\nAby zapobiec dryftowi zegara i zapewnić dokładny czas, należy skonfigurować synchronizację czasu za pomocą klienta NTP, takiego jak systemd-timesyncd.\n\n"
    },
    {
      "title": "Język",
      "level": 3,
      "content": "Otwórz w swoim edytorze tekstu plik /etc/locale.gen i odkomentuj w nim (usuń z początku wiersza znak #) następujące wpisy: en_US.UTF-8 UTF-8, pl_PL.UTF-8 UTF-8 i inne wymagane lokalizacje. Następnie wygeneruj obsługę języków poleceniem:\n\n```\n# locale-gen\n```\n\nUtwórz plik locale.conf(5) i odpowiednio ustaw zmienną LANG, na przykład:\n\n```\n/etc/locale.conf\n```\n\n```\nLANG=pl_PL.UTF-8\n```\n\nJeśli zmieniłeś układ klawiatury, zapisz te zmiany w pliku vconsole.conf(5):\n\n```\n/etc/vconsole.conf\n```\n\n```\nKEYMAP=pl\n```\n\nJeżeli chcesz, by w konsoli była możliwość wprowadzania polskich znaków, plik vconsole.conf(5) powinien wyglądać w następujący sposób:\n\n```\n/etc/vconsole.conf\n```\n\n```\nKEYMAP=pl\nFONT=Lat2-Terminus16\nFONT_MAP=8859-2\n```\n\n"
    },
    {
      "title": "Konfiguracja sieci",
      "level": 3,
      "content": "Utwórz plik hostname:\n\n```\n/etc/hostname\n```\n\n```\ntwojanazwahosta\n```\n\nUkończ konfigurację sieci dla nowo zainstalowanego systemu, w tym wybrane oprogramowanie do zarządzania siecią.\n\n"
    },
    {
      "title": "Initramfs",
      "level": 3,
      "content": "Stworzenie nowego initramfs zazwyczaj nie jest wymagane, gdyż polecenie mkinitcpio było uruchomione podczas instalacji jądra systemu poleceniem pacstrap.\n\nDla LVM, szyfrowania systemu lub RAID, zmodyfikuj plik mkinitcpio.conf(5) i utwórz ponownie obraz initramfs:\n\n```\n# mkinitcpio -P\n```\n\n"
    },
    {
      "title": "Hasło użytkownika root",
      "level": 3,
      "content": "Ustaw hasło dla użytkownika root:\n\n```\n# passwd\n```\n\n"
    },
    {
      "title": "Program rozruchowy",
      "level": 3,
      "content": "Wybierz i zainstaluj odpowiedni program rozruchowy.\n\n"
    },
    {
      "title": "Uruchom ponownie",
      "level": 2,
      "content": "Opuść środowisko chroot poleceniem exit lub naciskając Ctrl+D.\n\nOpcjonalnie manualnie odmontuj wszystkie partycje poleceniem umount -R /mnt, co pozwoli na sprawdzenie \"zajętych\" partycji i znalezienia przyczyny poleceniem fuser(1).\n\nNa koniec, uruchom ponownie maszynę wpisując reboot. Pozostałe partycje zostaną odmontowane automatycznie przez systemd. Po wyłączeniu usuń nośnik instalacyjny, a po ponownym uruchomieniu zaloguj się na koncie root, aby dokończyć konfigurację nowo zainstalowanego systemu.\n\n"
    },
    {
      "title": "Po instalacji",
      "level": 2,
      "content": "Zobacz General recommendations (Polski) dla możliwości zarządzania systemem i poradników po instalacji (takich jak instalacja graficznego interfejsu użytkownika, dźwięku czy gładzika).\n\nDla listy aplikacji, które mogą się okazać przydatne, zobacz artykuł List of applications (Polski).\n\n"
    }
  ]
}