{
  "title": "Load the module at boot",
  "url": "https://wiki.archlinux.org/title/Load_the_module_at_boot",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Boot debugging\n- Compile kernel module\n- Kernel\n- Kernel parameters\n\nKernel modules are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need to reboot the system.\n\nTo create a kernel module, you can read The Linux Kernel Module Programming Guide. A module can be configured as built-in or loadable. To dynamically load or remove a module, it has to be configured as a loadable module in the kernel configuration (the line related to the module will therefore display the letter M).\n\nTo rebuild a kernel module automatically when a new kernel is installed, see Dynamic Kernel Module Support (DKMS).\n\n"
    },
    {
      "title": "Obtaining information",
      "level": 2,
      "content": "Usually modules depend on the kernel release and are stored in the /usr/lib/modules/kernel_release/ directory.\n\nTo show what kernel modules are currently loaded:\n\n```\n$ lsmod\n```\n\nTo show information about a module:\n\n```\n$ modinfo module_name\n```\n\nTo list the options that are set for a loaded module use systool(1) from sysfsutils:\n\n```\n$ systool -v -m module_name\n```\n\nTo display the comprehensive configuration of all the modules:\n\n```\n$ modprobe -c | less\n```\n\nTo display the configuration of a particular module:\n\n```\n$ modprobe -c | grep module_name\n```\n\nList the dependencies of a module (or alias), including the module itself:\n\n```\n$ modprobe --show-depends module_name\n```\n\n"
    },
    {
      "title": "Automatic module loading",
      "level": 2,
      "content": "Today, all necessary modules loading is handled automatically by udev, so if you do not need to use any out-of-tree kernel modules, there is no need to put modules that should be loaded at boot in any configuration file. However, there are cases where you might want to load an extra module during the boot process, or blacklist another one for your computer to function properly.\n\n"
    },
    {
      "title": "Early module loading",
      "level": 3,
      "content": "Early module loading depends on the initramfs generator used:\n\n- Booster#Early module loading\n- Dracut#Early kernel module loading\n- Mkinitcpio#MODULES\n\n"
    },
    {
      "title": "systemd",
      "level": 3,
      "content": "Kernel modules can be explicitly listed in files under /etc/modules-load.d/ for systemd to load them during boot. Each configuration file is named in the style of /etc/modules-load.d/program.conf. Configuration files simply contain a list of kernel modules names to load, separated by newlines. Empty lines and lines whose first non-whitespace character is # or ; are ignored.\n\n```\n/etc/modules-load.d/virtio-net.conf\n```\n\n```\n# Load virtio_net.ko at boot\nvirtio_net\n```\n\nSee modules-load.d(5) for more details.\n\n"
    },
    {
      "title": "Manual module handling",
      "level": 2,
      "content": "Kernel modules are handled by tools provided by the kmod package, which is installed as a dependency of a kernel package. You can use these tools manually. To load a module:\n\n```\n# modprobe module_name\n```\n\nTo load a module by a file name—i.e. one that is not installed in the /usr/lib/modules/kernel_release/ directory—use any of:\n\n```\n# insmod file_name module_options\n# modprobe file_name\n```\n\nTo unload—remove—a module, use any of:\n\n```\n# rmmod module_name\n# modprobe -r module_name\n# modprobe --remove module_name\n```\n\n"
    },
    {
      "title": "Setting module options",
      "level": 2,
      "content": "To pass a parameter to a kernel module, you can pass them manually with modprobe or assure certain parameters are always applied using a modprobe configuration file or by using the kernel command line. If the module is built into the kernel, the kernel command line must be used and other methods will not work.\n\n"
    },
    {
      "title": "Using modprobe",
      "level": 3,
      "content": "The basic way to pass parameters to a module is using the modprobe command. Parameters are specified on command line using simple key=value assignments:\n\n```\n# modprobe module_name parameter_name=parameter_value\n```\n\n"
    },
    {
      "title": "Using modprobe.d",
      "level": 3,
      "content": "Configuration files in the /etc/modprobe.d/ directory can be used to pass module settings to udev, which will use modprobe to manage the loading of the modules during system boot. Files in this directory can have any name, given that they end with the .conf extension. The file name matters, see modprobe.d(5) § CONFIGURATION DIRECTORIES AND PRECEDENCE. To show the effective configuration:\n\n```\n$ systemd-analyze cat-config modprobe.d\n```\n\nThe syntax is:\n\n```\n/etc/modprobe.d/file_name.conf\n```\n\n```\noptions module_name parameter_name=parameter_value\n```\n\nNote: **must** \n\nMultiple module parameters are separated by spaces, in turn a parameter can receive a list of values which is separated by commas:\n\n```\n/etc/modprobe.d/file_name.conf\n```\n\n```\noptions module_name param1=value1 param2=value2a,value2b …\n```\n\nFor example:\n\n```\n/etc/modprobe.d/thinkfan.conf\n```\n\n```\n# On ThinkPads, this lets the 'thinkfan' daemon control fan speed\noptions thinkpad_acpi fan_control=1\n```\n\n"
    },
    {
      "title": "Using kernel command line",
      "level": 3,
      "content": "You can also pass options to the module using the kernel command line. This is the only working option for modules built into the kernel. For all common boot loaders, the following syntax is correct:\n\n```\nmodule_name.parameter_name=parameter_value\n```\n\nFor example:\n\n```\nthinkpad_acpi.fan_control=1\n```\n\nSimply add this to the appropriate line in your boot loader configuration, as described in Kernel parameters#Boot loader configuration.\n\n"
    },
    {
      "title": "Aliasing",
      "level": 2,
      "content": "Aliases are alternate names for a module. For example: alias my-mod really_long_modulename means you can use modprobe my-mod instead of modprobe really_long_modulename. You can also use shell-style wildcards, so alias my-mod* really_long_modulename means that modprobe my-mod-something has the same effect. Create an alias:\n\n```\n/etc/modprobe.d/myalias.conf\n```\n\n```\nalias my-mod really_long_module_name\n```\n\nAliases can be internal—contained in the module itself. Internal aliases are usually used for #Automatic module loading when it is needed by an application, e.g. when the kernel detects a new device. To see the module internal aliases:\n\n```\n$ modinfo --field=alias module_name\n```\n\nTo see both configured and internal aliases:\n\n```\n$ modprobe --showconfig | grep '\\<module_name$'\n```\n\n"
    },
    {
      "title": "Blacklisting",
      "level": 2,
      "content": "Blacklisting, in the context of kernel modules, is a mechanism to prevent the kernel module from loading. This could be useful if, for example, the associated hardware is not needed, or if loading that module causes problems: for instance there may be two kernel modules that try to control the same piece of hardware, and loading them together would result in a conflict.\n\nSome modules are loaded as part of the initramfs. mkinitcpio -M will print out all automatically detected modules: to prevent the initramfs from loading some of those modules, blacklist them in a .conf file under /etc/modprobe.d and it shall be added in by the modconf hook during image generation. Running mkinitcpio -v will list all modules pulled in by the various hooks (e.g. filesystems hook, block hook, etc.). Remember to add that .conf file to the FILES array in /etc/mkinitcpio.conf if you do not have the modconf hook in your HOOKS array (e.g. you have deviated from the default configuration), and once you have blacklisted the modules regenerate the initramfs, and reboot afterwards.\n\n"
    },
    {
      "title": "alias",
      "level": 4,
      "content": "Disable an alias by overriding. For example, to prevent Bluetooth module autoloading taking module named off does not exist:\n\n```\n/etc/modprobe.d/modprobe.conf\n```\n\n```\nalias net-pf-31 off\n```\n\n"
    },
    {
      "title": "blacklist",
      "level": 4,
      "content": "To disable all internal aliases for a given module use the blacklist keyword. For example, to prevent the pcspkr module from loading on boot to avoid sounds through the PC speaker:\n\n```\n/etc/modprobe.d/nobeep.conf\n```\n\n```\nblacklist pcspkr\n```\n\n"
    },
    {
      "title": "install",
      "level": 4,
      "content": "There is a workaround for the behaviour described in the #alias and #blacklist notes. The install configuration command instructs modprobe to run a custom command instead of inserting the module in the kernel as normal, so you can simulate the successful module loading with:\n\n```\n/etc/modprobe.d/blacklist.conf\n```\n\n```\ninstall module_name /bin/true\n```\n\nYou can force the module to always fail loading with /bin/false: this will effectively prevent the module—and any other that depends on it—from loading by any means, and a log error message may be produced.\n\n"
    },
    {
      "title": "Using kernel command line",
      "level": 3,
      "content": "You can also blacklist modules from the boot loader boot entry configuration.\n\nSimply add module_blacklist=module_name_1,module_name_2,module_name_3 to your kernel command line, as described in Kernel parameters#Boot loader configuration.\n\n- When you are blacklisting more than one module, note that they are separated by commas only. Spaces or anything else might presumably break the syntax.\n- module_blacklist will make the kernel completely refuse to load the module.\n- If you only want to prevent implicit loading, but maybe load the module manually later, the correct parameter is modprobe.blacklist=module_name_1,module_name_2,module_name_3. This will however not prevent explicit loads during the boot, e.g. by systemd or other modules.\n\nAnother use case for a command line option is to disable hardware-specific components of a module without disabling the module entirely. For example, disabling a microphone while retaining other sound out options. See BBS#303475 for a few examples.\n\n"
    },
    {
      "title": "Module does not load",
      "level": 3,
      "content": "In case a specific module does not load and the boot log (accessible by running journalctl -b as root) says that the module is blacklisted, but the directory /etc/modprobe.d/ does not show a corresponding entry, check another modprobe source directory at /usr/lib/modprobe.d/ for blacklisting entries.\n\nA module will not be loaded if the \"vermagic\" string contained within the kernel module does not match the value of the currently running kernel. If it is known that the module is compatible with the current running kernel the \"vermagic\" check can be ignored with modprobe --force-vermagic.\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Disable PC speaker beep\n- Writing a WMI driver - an LWM introduction\n\n"
    }
  ]
}