{
  "title": "Problemas Comunes",
  "url": "https://wiki.archlinux.org/title/Problemas_Comunes",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2021-02-12** \n\nArtículos relacionados\n\n- Bug reporting guidelines (Español)\n- Step-by-step debugging guide\n- Debugging/Getting traces\n- Depuración colaborativa en IRC\n\nEste artículo explica algunos métodos para solucionar problemas generales. Para cuestiones específicas relativas a una aplicación, remítase a la página wiki para ese programa en particular.\n\n"
    },
    {
      "title": "Atención al detalle",
      "level": 3,
      "content": "Para resolver un problema que esté teniendo, es absolutamente crucial comprender básicamente cómo funciona ese subsistema específico. ¿Cómo funciona y qué necesita para ejecutarse sin error? Si no puede contestar cómodamente a estas preguntas, entonces es mejor que revise el artículo Archwiki del subsistema con el que tiene problemas. Una vez que sienta que lo ha entendido, le será más fácil identificar la causa del problema.\n\n"
    },
    {
      "title": "Preguntas/lista de control",
      "level": 3,
      "content": "A continuación se presentan una serie de preguntas que deberá hacerse a sí mismo cuando se trata de un sistema que no funciona bien. Debajo de cada pregunta, hay notas que explican el método para dar respuesta a cada pregunta, seguido de algunos ejemplos claros sobre cómo recopilar fácilmente los datos y qué herramientas se pueden usar para revisar los registros y el diario (journal).\n\n1. ¿Cuál es el problema? Sea lo más preciso posible. Esto le ayudará a no confundirse y/o no seguir un camino incorrecto cuando al buscar información específica.\n1. ¿Hay mensajes de error? (si los hay) Copie y pegue las salidas completas que contienen los mensajes de error relacionadas con su problema en un archivo separado como $HOME/issue.log. Por ejemplo, para enviar la salida de la siguiente orden de mkinitcpio a $HOME/issue.log: $ mkinitcpio -p linux >> $HOME/issue.log\n1. ¿Puede reproducir el problema? Si es así, indique exactamente paso a paso las instrucciones/órdenes necesarias para reproducirlo. Para situaciones de línea de órdenes, puede comenzar simplemente grabando sus órdenes y su salida. Por ejemplo, con la orden script(1), que es parte de util-linux. Para deshacerse de los caracteres de control no imprimibles y de otro tipo incrustados en el archivo typescript, se pueden utilizar herramientas básicas de Unix. Por ejemplo, tr. Las secuencias ANSI son más difíciles de manejar porque son más complejas. El uso de sed se describe en https://stackpointer.io/unix/unix-linux-remove-ansi-escape-sequences/464/.\n1. ¿Cuándo se encontró por primera vez con este problema, y qué cambió entre ese momento y antes de que el sistema comenzase a funcionar erróneamente? Si ocurrió justo después de una actualización, enumere todos los paquetes que se han actualizado. Incluya los números de versión, copiando toda la actualización de pacman.log (/var/log/pacman.log). También tome nota de los estados de cualquier servicio necesario para dar soporte a la(s) aplicación(es) que está funcionando mal, usando las herramientas systemctl de systemd. Por ejemplo, para reenviar la salida del siguiente comando de systemd a $HOME/issue.log: $ systemctl status dhcpcd@eth0.service >> $HOME/issue.log Nota: Utilizar >> asegurará que cualquier texto presente en $HOME/issue.log no se sobrescribirá.\n\n```\n$ mkinitcpio -p linux >> $HOME/issue.log\n```\n\n```\n$ systemctl status dhcpcd@eth0.service >> $HOME/issue.log\n```\n\nNote: **>>** \n\n"
    },
    {
      "title": "Enfoque",
      "level": 3,
      "content": "En lugar de abordar un problema diciendo,\n\nLa aplicación X no funciona.\n\nle resultará más útil formular su problema en el contexto del sistema como un todo, como:\n\nLa aplicación X produce el/los error(es) Y al realizar las tareas Z bajo las condiciones A y B.\n\n"
    },
    {
      "title": "Soporte adicional",
      "level": 3,
      "content": "Con toda la información delante suya, debe tener una buena idea de lo que está sucediendo con el sistema y ahora puede comenzar a trabajar en una solución adecuada.\n\nSi necesita soporte adicional, puede encontrarlo en los foros o el IRC en irc.libera.chat #archlinux. Véase Canales de IRC para otras opciones.\n\nCuando solicite ayuda, publique las salidas/registros completas/os, no solo las secciones que considere importantes. Las fuentes de información incluyen:\n\n- Salida completa de cualquier comando involucrado - no seleccione únicamente lo que considere relevante.\n- Salida de journalctl de systemd. Para una salida más extensa, utilice el parámetro de arranque systemd.log_level=debug.\n- Archivos de registro (eche un vistazo a /var/log)\n- Archivos de configuración relevantes\n- Controladores involucrados\n- Versiones de paquetes involucrados\n- Kernel: dmesg. Para un problema de arranque, al menos las últimas 10 líneas mostradas, preferiblemente más\n- Redes: Salida exacta de los comandos involucrados, y cualquier archivo de configuración\n- Xorg: /var/log/Xorg.0.log, y registros (logs) anteriores si ha sobrescrito el problemático\n- Pacman: si una actualización reciente rompió algo, busque en /var/log/pacman.log\n\nUna de las mejores formas de publicar esta información es usar un pastebin en línea. Puede instalar el paquete pbpstAUR o gist para enviar información automáticamente. Por ejemplo, para enviar el contenido de su diario systemd desde este arranque, debe hacer lo siguiente:\n\n```\n# journalctl -xb | pbpst -S\n```\n\nLuego se mostrará un enlace que puede pegar en el foro o IRC.\n\nAdemás, antes de publicar su pregunta, puede revisar cómo hacer preguntas inteligentes. Véase también Código de conducta.\n\n"
    },
    {
      "title": "Problemas de arranque",
      "level": 2,
      "content": "El diagnóstico de errores durante el proceso de arranque implica cambiar los parámetros del kernel y reiniciar el sistema.\n\nSi no es posible arrancar el sistema, inicie desde una imagen en vivo y cambie la raíz al sistema existente.\n\n"
    },
    {
      "title": "Mensajes de la consola",
      "level": 3,
      "content": "Después del proceso de inicio, la pantalla se borra y aparece el mensaje de inicio de sesión, lo que deja a los usuarios incapaces de leer los mensajes del arranque y los de error. Este comportamiento predeterminado puede cambiarse utilizando los métodos descritos en las secciones siguientes.\n\nTenga en cuenta que, independientemente de la opción elegida, los mensajes del kernel pueden mostrarse para su inspección después del arranque utilizando journalctl -k o dmesg. Para mostrar todos los registros del arranque actual utilice journalctl -b.\n\n"
    },
    {
      "title": "Control de flujo",
      "level": 4,
      "content": "Esta es una administración básica que se aplica a la mayoría de los emuladores de terminal, incluidas las consolas virtuales (vc):\n\n- Pulse Ctrl+s para pausar la salida\n- Y Ctrl+q para reanudarla\n\nEsto pausa no solo la salida, sino también los programas que intentan imprimir en el terminal, ya que bloquearán sobre las llamadas write() mientras la salida esté en pausa. Si su init parece congelado, asegúrese de que la consola del sistema no esté en pausa.\n\nPara ver los mensajes de error que ya han mostrado, véase Mantener los mensajes de arranque en tty1.\n\n"
    },
    {
      "title": "Salida de depuración",
      "level": 4,
      "content": "La mayoría de los mensajes del kernel están ocultos durante el arranque. Puede ver más de estos mensajes añadiendo diferentes parámetros de kernel. Los más simples son:\n\n- debug habilita los mensajes de depuración tanto para el kernel como para systemd\n- ignore_loglevel fuerza a que se impriman todos los mensajes del kernel\n\nOtros parámetros que puede añadir y que podrían ser útiles en ciertas situaciones son:\n\n- earlyprintk=vga,keep imprime los primeros mensajes en el proceso de arranque del kernel, en caso de que el kernel falle antes de que se muestre el resultado. Debe cambiar vga a efi para los sistemas EFI\n- log_buf_len=16M asigna un búfer de mensajes del kernel más grande (16 MiB), para garantizar que la salida de depuración no se sobrescriba\n\nTambién hay una serie de parámetros de depuración separados para permitir la depuración en subsistemas específicos, poe ejemplo bootmem_debug, sched_debug. Véase la documentación de los parámetros del kernel para obtener información específica.\n\n"
    },
    {
      "title": "netconsole",
      "level": 4,
      "content": "netconsole es un módulo del kernel que envía todos los mensajes de registro del kernel (es decir, dmesg) a través de la red a otra computadora, sin involucrar el espacio del usuario (por ejemplo, syslogd). El nombre \"netconsole\" es inapropiado porque en realidad no es una \"consola\", sino más bien un servicio de registro remoto.\n\nSe puede utilizar de forma integrada o como módulo. netconsole se inicializa inmediatamente después de las tarjetas NIC y mostrará la interfaz especificada lo antes posible. El módulo se utiliza principalmente para capturar la salida de pánico del kernel (kernel panic) de una máquina sin monitor, o en otras situaciones donde el espacio de usuario ya no es funcional.\n\n"
    },
    {
      "title": "Intérprete de línea de órdenes de recuperación",
      "level": 3,
      "content": "Obtener un intérprete de línea de órdenes interactivo en algún momento del proceso de arranque puede ayudarle a identificar exactamente dónde y por qué está fallando algo. Hay varios parámetros del kernel para hacerlo, pero todos ellos lanzan un intérprete de línea de órdenes normal que le permite ejecutar exit, lo que posibilita al kernel reanudar lo que estaba haciendo:\n\n- rescue inicia un intérprete de línea de órdenes poco después de que el sistema de archivos raíz se vuelva a leer/escribir\n- emergency inicia un intérprete de línea de órdenes incluso más temprano, antes de que se instalen la mayoría de los sistemas de archivos\n- init=/bin/sh (como último recurso) cambia el programa init a un intérprete de línea de órdenes de superusuario (root). rescue y emergency dependen de systemd, pero esto debería funcionar incluso si systemd falla\n\nOtra opción es el intérprete de línea de órdenes de depuración de systemd que añade un intérprete de línea de órdenes de superusuario en tty9 (accesible con Ctrl+Alt+F9). Se puede habilitar añadiendo systemd.debug_shell a los parámetros del kernel, o activando debug-shell.service.\n\n"
    },
    {
      "title": "Pantalla en blanco con una tarjeta gráfica Intel",
      "level": 3,
      "content": "Esto es debido muy probablemente a un problema con la configuración del modo del kernel. Pruebe a desactivar modesetting o cambiar el puerto de la tarjeta gráfica.\n\n"
    },
    {
      "title": "Atascado mientras se carga el kernel",
      "level": 3,
      "content": "Pruebe a desactivar ACPI añadiendo acpi=off a los parámetros del kernel.\n\n"
    },
    {
      "title": "Sistema no arrancable",
      "level": 3,
      "content": "Si el sistema no arranca en absoluto, simplemente arranque desde una imagen live y realice chroot para iniciar sesión en el sistema y solucionar el problema.\n\n"
    },
    {
      "title": "Depurar los errores de los módulos del kernel",
      "level": 3,
      "content": "Véase como obtener información de los módulos del kernel.\n\n"
    },
    {
      "title": "Depurar errores de hardware",
      "level": 3,
      "content": "- Puede visualizar información adicional de depuración sobre su hardware siguiendo udev#Debug output.\n- Asegúrese de que las actualizaciones de microcódigo se aplican en su sistema.\n- Para comprobar la memoria RAM, véase Stress testing#MemTest86+.\n\n"
    },
    {
      "title": "Kernel panics",
      "level": 2,
      "content": "Un pánico del kernel (o Kernel panic) ocurre cuando el kernel de Linux entra en un estado de fallo irrecuperable. El estado generalmente se origina en controladores de hardware defectuosos que provocan que la máquina quede estancada, no responda y requiera un reinicio. Justo antes del interbloqueo, se genera un mensaje de diagnóstico que consiste en: el \"estado de la máquina\" cuando ocurrió el fallo, un \"seguimiento de la llamada\" (call trace) que conduce a la función del kernel que reconoció el fallo y una lista de módulos cargados en ese momento. Afortunadamente, estos pánicos no ocurren muy a menudo usando versiones mainline del kernel, como los suministrados por los repositorios oficiales, pero cuando suceden, debe saber como manejarlos.\n\n"
    },
    {
      "title": "Examinar los mensajes de pánico",
      "level": 3,
      "content": "Si se produce un kernel panic al inicio del proceso de arranque, es posible que aparezca un mensaje en la consola que contenga \"Kernel panic - not syncing:\" pero una vez que Systemd se está ejecutando, los mensajes del kernel serán capturados y escritos en el registro del sistema. Sin embargo, cuando se produce un kernel panic, el mensaje de diagnóstico generado por el kernel \"casi nunca\" se escribe en el archivo de registro en el disco porque los interbloqueos de la máquina antes de system-journald tienen la ocasión. Por lo tanto, la única forma de examinar el mensaje de pánico es verlo en la consola como sucede (sin recurrir a la configuración de un kdump crashkernel). Puede hacerlo arrancando con los siguientes parámetros del kernel e intentando reproducir el mensaje de pánico en tty1:\n\n```\nsystemd.journald.forward_to_console=1 console=tty1\n```\n\n"
    },
    {
      "title": "Escenario de ejemplo: módulo defectuoso",
      "level": 4,
      "content": "Es posible adivinar qué subsistema o módulo está causando el pánico usando la información en el mensaje de diagnóstico. En este escenario, tenemos un pánico en una máquina (imaginaria) durante el arranque. Preste atención a las líneas resaltadas en negrita:\n\n```\nkernel: BUG: unable to handle kernel NULL pointer dereference at (null) [1]\nkernel: IP: fw_core_init+0x18/0x1000 [firewire_core] [2]\nkernel: PGD 718d00067 \nkernel: P4D 718d00067 \nkernel: PUD 7b3611067 \nkernel: PMD 0 \nkernel: \nkernel: Oops: 0002 [#1] PREEMPT SMP\nkernel: Modules linked in: firewire_core(+) crc_itu_t cfg80211 rfkill ipt_REJECT nf_reject_ipv4 nf_log_ipv4 nf_log_common xt_LOG nf_conntrack_ipv4 ... [3] \nkernel: CPU: 6 PID: 1438 Comm: modprobe Tainted: P           O    4.13.3-1-ARCH #1\nkernel: Hardware name: Gigabyte Technology Co., Ltd. H97-D3H/H97-D3H-CF, BIOS F5 06/26/2014\nkernel: task: ffff9c667abd9e00 task.stack: ffffb53b8db34000\nkernel: RIP: 0010:fw_core_init+0x18/0x1000 [firewire_core]\nkernel: RSP: 0018:ffffb53b8db37c68 EFLAGS: 00010246\nkernel: RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\nkernel: RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffffffffc16d3af4\nkernel: RBP: ffffb53b8db37c70 R08: 0000000000000000 R09: ffffffffae113e95\nkernel: R10: ffffe93edfdb9680 R11: 0000000000000000 R12: ffffffffc16d9000\nkernel: R13: ffff9c6729bf8f60 R14: ffffffffc16d5710 R15: ffff9c6736e55840\nkernel: FS:  00007f301fc80b80(0000) GS:ffff9c675dd80000(0000) knlGS:0000000000000000\nkernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nkernel: CR2: 0000000000000000 CR3: 00000007c6456000 CR4: 00000000001406e0\nkernel: Call Trace:\nkernel:  do_one_initcall+0x50/0x190 [4]\nkernel:  ? do_init_module+0x27/0x1f2\nkernel:  do_init_module+0x5f/0x1f2\nkernel:  load_module+0x23f3/0x2be0\nkernel:  SYSC_init_module+0x16b/0x1a0\nkernel:  ? SYSC_init_module+0x16b/0x1a0\nkernel:  SyS_init_module+0xe/0x10\nkernel:  entry_SYSCALL_64_fastpath+0x1a/0xa5\nkernel: RIP: 0033:0x7f301f3a2a0a\nkernel: RSP: 002b:00007ffcabbd1998 EFLAGS: 00000246 ORIG_RAX: 00000000000000af\nkernel: RAX: ffffffffffffffda RBX: 0000000000c85a48 RCX: 00007f301f3a2a0a\nkernel: RDX: 000000000041aada RSI: 000000000001a738 RDI: 00007f301e7eb010\nkernel: RBP: 0000000000c8a520 R08: 0000000000000001 R09: 0000000000000085\nkernel: R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000c79208\nkernel: R13: 0000000000c8b4d8 R14: 00007f301e7fffff R15: 0000000000000030\nkernel: Code: <c7> 04 25 00 00 00 00 01 00 00 00 bb f4 ff ff ff e8 73 43 9c ec 48 \nkernel: RIP: fw_core_init+0x18/0x1000 [firewire_core] RSP: ffffb53b8db37c68\nkernel: CR2: 0000000000000000\nkernel: ---[ end trace 71f4306ea1238f17 ]---\nkernel: Kernel panic - not syncing: Fatal exception [5]\nkernel: Kernel Offset: 0x80000000 from 0xffffffff810000000 (relocation range: 0xffffffff800000000-0xfffffffffbffffffff\nkernel: ---[ end Kernel panic - not syncing: Fatal exception\n```\n\n- [1] Indica el tipo de error que causó el pánico. En este caso, era un error del programador.\n- [2] Indica que el pánico ocurrió en una función llamada fw_core_init en el módulo firewire_core.\n- [3] Indica que firewire_core fue el último módulo que se inició.\n- [4] Indica que la función que llamó a la función fw_core_init fue do_one_initcall.\n- [5] Indica que este mensaje de oops es, de hecho, un kernel panic y el sistema está ahora bloqueado.\n\nPodemos suponer entonces que el pánico ocurrió durante la rutina de inicialización del módulo firewire_core al iniciarse. (Podríamos suponer, entonces, que el hardware firewire de la máquina es incompatible con esta versión del módulo del controlador firewire debido a un error del programador, y tendrá que esperar una nueva versión.) Mientras tanto, la forma más fácil de hacer funcionar la máquina nuevamente es evitar que el módulo se inicie. Podemos hacer esto de una de estas dos maneras:\n\n- Si el módulo se está iniciando durante la ejecución de initramfs, reinicie con el parámetro del kernel rd.blacklist=firewire_core.\n- De lo contrario, reinicie con el parámetro del kernel module_blacklist=firewire_core.\n\n"
    },
    {
      "title": "Reiniciar en un intérprete de línea de órdenes de superusuario y solucionar el problema",
      "level": 3,
      "content": "Necesitará un intérprete de línea de órdenes de superusuario para realizar cambios en el sistema para que no se produzca el pánico. Si se produce un pánico durante el arranque, existen varias estrategias para obtener un intérprete de línea de órdenes de superusuario antes de que la máquina se bloquee:\n\n- Reinicie con el parámetro del kernel emergency, rd.emergency, o -b para obtener una manera de iniciar sesión justo después de que se monte el sistema de archivos raíz y systemd se ha iniciado.\n\nNote: **solo lectura** \n\n- Reinicie con el parámetro del kernel rescue, rd.rescue, single, s, S, o { {ic|1}} para poder iniciar sesión justo después de montar los sistemas de archivos locales.\n- Reinicie con el parámetro del kernel systemd.debug_shell para obtener un intérprete de línea de órdenes de superusuario al iniciar en tty9. Cambie a este presionando Ctrl-Alt-F9.\n- Experimente reiniciando con diferentes conjuntos de parámetros del kernel para posibilitar la deshabilitación de la función del kernel que está causando el pánico. Pruebe los \"viejos recursos\" acpi=off y nolapic.\n\n- Como último recurso, arranque con el CD de instalación de Arch Linux y monte el sistema de archivos raíz en /mnt y luego ejecute arch-chroot /mnt como superusuario.\n- Desactive el servicio o programa que está causando el problema, revierta la actualización defectuosa o solucione el problema de configuración.\n\n"
    },
    {
      "title": "Administrar paquetes",
      "level": 2,
      "content": "Véase solución de problemas con pacman para los temas más generales, y solución de problemas de cifrado de paquetes con pacman para los problemas con las claves PGP.\n\n"
    },
    {
      "title": "Arreglar un sistema roto",
      "level": 3,
      "content": "Si realizó una actualización parcial que rompió algo, intente actualizar todos los paquetes y, si tiene éxito, posiblemente reinicie:\n\n```\n# pacman -Syu\n```\n\nSi generalmente inicia en una GUI y eso está fallando, tal vez pueda presionar desde Ctrl+Alt+F1 hasta Ctrl+Alt+F6 y llegar a un tty de trabajo para ejecutar pacman.\n\nSi el sistema está lo suficientemente dañado como para que no pueda ejecutar pacman, inicie utilizando un ISO mensual de Arch desde una unidad flash USB, un disco óptico o una red con PXE. (No siga el resto de la guía de instalación).\n\nMonte su sistema de archivos raíz:\n\n```\n[ISO] # mount /dev/dispositivoconelsistemadearchivosraiz /mnt\n```\n\nMonte cualquier otra partición que haya creado por separado, añadiendo el prefijo /mnt a todas ellas, es decir:\n\n```\n[ISO] # mount /dev/dispositivodearranque /mnt/boot\n```\n\nIntente utilizar pacman en su sistema:\n\n```\n[ISO] # arch-chroot /mnt\n[chroot] # pacman -Syu\n```\n\nSi falla, salga del chroot e intente:\n\n```\n[ISO] # pacman -Syu --sysroot /mnt\n```\n\nSi eso falla, intente:\n\n```\n[ISO] # pacman -Syu --root /mnt --cachedir /mnt/var/cache/pacman/pkg\n```\n\n"
    },
    {
      "title": "Depuración colaborativa en IRC",
      "level": 2,
      "content": "Para solicitar ayuda de un canal de ayuda de IRC (como #archlinux), puede utilizar servicios de depuración colaborativa (como pastebin) para dar a los usuarios de IRC detalles sobre los problemas que está viendo o archivos de configuración que necesite referenciar.\n\n"
    },
    {
      "title": "Utilización del IRC",
      "level": 3,
      "content": "Cuando le indique a las personas en la sala de charla cuál es su problema, a veces necesitarán conocer información adicional. Esto podría ser la salida (por ejemplo) de una orden o el contenido de un archivo de configuración. Es una regla general para los canales de IRC nunca pegar texto de más de tres líneas. Cuando necesite más, los servicios de pegado (por ejemplo, pastebin) permiten el uso temporal del almacenamiento de información de texto. Para evitar tener que escribir la información físicamente y luego escribirla manualmente en un canal de IRC, aquí es donde resulta útil utilizar un programa de depuración colaborativo que pueda enviar la información a un servicio de pegado. Hay varias herramientas que se pueden utilizar para enviar información a un servicio pastebin.\n\n"
    },
    {
      "title": "Enviar errores/mensajes al archivo",
      "level": 3,
      "content": "Muchos de estos programas necesitarán tener un archivo para subirlo. Si está utilizando un programa que necesita compartir su salida, puede escribirlo en un archivo de texto haciendo:\n\n```\nprograma > salida-programa.txt 2>&1\n```\n\nPor ejemplo:\n\n```\nfdisk -l > particiones.txt 2>&1\n```\n\nRedirigirá toda la salida a un archivo de texto (tanto la salida estándar como la salida de error estándar) y se puede subir a un servicio pastebin.\n\n"
    },
    {
      "title": "Preguntas sobre el instalador de la consola",
      "level": 3,
      "content": "Ocasionalmente, es posible que deba mostrar una imagen de lo que trata su pregunta (por ejemplo, si tiene una pregunta sobre un instalador basado en consola). Para ello, puede utilizar fbshot. fbshot es un programa de captura de pantalla framebuffer. Para tomar una captura de pantalla de la primera consola (Ctrl+Alt+F1):\n\n```\nfbshot -c 1 consola1.png\n```\n\nLuego, puede utilizar enlaces y un sitio web de alojamiento de imágenes para subir la imagen.\n\n"
    },
    {
      "title": "fuser",
      "level": 2,
      "content": "fuser es una utilidad de línea de órdenes para la identificación de los procesos que utilizan recursos como archivos, sistemas de archivos y puertos TCP/UDP.\n\nfuser está incluido en el paquete psmisc, que debe estar ya instalado como dependencia del meta paquete base. Véase fuser(1) para más detalles.\n\n"
    },
    {
      "title": "Permisos de sesión",
      "level": 2,
      "content": "En primer lugar, asegúrese de que tiene una sesión local válida dentro de X:\n\n```\n$ loginctl show-session $XDG_SESSION_ID\n```\n\nEsta debe contener Remote=no y Active=yes en la salida. Si no es así, asegúrese de que X se ejecuta en la misma tty donde se produjo el inicio de sesión. Esto es necesario a fin de preservar la sesión iniciada. Esto es manejado de forma predeterminada por /etc/X11/xinit/xserverrc.\n\nLas acciones polkit no requieren una configuración posterior. Algunas acciones polkit requieren una autenticación adicional, incluso con una sesión local. Un agente de autenticación polkit debe estar en ejecución para que esto funcione. Véase Agentes de autenticación para más información.\n\n"
    },
    {
      "title": "Mensaje: \"error while loading shared libraries\"",
      "level": 2,
      "content": "Si, durante el uso de un programa, se produce un error similar al siguiente:\n\n```\nerror while loading shared libraries: libusb-0.1.so.4: cannot open shared object file: No such file or directory\n```\n\nUtilice pacman o pkgfile para buscar el paquete al cual pertenece la biblioteca que falta:\n\n```\n$ pacman -F libusb-0.1.so.4\n```\n\n```\nextra/libusb-compat 0.1.5-1\n    usr/lib/libusb-0.1.so.4\n```\n\nEn este caso, el paquete libusb-compat necesita ser instalado.\n\nEl error también puede significar que el paquete que ha utilizado para instalar el programa no enumera la biblioteca como una dependencia en su PKGBUILD: si se trata de un paquete oficial, informe del error; si se trata de un paquete de AUR, informe a su mantenedor en su página del sitio web de AUR.\n\n"
    },
    {
      "title": "Mensaje: \"file: could not find any magic files!\"",
      "level": 2,
      "content": "Si ve este mensaje, es probable que indique que la actualización de un paquete ha dañado el archivo de enlaces de tiempo de ejecución del vinculador dinámico y su sistema ahora está esencialmente lisiado. No podrá volver a compilar o reinstalar el paquete responsable ni reconstruir el initramfs hasta que lo solucione.\n\n"
    },
    {
      "title": "Problema",
      "level": 3,
      "content": "Es probable que una actualización del paquete haya agregado un archivo.conf no válido al directorio /etc/ld.so.conf.d o editado /etc/ld.so.conf incorrectamente. El resultado es que el archivo de enlaces de tiempo de ejecución del vinculador dinámico /etc/ld.so.cache se vuelve a generar con datos no válidos. Esto puede causar que fallen todos los programas del sistema que dependan de bibliotecas compartidas (es decir, casi todos).\n\n"
    },
    {
      "title": "Solución",
      "level": 3,
      "content": "1. Arranque con el CD de instalación de Arch Linux.\n1. Monte su sistema de archivos raíz / en /mnt y su sistema de archivos /boot en /mnt/boot y entre en el sistema dañado ejecutando arch-chroot /mnt como superusuario.\n1. Examine el archivo /etc/ld.so.conf y elimine las líneas no válidas encontradas.\n1. Examine los archivos ubicados en el directorio /etc/ld.so.conf.d/ y elimine los archivos no válidos.\n1. Reconstruya el archivo de enlaces de tiempo de ejecución del vinculador dinámico /etc/ld.so.cache ejecutando ldconfig como superusuario.\n1. Reconstruya el initramfs ejecutando mkinitcpio -p linux como superusuario.\n1. Salga del chroot, desmonte los sistemas de archivos y reinicie de nuevo el sistema.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- A how-to in troubleshooting for newcomers\n- List of Tools for UBCD - Memtest-like tools to add to grub.cfg on UltimateBootCD.com\n- Wikipedia:BIOS Boot partition\n- REISUB\n- Debug Logging to a Serial Console en Freedesktop.org\n- How to Isolate Linux ACPI Issues en Archive.org\n\n"
    }
  ]
}