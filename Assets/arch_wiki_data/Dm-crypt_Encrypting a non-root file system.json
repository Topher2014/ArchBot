{
  "title": "Dm-crypt/Encrypting a non-root file system",
  "url": "https://wiki.archlinux.org/title/Dm-crypt/Encrypting_a_non-root_file_system",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "The following are examples of encrypting a secondary, i.e. non-root, filesystem with dm-crypt.\n\n"
    },
    {
      "title": "Overview",
      "level": 2,
      "content": "Encrypting a secondary filesystem usually protects only sensitive data while leaving the operating system and program files unencrypted. This is useful for encrypting an external medium, such as a USB drive, so that it can be moved to different computers securely. One might also choose to encrypt sets of data separately according to who has access to it.\n\nBecause dm-crypt is a block-level encryption layer, it only encrypts whole block devices, e.g. partitions and loop devices. Encrypting individual files requires a filesystem-level encryption layer, such as eCryptfs or EncFS. See Data-at-rest encryption for general information about securing private data.\n\n"
    },
    {
      "title": "Partition",
      "level": 2,
      "content": "This example covers the encryption of the /home partition, but it can be applied to any other comparable non-root partition containing user data.\n\nIt is assumed that the partition already exists. If it contained data before, you may consider securely erasing the partition (dm-crypt specific methods). Erasing a single partition instead of the entire disk may still leak some data.\n\nThen setup the LUKS header with:\n\n```\n# cryptsetup options luksFormat device\n```\n\nReplace device with the previously created partition. See dm-crypt/Device encryption#Encryption options for LUKS mode for details like the available options.\n\nTo gain access to the encrypted partition, unlock it with the device mapper, using:\n\n```\n# cryptsetup open device name\n```\n\nAfter unlocking the partition, it will be available at /dev/mapper/name. Now create a file system of your choice with:\n\n```\n# mkfs.fstype /dev/mapper/name\n```\n\nMount the file system to /home, or if it should be accessible to only one user to /home/username, see #Manual mounting and unmounting.\n\n"
    },
    {
      "title": "Manual mounting and unmounting",
      "level": 3,
      "content": "To mount the partition:\n\n```\n# cryptsetup open device name\n# mount -t fstype /dev/mapper/name /mnt/home\n```\n\nTo unmount it:\n\n```\n# umount /mnt/home\n# cryptsetup close name\n```\n\n"
    },
    {
      "title": "Automated unlocking and mounting",
      "level": 3,
      "content": "There are three different solutions for automating the process of unlocking the partition and mounting its filesystem.\n\n"
    },
    {
      "title": "At boot time",
      "level": 4,
      "content": "Using the /etc/crypttab configuration file, unlocking happens at boot time by systemd's automatic parsing. This is the recommended solution if you want to use one common partition for all user's home partitions or automatically mount another encrypted block device.\n\nSee dm-crypt/System configuration#crypttab for references and dm-crypt/System configuration#Mounting at boot time for an example setup.\n\n"
    },
    {
      "title": "On user login",
      "level": 4,
      "content": "- Using pam_exec: recommended if you want to have a single user's home directory on a partition.\n- Using pam_mount.\n\n"
    },
    {
      "title": "File container",
      "level": 2,
      "content": "Cryptsetup operates with devices, therefore a loop device is required when using a file container. But cryptsetup can take care of the loop device management in the background (see Gentoo:Custom Initramfs#Encrypted keyfile), the user is not required to invoke losetup manually.\n\nFirst, start by creating an encrypted file container with dd, using an appropriate random number generator:\n\n```\n$ dd if=/dev/urandom of=bigsecret.img bs=100M count=1 iflag=fullblock\n```\n\nThis will create the file bigsecret.img with a size of 100 mebibytes.\n\nMake sure to not omit the iflag=fullblock option, otherwise dd might return a partial read. See dd#Partial read: copied data is smaller than requested for details.\n\nTo avoid having to resize the container later on, make sure to make it larger than the total size of the files to be encrypted, plus internal file-system/metadata overhead, plus LUKS header. If you are going to use LUKS mode, its metadata header alone requires up to 16 mebibytes. Creating a file smaller than the LUKS2 header (16 MiB) will give a Requested offset is beyond real size of device bigsecret.img error when trying to open the device.\n\nThe subsequent steps are the same as described in #Partition, but instead of using a device use bigsecret.img.\n\nIn the background, cryptsetup will take care of finding a free loop device and attaching the file to it. After unmouting, the file container should be closed accordingly; cryptsetup will also detach the used loop device afterwards.\n\n"
    },
    {
      "title": "Manual mounting and unmounting using losetup",
      "level": 3,
      "content": "To manually mount a file container with a LUKS and an ext4 filesystem inside, first find an unused loop device:\n\n```\n# losetup --find\n```\n\nThen attach the file container to a loop device, e.g. loop0:\n\n```\n# losetup /dev/loop0 bigsecret.img\n```\n\nNow proceed with the normal cryptsetup operation:\n\n```\n# cryptsetup open /dev/loop0 secret\n# mount -t ext4 /dev/mapper/secret /mnt/secret\n```\n\nProceed in reverse order to unmount the container properly:\n\n```\n# umount /mnt/secret\n# cryptsetup close secret\n```\n\nTo detach the used loop device:\n\n```\n# losetup --detach /dev/loop0\n```\n\n"
    }
  ]
}